Al asignar una colección de tipo `Collection<String>` a una variable de tipo `Collection<Any>`, se pierde la información específica de los tipos, pero algunas operaciones como `contains` siguen siendo seguras debido a su naturaleza pura (no modifican el estado).

```kotlin showLineNumbers
val strings: Collection<String> = listOf("Kotlin", "Java")
val anys: Collection<Any> = strings
println(anys.contains(420))  // Output: false
println(strings.contains(420))  // Error de compilación
```

**Explicación**:
1. (2) La asignación es válida debido a la **covarianza**: `Collection<String>` es un subtipo de `Collection<Any>`.
2. (3) Aunque `420` no es un `String`, el método `contains` espera un `Any` en `anys`, lo que permite la llamada. El resultado es `false`, ya que `420` no está en la colección.
3. (4) Al intentar usar `contains` directamente en `strings` con un `Int`, el compilador arroja un error porque espera un parámetro de tipo `String`.
