---

title: Void-Safety

---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## El Problema de los Punteros Nulos

Los punteros o referencias nulas, descritos por Tony Hoare como "el error de mil millones de dólares", son una fuente común de errores en tiempo de ejecución. Este problema ocurre cuando una variable, que se espera que contenga una referencia a un objeto, en realidad contiene un valor nulo. Al intentar acceder a los métodos o propiedades de dicho objeto nulo, se producen fallos críticos.

## Motivación

El manejo inadecuado de valores nulos es una causa importante de errores difíciles de detectar y que pueden comprometer la estabilidad y seguridad del software. En proyectos grandes, estos errores son aún más peligrosos y costosos de corregir. Por ello, es fundamental gestionar correctamente los valores nulos para asegurar la calidad y fiabilidad del software desde el inicio.

## Enfoques en Diferentes Lenguajes

- **Java**: En Java, las referencias nulas son comunes, lo que obliga a lxs desarrolladorxs a realizar verificaciones constantes para evitar errores, lo que lleva a código redundante y difícil de mantener. Las excepciones `NullPointerException` son frecuentes si no se manejan adecuadamente.

- **C#**: En C#, los tipos de referencia son no anulables por defecto, pero se pueden declarar como anulables utilizando `?`. Esto obliga a los desarrolladores a tener más cuidado con los valores nulos y mejora la seguridad del código.

- **Scala**: Scala introduce el tipo `Option`, el cual obliga a lxs desarrolladorxs a manejar explícitamente la posibilidad de que no haya un valor (`None`). Sin embargo, no elimina por completo el riesgo de `NullPointerException`, ya que `Option` puede contener un valor nulo si no se maneja correctamente.

### Solución en Kotlin: Seguridad de Tipos frente a Nulos

Kotlin introduce un sistema de tipos que diferencia entre referencias anulables y no anulables, evitando así la mayoría de los errores de `NullPointerException` en tiempo de ejecución.

#### Tipos no nullables y nullables

En Kotlin, las variables son no nullables por defecto, lo que significa que no pueden contener `null` a menos que se declare explícitamente con `?`:

```kotlin
var a: String = "No es nulo"
var b: String? = "Posiblemente nulo"
a = null // Error: tipo no nullable
b = null // Permitido: tipo nullable
```

#### Inferencia de tipos y nulabilidad

La inferencia de tipos en Kotlin también aplica a los valores nullable, siguiendo las mismas reglas:

```kotlin
var c = "Hola" // Tipo inferido como String, no nullable
c = null // Error: c es no nullable
```

#### Llamadas Seguras en Kotlin

Kotlin obliga a manejar explícitamente variables que pueden ser nulas, asegurándose de que no se acceda a métodos o propiedades sin la validación adecuada. Si una variable puede ser nula, Kotlin requiere una verificación previa:

```kotlin
val a: String? = TODO()
if (a != null) {
    println(a.length) // Acceso seguro
} else {
    println("a es nulo")
}
```

Para simplificar, el operador de llamada segura (`?.`) permite realizar operaciones solo si la variable no es nula:

```kotlin
println(a?.length) // Si a es nulo, devuelve null sin lanzar una excepción.
```

#### Operador Elvis

El operador Elvis (`?:`) proporciona una manera elegante de manejar valores nulos, permitiendo devolver un valor por defecto cuando una expresión resulta nula:

```kotlin
val a: String? = TODO()
val l = a?.length ?: -1 // Si a es nulo, l será -1
```

Este operador es extremadamente útil para evitar nulos en el flujo de datos sin necesidad de condicionales complejos, haciendo el código más claro y conciso.

:::tip Ejercicio: Procesamiento de Temperaturas de Ciudades

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        1. **Datos de Entrada**: Define un mapa (`Map<String, Int?>`) donde las claves sean los nombres de las ciudades y los valores representen las temperaturas registradas, que pueden ser nulas si no hay datos disponibles.

        2. **Procesamiento de Datos**: Itera sobre el mapa utilizando un bucle y llamadas seguras para manejar los valores nulos.

        3. **Salida del Programa**: Imprime el nombre de la ciudad junto con su temperatura. Si la temperatura es nula, imprime el mensaje `Temperatura no disponible`.

        Este ejercicio permite ver cómo Kotlin maneja de manera segura los valores nulos, evitando errores en tiempo de ejecución y mejorando la estabilidad del software.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun main() {
            val temperaturasPorCiudad = mapOf(
                "Madrid" to 22,
                "París" to null,
                "Berlín" to 18,
                "Roma" to null,
                "Londres" to 15
            )
            for ((ciudad, temperatura) in temperaturasPorCiudad) {
                val temperaturaFormateada = temperatura?.toString() ?: "Temperatura no disponible"
                println("La temperatura en $ciudad es: $temperaturaFormateada")
            }
        }
        ```
    </TabItem>
</Tabs>
:::

#### Ejemplos en Otros Lenguajes

**Scala** utiliza el tipo `Option` para manejar valores que pueden ser nulos. Aquí tienes un ejemplo similar al de Kotlin:

```scala
val temperaturasPorCiudad = Map(
  "Madrid" -> Some(22),
  "París" -> None,
  "Berlín" -> Some(18),
  "Roma" -> None,
  "Londres" -> Some(15)
)

temperaturasPorCiudad.foreach {
  case (ciudad, Some(temp)) => println(s"La temperatura en $ciudad es: $temp")
  case (ciudad, None) => println(s"Temperatura en $ciudad no disponible")
}
```

**Rust** usa el tipo `Option` de manera similar:

```rust
let temperaturas_por_ciudad = vec![
    ("Madrid", Some(22)),
    ("París", None),
    ("Berlín", Some(18)),
    ("Roma", None),
    ("Londres", Some(15)),
];

for (ciudad, temp) in temperaturas_por_ciudad {
    match temp {
        Some(t) => println!("La temperatura en {} es: {}", ciudad, t),
        None => println!("Temperatura en {} no disponible", ciudad),
    }
}
```

**JavaScript** no tiene un manejo explícito de nullables como Kotlin, pero puedes usar validaciones similares:

```javascript
const temperaturasPorCiudad = {
    "Madrid": 22,
    "París": null,
    "Berlín": 18,
    "Roma": null,
    "Londres": 15
};

for (const [ciudad, temperatura] of Object.entries(temperaturasPorCiudad)) {
    console.log(`La temperatura en ${ciudad} es: ${temperatura ?? "Temperatura no disponible"}`);
}
```
