---
title: Código Limpio y Mantenible
---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

## Código fácil de leer y entender

El código debe ser claro y fácil de leer para cualquier desarrolladorx, no solo para quien lo escribió. Algunas prácticas esenciales incluyen:

- **Nombres descriptivos**: Utiliza nombres que sean claros y expresivos para variables y funciones.

```kotlin
fun cx(cxPb: Double): Gt {
    // ...
}
```

vs.

```kotlin
fun performCrossover(crossoverProbability: Double): Genotype {
    // ...
}
```

En el segundo ejemplo, los nombres son mucho más intuitivos, lo que facilita el entendimiento.

- **Facilitar el trabajo en equipo**: Un código limpio y estructurado mejora la colaboración. Lxs nuevxs desarrolladorxs pueden integrarse rápidamente y hacer revisiones más efectivas.

- **Soporte a la evolución del software**: Un código mantenible permite realizar cambios y agregar nuevas funcionalidades de manera eficiente, reduciendo la deuda técnica y minimizando riesgos.

## Impacto en la mantenibilidad

- **Facilidad de entendimiento**: Otrxs desarrolladorxs pueden comprender rápidamente el propósito del código, lo que mejora la colaboración y agiliza la incorporación de nuevxs integrantes al equipo.

- **Prevención de errores**: Un código legible facilita la identificación de problemas potenciales antes de que se conviertan en errores críticos.

- **Modificaciones eficientes**: Un código bien estructurado y documentado facilita la implementación de nuevas funcionalidades y la refactorización con menor riesgo.

## Impacto en la escalabilidad

- **Adaptabilidad a nuevos requisitos**: Un código bien estructurado es más flexible ante cambios, permitiendo que el software evolucione sin comprometer la calidad del código existente.

- **Reutilización de componentes**: Componentes modulares y bien definidos pueden ser reutilizados en otros proyectos, ahorrando tiempo de desarrollo.

- **Mejora de la eficiencia del equipo**: Un código limpio permite a lxs miembros del equipo trabajar de manera más productiva, reduciendo conflictos y minimizando la necesidad de refactorizaciones extensas.

## Principios de código limpio

### Nombres descriptivos

Un buen nombre debe revelar la intención. Si es necesario un comentario para explicar lo que hace una función o variable, entonces el nombre no es lo suficientemente claro.

*Ejemplo con nombres poco descriptivos*:

```kotlin
fun getThem(theList: List<IntArray>): List<IntArray> {
    val list1 = mutableListOf<IntArray>()
    for (x in theList) {
        if (x[0] == 4) {
            list1.add(x)
        }
    }
    return list1
}
```

*Ejemplo mejorado con nombres descriptivos*:

```kotlin
fun getFlaggedCells(gameBoard: List<IntArray>): List<IntArray> {
    val flaggedCells = mutableListOf<IntArray>()
    for (cell in gameBoard) {
        if (cell[STATUS_VALUE] == FLAGGED) {
            flaggedCells.add(cell)
        }
    }
    return flaggedCells
}
```

En este caso:
- `gameBoard` sugiere claramente el contexto.
- `flaggedCells` indica explícitamente lo que se está almacenando en la lista.
- `cell` es un nombre más adecuado para cada elemento de la lista.

### Evitar nombres confusos

Evita nombres que varían ligeramente, ya que pueden causar confusión:

- *Incorrecto*: `XYZControllerForEfficientHandlingOfStrings` vs `XYZControllerForEfficientStorageOfStrings`

Tampoco es recomendable usar nombres secuenciales como `a1`, `a2`, ..., `aN`.

*Ejemplo con nombres poco informativos*:

```kotlin
fun copyChars(a1: CharArray, a2: CharArray) {
    for (i in a1.indices) {
        a2[i] = a1[i]
    }
}
```

*Ejemplo mejorado con nombres descriptivos*:

```kotlin
fun copyChars(source: CharArray, destination: CharArray) {
    for (i in source.indices) {
        destination[i] = source[i]
    }
}
```

### Nombres pronunciables

Es fundamental que los nombres sean pronunciables. Como dice Robert C. Martin en *Clean Code*:

> "If you can't pronounce it, you can't discuss it without sounding like an idiot. (...) This matters because programming is a social activity."

*Ejemplo con nombre poco pronunciable*:

```kotlin
val genymdhms: String = TODO() // "generation date, year, month, day, hour, minute, and second"
```

### Funciones

- Las funciones deben ser pequeñas. Como señala Robert C. Martin en *Clean Code*:

> "The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that."

- Las funciones deben tener un solo propósito claro y no dividirse en secciones.

- El número ideal de argumentos de una función es 0, seguido por 1 y luego 2. Tres o más deben estar fuertemente justificados.

- Las funciones deben hacer algo o responder una pregunta, pero no ambas.

### Comentarios

Robert C. Martin también nos recuerda que:

> "The proper use of comments is to compensate for our failure to express ourselves in code."

- Los comentarios son propensos a quedar obsoletos, por lo que deben mantenerse actualizados.
- Deben usarse cuando el código por sí solo no sea suficiente para expresar la intención, pero no como sustituto de un código claro.

### Formato de código

- **Archivos pequeños**: Son más fáciles de manejar y leer.
- **Orden lógico**: El código se lee de arriba hacia abajo, por lo que debe estar organizado de manera que su flujo sea lógico.
- **Estándares de formato**: Es importante definir y seguir estándares de formato en el proyecto para asegurar la consistencia.
- **Herramientas de análisis estático**: Estas herramientas pueden ayudar a detectar problemas de formato y garantizar que el código cumpla con los estándares establecidos.

Mantener un formato de código coherente no solo mejora la legibilidad, sino que también facilita la colaboración y el mantenimiento a largo plazo.
