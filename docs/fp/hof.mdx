---
title: Funciones de Alto Orden
---
import Definition from "../../src/components/Definition";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

## Tipos de Funciones

El **tipo de una función** se define en función de los tipos de sus parámetros y su tipo de retorno. En Kotlin, podemos expresar esto de la siguiente manera:

```kotlin
f: (A, B) -> C
```

Aquí, `A` y `B` representan los tipos de los parámetros que la función acepta, y `C` es el tipo de dato que la función devuelve como resultado. Este tipo de notación es útil para entender cómo las funciones manipulan los datos.

Cuando hablamos de una **función miembro** o una **función de extensión** de un objeto, el tipo de función se expresa incluyendo el tipo del objeto que contiene la función:

```kotlin
f: W.(X, Y) -> Z
```

En este caso, `W` es el tipo del objeto que posee la función, mientras que `X` y `Y` son los tipos de los parámetros que la función acepta, y `Z` es el tipo de retorno.

## Ciudadanos de Primera Clase

Una entidad en un lenguaje de programación es considerada un **"ciudadano de primera clase"** si puede:

- Ser creada dinámicamente durante la ejecución del programa.
- Asignarse a variables.
- Pasarse como argumento a otras funciones.
- Retornarse desde funciones.
- Almacenarse en estructuras de datos como listas o diccionarios.

En Kotlin, las **funciones son ciudadanos de primera clase**, lo que significa que pueden ser tratadas como cualquier otro valor. Esto permite un estilo de programación más modular y reutilizable, ya que puedes pasar y devolver funciones de manera flexible.

### Ejemplo

```kotlin
fun add(a: Int, b: Int): Int = a + b

val add2: (Int, Int) -> Int = ::add
```

En este ejemplo, `add2` es una referencia a la función `add`, lo que demuestra cómo las funciones pueden ser asignadas a variables en Kotlin.

:::info Operador de Referencia de Función
El operador `::` en Kotlin se llama **operador de referencia de función** y se utiliza para obtener una referencia a una función existente. En el ejemplo, `::add` toma la función `add` y la convierte en un valor que puede asignarse a una variable (`add2`), pasarse como argumento o retornarse desde una función.
:::

## Funciones de Alto Orden

Las **funciones de alto orden** son aquellas que **reciben** otras funciones como parámetros o **retornan** una función como resultado. Esto permite un nivel adicional de abstracción y reutilización de código.

Por ejemplo, una función que aplique otra función a todos los elementos de una lista podría tener el siguiente tipo:

```kotlin
(List<A>, (A) -> B) -> List<B>
```

o

```kotlin
List<A>.((A) -> B) -> List<B>
```

Esto indica que la función toma una lista de tipo `A`, una función que transforma elementos de tipo `A` en `B`, y devuelve una nueva lista de tipo `B`.

Otro ejemplo es una función que componga dos funciones y retorne una nueva función. Su tipo sería:

```kotlin
(f: (A) -> B, g: (B) -> C) -> ((A) -> C)
```

Esto significa que la función toma dos funciones `f` y `g` y devuelve una nueva función que transforma un valor de tipo `A` a tipo `C` pasando por los dos pasos intermedios (primero aplica `f` y luego `g`).

### Asociación a la derecha

En la notación de funciones, el operador `->` se asocia a la derecha, lo que significa que:

```kotlin
(A) -> (B) -> C
```

Es equivalente a:

```kotlin
(A) -> ((B) -> C)
```

Esto implica que la función acepta un parámetro de tipo `A` y retorna una función que a su vez toma un parámetro de tipo `B` y retorna un valor de tipo `C`. Este concepto es clave en la **currificación**, una técnica común en la programación funcional.

<Definition title={`Currificación`}>
La **currificación** es el proceso de convertir una función que toma múltiples argumentos en una secuencia de funciones que toman un solo argumento. Esto permite aplicar parcialmente una función, es decir, proporcionar solo algunos de los argumentos necesarios y obtener una nueva función que espera los argumentos restantes.
</Definition>

:::tip Ejercicio: Tipos de Funciones
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Indica el tipo de:
        1. Una función que toma una lista y un predicado (una función que devuelve un booleano) y retorna una lista con solo los elementos que cumplan el predicado.
        2. Una función que toma un `String` que representa un idioma y devuelve una función que toma un nombre y retorna un saludo adecuado a ese idioma.
        3. Una función que toma una lista y una función que combina los elementos de la lista, y retorna un único elemento que resulta de aplicar dicha función.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        1. `(List<A>, (A) -> Boolean) -> List<A>`
        2. `(String) -> (String) -> String`
        3. `(List<A>, (List<A>) -> A) -> A`
    </TabItem>
</Tabs>
:::

### Map

Vamos a programar la función `map`. Esta función toma una lista y una función, luego aplica esa función a todos los elementos de la lista, devolviendo una nueva lista con los resultados.

```kotlin
fun double(n: Int): Int = n * 2

fun square(n: Int): Int = n * n

fun main() {
    println(map(listOf(1, 2, 3, 4, 5), ::double))
    println(map(listOf(1, 2, 3, 4, 5), ::square))
}
```

#### Implementación iterativa de `map`

La implementación básica de `map` toma una lista de cualquier tipo y una función que se aplica a cada elemento de esa lista. La función `map` recorre la lista original, aplica la función a cada elemento, y devuelve una nueva lista con los resultados.

```kotlin
fun <T, R> map(list: List<T>, f: (T) -> R): List<R> {
    val result = mutableListOf<R>()
    for (i in list) {
    result.add(f(i))
}
    return result
}
```

En este código, se crea una lista mutable `result` que almacenará los resultados. A continuación, la función recorre cada elemento de la lista original, aplica la función `f`, y añade el resultado a `result`. Finalmente, se retorna la nueva lista con los resultados aplicados.

:::danger Problema de Mutabilidad
El uso de estructuras mutables como `MutableList` puede generar **efectos secundarios** y **errores inesperados**. En programación funcional, se recomienda evitar la mutabilidad y trabajar con estructuras inmutables para reducir el riesgo de errores y mejorar la mantenibilidad del código.
:::

#### Implementación Recursiva

Una forma más **funcional** de implementar `map` sería utilizando **recursión** en lugar de un bucle. Esta implementación evita el uso de estructuras mutables, lo cual es más acorde con los principios de la programación funcional.

```kotlin
fun <T, R> map(list: List<T>, f: (T) -> R): List<R> = if (list.isEmpty()) {
    emptyList()
} else {
    listOf(f(list.first())) + map(list.drop(1), f)
}
```

En este caso, la función `map` verifica si la lista está vacía. Si lo está, retorna una lista vacía. Si no, aplica la función `f` al primer elemento de la lista (`list.first()`), lo agrega a una nueva lista, y luego llama recursivamente a `map` con el resto de los elementos de la lista (`list.drop(1)`).

:::tip Ejercicio: Implementación de `filter`
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Programa la función ``filter``, que toma una lista de valores de tipo ``T`` y un predicado y retorna una nueva lista con sólo los elementos que cumplen el predicado; utiliza recursión
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun filter(list: List<Int>, f: (Int) -> Boolean): List<Int> = if (list.isEmpty()) {
            emptyList()
        } else {
            val head = list.first()
            val tail = list.drop(1)
            if (f(head)) {
                listOf(head) + filter(tail, f)
            } else {
                filter(tail, f)
            }
        }
        ```
    </TabItem>
</Tabs>
:::

## ¿Qué vimos en este artículo?

En esta lección, exploramos conceptos fundamentales de **funciones de alto orden** en Kotlin y cómo las funciones son tratadas como **ciudadanos de primera clase**. Esto permite que las funciones sean asignadas a variables, pasadas como parámetros, y retornadas desde otras funciones, habilitando un estilo de programación más modular y reutilizable.

1. **Tipos de Funciones**: Aprendimos a expresar el tipo de una función en función de los tipos de sus parámetros y su tipo de retorno, tanto para funciones simples como para funciones miembro o de extensión.

2. **Ciudadanos de Primera Clase**: Vimos cómo en Kotlin, las funciones son ciudadanos de primera clase, lo que significa que pueden ser tratadas como valores.

3. **Operador `::`**: Exploramos el **operador de referencia de función** `::`, que permite obtener una referencia a una función existente para ser usada en otro contexto, como asignarla a una variable.

4. **Funciones de Alto Orden**: Profundizamos en las funciones que aceptan otras funciones como parámetros o retornan funciones. Esto permite un mayor nivel de abstracción en el código.

5. **Implementación de `map`**: Implementamos la función `map` de manera iterativa y recursiva, y discutimos las ventajas de evitar estructuras mutables para seguir los principios de la programación funcional.

### Próxima lección: Funciones Lambda

En la próxima lección, exploraremos las **funciones lambda** en Kotlin. Veremos cómo nos permiten escribir código más conciso y flexible, y cómo podemos utilizarlas para simplificar la creación de funciones de alto orden.
