---
title: Funciones de Alto Orden
---
import Definition from "../../src/components/Definition";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../src/components/ReadingTime';
import Exercise from '@site/src/components/exercise/Exercise';
import Solution from '@site/src/components/exercise/Solution';
import References from '@site/src/components/ReferencesComponent';

<ReadingTime />

<details>
    <summary>Comencemos por crear un módulo para esta sección</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell showLineNumbers
            New-Item -Path "hof\src\main\kotlin" -ItemType Directory
            Set-Content -Path "hof\build.gradle.kts" -Value "// Intentionally left blank"
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell showLineNumbers
            mkdir hof\src\main\kotlin
            "// Intentionally left blank" > hof\build.gradle.kts
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash showLineNumbers
            mkdir -p hof/src/main/kotlin
            echo "// Intentionally left blank" > hof/build.gradle.kts
            ```
        </TabItem>
    </Tabs>
</details>

Las **funciones de alto orden** son aquellas que **reciben** otras funciones como parámetros o **retornan** una función como resultado. Esto permite un nivel adicional de abstracción y reutilización de código.

Por ejemplo, una función que aplique otra función a todos los elementos de una lista podría tener el siguiente tipo:

```kotlin
(List<A>, (A) -> B) -> List<B>
```

o

```kotlin
List<A>.((A) -> B) -> List<B>
```

Esto indica que la función toma una lista de tipo `A`, una función que transforma elementos de tipo `A` en `B`, y devuelve una nueva lista de tipo `B`.

Otro ejemplo es una función que componga dos funciones y retorne una nueva función. Su tipo sería:

```kotlin
(f: (A) -> B, g: (B) -> C) -> ((A) -> C)
```

Esto significa que la función toma dos funciones `f` y `g` y devuelve una nueva función que transforma un valor de tipo `A` a tipo `C` pasando por los dos pasos intermedios (primero aplica `f` y luego `g`).

### Asociación a la derecha

En la notación de funciones, el operador `->` se asocia a la derecha, lo que significa que:

```kotlin
(A) -> (B) -> C
```

Es equivalente a:

```kotlin
(A) -> ((B) -> C)
```

Esto implica que la función acepta un parámetro de tipo `A` y retorna una función que a su vez toma un parámetro de tipo `B` y retorna un valor de tipo `C`. Este concepto es clave en la **currificación**, una técnica común en la programación funcional.

<Definition title={`Currificación`}>
La **currificación** es el proceso de convertir una función que toma múltiples argumentos en una secuencia de funciones que toman un solo argumento. Esto permite aplicar parcialmente una función, es decir, proporcionar solo algunos de los argumentos necesarios y obtener una nueva función que espera los argumentos restantes.
</Definition>

<Exercise title={"Tipos de Funciones"}>
    
    Indica el tipo de:

    1. Una función que toma una lista y un predicado (una función que devuelve un booleano) y retorna una lista con solo los elementos que cumplan el predicado.
    2. Una función que toma un `String` que representa un idioma y devuelve una función que toma un nombre y retorna un saludo adecuado a ese idioma.
    3. Una función que toma una lista y una función que combina los elementos de la lista, y retorna un único elemento que resulta de aplicar dicha función.

    <Solution>
        1. `(List<A>, (A) -> Boolean) -> List<A>`
        2. `(String) -> (String) -> String`
        3. `(List<A>, (List<A>) -> A) -> A`    
    </Solution>
</Exercise>

### Map

Vamos a programar la función `map`. Esta función toma una lista y una función, luego aplica esa función a todos los elementos de la lista, devolviendo una nueva lista con los resultados.

<details>
    <summary>Si quieres crear el archivo desde la terminal...</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path hof\src\main\kotlin\com\github\your_user\functional\map\Main.kt -ItemType File
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            ni hof\src\main\kotlin\com\github\your_user\functional\map\Main.kt
            ```
        </TabItem>
        <TabItem value="Unix" label="Unix">
            ```bash
            touch hof/src/main/kotlin/com/github/your_user/functional/map/Main.kt
            ```
        </TabItem>
    </Tabs>
</details>

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Main.kt"
        println(map(listOf(1, 2, 3, 4, 5), ::double))
        println(map(listOf(1, 2, 3, 4, 5), ::square))
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Main.kt"
        package com.github.your_user.functional.map

        fun double(n: Int): Int = n * 2

        fun square(n: Int): Int = n * n

        fun main() {
            println(map(listOf(1, 2, 3, 4, 5), ::double))
            println(map(listOf(1, 2, 3, 4, 5), ::square))
        }
        ```
    </TabItem>
</Tabs>

#### Implementación iterativa de `map`

<details>
    <summary>Si quieres crear el archivo desde la terminal...</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path hof\src\main\kotlin\com\github\your_user\functional\map\Map.kt -ItemType File
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            ni hof\src\main\kotlin\com\github\your_user\functional\map\Map.kt
            ```
        </TabItem>
        <TabItem value="Unix" label="Unix">
            ```bash
            touch hof/src/main/kotlin/com/github/your_user/functional/map/Map.kt
            ```
        </TabItem>
    </Tabs>
</details>

La implementación básica de `map` toma una lista de cualquier tipo y una función que se aplica a cada elemento de esa lista. La función `map` recorre la lista original, aplica la función a cada elemento, y devuelve una nueva lista con los resultados.

<Tabs>
    <TabItem value="Código esencial" label="Código esencial">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Map.kt"
        fun <T, R> map(list: List<T>, f: (T) -> R): List<R> {
            val result = mutableListOf<R>()
            for (i in list) {
                result.add(f(i))
            }
            return result
        }
        ```
    </TabItem>
    <TabItem value="Código completo" label="Código completo">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Map.kt"
        package com.github.your_user.functional.map

        fun <T, R> map(list: List<T>, f: (T) -> R): List<R> {
            val result = mutableListOf<R>()
            for (i in list) {
                result.add(f(i))
            }
            return result
        }
        ```
    </TabItem>
</Tabs>

En este código, se crea una lista mutable `result` que almacenará los resultados. A continuación, la función recorre cada elemento de la lista original, aplica la función `f`, y añade el resultado a `result`. Finalmente, se retorna la nueva lista con los resultados aplicados.

:::danger Problema de Mutabilidad
El uso de estructuras mutables como `MutableList` puede generar **efectos secundarios** y **errores inesperados**. En programación funcional, se recomienda evitar la mutabilidad y trabajar con estructuras inmutables para reducir el riesgo de errores y mejorar la mantenibilidad del código.
:::

#### Implementación Recursiva

Una forma más **funcional** de implementar `map` sería utilizando **recursión** en lugar de un bucle. Esta implementación evita el uso de estructuras mutables, lo cual es más acorde con los principios de la programación funcional.

<Tabs>
    <TabItem value="Código esencial" label="Código esencial">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Map.kt"
        fun <T, R> map(list: List<T>, f: (T) -> R): List<R> = if (list.isEmpty()) {
            emptyList()
        } else {
            listOf(f(list.first())) + map(list.drop(1), f)
        }
        ```
    </TabItem>
    <TabItem value="Código completo" label="Código completo">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/map/Map.kt"
        package com.github.your_user.functional.map

        fun <T, R> map(list: List<T>, f: (T) -> R): List<R> = if (list.isEmpty()) {
            emptyList()
        } else {
            listOf(f(list.first())) + map(list.drop(1), f)
        }
        ```
    </TabItem>
</Tabs>

En este caso, la función `map` verifica si la lista está vacía. Si lo está, retorna una lista vacía. Si no, aplica la función `f` al primer elemento de la lista (`list.first()`), lo agrega a una nueva lista, y luego llama recursivamente a `map` con el resto de los elementos de la lista (`list.drop(1)`).

<Exercise title="Implementación de filter">
    Programa la función `filter`, que toma una lista de valores de tipo `T` y un predicado, y retorna una nueva lista con solo los elementos que cumplen el predicado. Utiliza recursión.

    <Solution>
        ```kotlin
        fun filter(list: List<Int>, f: (Int) -> Boolean): List<Int> = if (list.isEmpty()) {
            emptyList()
        } else {
            val head = list.first()
            val tail = list.drop(1)
            if (f(head)) {
                listOf(head) + filter(tail, f)
            } else {
                filter(tail, f)
            }
        }
        ```
    </Solution>
</Exercise>

### Fold

<details>
    <summary>Si quieres crear el archivo desde la terminal...</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path hof\src\main\kotlin\com\github\your_user\functional\fold\Fold.kt -ItemType File
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            ni hof\src\main\kotlin\com\github\your_user\functional\fold\Fold.kt
            ```
        </TabItem>
        <TabItem value="Unix" label="Unix">
            ```bash
            touch hof/src/main/kotlin/com/github/your_user/functional/fold/Fold.kt
            ```
        </TabItem>
    </Tabs>
</details>

Imagina que tienes una lista de números y quieres sumarlos todos. Una forma de hacerlo es recorrer cada número y sumar su valor al total. Este proceso de "acumular" valores es exactamente lo que hace una función como `fold`.

En programación funcional, **`fold`** toma una lista y la "reduce" a un solo valor aplicando una operación (por ejemplo, sumar o multiplicar) a todos sus elementos, uno por uno.

#### ¿Cómo funciona?

1. **Elemento inicial**: Necesitamos un valor inicial que actúe como "base". Este valor se usa para comenzar la acumulación.
2. **Función de acumulación**: Usamos una función que toma dos valores: el acumulador (que guarda el resultado parcial) y el siguiente elemento de la lista. La función combina estos dos valores y devuelve un nuevo valor acumulado.
3. **Recorrer la lista**: Aplicamos esta función de acumulación a cada elemento de la lista, combinándolo con el valor acumulado hasta ese punto.

#### Ejemplo con suma

Si tienes la lista `[1, 2, 3]` y quieres sumar los números, el proceso sería algo así:

- Partimos con un acumulador inicial, por ejemplo, `0`.
- Tomamos el primer número (`1`) y lo sumamos al acumulador (`0 + 1 = 1`).
- Tomamos el siguiente número (`2`) y lo sumamos al acumulador (`1 + 2 = 3`).
- Tomamos el último número (`3`) y lo sumamos al acumulador (`3 + 3 = 6`).

El resultado final es `6`.

#### Implementación recursiva de `fold`

A continuación, vamos a implementar una versión recursiva de `fold`:

<Tabs>
    <TabItem value="Código esencial" label="Código esencial">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/fold/Fold.kt"
        fun <T, R> fold(list: List<T>, initial: R, combine: (R, T) -> R): R =
            if (list.isEmpty()) {
                initial
            } else {
                val first = list.first()
                val rest = list.drop(1)
                val newAcc = combine(initial, first)
                fold<T, R>(rest, newAcc, combine)
            }
        ```
    </TabItem>
    <TabItem value="Código completo" label="Código completo">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/fold/Fold.kt"
        package cl.ravenhill.functional.fold

        fun <T, R> fold(list: List<T>, initial: R, combine: (R, T) -> R): R =
            if (list.isEmpty()) {
                initial
            } else {
                val first = list.first()
                val rest = list.drop(1)
                val newAcc = combine(initial, first)
                fold<T, R>(rest, newAcc, combine)
            }
        ```
    </TabItem>
</Tabs>

**¿Qué hace esta función?**
- **(1)** Recibe una lista de tipo `T`, un valor inicial de tipo `R`, y una función que combina un valor de tipo `R` con un valor de tipo `T` para producir un nuevo valor de tipo `R`.
- **(3)** Si la lista está vacía, retorna el valor inicial.
- **(5-6)** Si no, toma el primer elemento de la lista y el resto de la lista.
- **(7)** Combina el valor inicial con el primer elemento.
- **(8)** Llama recursivamente a `fold` con el resto de la lista y el nuevo valor acumulado.

#### Ejemplo de uso

<details>
    <summary>Si quieres crear el archivo desde la terminal...</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path hof\src\main\kotlin\com\github\your_user\functional\fold\Main.kt -ItemType File
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            ni hof\src\main\kotlin\com\github\your_user\functional\fold\Main.kt
            ```
        </TabItem>
        <TabItem value="Unix" label="Unix">
            ```bash
            touch hof/src/main/kotlin/com/github/your_user/functional/fold/Main.kt
            ```
        </TabItem>
    </Tabs>
</details>

Vamos a usar esta función para sumar una lista de números:

<Tabs>
    <TabItem value="Código esencial" label="Código esencial">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/fold/Main.kt"
        val numbers = listOf(1, 2, 3, 4, 5)
        val result = fold(numbers, 0, ::sum)
        println(result)  // Imprime: 15
        ```
    </TabItem>
    <TabItem value="Código completo" label="Código completo">
        ```kotlin showLineNumbers title="hof/src/main/kotlin/com/github/your_user/functional/fold/Main.kt"
        package com.github.your_user.functional.fold

        fun sum(a: Int, b: Int) = a + b

        fun main() {
            val numbers = listOf(1, 2, 3, 4, 5)
            val result = fold(numbers, 0, ::sum)
            println(result)  // Imprime: 15
        }
        ```
    </TabItem>
</Tabs>

Aquí usamos la función `sum` para combinar los números. El valor inicial es `0`, y la lista es `[1, 2, 3, 4, 5]`. El resultado final será `15`.

<Exercise title="Generación de acrónimos">
    Supongamos que necesitas implementar una función que construya un acrónimo a partir de una lista de palabras. En específico, tu objetivo es construir una nueva palabra a partir de la primera letra de cada palabra de la lista. Si la palabra tiene menos de 3 letras, la ignoras.

    Implementa la función `acronym: (List<String>) -> String` que cumpla con esta especificación utilizando la función `fold`.

    <Solution>
        ```kotlin
        fun combine(acc: String, word: String): String =
            if (word.length >= 3) acc + word.first() else acc
        fun acronym(words: List<String>) = fold(words, "", ::combine)
        ```
    </Solution>
</Exercise>

### Resumen de la Lección

En esta lección, exploramos las **funciones de alto orden**, su poder para recibir o retornar otras funciones, y cómo permiten un nivel más alto de abstracción y reutilización de código.

Vimos cómo funcionan conceptos clave como:

1. **Currificación**: El proceso de convertir una función con múltiples argumentos en una secuencia de funciones que toman un solo argumento. Esto permite la aplicación parcial de funciones.
2. **Map**: Implementamos la función `map` tanto de forma iterativa como recursiva, y discutimos los problemas de mutabilidad en las estructuras de datos.
3. **Filter**: Implementamos `filter` como una función recursiva que selecciona los elementos de una lista que cumplen con un predicado.
4. **Fold**: Introdujimos el concepto de **fold** como una forma de "reducir" una lista a un único valor aplicando una operación acumulativa. Exploramos su uso para sumar números y generar acrónimos a partir de listas de palabras.

Al final, comprendimos cómo estas funciones permiten una programación más funcional, modular y flexible.

<References references={[
    {
        title: "Getting started with functional programming in Kotlin",
        bookTitle: "Functional Programming in Kotlin",
        pages: "17-30",
        location: "Shelter Island, NY",
        publisher: "Manning",
        year: "2021",
        type: "book",
        author: 'Marco Vermeulen, Rúnar Bjarnason, Paul Chiusano'
    },
]}
/>
