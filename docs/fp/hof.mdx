---
title: Funciones de Alto Orden
---
import Definition from "../../src/components/Definition";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

Las **funciones de alto orden** son aquellas que **reciben** otras funciones como parámetros o **retornan** una función como resultado. Esto permite un nivel adicional de abstracción y reutilización de código.

Por ejemplo, una función que aplique otra función a todos los elementos de una lista podría tener el siguiente tipo:

```kotlin
(List<A>, (A) -> B) -> List<B>
```

o

```kotlin
List<A>.((A) -> B) -> List<B>
```

Esto indica que la función toma una lista de tipo `A`, una función que transforma elementos de tipo `A` en `B`, y devuelve una nueva lista de tipo `B`.

Otro ejemplo es una función que componga dos funciones y retorne una nueva función. Su tipo sería:

```kotlin
(f: (A) -> B, g: (B) -> C) -> ((A) -> C)
```

Esto significa que la función toma dos funciones `f` y `g` y devuelve una nueva función que transforma un valor de tipo `A` a tipo `C` pasando por los dos pasos intermedios (primero aplica `f` y luego `g`).

### Asociación a la derecha

En la notación de funciones, el operador `->` se asocia a la derecha, lo que significa que:

```kotlin
(A) -> (B) -> C
```

Es equivalente a:

```kotlin
(A) -> ((B) -> C)
```

Esto implica que la función acepta un parámetro de tipo `A` y retorna una función que a su vez toma un parámetro de tipo `B` y retorna un valor de tipo `C`. Este concepto es clave en la **currificación**, una técnica común en la programación funcional.

<Definition title={`Currificación`}>
La **currificación** es el proceso de convertir una función que toma múltiples argumentos en una secuencia de funciones que toman un solo argumento. Esto permite aplicar parcialmente una función, es decir, proporcionar solo algunos de los argumentos necesarios y obtener una nueva función que espera los argumentos restantes.
</Definition>

:::tip Ejercicio: Tipos de Funciones
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Indica el tipo de:
        1. Una función que toma una lista y un predicado (una función que devuelve un booleano) y retorna una lista con solo los elementos que cumplan el predicado.
        2. Una función que toma un `String` que representa un idioma y devuelve una función que toma un nombre y retorna un saludo adecuado a ese idioma.
        3. Una función que toma una lista y una función que combina los elementos de la lista, y retorna un único elemento que resulta de aplicar dicha función.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        1. `(List<A>, (A) -> Boolean) -> List<A>`
        2. `(String) -> (String) -> String`
        3. `(List<A>, (List<A>) -> A) -> A`
    </TabItem>
</Tabs>
:::

### Map

Vamos a programar la función `map`. Esta función toma una lista y una función, luego aplica esa función a todos los elementos de la lista, devolviendo una nueva lista con los resultados.

```kotlin
fun double(n: Int): Int = n * 2

fun square(n: Int): Int = n * n

fun main() {
    println(map(listOf(1, 2, 3, 4, 5), ::double))
    println(map(listOf(1, 2, 3, 4, 5), ::square))
}
```

#### Implementación iterativa de `map`

La implementación básica de `map` toma una lista de cualquier tipo y una función que se aplica a cada elemento de esa lista. La función `map` recorre la lista original, aplica la función a cada elemento, y devuelve una nueva lista con los resultados.

```kotlin
fun <T, R> map(list: List<T>, f: (T) -> R): List<R> {
    val result = mutableListOf<R>()
    for (i in list) {
        result.add(f(i))
    }
    return result
}
```

En este código, se crea una lista mutable `result` que almacenará los resultados. A continuación, la función recorre cada elemento de la lista original, aplica la función `f`, y añade el resultado a `result`. Finalmente, se retorna la nueva lista con los resultados aplicados.

:::danger Problema de Mutabilidad
El uso de estructuras mutables como `MutableList` puede generar **efectos secundarios** y **errores inesperados**. En programación funcional, se recomienda evitar la mutabilidad y trabajar con estructuras inmutables para reducir el riesgo de errores y mejorar la mantenibilidad del código.
:::

#### Implementación Recursiva

Una forma más **funcional** de implementar `map` sería utilizando **recursión** en lugar de un bucle. Esta implementación evita el uso de estructuras mutables, lo cual es más acorde con los principios de la programación funcional.

```kotlin
fun <T, R> map(list: List<T>, f: (T) -> R): List<R> = if (list.isEmpty()) {
    emptyList()
} else {
    listOf(f(list.first())) + map(list.drop(1), f)
}
```

En este caso, la función `map` verifica si la lista está vacía. Si lo está, retorna una lista vacía. Si no, aplica la función `f` al primer elemento de la lista (`list.first()`), lo agrega a una nueva lista, y luego llama recursivamente a `map` con el resto de los elementos de la lista (`list.drop(1)`).

:::tip Ejercicio: Implementación de `filter`
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Programa la función ``filter``, que toma una lista de valores de tipo ``T`` y un predicado y retorna una nueva lista con sólo los elementos que cumplen el predicado; utiliza recursión
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun filter(list: List<Int>, f: (Int) -> Boolean): List<Int> = if (list.isEmpty()) {
            emptyList()
        } else {
            val head = list.first()
            val tail = list.drop(1)
            if (f(head)) {
                listOf(head) + filter(tail, f)
            } else {
                filter(tail, f)
            }
        }
        ```
    </TabItem>
</Tabs>
:::

### Fold

Imagina que tienes una lista de números y quieres sumarlos todos. Una forma de hacerlo es recorrer cada número y sumar su valor al total. Este proceso de "acumular" valores es exactamente lo que hace una función como `fold`.

En programación funcional, **`fold`** toma una lista y la "reduce" a un solo valor aplicando una operación (por ejemplo, sumar o multiplicar) a todos sus elementos, uno por uno.

#### ¿Cómo funciona?

1. **Elemento inicial**: Necesitamos un valor inicial que actúe como "base". Este valor se usa para comenzar la acumulación.
2. **Función de acumulación**: Usamos una función que toma dos valores: el acumulador (que guarda el resultado parcial) y el siguiente elemento de la lista. La función combina estos dos valores y devuelve un nuevo valor acumulado.
3. **Recorrer la lista**: Aplicamos esta función de acumulación a cada elemento de la lista, combinándolo con el valor acumulado hasta ese punto.

#### Ejemplo con suma

Si tienes la lista `[1, 2, 3]` y quieres sumar los números, el proceso sería algo así:

- Partimos con un acumulador inicial, por ejemplo, `0`.
- Tomamos el primer número (`1`) y lo sumamos al acumulador (`0 + 1 = 1`).
- Tomamos el siguiente número (`2`) y lo sumamos al acumulador (`1 + 2 = 3`).
- Tomamos el último número (`3`) y lo sumamos al acumulador (`3 + 3 = 6`).

El resultado final es `6`.

#### Implementación recursiva de `fold`

A continuación, vamos a implementar una versión recursiva de `fold`:

```kotlin
fun <T, R> fold(list: List<T>, initial: R, combine: (R, T) -> R) =
    if (list.isEmpty()) {
        initial // Caso base: devolvemos el valor acumulado
    } else {
        // Caso recursivo: combinamos el primer elemento de la lista con el valor acumulado,
        // luego seguimos procesando el resto de la lista
        val first = list.first() // Primer elemento
        val rest = list.drop(1)  // Resto de la lista
        val newAcc = combine(initial, first) // Actualizamos el acumulador
        fold(rest, newAcc, combine) // Llamada recursiva con la nueva lista y acumulador
    }
```

#### Ejemplo de uso

Vamos a usar esta función para sumar una lista de números:

```kotlin
fun sum(a: Int, b: Int) = a + b

fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    val result = fold(numbers, 0, ::sum)
    println(result)  // Imprime: 15
}
```

Aquí usamos la función `sum` para combinar los números. El valor inicial es `0`, y la lista es `[1, 2, 3, 4, 5]`. El resultado final será `15`.

:::tip Ejercicio
<Tabs>
    <TabItem value="Enunciado" label="Enunciado">
        Supongamos que necesitas implementar una función que construya un acrónimo a partir de una lista de palabras. En específico, tu objetivo es construir una nueva palabra a partir de la primera letra de cada palabra de la lista. Si la palabra tiene menos de 3 letras, la ignoras.

        Implementa la función ``acronym: (List<String>) -> String`` que cumpla con esta especificación utilizando la función ``fold``.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun combine(acc: String, word: String): String =
            if (word.length >= 3) acc + word.first() else acc
        fun acronym(words: List<String>) = fold(words, "", ::combine)
        ```
    </TabItem>
</Tabs>
:::

<details>
    <summary>Ejemplos en otros lenguajes</summary>
    ## Ejemplos de Funciones de Alto Orden en Otros Lenguajes

    ### Scala

    En Scala, la implementación de `map` usando recursión sería de esta manera:

    ```scala
    def double(n: Int): Int = n * 2
    def square(n: Int): Int = n * n

    def map[T, R](list: List[T], f: T => R): List[R] = list match {
        case Nil => Nil
        case head :: tail => f(head) :: map(tail, f)
    }

    @main def main(): Unit = {
        val nums = List(1, 2, 3, 4)
        println(map(nums, double))  // List(2, 4, 6, 8)
        println(map(nums, square))  // List(1, 4, 9, 16)
    }
    ```

    En este código, la recursión se logra verificando si la lista está vacía (caso base) y aplicando la función `f` al primer elemento, seguido de una llamada recursiva sobre el resto de la lista.

    ### TypeScript

    En TypeScript, podemos implementar una versión recursiva de `map` como esta:

    ```typescript
    function double(n: number): number {
        return n * 2;
    }

    function square(n: number): number {
        return n * n;
    }

    function map<T, R>(list: T[], f: (arg: T) => R): R[] {
        if (list.length === 0) {
            return [];
        }
        const [head, ...tail] = list;
        return [f(head), ...map(tail, f)];
    }

    const nums = [1, 2, 3, 4];
    console.log(map(nums, double));  // [2, 4, 6, 8]
    console.log(map(nums, square));  // [1, 4, 9, 16]
    ```

    Este código es recursivo y utiliza el operador de desestructuración para separar la lista en su **cabeza** (primer elemento) y **cola** (resto de la lista), aplicando `map` sobre el resto de los elementos.

    ### Python

    La implementación recursiva en Python sería algo como esto:

    ```python
    from typing import Callable

    def double(n: int) -> int:
        return n * 2

    def square(n: int) -> int:
        return n * n

    def map_list(lst: list[int], func: Callable[[int], int]) -> list[int]:
        if not lst:
            return []
        return [func(lst[0])] + map_list(lst[1:], func)

    nums = [1, 2, 3, 4]
    print(map_list(nums, double))  # [2, 4, 6, 8]
    print(map_list(nums, square))  # [1, 4, 9, 16]
    ```

    En este código, usamos la recursión para ir reduciendo la lista hasta que esté vacía (caso base), aplicando la función al primer elemento y concatenando el resultado con la llamada recursiva para el resto de la lista.

    ### Haskell

    En Haskell, la versión recursiva de `map` es casi natural debido a su enfoque en la recursión:

    ```haskell
    double :: Int -> Int
    double n = n * 2

    square :: Int -> Int
    square n = n * n

    map' :: (a -> b) -> [a] -> [b]
    map' _ [] = []
    map' f (x:xs) = f x : map' f xs

    main = do
    print (map' double [1, 2, 3, 4])  -- [2, 4, 6, 8]
    print (map' square [1, 2, 3, 4])  -- [1, 4, 9, 16]
    ```

    En Haskell, la recursión es un enfoque estándar. El caso base es la lista vacía, y en cada paso se aplica la función al primer elemento, seguido de una llamada recursiva al resto de la lista.

    ### Clojure

    La implementación recursiva en Clojure también es directa:

    ```clojure
    (defn double-it [n]
        (* n 2))

    (defn square [n]
        (* n n))

    (defn map-fn [f lst]
        (if (empty? lst)
            '()
            (cons (f (first lst)) (map-fn f (rest lst)))))

    (println (map-fn double-it [1, 2, 3, 4]))  ; (2 4 6 8)
    (println (map-fn square [1, 2, 3, 4]))     ; (1 4 9 16)
    ```

    Aquí también usamos recursión de forma explícita, con `first` y `rest` para descomponer la lista en su cabeza y cola respectivamente, aplicando `map-fn` sobre los elementos restantes.

    ### Java

    En Java, la recursión es menos común, pero podemos implementar `map` de manera recursiva usando las estructuras básicas del lenguaje:

    ```java
    import java.util.ArrayList;
    import java.util.List;
    import java.util.function.Function;

    public class Main {
        public static int doubleIt(int n) {
            return n * 2;
        }

        public static int square(int n) {
            return n * n;
        }

        public static <T, R> List<R> map(List<T> list, Function<T, R> func) {
            if (list.isEmpty()) {
                return new ArrayList<>();
            }
            List<R> result = new ArrayList<>();
            result.add(func.apply(list.get(0)));
            result.addAll(map(list.subList(1, list.size()), func));
            return result;
        }

        public static void main(String[] args) {
            List<Integer> nums = List.of(1, 2, 3, 4);
            System.out.println(map(nums, Main::doubleIt));  // [2, 4, 6, 8]
            System.out.println(map(nums, Main::square));    // [1, 4, 9, 16]
        }
    }
    ```

    Aquí usamos recursión en lugar de bucles. `map` se llama a sí misma con la sublista restante, aplicando la función al primer elemento de la lista original.
</details>

## ¿Qué vimos en este artículo?

En esta lección, exploramos el concepto de **funciones de alto orden**, que son aquellas que aceptan funciones como parámetros o devuelven funciones como resultado. Estas funciones permiten una mayor abstracción y modularidad, lo que facilita la reutilización de código y la creación de soluciones más flexibles.

- Vimos cómo **las funciones son ciudadanos de primera clase** en Kotlin, lo que significa que pueden ser tratadas como valores que se asignan a variables, se pasan como argumentos y se devuelven desde otras funciones.
- Aprendimos a definir y usar **funciones de alto orden**, observando su tipo y cómo aplicar funciones a los elementos de una lista usando ejemplos como `map` y `filter`.
- Exploramos las implementaciones tanto **iterativas** como **recursivas** de funciones de alto orden, destacando las ventajas de la recursión en un enfoque funcional y los peligros de la mutabilidad en el diseño de código.
- Finalmente, revisamos el concepto de **fold**, una poderosa función para reducir listas a un solo valor, y cómo se puede implementar recursivamente para sumar elementos o construir estructuras más complejas como acrónimos.

A lo largo de la lección, también vimos ejemplos prácticos de estos conceptos en varios lenguajes de programación, desde Kotlin hasta Python, Scala, TypeScript, Haskell, y otros, demostrando cómo las funciones de alto orden son un pilar fundamental en la programación funcional y son ampliamente soportadas en distintos lenguajes.

### Próxima lección: Funciones Lambda

En la próxima lección, exploraremos las **funciones lambda** en Kotlin. Veremos cómo nos permiten escribir código más conciso y flexible, y cómo podemos utilizarlas para simplificar la creación de funciones de alto orden.
