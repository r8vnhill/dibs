---
title: Enumeraciones en otros lenguajes
---

## C\#

En **C#**, las enumeraciones (`enum`) son tipos de valor que representan un conjunto de constantes nombradas. A diferencia de Kotlin y otros lenguajes como Swift o Rust, las enumeraciones en C# son más limitadas y no pueden contener métodos ni propiedades adicionales, excepto en versiones más recientes del lenguaje que permiten ciertas extensiones.

### Definición de la Enumeración

```csharp
public enum DeliveryState
{
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled
}
```

### Uso de la Enumeración

Puedes utilizar la enumeración `DeliveryState` para representar el estado de una entrega en tu aplicación:

```csharp
public void HandleOrderState(DeliveryState state)
{
    switch (state)
    {
        case DeliveryState.Pending:
            Console.WriteLine("Order is pending");
            break;
        case DeliveryState.Paid:
            Console.WriteLine("Order is paid");
            break;
        case DeliveryState.Shipped:
            Console.WriteLine("Order is shipped");
            break;
        case DeliveryState.Delivered:
            Console.WriteLine("Order is delivered");
            break;
        case DeliveryState.Cancelled:
            Console.WriteLine("Order is cancelled");
            break;
        default:
            throw new ArgumentOutOfRangeException(nameof(state), state, null);
    }
}
```

En este ejemplo:

- Se utiliza un `switch` para manejar cada posible valor de la enumeración.
- El `default` maneja cualquier valor fuera del rango esperado, aunque en este caso no debería ser necesario si todos los casos están cubiertos.

### Similitudes con Kotlin

- **Definición de Valores Nombrados**: Tanto en C# como en Kotlin, las enumeraciones permiten definir un conjunto de constantes nombradas que representan estados o valores predefinidos.
- **Uso en Estructuras de Control**: Ambos lenguajes permiten usar las enumeraciones en estructuras de control como `switch`/`when` para tomar decisiones basadas en el valor actual.

### Diferencias con Kotlin

- **Capacidad de Extensión**: En Kotlin, las enumeraciones pueden contener propiedades, métodos e incluso implementar interfaces. En C#, las enumeraciones tradicionales no pueden contener métodos ni propiedades. Sin embargo, desde C# 8.0 y versiones posteriores, es posible agregar métodos a enums utilizando métodos de extensión.
- **Exhaustividad**: El `switch` en C# no es exhaustivo por defecto, esto introduce posibles errores si se agregan más valores a las enumeraciones. En Kotlin, el `when` puede ser exhaustivo, y el compilador fuerza que se manejen todos los casos.
- **Valores Subyacentes**: En C#, cada miembro de una enumeración tiene un valor numérico subyacente (por defecto `int`), y es posible asignar valores específicos a cada miembro.

### Agregando Funcionalidad con Métodos de Extensión

Para agregar métodos a una enumeración en C#, puedes utilizar **métodos de extensión**:

```csharp
public static class DeliveryStateExtensions
{
    public static bool IsFinalState(this DeliveryState state)
    {
        return state == DeliveryState.Delivered || state == DeliveryState.Cancelled;
    }

    public static string Signal(this DeliveryState state)
    {
        return state switch
        {
            DeliveryState.Pending => "Order is pending",
            DeliveryState.Paid => "Order is paid",
            DeliveryState.Shipped => "Order is shipped",
            DeliveryState.Delivered => "Order is delivered",
            DeliveryState.Cancelled => "Order is cancelled",
            _ => throw new ArgumentOutOfRangeException(nameof(state), state, null)
        };
    }
}
```

Ahora puedes utilizar estos métodos como si fueran parte de la enumeración:

```csharp
public void HandleOrderState(DeliveryState state)
{
    if (state.IsFinalState())
    {
        Console.WriteLine("Final state: " + state.Signal());
    }
    else
    {
        Console.WriteLine("Non-final state: " + state.Signal());
    }
}
```

### Similitudes y Diferencias en este Contexto

- **Similitud**: Al igual que en Kotlin, puedes asociar comportamiento a los valores de la enumeración mediante métodos (aunque en C# se logra con métodos de extensión).
- **Diferencia**: En Kotlin, los métodos y propiedades pueden definirse directamente dentro de la enumeración, mientras que en C# necesitas utilizar métodos de extensión externos.

### Limitaciones de las Enumeraciones en C#

1. **No Pueden Contener Estado o Datos Asociados**: Las enumeraciones en C# no pueden tener propiedades o campos para almacenar datos adicionales por defecto.
2. **No Soportan Herencia**: Las enumeraciones en C# no pueden heredar de otras enumeraciones o clases.
3. **Valores Numéricos Subyacentes**: Cada miembro de una enumeración en C# tiene un valor numérico, lo que puede llevar a usos no intencionales si se manipulan como enteros.

### Ventajas de las Enumeraciones en C#

1. **Simplicidad**: Son sencillas de definir y utilizar para representar un conjunto fijo de constantes.
2. **Interoperabilidad**: Los enums de C# son ampliamente soportados y se integran bien con otras partes del ecosistema .NET.
3. **Bit Flags**: Puedes utilizar atributos como `[Flags]` para representar combinaciones de valores mediante operaciones bit a bit.

### Ejemplo con el Atributo `[Flags]`

```csharp
[Flags]
public enum FileAccess
{
    Read = 1,
    Write = 2,
    Execute = 4
}

// Uso:
var access = FileAccess.Read | FileAccess.Write;
if ((access & FileAccess.Read) == FileAccess.Read)
{
    Console.WriteLine("Read access granted.");
}
```

### Comparación con Kotlin

- **Operaciones Bit a Bit**: En C#, es común utilizar enums con el atributo `[Flags]` para manejar combinaciones de valores, lo cual no es directamente soportado en las enumeraciones de Kotlin.
- **Capacidad de Extensión Limitada**: Aunque es posible agregar métodos de extensión, las enumeraciones en C# son menos flexibles que en Kotlin en cuanto a la capacidad de contener lógica y estado adicional.

## Rust

En **Rust**, las enumeraciones (`enum`) son tipos algebraicos que permiten representar un conjunto de variantes, cada una de las cuales puede tener datos asociados y métodos. Las enumeraciones en Rust son más potentes que en muchos otros lenguajes y permiten lograr un comportamiento similar al de las enumeraciones en Kotlin.

### Definición de la Enumeración

```rust
enum DeliveryState {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}
```

### Métodos en Enumeraciones

Puedes implementar métodos para las enumeraciones utilizando bloques `impl`. Esto te permite asociar funciones y propiedades a las variantes de la enumeración.

```rust
impl DeliveryState {
    fn signal(&self) -> &str {
        match self {
            DeliveryState::Pending => "Order is pending",
            DeliveryState::Paid => "Order is paid",
            DeliveryState::Shipped => "Order is shipped",
            DeliveryState::Delivered => "Order is delivered",
            DeliveryState::Cancelled => "Order is cancelled",
        }
    }

    fn is_final_state(&self) -> bool {
        matches!(self, DeliveryState::Delivered | DeliveryState::Cancelled)
    }
}
```

### Uso del `match` Exhaustivo

En Rust, el `match` es exhaustivo por defecto. Esto significa que el compilador te obligará a manejar todos los posibles valores de la enumeración, similar al `when` exhaustivo de Kotlin.

```rust
fn handle_order_state(state: DeliveryState) {
    match state {
        DeliveryState::Pending => println!("Order is pending"),
        DeliveryState::Paid => println!("Order is paid"),
        DeliveryState::Shipped => println!("Order is shipped"),
        DeliveryState::Delivered => println!("Order is delivered"),
        DeliveryState::Cancelled => println!("Order is cancelled"),
        // No se necesita un caso 'default' ya que el 'match' es exhaustivo
    }
}
```

Alternativamente, utilizando los métodos que definimos:

```rust
fn handle_order_state(state: DeliveryState) {
    if state.is_final_state() {
        println!("Final state: {}", state.signal());
    } else {
        println!("Non-final state: {}", state.signal());
    }
}
```

### Similitudes con Kotlin

- **Exhaustividad en 'match'**: Al igual que el `when` de Kotlin, el `match` de Rust es exhaustivo, lo que ayuda a evitar errores en tiempo de ejecución por valores no manejados.
- **Métodos Asociados**: Puedes definir métodos para la enumeración, permitiendo asociar comportamientos comunes y específicos.
- **Seguridad de Tipos**: Las enumeraciones en Rust aseguran que solo se utilicen valores válidos, mejorando la fiabilidad del código.

### Diferencias y Limitaciones

- **Implementación de Métodos por Variante**: A diferencia de Kotlin, en Rust no puedes definir implementaciones específicas de métodos directamente en cada variante de la enumeración. En su lugar, utilizas un `match` dentro del método para manejar cada caso.
- **Datos Asociados**: Rust permite que cada variante de la enumeración tenga datos asociados, lo que proporciona una flexibilidad adicional que no está presente en las enumeraciones de Kotlin.
- **Sintaxis**: La sintaxis y las convenciones son diferentes, lo que puede requerir adaptación si vienes de Kotlin.

### Ventajas de las Enumeraciones en Rust

1. **Patrones de Diseño Flexibles**: Las enumeraciones con datos asociados permiten crear estructuras de datos complejas y manejar diferentes casos de manera elegante.
2. **Comprobación en Tiempo de Compilación**: El compilador verifica que todos los casos de una enumeración se manejan en un `match`, previniendo errores en tiempo de ejecución.
3. **Eficiencia**: Rust es conocido por su alto rendimiento y eficiencia en la gestión de recursos, lo que se extiende al uso de enumeraciones.

### Limitaciones

- **Complejidad en Casos Simples**: Para casos simples, la necesidad de utilizar `match` puede hacer que el código sea más verboso en comparación con Kotlin.
- **Sin Herencia en Enums**: Rust no permite la herencia o implementación directa de traits en variantes individuales de una enumeración.

## Swift

En **Swift**, las enumeraciones (`enum`) son más potentes y flexibles que en muchos otros lenguajes. No solo definen un conjunto de casos relacionados, sino que también pueden almacenar **valores asociados** y **propiedades**, y pueden definir **métodos**, lo que las hace comparables a las **enumeraciones** y **clases selladas** en Kotlin.

### Definición Básica de Enumeraciones en Swift

Una enumeración básica en Swift se define utilizando la palabra clave `enum`. Aquí hay un ejemplo que representa los estados de entrega, similar al ejemplo en Kotlin:

```swift
enum DeliveryState {
    case pending
    case paid
    case shipped
    case delivered
    case cancelled
}
```

**Uso:**

```swift
func handleOrderState(state: DeliveryState) {
    switch state {
    case .pending:
        print("Order is pending")
    case .paid:
        print("Order is paid")
    case .shipped:
        print("Order is shipped")
    case .delivered:
        print("Order is delivered")
    case .cancelled:
        print("Order is cancelled")
    }
}

handleOrderState(state: .pending)
handleOrderState(state: .paid)
```

### Similitudes con Kotlin

- **Definición de Casos**: Ambos lenguajes permiten definir enumeraciones con un conjunto fijo de casos.

- **Exhaustividad en Switch/When**: Tanto en Swift como en Kotlin, los bloques `switch` (Swift) y `when` (Kotlin) deben ser exhaustivos, es decir, deben manejar todos los posibles casos de la enumeración, o de lo contrario se debe proporcionar un caso `default` o `else`.

- **Métodos Asociados**: Las enumeraciones en ambos lenguajes pueden contener métodos y propiedades.

### Diferencias con Kotlin

- **Valores Asociados**: Swift permite que cada caso de una enumeración tenga **valores asociados**, lo que permite almacenar datos adicionales con cada caso. En Kotlin, para lograr algo similar, se utilizan **clases selladas** o se agregan propiedades constantes a cada caso de la enumeración.

- **Raw Values vs. Associated Values**: En Swift, las enumeraciones pueden tener **raw values** (valores crudos) que son iguales para todos los casos (como enteros o strings), o **valores asociados** que pueden variar para cada instancia de un caso.

- **No Necesita Métodos Abstractos**: A diferencia de Kotlin, donde puedes tener métodos abstractos en una enumeración que cada caso debe implementar, en Swift generalmente se utiliza un `switch` dentro de un método para manejar la lógica específica de cada caso.

### Ejemplo con Métodos y Valores Asociados

Supongamos que queremos que cada estado de entrega proporcione un mensaje específico y también indique si es un estado final.

```swift
enum DeliveryState {
    case pending
    case paid
    case shipped
    case delivered
    case cancelled

    func signal() -> String {
        switch self {
        case .pending:
            return "Order is pending"
        case .paid:
            return "Order is paid"
        case .shipped:
            return "Order is shipped"
        case .delivered:
            return "Order is delivered"
        case .cancelled:
            return "Order is cancelled"
        }
    }

    func isFinalState() -> Bool {
        return self == .delivered || self == .cancelled
    }
}
```

**Uso:**

```swift
func handleOrderState(state: DeliveryState) {
    if state.isFinalState() {
        print("Final state: \(state.signal())")
    } else {
        print("Non-final state: \(state.signal())")
    }
}

handleOrderState(state: .shipped)
handleOrderState(state: .delivered)
```

### Valores Asociados en Swift

A diferencia de Kotlin, Swift permite que cada caso tenga valores asociados diferentes. Esto es útil para casos donde cada estado puede llevar información adicional.

**Ejemplo:**

```swift
enum GameEvent {
    case healthBoost(amount: Int)
    case manaDrain(amount: Int)
    case poison(duration: Int)
    case energySurge(amount: Int)
}

class Player {
    var health: Int
    var mana: Int

    init(health: Int, mana: Int) {
        self.health = health
        self.mana = mana
    }

    func apply(event: GameEvent) {
        switch event {
        case .healthBoost(let amount):
            increaseHealth(by: amount)
        case .manaDrain(let amount):
            decreaseMana(by: amount)
        case .poison(let duration):
            decreaseHealth(by: duration * 5) // Por ejemplo, resta 5 de salud por cada unidad de duración
        case .energySurge(let amount):
            increaseMana(by: amount)
        }
    }

    func increaseHealth(by amount: Int) {
        health += amount
    }

    func decreaseHealth(by amount: Int) {
        health -= amount
    }

    func increaseMana(by amount: Int) {
        mana += amount
    }

    func decreaseMana(by amount: Int) {
        mana -= amount
    }
}
```

**Uso:**

```swift
let player = Player(health: 100, mana: 50)
player.apply(event: .healthBoost(amount: 20))
player.apply(event: .manaDrain(amount: 15))
```

### Similitudes y Diferencias en este Contexto

- **Similitud**: Ambos lenguajes permiten que las enumeraciones contengan métodos y se utilicen para representar eventos o estados en un juego.

- **Diferencia**: En Swift, los valores asociados permiten pasar información directamente con cada caso, sin necesidad de implementar métodos abstractos o concretos en cada caso como en Kotlin.

### Funciones Útiles en Enumeraciones de Swift

1. **`allCases`**: Si la enumeración conforma al protocolo `CaseIterable`, puedes obtener una colección de todos los casos.

 ```swift
 enum Direction: CaseIterable {
     case north, south, east, west
 }

 for direction in Direction.allCases {
     print(direction)
 }
    ```

2. **Inicialización con Raw Values**: Si la enumeración tiene raw values, puedes crear una instancia a partir de ese valor.

 ```swift
 enum Planet: Int {
     case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
 }

 let planet = Planet(rawValue: 3) // earth
    ```

### Limitaciones de las Enumeraciones en Swift

1. **No Soportan Herencia**: A diferencia de las clases, las enumeraciones en Swift no pueden heredar de otras enumeraciones o clases.

2. **No Pueden Añadir Casos en Extensiones**: No es posible añadir nuevos casos a una enumeración utilizando extensiones.

### Comparación con Kotlin

- **Herencia y Clases Selladas**: En Kotlin, si necesitas más flexibilidad y comportamiento polimórfico, puedes usar **clases selladas**, que permiten herencia y pueden contener estados más complejos. En Swift, las enumeraciones con valores asociados y protocolos pueden cubrir muchos casos donde en Kotlin se usarían clases selladas.

- **Exhaustividad**: Tanto Swift como Kotlin requieren que los `switch`/`when` sean exhaustivos, lo que mejora la seguridad del código al obligar a manejar todos los casos posibles.

- **Valores Asociados vs. Data Classes**: En Kotlin, para asociar datos con un caso específico, a menudo se usan **data classes** dentro de una **clase sellada**. En Swift, los valores asociados en las enumeraciones permiten lograr esto de manera más directa.

