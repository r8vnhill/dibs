---
title: Enumeraciones en otros lenguajes
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../../../src/components/ReadingTime';

<ReadingTime/>

## Haskell

En **Haskell**, las enumeraciones se definen utilizando **tipos de datos algebraicos**. Haskell permite crear tipos de datos con múltiples constructores, y puedes asociar funciones y métodos para operar con ellos. Al igual que en Kotlin, Haskell ofrece patrones de coincidencia exhaustivos, lo que significa que el compilador te advertirá si no has manejado todos los casos posibles.

### Definición de la Enumeración

```haskell
data DeliveryState = Pending | Paid | Shipped | Delivered | Cancelled
```

### Métodos en Enumeraciones

En Haskell, puedes definir funciones que operen sobre el tipo `DeliveryState`. Aunque no puedes asociar métodos directamente a los constructores como en Kotlin, puedes utilizar funciones y patrones para lograr un comportamiento similar.

```haskell
signal :: DeliveryState -> String
signal Pending   = "Order is pending"
signal Paid      = "Order is paid"
signal Shipped   = "Order is shipped"
signal Delivered = "Order is delivered"
signal Cancelled = "Order is cancelled"

isFinalState :: DeliveryState -> Bool
isFinalState Delivered = True
isFinalState Cancelled = True
isFinalState _         = False
```

### Uso de Pattern Matching Exhaustivo

En Haskell, al utilizar `case` o definir funciones mediante patrones, el compilador verifica que todos los casos estén cubiertos, similar al `when` exhaustivo de Kotlin.

```haskell
handleOrderState :: DeliveryState -> IO ()
handleOrderState state =
  if isFinalState state
    then putStrLn $ "Final state: " ++ signal state
    else putStrLn $ "Non-final state: " ++ signal state
```

### Ejemplo de Uso

```haskell
main :: IO ()
main = do
  handleOrderState Pending
  handleOrderState Paid
```

### Similitudes con Kotlin

- **Pattern Matching Exhaustivo**: Haskell exige que se manejen todos los casos posibles en patrones, similar al `when` de Kotlin.
- **Seguridad de Tipos**: Solo se pueden utilizar los valores definidos en `DeliveryState`, evitando estados inválidos.
- **Funciones Asociadas**: Puedes definir funciones que operen sobre el tipo de datos, similar a los métodos en Kotlin.

### Diferencias y Limitaciones

- **Sintaxis y Paradigma**: Haskell es un lenguaje puramente funcional, y la sintaxis y enfoque difieren significativamente de Kotlin.
- **No Métodos en Constructores**: No puedes asociar métodos directamente a cada constructor como en Kotlin; en su lugar, utilizas funciones separadas.
- **Inmutabilidad**: Todos los valores son inmutables, lo que puede afectar cómo se manejan los estados si vienes de un lenguaje orientado a objetos.

### Ventajas de las Enumeraciones en Haskell

1. **Patrones de Diseño Funcionales**: Haskell aprovecha al máximo los patrones funcionales, lo que puede llevar a código conciso y expresivo.
2. **Verificación en Tiempo de Compilación**: El compilador ayuda a garantizar que todos los casos se manejan, reduciendo errores en tiempo de ejecución.
3. **Simplicidad**: La definición de tipos de datos es sencilla y clara.

### Limitaciones

- **Curva de Aprendizaje**: Si no estás familiarizado con la programación funcional, puede llevar tiempo adaptarse.
- **Falta de Métodos Asociados**: No puedes tener métodos dentro de los tipos de datos como en Kotlin; necesitas definir funciones por separado.

## Rust

En **Rust**, las enumeraciones (`enum`) son tipos algebraicos que permiten representar un conjunto de variantes, cada una de las cuales puede tener datos asociados y métodos. Las enumeraciones en Rust son más potentes que en muchos otros lenguajes y permiten lograr un comportamiento similar al de las enumeraciones en Kotlin.

### Definición de la Enumeración

```rust
enum DeliveryState {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}
```

### Métodos en Enumeraciones

Puedes implementar métodos para las enumeraciones utilizando bloques `impl`. Esto te permite asociar funciones y propiedades a las variantes de la enumeración.

```rust
impl DeliveryState {
    fn signal(&self) -> &str {
        match self {
            DeliveryState::Pending => "Order is pending",
            DeliveryState::Paid => "Order is paid",
            DeliveryState::Shipped => "Order is shipped",
            DeliveryState::Delivered => "Order is delivered",
            DeliveryState::Cancelled => "Order is cancelled",
        }
    }

    fn is_final_state(&self) -> bool {
        matches!(self, DeliveryState::Delivered | DeliveryState::Cancelled)
    }
}
```

### Uso del `match` Exhaustivo

En Rust, el `match` es exhaustivo por defecto. Esto significa que el compilador te obligará a manejar todos los posibles valores de la enumeración, similar al `when` exhaustivo de Kotlin.

```rust
fn handle_order_state(state: DeliveryState) {
    match state {
        DeliveryState::Pending => println!("Order is pending"),
        DeliveryState::Paid => println!("Order is paid"),
        DeliveryState::Shipped => println!("Order is shipped"),
        DeliveryState::Delivered => println!("Order is delivered"),
        DeliveryState::Cancelled => println!("Order is cancelled"),
        // No se necesita un caso 'default' ya que el 'match' es exhaustivo
    }
}
```

Alternativamente, utilizando los métodos que definimos:

```rust
fn handle_order_state(state: DeliveryState) {
    if state.is_final_state() {
        println!("Final state: {}", state.signal());
    } else {
        println!("Non-final state: {}", state.signal());
    }
}
```

### Similitudes con Kotlin

- **Exhaustividad en 'match'**: Al igual que el `when` de Kotlin, el `match` de Rust es exhaustivo, lo que ayuda a evitar errores en tiempo de ejecución por valores no manejados.
- **Métodos Asociados**: Puedes definir métodos para la enumeración, permitiendo asociar comportamientos comunes y específicos.
- **Seguridad de Tipos**: Las enumeraciones en Rust aseguran que solo se utilicen valores válidos, mejorando la fiabilidad del código.

### Diferencias y Limitaciones

- **Implementación de Métodos por Variante**: A diferencia de Kotlin, en Rust no puedes definir implementaciones específicas de métodos directamente en cada variante de la enumeración. En su lugar, utilizas un `match` dentro del método para manejar cada caso.
- **Datos Asociados**: Rust permite que cada variante de la enumeración tenga datos asociados, lo que proporciona una flexibilidad adicional que no está presente en las enumeraciones de Kotlin.
- **Sintaxis**: La sintaxis y las convenciones son diferentes, lo que puede requerir adaptación si vienes de Kotlin.

### Ventajas de las Enumeraciones en Rust

1. **Patrones de Diseño Flexibles**: Las enumeraciones con datos asociados permiten crear estructuras de datos complejas y manejar diferentes casos de manera elegante.
2. **Comprobación en Tiempo de Compilación**: El compilador verifica que todos los casos de una enumeración se manejan en un `match`, previniendo errores en tiempo de ejecución.
3. **Eficiencia**: Rust es conocido por su alto rendimiento y eficiencia en la gestión de recursos, lo que se extiende al uso de enumeraciones.

### Limitaciones

- **Complejidad en Casos Simples**: Para casos simples, la necesidad de utilizar `match` puede hacer que el código sea más verboso en comparación con Kotlin.
- **Sin Herencia en Enums**: Rust no permite la herencia o implementación directa de traits en variantes individuales de una enumeración.

## Swift

En **Swift**, las enumeraciones (`enum`) son más potentes y flexibles que en muchos otros lenguajes. No solo definen un conjunto de casos relacionados, sino que también pueden almacenar **valores asociados** y **propiedades**, y pueden definir **métodos**, lo que las hace comparables a las **enumeraciones** y **clases selladas** en Kotlin.

### Definición Básica de Enumeraciones en Swift

Una enumeración básica en Swift se define utilizando la palabra clave `enum`. Aquí hay un ejemplo que representa los estados de entrega, similar al ejemplo en Kotlin:

```swift
enum DeliveryState {
    case pending
    case paid
    case shipped
    case delivered
    case cancelled
}
```

**Uso:**

```swift
func handleOrderState(state: DeliveryState) {
    switch state {
    case .pending:
        print("Order is pending")
    case .paid:
        print("Order is paid")
    case .shipped:
        print("Order is shipped")
    case .delivered:
        print("Order is delivered")
    case .cancelled:
        print("Order is cancelled")
    }
}

handleOrderState(state: .pending)
handleOrderState(state: .paid)
```

### Similitudes con Kotlin

- **Definición de Casos**: Ambos lenguajes permiten definir enumeraciones con un conjunto fijo de casos.

- **Exhaustividad en Switch/When**: Tanto en Swift como en Kotlin, los bloques `switch` (Swift) y `when` (Kotlin) deben ser exhaustivos, es decir, deben manejar todos los posibles casos de la enumeración, o de lo contrario se debe proporcionar un caso `default` o `else`.

- **Métodos Asociados**: Las enumeraciones en ambos lenguajes pueden contener métodos y propiedades.

### Diferencias con Kotlin

- **Valores Asociados**: Swift permite que cada caso de una enumeración tenga **valores asociados**, lo que permite almacenar datos adicionales con cada caso. En Kotlin, para lograr algo similar, se utilizan **clases selladas** o se agregan propiedades constantes a cada caso de la enumeración.

- **Raw Values vs. Associated Values**: En Swift, las enumeraciones pueden tener **raw values** (valores crudos) que son iguales para todos los casos (como enteros o strings), o **valores asociados** que pueden variar para cada instancia de un caso.

- **No Necesita Métodos Abstractos**: A diferencia de Kotlin, donde puedes tener métodos abstractos en una enumeración que cada caso debe implementar, en Swift generalmente se utiliza un `switch` dentro de un método para manejar la lógica específica de cada caso.

### Ejemplo con Métodos y Valores Asociados

Supongamos que queremos que cada estado de entrega proporcione un mensaje específico y también indique si es un estado final.

```swift
enum DeliveryState {
    case pending
    case paid
    case shipped
    case delivered
    case cancelled

    func signal() -> String {
        switch self {
        case .pending:
            return "Order is pending"
        case .paid:
            return "Order is paid"
        case .shipped:
            return "Order is shipped"
        case .delivered:
            return "Order is delivered"
        case .cancelled:
            return "Order is cancelled"
        }
    }

    func isFinalState() -> Bool {
        return self == .delivered || self == .cancelled
    }
}
```

**Uso:**

```swift
func handleOrderState(state: DeliveryState) {
    if state.isFinalState() {
        print("Final state: \(state.signal())")
    } else {
        print("Non-final state: \(state.signal())")
    }
}

handleOrderState(state: .shipped)
handleOrderState(state: .delivered)
```

### Valores Asociados en Swift

A diferencia de Kotlin, Swift permite que cada caso tenga valores asociados diferentes. Esto es útil para casos donde cada estado puede llevar información adicional.

**Ejemplo:**

```swift
enum GameEvent {
    case healthBoost(amount: Int)
    case manaDrain(amount: Int)
    case poison(duration: Int)
    case energySurge(amount: Int)
}

class Player {
    var health: Int
    var mana: Int

    init(health: Int, mana: Int) {
        self.health = health
        self.mana = mana
    }

    func apply(event: GameEvent) {
        switch event {
        case .healthBoost(let amount):
            increaseHealth(by: amount)
        case .manaDrain(let amount):
            decreaseMana(by: amount)
        case .poison(let duration):
            decreaseHealth(by: duration * 5) // Por ejemplo, resta 5 de salud por cada unidad de duración
        case .energySurge(let amount):
            increaseMana(by: amount)
        }
    }

    func increaseHealth(by amount: Int) {
        health += amount
    }

    func decreaseHealth(by amount: Int) {
        health -= amount
    }

    func increaseMana(by amount: Int) {
        mana += amount
    }

    func decreaseMana(by amount: Int) {
        mana -= amount
    }
}
```

**Uso:**

```swift
let player = Player(health: 100, mana: 50)
player.apply(event: .healthBoost(amount: 20))
player.apply(event: .manaDrain(amount: 15))
```

### Similitudes y Diferencias en este Contexto

- **Similitud**: Ambos lenguajes permiten que las enumeraciones contengan métodos y se utilicen para representar eventos o estados en un juego.

- **Diferencia**: En Swift, los valores asociados permiten pasar información directamente con cada caso, sin necesidad de implementar métodos abstractos o concretos en cada caso como en Kotlin.

### Funciones Útiles en Enumeraciones de Swift

1. **`allCases`**: Si la enumeración conforma al protocolo `CaseIterable`, puedes obtener una colección de todos los casos.

 ```swift
 enum Direction: CaseIterable {
     case north, south, east, west
 }

 for direction in Direction.allCases {
     print(direction)
 }
    ```

2. **Inicialización con Raw Values**: Si la enumeración tiene raw values, puedes crear una instancia a partir de ese valor.

 ```swift
 enum Planet: Int {
     case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
 }

 let planet = Planet(rawValue: 3) // earth
    ```

### Limitaciones de las Enumeraciones en Swift

1. **No Soportan Herencia**: A diferencia de las clases, las enumeraciones en Swift no pueden heredar de otras enumeraciones o clases.

2. **No Pueden Añadir Casos en Extensiones**: No es posible añadir nuevos casos a una enumeración utilizando extensiones.

### Comparación con Kotlin

- **Herencia y Clases Selladas**: En Kotlin, si necesitas más flexibilidad y comportamiento polimórfico, puedes usar **clases selladas**, que permiten herencia y pueden contener estados más complejos. En Swift, las enumeraciones con valores asociados y protocolos pueden cubrir muchos casos donde en Kotlin se usarían clases selladas.

- **Exhaustividad**: Tanto Swift como Kotlin requieren que los `switch`/`when` sean exhaustivos, lo que mejora la seguridad del código al obligar a manejar todos los casos posibles.

- **Valores Asociados vs. Data Classes**: En Kotlin, para asociar datos con un caso específico, a menudo se usan **data classes** dentro de una **clase sellada**. En Swift, los valores asociados en las enumeraciones permiten lograr esto de manera más directa.
