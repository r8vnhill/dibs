---
title: Tipos suma
---
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>

Un **tipo suma** es un tipo de datos que permite representar una elección entre múltiples posibilidades, donde un valor puede pertenecer a uno de varios tipos predefinidos. En Kotlin, los tipos suma se pueden implementar mediante mecanismos como las clases selladas o las enumeraciones. Este enfoque es útil en casos donde un valor puede adoptar diversas formas, como los días de la semana o los estados en una máquina de estados finitos.

Uno de los ejemplos más comunes de tipos suma es **either**, que modela un valor que puede ser de uno de dos tipos posibles. Al igual que `Pair` es representativo de los tipos producto, **either** es representativo de los tipos suma. Así como los tipos producto pueden componerse a partir de pares, cualquier tipo suma puede modelarse como una composición de instancias de **either**, proporcionando una forma flexible de estructurar decisiones en el código.

Los tipos suma son particularmente útiles en situaciones donde se debe modelar la posibilidad de alternativas claramente diferenciadas, como el éxito o el fallo en una operación, o diferentes variantes de un objeto en un sistema.

## Soporte en otros lenguajes

- **Haskell**: Utiliza tipos algebraicos de datos (`data`) para representar tipos suma, como en `Either`.
- **Scala**: Utiliza _clases selladas_ para representar conjuntos finitos de tipos. Scala 3 introduce _union types_ y _enumeraciones_ para manejar tipos suma.
- **F#**: Usa las _discriminated unions_ para definir tipos que representan varias opciones de valor.
- **Rust**: Emplea las _enumeraciones_ para manejar tipos suma, permitiendo que cada variante de la enumeración tenga su propia estructura de datos.
- **TypeScript**: Introduce los _union types_ para permitir que una variable pueda ser de varios tipos posibles.
- **Swift**: Usa _enumeraciones_ que pueden contener datos asociados para representar tipos suma.
- **OCaml**: Utiliza _variant types_ para definir tipos suma mediante constructores que representan diferentes casos de datos.

Estos lenguajes ofrecen mecanismos diferentes para trabajar con tipos suma, lo que los hace útiles en situaciones donde un valor puede tener múltiples formas o variantes.

## Ejemplo Práctico: Modelando el estado de pedidos de una tienda en línea

En el contexto de un sistema para una tienda en línea, podríamos querer representar los estados de un pedido, como:

- Pendiente
- Pagado
- Enviado
- Entregado
- Cancelado

## Primer Enfoque: Strings

Podríamos comenzar usando strings para representar estos estados en **Kotlin**, pero rápidamente notaríamos problemas como la posibilidad de errores en tiempo de ejecución debido a valores mal escritos o incorrectos:

```kotlin
fun handleOrderState(state: String) = when (state) {
    "Pending" -> println("Order is pending")
    "Paid" -> println("Order is paid")
    "Shipped" -> println("Order is shipped")
    "Delivered" -> println("Order is delivered")
    "Cancelled" -> println("Order is cancelled")
    else -> println("Unknown state")
}
```

Este enfoque no garantiza que el estado sea uno de los valores válidos, lo que puede llevar a problemas difíciles de detectar. Para evitar estos errores, podemos utilizar **tipos suma**. En las próximas lecciones veremos cómo abordar este problema con **clases selladas** y **enumeraciones**.

## ¿Qué Aprendimos?

En esta lección, exploramos el concepto de **tipos suma** y su implementación en diversos lenguajes, demostrando cómo permiten representar valores que pueden ser de múltiples formas o variantes, mejorando la seguridad y claridad del código. Aprendimos que en **Kotlin**, estos tipos se pueden implementar utilizando **clases selladas** y **enumeraciones**, proporcionando un enfoque seguro y estructurado para manejar diferentes posibilidades de valor, como el estado de un pedido en una tienda en línea.

También vimos que, aunque se podrían usar strings para representar estos estados, esto conlleva riesgos de errores en tiempo de ejecución debido a la falta de validación estática. Los **tipos suma** eliminan este riesgo al asegurar que solo se utilicen valores válidos en tiempo de compilación, mejorando la robustez de las aplicaciones.

En futuras lecciones, profundizaremos en las implementaciones prácticas de tipos suma en Kotlin y compararemos sus enfoques con otros lenguajes, asegurando que comprendas cómo aplicar estas técnicas para modelar alternativas y decisiones de manera segura en tus proyectos.

<References references={
    [
        {
            title: "6. Simple Algebraic Data Types",
            type: "book",
            bookTitle: "Category Theory for Programmers",
            author: "Bartosz Milewski",
            pages: "55–68",
            publisher: "Millington Keynes",
            year: "2019",
            location: "Lightning Source UK",
        },
    ]
} />
