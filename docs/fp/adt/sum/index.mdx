---
title: Tipos suma
---
import References from "../../../../src/components/ReferencesComponent";
import ReadingTime from '../../../../src/components/ReadingTime';

<ReadingTime/>

Un **tipo suma** es un tipo de datos que permite representar una elección entre múltiples posibilidades, donde un valor puede pertenecer a uno de varios tipos predefinidos. En Kotlin, los tipos suma se pueden implementar mediante mecanismos como las clases selladas o las enumeraciones. Este enfoque es útil en casos donde un valor puede adoptar diversas formas, como los días de la semana o los estados en una máquina de estados finitos.

Uno de los ejemplos más comunes de tipos suma es **either**, que modela un valor que puede ser de uno de dos tipos posibles. Al igual que `Pair` es representativo de los tipos producto, **either** es representativo de los tipos suma. Así como los tipos producto pueden componerse a partir de pares, cualquier tipo suma puede modelarse como una composición de instancias de **either**, proporcionando una forma flexible de estructurar decisiones en el código.

Los tipos suma son particularmente útiles en situaciones donde se debe modelar la posibilidad de alternativas claramente diferenciadas, como el éxito o el fallo en una operación, o diferentes variantes de un objeto en un sistema.

## Soporte en otros lenguajes

- **Haskell**: Utiliza tipos algebraicos de datos (`data`) para representar tipos suma, como en `Either`.
- **Scala**: Utiliza _clases selladas_ para representar conjuntos finitos de tipos. Scala 3 introduce _union types_ y _enumeraciones_ para manejar tipos suma.
- **F#**: Usa las _discriminated unions_ para definir tipos que representan varias opciones de valor.
- **Rust**: Emplea las _enumeraciones_ para manejar tipos suma, permitiendo que cada variante de la enumeración tenga su propia estructura de datos.
- **TypeScript**: Introduce los _union types_ para permitir que una variable pueda ser de varios tipos posibles.
- **Swift**: Usa _enumeraciones_ que pueden contener datos asociados para representar tipos suma.
- **OCaml**: Utiliza _variant types_ para definir tipos suma mediante constructores que representan diferentes casos de datos.

Estos lenguajes ofrecen mecanismos diferentes para trabajar con tipos suma, lo que los hace útiles en situaciones donde un valor puede tener múltiples formas o variantes.

## Ejemplo Práctico: Modelando el estado de pedidos de una tienda en línea

En el contexto de un sistema para una tienda en línea, podríamos querer representar los estados de un pedido, como:

- Pendiente
- Pagado
- Enviado
- Entregado
- Cancelado

## Primer Enfoque: Strings

Podríamos comenzar usando strings para representar estos estados en **Kotlin**, pero rápidamente notaríamos problemas como la posibilidad de errores en tiempo de ejecución debido a valores mal escritos o incorrectos:

```kotlin
fun handleOrderState(state: String) = when (state) {
    "Pending" -> println("Order is pending")
    "Paid" -> println("Order is paid")
    "Shipped" -> println("Order is shipped")
    "Delivered" -> println("Order is delivered")
    "Cancelled" -> println("Order is cancelled")
    else -> println("Unknown state")
}
```

Este enfoque no garantiza que el estado sea uno de los valores válidos, lo que puede llevar a problemas difíciles de detectar. Para evitar estos errores, podemos utilizar **tipos suma**. En las próximas lecciones veremos cómo abordar este problema con **clases selladas** y **enumeraciones**.

## ¿Qué sacamos en limpio?

Los **tipos suma** son esenciales cuando necesitamos modelar diferentes variantes de un valor o entidad dentro de un sistema. Utilizar **strings** o tipos primitivos puede resultar en errores difíciles de detectar, ya que no hay una garantía de que los valores sean válidos en tiempo de compilación.

Al aprovechar mecanismos como las **clases selladas** y **enumeraciones** en Kotlin, o sus equivalentes en otros lenguajes, podemos garantizar que nuestros valores pertenezcan a un conjunto finito de alternativas bien definidas, haciendo nuestro código más seguro y fácil de mantener. Además, esto nos permite representar decisiones, estados o resultados de forma clara, robusta y expresiva.

<References references={
    [
        {
            title: "6. Simple Algebraic Data Types",
            type: "book",
            bookTitle: "Category Theory for Programmers",
            author: "Bartosz Milewski",
            pages: "55–68",
            publisher: "Millington Keynes",
            year: "2019",
            location: "Lightning Source UK",
        },
    ]
} />
