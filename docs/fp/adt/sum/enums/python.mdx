---
title: Enumeraciones en Python
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import {ProCons, Pros, Cons} from '/src/components/cajitas/ProCons';

<ReadingTime/>

En **Python**, las enumeraciones se manejan con la clase `Enum` del m√≥dulo `enum`. Aunque ambas plataformas ofrecen una forma estructurada de trabajar con valores predefinidos, hay diferencias clave en las funcionalidades y en c√≥mo se utilizan las enumeraciones en cada lenguaje.

## üìå Definici√≥n y Uso B√°sico

En Python, se pueden definir enumeraciones de la siguiente manera:

```python showLineNumbers
from enum import Enum

class DeliveryState(Enum):
    PENDING = 0
    PAID = 1
    SHIPPED = 2
    DELIVERED = 3
    CANCELLED = 4
```

Aqu√≠, `DeliveryState` es una enumeraci√≥n que contiene los mismos valores que definimos en Kotlin. Sin embargo, hay algunas diferencias importantes:

- **Tipado Est√°tico vs. Din√°mico**: A diferencia de Kotlin, Python es un lenguaje de tipado din√°mico, lo que significa que no se tiene la misma garant√≠a de **seguridad de tipos** en tiempo de compilaci√≥n. En Kotlin, el compilador asegura que solo se usen valores v√°lidos de la enumeraci√≥n, mientras que en Python, los errores relacionados con valores no v√°lidos se detectan en tiempo de ejecuci√≥n.
- **No Exhaustividad**: En Python, no hay un mecanismo directo que garantice que se manejan todos los casos de una enumeraci√≥n. En Kotlin, `when` asegura la exhaustividad, pero en Python, el uso de una sentencia `if-else` no tiene esta garant√≠a autom√°tica.

## üöÄ Uso de `auto()` en Enumeraciones  

Python proporciona `enum.auto()`, una forma conveniente de asignar valores autom√°ticamente a los miembros de una enumeraci√≥n sin necesidad de definirlos manualmente.  

:::tip ¬øCu√°ndo usar `auto()`?

‚úîÔ∏è Si **no necesitas valores espec√≠ficos**, pero s√≠ una enumeraci√≥n con valores √∫nicos.  
‚úîÔ∏è Si quieres evitar asignar valores manualmente para reducir errores y mejorar la legibilidad.  
‚ùå No es √∫til si cada miembro debe tener un valor espec√≠fico (por ejemplo, c√≥digos HTTP o estados con valores predefinidos).  

:::

```python showLineNumbers
from enum import Enum, auto

class DeliveryState(Enum):
    PENDING = auto()
    PAID = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELLED = auto()

print(list(DeliveryState))  
# Output: [<DeliveryState.PENDING: 1>, <DeliveryState.PAID: 2>, <DeliveryState.SHIPPED: 3>, <DeliveryState.DELIVERED: 4>, <DeliveryState.CANCELLED: 5>]
```

#### Detalles clave sobre `auto()`

- Los valores asignados comienzan en `1` y aumentan secuencialmente.  
- No se puede combinar `auto()` con valores manuales dentro de la misma enumeraci√≥n.  
- Es √∫til cuando solo interesa identificar cada estado sin importar su valor num√©rico.  

## üîß Personalizaci√≥n de M√©todos

En Python, se pueden agregar m√©todos a las enumeraciones, similar a Kotlin, pero la forma de hacerlo es un poco diferente:

```python showLineNumbers
from enum import Enum

class DeliveryState(Enum):
    PENDING = 0
    PAID = 1
    SHIPPED = 2
    DELIVERED = 3
    CANCELLED = 4

    def signal(self):
        return {
            DeliveryState.PENDING: "Order is pending",
            DeliveryState.PAID: "Order is paid",
            DeliveryState.SHIPPED: "Order is shipped",
            DeliveryState.DELIVERED: "Order is delivered",
            DeliveryState.CANCELLED: "Order is cancelled"
        }[self]
```

## üèóÔ∏è Implementaci√≥n de Comportamientos Comunes en Python

Tanto en **Kotlin** como en **Python**, es posible definir m√©todos en las enumeraciones para devolver valores espec√≠ficos o ejecutar acciones seg√∫n el estado de la enumeraci√≥n. Sin embargo, hay diferencias clave entre ambos lenguajes:

- En **Kotlin**, se pueden definir **m√©todos abstractos** dentro de las enumeraciones, lo que obliga a cada valor a proporcionar una implementaci√≥n espec√≠fica.  
- En **Python**, **esto no es posible de manera nativa**. No se puede hacer que cada valor de la enumeraci√≥n implemente un m√©todo de manera obligatoria.  

En lugar de interfaces, en **Python** se puede usar **herencia m√∫ltiple y mixins** para compartir comportamientos comunes entre las enumeraciones.  

#### üìå **Ejemplo de herencia m√∫ltiple y mixins en enumeraciones**  

```python showLineNumbers
from enum import Enum

class Notifier:
    def notify(self, subscriber, message):
        print(f"Notifying {subscriber.__class__.__name__}: {message}")

class Storable:
    def store(self):
        print("Storing data")

class DeliveryState(Enum, Notifier, Storable):
    PENDING = ("Order is pending", 0)
    PAID = ("Order is paid", 1)
    SHIPPED = ("Order is shipped", 2)
    DELIVERED = ("Order is delivered", 3)
    CANCELLED = ("Order is cancelled", 4)

    def __init__(self, description, code):
        self.description = description
        self.code = code

    def signal(self):
        return self.description

    def is_final_state(self):
        return self in (self.DELIVERED, self.CANCELLED)

# Uso
state = DeliveryState.PAID
print(state.signal())  # Output: "Order is paid"
state.notify(object(), "Order is paid")  # Output: "Notifying object: Order is paid"
state.store()  # Output: "Storing data"
print(state.is_final_state())  # Output: False
```

### üßê ¬øPor qu√© __init__() en una enumeraci√≥n?

Python permite que cada miembro de una enumeraci√≥n tenga valores adicionales asociados, lo que ampl√≠a su funcionalidad m√°s all√° de ser simples valores constantes.  

En el ejemplo anterior, cada estado de `DeliveryState` almacena una **descripci√≥n (`description`)** y un **c√≥digo (`code`)** dentro de la enumeraci√≥n. Sin embargo, en la mayor√≠a de los casos, **las enumeraciones no requieren `__init__()`** si solo representan valores constantes.  

#### ‚úÖ Ejemplo sin `__init__()` (solo valores constantes)

```python showLineNumbers
from enum import Enum

class SimpleDeliveryState(Enum):
    PENDING = 0
    PAID = 1
    SHIPPED = 2
    DELIVERED = 3
    CANCELLED = 4
```

üìå **¬øCu√°ndo usar `__init__()`?**  
- ‚úîÔ∏è **Si necesitas almacenar informaci√≥n adicional** en cada miembro de la enumeraci√≥n (como en el caso de `description` y `code`).  
- ‚ùå **Si solo necesitas valores constantes**, `__init__()` es innecesario y puede hacer el c√≥digo m√°s complejo de lo necesario.  

## üîç Acceso y Validaci√≥n de Valores

En Kotlin, se puede validar y acceder a los valores de la enumeraci√≥n con m√©todos como `valueOf`. Python ofrece una forma similar:

```python showLineNumbers
try:
    state = DeliveryState["PAID"]
    print(state)
except KeyError:
    print("Invalid state")
```

Python utiliza `KeyError` si un valor no existe, mientras que en Kotlin se lanza una `IllegalArgumentException`. Ambos lenguajes requieren el manejo expl√≠cito de errores si se busca un valor no v√°lido, pero Python no ofrece una funci√≥n equivalente a `entries` para iterar directamente sobre todos los valores de la enumeraci√≥n, como en Kotlin.

Tambi√©n es  posible iterar sobre los valores de la enumeraci√≥n en Python:

```python showLineNumbers
for state in DeliveryState:
    print(state)
```

## ‚öñÔ∏è Comparaci√≥n Final

| **Caracter√≠stica**       | **Kotlin**                                                                                                                                       | **Python**                                                                                                                                     |
|--------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| **Tipado Est√°tico**      | Garantiza la **seguridad de tipos** en tiempo de compilaci√≥n, asegurando que solo se utilicen valores v√°lidos de la enumeraci√≥n.                 | Tipado din√°mico, los errores relacionados con valores no v√°lidos se detectan en tiempo de ejecuci√≥n.                                           |
| **Exhaustividad**        | El uso de `when` asegura que se manejen todos los casos posibles, eliminando la necesidad de un bloque `else` y garantizando cobertura completa. | No hay mecanismo directo para asegurar exhaustividad en sentencias `if-else`, lo que puede resultar en casos no manejados sin advertencia.     |
| **M√©todos Abstractos**   | Permite definir m√©todos abstractos en las enumeraciones, obligando a que cada valor proporcione una implementaci√≥n espec√≠fica.                   | No hay soporte directo para m√©todos abstractos en las enumeraciones, por lo que no se puede imponer la implementaci√≥n espec√≠fica por valor.    |
| **Interfaces vs Mixins** | Utiliza **interfaces** para compartir comportamientos comunes, proporcionando una estructura clara y segura en tiempo de compilaci√≥n.            | Utiliza **herencia m√∫ltiple** y **mixins**, lo que da flexibilidad pero puede introducir complejidad y conflictos si no se maneja con cuidado. |
| **Acceso a Valores**     | Ofrece `valueOf` para buscar valores de la enumeraci√≥n de manera segura y `entries` para iterar sobre todos los valores disponibles.             | Ofrece acceso mediante `[]`, pero no incluye una funci√≥n nativa como `entries` para listar todos los valores de la enumeraci√≥n.                |

### ‚úÖ Ventajas y Desventajas de Enumeraciones en Python

<ProCons>
    <Pros>
        - **Flexibilidad**: La herencia m√∫ltiple y los mixins permiten una combinaci√≥n flexible de comportamientos para las enumeraciones, dando m√°s opciones de personalizaci√≥n.
        - **Simplicidad**: Definir y utilizar enumeraciones en Python es directo, lo que facilita su uso para casos simples y r√°pidos sin mucha configuraci√≥n adicional.
        - **Compatibilidad con Tipos Anidados**: Python permite asociar f√°cilmente datos adicionales a cada valor de la enumeraci√≥n a trav√©s de constructores, similar a Kotlin.
    </Pros>
    <Cons>
        - **Falta de Control en Tiempo de Compilaci√≥n**: El tipado din√°mico y la falta de exhaustividad en Python pueden resultar en errores que solo se detectan en tiempo de ejecuci√≥n, aumentando el riesgo de errores no manejados.
        - **Ausencia de M√©todos Abstractos en Enumeraciones**: Python no obliga a que cada valor de la enumeraci√≥n implemente m√©todos espec√≠ficos, lo que puede llevar a comportamientos inconsistentes si no se manejan con cuidado.
        - **Complejidad con Herencia M√∫ltiple**: Aunque la herencia m√∫ltiple y los mixins ofrecen flexibilidad, tambi√©n introducen la posibilidad de conflictos y complicaciones en el c√≥digo si se utilizan en exceso o sin control.
    </Cons>
</ProCons>

## üéØ Conclusiones  

### üìå Puntos clave  

- **üîí Seguridad de tipos y exhaustividad**  
  - Kotlin garantiza **seguridad de tipos** en tiempo de compilaci√≥n y exige que todas las ramas de un `when` sean manejadas.  
  - Python, al ser de **tipado din√°mico**, permite m√°s flexibilidad, pero los errores se detectan solo en tiempo de ejecuci√≥n.  
- **‚ö° Uso de `enum.auto()`**  
  - Permite asignar valores autom√°ticamente en Python, similar a c√≥mo Kotlin define `enum class` sin valores expl√≠citos.  
  - Evita errores humanos al asignar valores manualmente.  
- **üõ† M√©todos y comportamientos en enumeraciones**  
  - Kotlin permite definir **m√©todos abstractos** en enumeraciones, asegurando que cada valor proporcione una implementaci√≥n espec√≠fica.  
  - Python **no soporta m√©todos abstractos en enums**, pero se puede lograr un comportamiento similar con **herencia m√∫ltiple y mixins**.  
- **üèó `__init__()` en Python**  
  - **No es obligatorio**, pero √∫til si cada valor de la enumeraci√≥n necesita almacenar datos adicionales, como un c√≥digo num√©rico o descripci√≥n.  
- **üîó Acceso y validaci√≥n de valores**  
  - Kotlin usa `valueOf()` para convertir strings en valores de la enumeraci√≥n, lanzando una `IllegalArgumentException` si el valor no es v√°lido.  
  - Python usa `DeliveryState["PAID"]`, pero lanza un `KeyError` si el valor no existe.  

### üöÄ Reflexi√≥n final  

Ambos lenguajes ofrecen soluciones potentes para definir y trabajar con enumeraciones, pero su enfoque difiere:  
- **Kotlin** prioriza **seguridad y estructura**, asegurando que las enumeraciones sean **exhaustivas** y **tipadas en tiempo de compilaci√≥n**.  
- **Python** enfatiza **flexibilidad y dinamismo**, permitiendo personalizaci√≥n avanzada con **herencia m√∫ltiple y mixins**, aunque con menos garant√≠as en tiempo de compilaci√≥n.  

La elecci√≥n entre Kotlin y Python para manejar enumeraciones depender√° del contexto del proyecto:  
‚úîÔ∏è **Si se necesita seguridad y exhaustividad** ‚Üí Kotlin es la mejor opci√≥n.  
‚úîÔ∏è **Si se busca flexibilidad y personalizaci√≥n avanzada** ‚Üí Python ofrece m√°s herramientas para adaptar las enumeraciones a diferentes necesidades.
