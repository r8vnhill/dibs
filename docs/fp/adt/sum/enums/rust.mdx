---
title: Enumeraciones en Rust
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import {ProCons, Pros, Cons} from '/src/components/cajitas/ProCons'

<ReadingTime/>

En **Rust**, las enumeraciones (enums) también se utilizan para representar **tipos suma**, permitiendo definir múltiples variantes que representan diferentes estados o condiciones. Aunque tanto Kotlin como Rust ofrecen esta funcionalidad, hay diferencias notables en cómo se implementan y se usan las enumeraciones en cada lenguaje.

### Definición y Uso Básico

En Rust, las enumeraciones se definen de manera similar a otros lenguajes, pero con algunas diferencias clave:

```rust showLineNumbers
enum DeliveryState {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}
```

Aquí, `DeliveryState` es una enumeración que contiene las mismas variantes que en Kotlin, pero Rust permite hacer más cosas con estas variantes:

- **Datos Asociados**: Rust permite que cada variante de una enumeración contenga datos asociados, algo similar a lo que Kotlin hace con los **constructores en enumeraciones**, pero en Rust, esto es más flexible.
- **Patrones de coincidencia exhaustivos**: Al igual que en Kotlin, Rust también garantiza que las coincidencias sean exhaustivas. Si no se cubren todas las variantes de una enumeración, el compilador mostrará un error.

### Patrones de Coincidencia

En Rust, se utiliza la expresión `match` para manejar enumeraciones de manera exhaustiva, similar a `when` en Kotlin. Sin embargo, a diferencia de Kotlin, Rust **obliga** a que todos los casos sean manejados, incluso si se usa un valor por defecto:

```rust showLineNumbers
fn handle_order_state(state: DeliveryState) {
    match state {
        DeliveryState::Pending => println!("Order is pending"),
        DeliveryState::Paid => println!("Order is paid"),
        DeliveryState::Shipped => println!("Order is shipped"),
        DeliveryState::Delivered => println!("Order is delivered"),
        DeliveryState::Cancelled => println!("Order is cancelled"),
    }
}
```

### Métodos en Enumeraciones

En Rust, es posible implementar métodos en las enumeraciones, similar a Kotlin. Sin embargo, a diferencia de Kotlin, Rust no permite agregar **métodos abstractos** directamente en las variantes. En lugar de eso, los métodos se definen en una **impl block** para la enumeración completa:

```rust showLineNumbers
impl DeliveryState {
    fn signal(&self) -> &str {
        match self {
            DeliveryState::Pending => "Order is pending",
            DeliveryState::Paid => "Order is paid",
            DeliveryState::Shipped => "Order is shipped",
            DeliveryState::Delivered => "Order is delivered",
            DeliveryState::Cancelled => "Order is cancelled",
        }
    }

    fn is_final_state(&self) -> bool {
        matches!(self, DeliveryState::Delivered | DeliveryState::Cancelled)
    }
}
```

### Comparación con Kotlin

| **Característica**             | **Kotlin**                                        | **Rust**                                             |
|-------------------------------|---------------------------------------------------|------------------------------------------------------|
| **Métodos Abstractos en Enums** | Los métodos abstractos permiten comportamientos específicos por variante. | No se pueden definir métodos abstractos en las variantes; los métodos se implementan en un `impl block` general. |
| **Datos Asociados**           | Los constructores pueden asociar datos a cada variante, pero de manera estática. | Cada variante puede tener diferentes datos asociados, permitiendo más flexibilidad. |
| **Patrones Exhaustivos**      | `when` asegura exhaustividad pero permite un bloque `else` opcional. | `match` asegura exhaustividad sin un valor por defecto, lo que obliga a manejar todos los casos. |

### Diferencias Únicas en Rust

1. **Datos Asociados Dinámicos**: Rust permite que las variantes de una enumeración tengan diferentes tipos y cantidades de datos asociados, lo que no es posible en Kotlin de forma directa. Esto ofrece más flexibilidad al modelar estados complejos con datos adicionales.
2. **Opciones sin Desventajas de Nulabilidad**: En Rust, las variantes de enumeración pueden tener valores que reemplazan las nulas, como `None` en lugar de `null`, lo que elimina errores comunes asociados a la nulabilidad en otros lenguajes.
3. **Seguridad en Tiempo de Compilación**: Rust impone una seguridad más estricta que Kotlin al forzar el manejo de todos los casos posibles sin una opción de escape (sin `else`). Esto asegura que no se omita ningún caso, mejorando la robustez del código.

### Ventajas y Desventajas de las Enumeraciones en Rust

<ProCons>
    <Pros>
        - **Datos Asociados Flexibles**: Las enumeraciones en Rust pueden contener datos asociados con cada variante, permitiendo modelar estados complejos y relaciones entre datos de manera eficiente.
        - **Seguridad Exhaustiva en Compilación**: El compilador de Rust fuerza a manejar todos los casos posibles en un `match`, garantizando un código más seguro y predecible.
        - **Integración Directa con Tipos Algebraicos**: Las enumeraciones en Rust son un componente fundamental para crear estructuras complejas, como las opciones y resultados (`Option` y `Result`), que se utilizan ampliamente para manejo seguro de valores y errores.
    </Pros>
    <Cons>
        - **Falta de Métodos Abstractos**: Rust no permite que las variantes de una enumeración definan comportamientos específicos directamente, lo que puede hacer que el código sea menos modular en comparación con Kotlin.
        - **Complejidad Adicional**: La flexibilidad de asociar datos diferentes a cada variante puede hacer que las estructuras sean más complejas y difíciles de manejar, especialmente para quienes no están familiarizados con el sistema de tipos de Rust.
    </Cons>
</ProCons>

## Conclusión

Las enumeraciones en **Rust** y **Kotlin** ofrecen capacidades poderosas y flexibles para representar tipos suma, pero cada uno tiene sus enfoques y limitaciones:

- **Rust** destaca por su flexibilidad en asociar datos y su seguridad estricta en tiempo de compilación.
- **Kotlin** ofrece un enfoque más estructurado y amigable para definir comportamientos específicos con métodos abstractos.

Al elegir entre ambos, es importante considerar las necesidades del proyecto y el enfoque preferido para manejar variantes y datos asociados.