---
title: rust
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<ReadingTime/>

## Rust

En **Rust**, las enumeraciones (`enum`) son tipos algebraicos que permiten representar un conjunto de variantes, cada una de las cuales puede tener datos asociados y métodos. Las enumeraciones en Rust son más potentes que en muchos otros lenguajes y permiten lograr un comportamiento similar al de las enumeraciones en Kotlin.

### Definición de la Enumeración

```rust
enum DeliveryState {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}
```

### Métodos en Enumeraciones

Puedes implementar métodos para las enumeraciones utilizando bloques `impl`. Esto te permite asociar funciones y propiedades a las variantes de la enumeración.

```rust
impl DeliveryState {
    fn signal(&self) -> &str {
        match self {
            DeliveryState::Pending => "Order is pending",
            DeliveryState::Paid => "Order is paid",
            DeliveryState::Shipped => "Order is shipped",
            DeliveryState::Delivered => "Order is delivered",
            DeliveryState::Cancelled => "Order is cancelled",
        }
    }

    fn is_final_state(&self) -> bool {
        matches!(self, DeliveryState::Delivered | DeliveryState::Cancelled)
    }
}
```

### Uso del `match` Exhaustivo

En Rust, el `match` es exhaustivo por defecto. Esto significa que el compilador te obligará a manejar todos los posibles valores de la enumeración, similar al `when` exhaustivo de Kotlin.

```rust
fn handle_order_state(state: DeliveryState) {
    match state {
        DeliveryState::Pending => println!("Order is pending"),
        DeliveryState::Paid => println!("Order is paid"),
        DeliveryState::Shipped => println!("Order is shipped"),
        DeliveryState::Delivered => println!("Order is delivered"),
        DeliveryState::Cancelled => println!("Order is cancelled"),
        // No se necesita un caso 'default' ya que el 'match' es exhaustivo
    }
}
```

Alternativamente, utilizando los métodos que definimos:

```rust
fn handle_order_state(state: DeliveryState) {
    if state.is_final_state() {
        println!("Final state: {}", state.signal());
    } else {
        println!("Non-final state: {}", state.signal());
    }
}
```

### Similitudes con Kotlin

- **Exhaustividad en 'match'**: Al igual que el `when` de Kotlin, el `match` de Rust es exhaustivo, lo que ayuda a evitar errores en tiempo de ejecución por valores no manejados.
- **Métodos Asociados**: Puedes definir métodos para la enumeración, permitiendo asociar comportamientos comunes y específicos.
- **Seguridad de Tipos**: Las enumeraciones en Rust aseguran que solo se utilicen valores válidos, mejorando la fiabilidad del código.

### Diferencias y Limitaciones

- **Implementación de Métodos por Variante**: A diferencia de Kotlin, en Rust no puedes definir implementaciones específicas de métodos directamente en cada variante de la enumeración. En su lugar, utilizas un `match` dentro del método para manejar cada caso.
- **Datos Asociados**: Rust permite que cada variante de la enumeración tenga datos asociados, lo que proporciona una flexibilidad adicional que no está presente en las enumeraciones de Kotlin.
- **Sintaxis**: La sintaxis y las convenciones son diferentes, lo que puede requerir adaptación si vienes de Kotlin.

### Ventajas de las Enumeraciones en Rust

1. **Patrones de Diseño Flexibles**: Las enumeraciones con datos asociados permiten crear estructuras de datos complejas y manejar diferentes casos de manera elegante.
2. **Comprobación en Tiempo de Compilación**: El compilador verifica que todos los casos de una enumeración se manejan en un `match`, previniendo errores en tiempo de ejecución.
3. **Eficiencia**: Rust es conocido por su alto rendimiento y eficiencia en la gestión de recursos, lo que se extiende al uso de enumeraciones.

### Limitaciones

- **Complejidad en Casos Simples**: Para casos simples, la necesidad de utilizar `match` puede hacer que el código sea más verboso en comparación con Kotlin.
- **Sin Herencia en Enums**: Rust no permite la herencia o implementación directa de traits en variantes individuales de una enumeración.
