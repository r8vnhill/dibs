---
title: Clases selladas y similares en otros lenguajes
---

## Haskell

En **Haskell**, los **tipos algebraicos de datos** (ADT, por sus siglas en inglés) son una forma común de representar **tipos suma**, equivalentes a las **clases selladas** en **Kotlin** o **Scala**. Los ADTs permiten definir un conjunto limitado de variantes, donde cada una puede tener datos asociados.

### Definición de Tipos Suma en Haskell

En Haskell, se puede definir un tipo suma con la palabra clave `data` para crear variantes con datos asociados. Aquí tienes un ejemplo que modela los estados de un pedido:

```haskell
data DeliveryState
  = Pending
  | Paid
  | Shipped String       -- Incluye un número de seguimiento
  | Delivered
  | Cancelled String     -- Incluye una razón de cancelación
  deriving (Show)
```

En este tipo `DeliveryState`, hemos definido cinco posibles estados:

- `Pending`
- `Paid`
- `Shipped String` (con un número de seguimiento)
- `Delivered`
- `Cancelled String` (con una razón de cancelación)

:::info `deriving (Show)`
La cláusula `deriving (Show)` en Haskell genera automáticamente una instancia de la clase `Show` para el tipo `DeliveryState`, lo que permite mostrar sus valores en la consola sin necesidad de definir manualmente cómo se imprimen.
:::

### Uso con Patrones

Haskell utiliza la coincidencia de patrones para manejar los diferentes casos de un tipo suma. El compilador **emite una advertencia**, pero no un error, si no se manejan todos los casos, y el código seguirá compilando.

Aquí hay una función que maneja los diferentes estados de un pedido:

```haskell
handleOrderState :: DeliveryState -> String
handleOrderState state = case state of
  Pending ->
    "Order is pending"
  Paid ->
    "Order is paid"
  Shipped trackingNumber ->
    "Order is shipped with tracking number " ++ trackingNumber
  Delivered ->
    "Order is delivered"
  Cancelled reason ->
    "Order is cancelled because " ++ reason
```

Si omitimos alguno de los casos, el compilador generará una advertencia:

```
Warning: Pattern match(es) are non-exhaustive
```

Sin embargo, el programa **compilará sin errores** y seguirá ejecutándose, aunque podría fallar en tiempo de ejecución si se encuentra un caso no manejado.

### Ventajas de Haskell en el Manejo de Tipos Suma

- **Advertencias de exhaustividad**: Haskell genera advertencias si no se manejan todas las variantes en una coincidencia de patrones.
- **Inmutabilidad**: Todos los datos en Haskell son inmutables por defecto, lo que simplifica el razonamiento sobre el estado.
- **Simplicidad Sintáctica**: La definición de tipos suma es concisa y clara, facilitando su comprensión y uso.

### Comparación con Kotlin

| Aspecto                      | Kotlin                                     | Haskell                                                 |
|------------------------------|--------------------------------------------|---------------------------------------------------------|
| **Definición de Tipos Suma** | `sealed class` o ``enum class``            | `data` con variantes                                    |
| **Exhaustividad**            | `when` exhaustivo (error si no cubre todo) | Coincidencia de patrones (advertencia si no exhaustivo) |
| **Restricción de Subtipos**  | Subclases en el mismo módulo y paquete     | Variantes definidas en el mismo tipo                    |
| **Inmutabilidad**            | Opcional con ``val``                       | Datos inmutables por defecto                            |

### Diferencias Clave

- **Advertencias de Exhaustividad**: En Haskell, la falta de coincidencia exhaustiva genera **advertencias** en tiempo de compilación, pero el código sigue compilando. En Kotlin, la falta de exhaustividad en `when` impide que el código compile.
- **Inmutabilidad**: En Haskell, la inmutabilidad es la norma, mientras que en Kotlin, las clases deben declararse explícitamente como inmutables.

### Reflexión y Variantes en Haskell

A diferencia de Kotlin, donde puedes usar `sealedSubclasses` para obtener todas las subclases de una clase sellada en tiempo de ejecución, Haskell no tiene un mecanismo similar integrado para obtener todas las variantes de un tipo suma de forma automática. Esto se debe a que Haskell es un lenguaje puramente funcional y no tiene un enfoque orientado a objetos ni un sistema de reflexión en el mismo sentido que Kotlin.

Si necesitas obtener todas las variantes de un tipo suma en Haskell, debes manejarlo de forma manual, utilizando las variantes explícitamente en el código:

```haskell
allDeliveryStates :: [DeliveryState]
allDeliveryStates = [Pending, Paid, Shipped "Example", Delivered, Cancelled "Example"]
```

Este enfoque funciona, pero requiere que lx desarrolladorx mantenga manualmente la lista de variantes, lo que introduce una posible fuente de error si se añaden o eliminan variantes en el futuro.

## Java

En **Java**, las **clases selladas** (introducidas en **Java 15** como una característica preliminar y oficializadas en **Java 17**) se utilizan de manera similar a Kotlin, permitiendo controlar qué subclases pueden extender una clase o implementar una interfaz. Aunque existen similitudes con Kotlin, también hay diferencias importantes, particularmente en cómo Java maneja la exhaustividad en los patrones `switch`.

### Características Clave de las Clases Selladas en Java

- **Restricción de subclases**: Las subclases deben estar explícitamente permitidas usando la palabra clave `permits`.
- **Exhaustividad opcional**: En Java, los `switch` pueden ser exhaustivos, pero no lo son por defecto en todas las versiones; algunas versiones pueden requerir un caso `default`.
- **Modificadores de acceso**: Las subclases deben estar dentro del mismo módulo o paquete que la clase sellada, similar a Kotlin.

### Ejemplo: Sistema de Pagos en Java

```java
public sealed interface Payment permits CreditCard, Cash, Unpaid {}

public record CreditCard(String number) implements Payment { }

public record Cash(int amount) implements Payment { }

public final class Unpaid implements Payment {}
```

En este ejemplo, la interfaz `Payment` es sellada y solo permite tres implementaciones: `CreditCard`, `Cash` y `Unpaid`. Esto es similar a cómo Kotlin restringe las subclases de una clase sellada.

:::note Ausencia de "data objects"
Es importante resaltar que los **records** en _Java_ necesitan recibir parámetros en su constructor, lo que impide que existan equivalentes directos a los **data objects** de _Kotlin_, debido a esto, se utiliza una clase cerrada (``final``) con un constructor vacío (que se genera automáticamente) para simular el comportamiento de un **data object**.
:::

### Manejo con `switch` en Java

En versiones recientes de Java, se puede utilizar un `switch` exhaustivo, pero a menudo es necesario incluir un caso `default` para manejar la exhaustividad, esto introduce un riesgo de errores si se agregan nuevas subclases en el futuro así que debe manejarse con precaución.

```java
public static void handlePayment(Payment payment) {
    switch (payment) {
        case CreditCard cc -> System.out.println("Credit card: " + cc.getNumber());
        case Cash cash -> System.out.println("Cash amount: " + cash.getAmount());
        case Unpaid unpaid -> System.out.println("Payment is unpaid");
        default -> throw new IllegalStateException("Unexpected payment type: " + payment);
    }
}
```

### Diferencias Clave con Kotlin

1. **Palabras clave**:
     - En Java, la restricción de subclases se especifica con `permits` en la declaración de la clase sellada. En Kotlin, las subclases deben estar en el mismo paquete y módulo sin una declaración explícita.

2. **Exhaustividad**:
     - En Kotlin, un `when` sobre una clase sellada **debe** ser exhaustivo; si no se cubren todos los casos, el código no compilará. En Java, aunque el `switch` puede ser exhaustivo, aún es común usar un caso `default` para manejar casos no contemplados o no permitidos.

3. **Manejo de objetos sellados**:
     - Kotlin tiene una sintaxis más expresiva para el manejo de clases selladas con el uso de `data objects` y `data classes`, mientras que en Java, todas las subclases deben ser clases concretas que extienden o implementan la clase o interfaz sellada.

### Reflexión en Java

En Java, listar todas las subclases de una clase sellada no es una tarea sencilla como en Kotlin con `sealedSubclasses`. No existe un equivalente directo, por lo que es necesario utilizar técnicas de **reflexión avanzada** o depender de bibliotecas externas que escanean el classpath para obtener las subclases de una clase.

#### Uso de Reflections en Java

Una manera de obtener todas las subclases de una clase sellada en Java es utilizar una biblioteca de reflexión como **Reflections**. Esta biblioteca permite buscar clases que implementan o extienden otras clases en el classpath.

##### Paso 1: Agregar la dependencia de **Reflections**

Agrega la dependencia de **Reflections** en tu archivo `build.gradle.kts`.

```kotlin
implementation("org.reflections:reflections:0.10.2")
```

##### Paso 2: Listar las subclases de una clase sellada

Ahora, puedes usar **Reflections** para encontrar las subclases de una clase sellada. Aquí tienes un ejemplo que lista todas las subclases de `Payment`, una interfaz sellada:

```java
Reflections reflections = new Reflections("cl.ravenhill");
Set<Class<? extends Payment>> subtypes = reflections.getSubTypesOf(Payment.class);
subtypes.forEach(subtype -> System.out.println("Subclass: " + subtype.getName()));
```

En este ejemplo, la clase **Reflections** escanea el paquete `"cl.ravenhill"` en el classpath y encuentra todas las clases que extienden o implementan `Payment`.

#### Limitaciones

- **Reflections** solo puede encontrar subclases que están **en el classpath** al momento de la ejecución. Si las subclases están distribuidas en otros módulos o paquetes no incluidos en el classpath, no serán detectadas.
- Es necesario configurar el paquete correcto en la clase **Reflections**, lo que puede ser un inconveniente si tienes una jerarquía de paquetes compleja.

#### Comparación con Kotlin

En Kotlin, el uso de la reflexión para obtener las subclases de una clase sellada es mucho más sencillo gracias a la función `sealedSubclasses`. No es necesario usar bibliotecas externas ni configurar el escaneo de paquetes manualmente. Solo necesitas invocar `sealedSubclasses` directamente:

```kotlin
fun listOrderStates() = DeliveryState::class.sealedSubclasses
```

Esto es posible debido a que Kotlin mantiene internamente la lista de subclases en el tiempo de compilación, lo que hace que la operación sea más eficiente y fácil de usar. En contraste, Java requiere bibliotecas adicionales y técnicas más avanzadas para lograr el mismo resultado.

## Scala

En **Scala**, también existen las **clases selladas** (sealed classes), que funcionan de manera similar a Kotlin, limitando las subclases a un conjunto específico que debe declararse en el mismo archivo o módulo. Las clases selladas permiten modelar de manera segura estados finitos, y facilitan la exhaustividad en expresiones como `match`, similar al `when` en Kotlin.

### Características de Clases Selladas en Scala

- **Propósito**: Al igual que en Kotlin, las clases selladas en Scala restringen la herencia para garantizar que solo un conjunto definido de subclases extienda la clase sellada.
- **Exhaustividad**: Scala asegura que las expresiones `match` sean exhaustivas, y advertirá al desarrollador si no se manejan todos los casos posibles.
- **Subclases**: Todas las subclases de una clase sellada deben declararse en el mismo archivo fuente.

### Ejemplo en Scala

Modelaremos el mismo sistema de estados de un pedido usando clases selladas en Scala:

```scala
sealed trait DeliveryState {
    def signal: String
    def isFinalState: Boolean = false
}

case object Pending extends DeliveryState {
    override def signal: String = "Order is pending"
}

case object Paid extends DeliveryState {
    override def signal: String = "Order is paid"
}

case class Shipped(trackingNumber: String) extends DeliveryState {
    override def signal: String = s"Order is shipped with tracking number $trackingNumber"
}

case object Delivered extends DeliveryState {
    override def signal: String = "Order is delivered"
    override def isFinalState: Boolean = true
}

case class Cancelled(reason: String) extends DeliveryState {
    override def signal: String = s"Order is cancelled because $reason"
    override def isFinalState: Boolean = true
}
```

### Uso con `match` Exhaustivo

En Scala, `match` es exhaustivo, y el compilador te advertirá si no has cubierto todas las posibilidades para una clase sellada:

```scala
def handleOrderState(state: DeliveryState): Unit = state match {
  case Pending => println(state.signal)
  case Paid => println(state.signal)
  case Shipped(trackingNumber) => println(state.signal)
  case Delivered => println(state.signal)
  case Cancelled(reason) => println(state.signal)
}
```

### Diferencias Clave con Kotlin

- **Exhaustividad**: Scala, al igual que Kotlin, garantiza la exhaustividad de las expresiones `match`, evitando errores en tiempo de ejecución debido a estados no manejados. Si no se manejan todos los casos, el compilador de Scala emitirá una advertencia.
- **Declaración de Subclases**: En Scala, las subclases de una clase sellada deben declararse en el mismo archivo fuente, lo que es similar a Kotlin, donde las subclases deben estar en el mismo módulo y paquete.
- **Compatibilidad**: Scala tiene soporte nativo para el patrón de **case classes**, lo que permite el uso de clases inmutables que implementan automáticamente métodos como `toString`, `equals`, y `hashCode`, similar a las `data classes` de Kotlin.

### Comparación con Kotlin

| Aspecto                           | Kotlin                                   | Scala                                |
|-----------------------------------|------------------------------------------|--------------------------------------|
| **Exhaustividad**                 | `when` exhaustivo                        | `match` exhaustivo                   |
| **Restricción de subclases**      | Mismo módulo y paquete                   | Mismo archivo fuente                 |
| **Clases inmutables**             | `data class`                             | `case class`                         |
| **Advertencias de exhaustividad** | Error de compilación si no es exhaustivo | Advertencia en tiempo de compilación |

#### Diferencias Clave

- **Exhaustividad en Kotlin**: Si un `when` sobre una clase sellada no cubre todos los casos, el código **no compilará** en Kotlin. Esto asegura que los desarrolladores siempre manejen todos los posibles estados, evitando errores en tiempo de ejecución.
- **Exhaustividad en Scala**: En Scala, si un `match` no cubre todas las posibilidades de una clase sellada, se genera una **advertencia** de compilación. Aunque esto advierte al desarrollador, el código sigue compilando.

Este comportamiento más estricto de Kotlin proporciona mayor seguridad al garantizar que los estados no manejados se identifiquen antes de la compilación, mientras que Scala otorga algo más de flexibilidad, pero con menos garantías en cuanto a exhaustividad.

## Swift

En **Swift**, el equivalente a las **clases selladas** en Kotlin es el uso de **enumerations** (enums) y **indirect enums**. Las enums en Swift no solo pueden definir valores estáticos, sino que también permiten asociar datos a cada caso, lo que las hace poderosas para representar estados o tipos finitos similares a las **clases selladas** en Kotlin. Además, Swift utiliza **pattern matching** para manejar los distintos casos de las enums.

### Definición de Enums en Swift

Swift permite definir enums con asociados de datos y asegurar la exhaustividad mediante el uso de la estructura `switch`. Aquí hay un ejemplo que modela los estados de un pedido:

```swift
enum DeliveryState {
    case pending
    case paid
    case shipped(trackingNumber: String)
    case delivered
    case cancelled(reason: String)
}
```

En este ejemplo, `DeliveryState` puede ser uno de los siguientes valores:

- `pending`: No contiene ningún dato adicional.
- `paid`: Igual que `pending`, no tiene datos asociados.
- `shipped(trackingNumber: String)`: Tiene un número de seguimiento asociado.
- `delivered`: No contiene datos adicionales.
- `cancelled(reason: String)`: Tiene una razón asociada.

### Uso con Pattern Matching

Swift utiliza el patrón de coincidencia (`switch`) para manejar las diferentes variantes de un enum. Swift garantiza que todos los casos de una enum se manejen exhaustivamente.

```swift
func handleOrderState(state: DeliveryState) -> String {
    switch state {
    case .pending:
        return "Order is pending"
    case .paid:
        return "Order is paid"
    case .shipped(let trackingNumber):
        return "Order is shipped with tracking number \(trackingNumber)"
    case .delivered:
        return "Order is delivered"
    case .cancelled(let reason):
        return "Order is cancelled because \(reason)"
    }
}
```

Si olvidamos manejar alguno de los casos en el `switch`, Swift generará un error de compilación, lo que asegura que los desarrolladores siempre gestionen todos los casos posibles.

### Ventajas de las Enums en Swift

1. **Exhaustividad garantizada**: Swift exige que los `switch` sean exhaustivos. Si falta algún caso, el compilador generará un error.
2. **Enums con valores asociados**: Las enums en Swift pueden contener datos asociados, similar a las **sealed classes** en Kotlin.
3. **Inmutabilidad**: Al igual que Kotlin, Swift es un lenguaje con enfoque en la seguridad y la inmutabilidad, lo que previene errores relacionados con el manejo de estados.

### Comparación entre Kotlin y Swift

| Aspecto                           | Kotlin                                   | Swift                                  |
|-----------------------------------|------------------------------------------|----------------------------------------|
| **Definición de Tipos Suma**      | `sealed class` o `enum class`            | `enum` con valores asociados           |
| **Exhaustividad**                 | `when` exhaustivo                        | `switch` exhaustivo                    |
| **Restricción de Subtipos**       | Subclases en el mismo módulo y paquete   | Todos los casos deben estar en el enum |
| **Inmutabilidad**                 | Opcional con `val`                       | Datos asociados inmutables             |

### Diferencias Clave

- **Restricción de Subtipos**: En Kotlin, las subclases de una clase sellada pueden estar en el mismo módulo y paquete, mientras que en Swift, los casos deben estar dentro de la definición de la `enum`. Esto garantiza que las variantes de un tipo estén completamente definidas en un solo lugar.
- **Datos asociados**: Mientras que Kotlin utiliza **sealed classes** o **data classes** para permitir estados con datos asociados, Swift maneja esto directamente dentro de sus `enum` con valores asociados.
