---
title: Tipos producto
---
import References from "../../../src/components/ReferencesComponent";

import ReadingTime from '../../../src/components/ReadingTime';

<ReadingTime />

## Pares

La implementación más simple de un tipo producto es el par. Un par, representado como $(A, B)$, $A \times B$ ó $A \to B$ ("$A$ to $B$"), es un tipo que contiene dos valores de tipos posiblemente diferentes. En Kotlin, los pares se pueden representar con la clase `Pair` de la biblioteca estándar.

```kotlin
val pair = Pair(1, true)
```

o

```kotlin
val pair = 1 to true
```

El nombre tipo producto proviene del hecho de que el tipo $A \times B$ tiene $|A| \cdot |B|$ valores posibles, donde $|A|$ y $|B|$ son el número de valores posibles de los tipos $A$ y $B$, respectivamente. En nuestro ejemplo, el par $\text{Int} \times \text{Boolean})$ tiene $2^{32} \cdot 2 = 2^{33}$ valores posibles.

## Tuplas

Aunque cualquier tipo puede ser representado como una composición de pares, como $(A, (B, C))$, una alternativa más directa es el uso de **tuplas**. Una tupla es un tipo producto que contiene un número fijo de valores de diferentes tipos. Cada valor en la tupla puede ser de un tipo distinto, y la cantidad de valores define la "dimensión" de la tupla (e.g., una tupla de tres elementos es una "triple").

En Kotlin, no existe un concepto general de tuplas, pero en esencia, cualquier clase que tenga varias propiedades puede actuar como una tupla de $n$ valores. Un ejemplo común es la clase `Triple`, que representa una tupla de tres elementos:

```kotlin
class Triple<A, B, C>(val first: A, val second: B, val third: C)
```

Por lo tanto, una tupla de tres valores en Kotlin podría ser representada con esta clase, donde cada elemento de la tupla tiene un tipo específico y puede ser accedido mediante las propiedades `first`, `second`, y `third`.

## Registros en Kotlin

Los **registros** son tipos de datos que agrupan un conjunto de campos con nombres específicos, también conocidos como **tuplas nombradas**. En Kotlin, estos se implementan fácilmente usando **data classes**. Una **data class** se encarga de representar datos de forma concisa, evitando la necesidad de escribir manualmente métodos comunes como `equals()`, `hashCode()`, `toString()`, y `copy()`.

### Definición de un Registro

```kotlin
data class Person(val name: String, val age: Int)
```

En este ejemplo, `Person` es un registro que contiene dos campos: `name` y `age`. Este tipo de clase es ideal para representar objetos de dominio en aplicaciones que requieren un conjunto fijo de propiedades.

### Características Automáticas de las Data Classes

Kotlin proporciona varias funcionalidades automáticas para las **data classes**:

- **`equals()`**: Compara dos instancias de la clase para verificar si sus propiedades son iguales.
- **`hashCode()`**: Genera un código hash basado en los valores de los campos.
- **`toString()`**: Devuelve una representación legible de la clase.
- **`copy()`**: Crea una copia de la instancia con la posibilidad de modificar algunos valores.
- **`componentN()`**: Permite la descomposición de la clase en sus propiedades usando destructuración.

Esto es equivalente a escribir la siguiente clase manualmente:

```kotlin
class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false
        other as Person
        if (name != other.name) return false
        if (age != other.age) return false
        return true
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + age
        return result
    }

    override fun toString() = "Person(name='$name', age=$age)"

    fun copy(name: String = this.name, age: Int = this.age) = Person(name, age)

    operator fun component1() = name

    operator fun component2() = age
}
```

### Uso de los Registros en Kotlin

Crear y manipular instancias de un registro es simple y eficiente. Por ejemplo:

```kotlin
val person = Person("Alice", 30)
val (name, age) = person   // Uso de destructuración
println("Name: $name, Age: $age")  // Imprime: Name: Alice, Age: 30

val newPerson = person.copy(name = "Bob")  // Crea una copia con un nuevo nombre
println(newPerson)  // Imprime: Person(name=Bob, age=30)
```

Este ejemplo muestra cómo crear una instancia de la clase `Person`, acceder a sus propiedades, utilizar la destructuración y crear copias con valores modificados de forma concisa, gracias a las capacidades integradas de las **data classes**.

:::warning
Si bien es posible definir los campos de un registro como `var` en lugar de `val`, se recomienda mantener los campos como `val` para garantizar la inmutabilidad de los registros. La manera de "mutar" un registro es mediante su función `copy()`.
:::

<details>
    <summary>Ejemplos en otros lenguajes</summary>

    ## Ejemplos en otros lenguajes

    ### Java

    En **Java**, los **records** se introdujeron en Java 16, lo que permite crear tipos inmutables con propiedades fijas de manera concisa, similares a las **data classes** de Kotlin:

    ```java
    public record Person(String name, int age) {}

    public class Main {
        public static void main(String[] args) {
            Person person = new Person("Alice", 30);
            System.out.println(person);  // Person[name=Alice, age=30]

            // Desestructuración usando los métodos accesores
            String name = person.name();
            int age = person.age();
            System.out.println("Name: " + name + ", Age: " + age);  // Name: Alice, Age: 30
        }
    }
    ```

    ### Python

    En **Python**, puedes usar la función decoradora `@dataclass` para definir clases con funcionalidades similares a las **data classes** de Kotlin. Esto genera automáticamente métodos como `__init__`, `__repr__`, `__eq__`, y más:

    ```python
    from dataclasses import dataclass

    @dataclass
    class Person:
        name: str
        age: int

    person = Person("Alice", 30)
    print(person)  # Person(name='Alice', age=30)

    # Accediendo a los atributos
    print(f"Name: {person.name}, Age: {person.age}")  # Name: Alice, Age: 30
    ```

    ### Scala

    En **Scala**, las **case classes** son una forma común de definir tipos producto, muy similar a las **data classes** de Kotlin. Las **case classes** generan automáticamente métodos como `equals()`, `hashCode()`, `toString()`, y proporcionan soporte para desestructuración y patrones de coincidencia:

    ```scala
    case class Person(name: String, age: Int)

    val person = Person("Alice", 30)
    println(person)  // Imprime: Person(Alice,30)

    // Desestructuración
    val Person(name, age) = person
    println(s"Name: $name, Age: $age")  // Imprime: Name: Alice, Age: 30

    // Comparación estructural
    val person2 = Person("Alice", 30)
    println(person == person2)  // true, compara los valores de los campos
    ```

    Las **case classes** también son inmutables y muy útiles en programación funcional, ya que facilitan el trabajo con estructuras de datos inmutables y la coincidencia de patrones.

    ### Rust

    En **Rust**, puedes usar las tuplas para representar tipos producto. Las tuplas en Rust son inmutables y de longitud fija:

    ```rust
    let person = (1, "Alice", 30);
    println!("ID: {}, Name: {}, Age: {}", person.0, person.1, person.2);
    ```

    Rust también tiene `structs`, que son similares a las data classes de Kotlin:

    ```rust
    struct Person {
        id: i32,
        name: String,
        age: i32,
    }

    let person = Person { id: 1, name: String::from("Alice"), age: 30 };
    println!("ID: {}, Name: {}, Age: {}", person.id, person.name, person.age);
    ```

</details>

## En resumen

Los **tipos producto** son una forma común de estructurar datos que contienen múltiples valores, posiblemente de diferentes tipos. Los **pares** y las **tuplas** son implementaciones básicas de estos tipos, que agrupan dos o más valores. En Kotlin, los pares pueden ser representados con la clase `Pair`, mientras que las tuplas de mayor tamaño, como las de tres valores, pueden ser representadas por clases como `Triple`.

Los **registros** son una variante más rica de los tipos producto, donde los valores están etiquetados con nombres, lo que mejora la claridad del código. En Kotlin, los registros se implementan mediante **data classes**, que proporcionan automáticamente métodos útiles como `equals()`, `hashCode()`, `toString()`, y `copy()`. Estas clases facilitan la manipulación de datos en aplicaciones que requieren objetos con un conjunto fijo de propiedades.

En resumen, los tipos producto permiten representar estructuras de datos de manera eficiente y clara, ya sea mediante pares, tuplas o registros. La elección entre estas opciones dependerá de las necesidades específicas del contexto, como la cantidad de valores que necesitas almacenar o la conveniencia de acceder a ellos por nombre en lugar de por posición.

<References references={
    [
        {
            title: "6. Simple Algebraic Data Types",
            type: "book",
            bookTitle: "Category Theory for Programmers",
            author: "Bartosz Milewski",
            pages: "55–68",
            publisher: "Millington Keynes",
            year: "2019",
            location: "Lightning Source UK",
        },
    ]
} />
