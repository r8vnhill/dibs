---
title: Tipos Producto
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="functional-programming-kt" />
<ModuleSetup module='product' task='setupProductTypeModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupProductTypeModule") {
        description = "Creates the base module and files for the Product Types lesson"
        module.set("adt:product")
        doLast {
            
        }
    }
    ```
</ModuleSetup>

Los tipos de datos no solo determinan el tipo de un valor, sino tambi√©n **cu√°ntos valores posibles** pueden representarse. En programaci√≥n funcional, **los tipos producto** son una de las construcciones fundamentales para agrupar datos: permiten **combinar m√∫ltiples valores en una √∫nica unidad compuesta**, lo cual es esencial para modelar estructuras ricas y expresivas.

El nombre *producto* proviene de las matem√°ticas: si un tipo $A$ tiene $|A|$ valores posibles, y otro tipo $B$ tiene $|B|$, entonces un valor de tipo $A \times B$ (producto cartesiano) tiene $|A| \times |B|$ combinaciones posibles. Este principio no solo tiene implicancias te√≥ricas, sino que gu√≠a la forma en que representamos y manipulamos estructuras en lenguajes como **Kotlin**.

En esta lecci√≥n exploraremos distintos niveles de representaci√≥n de tipos producto en Kotlin, desde estructuras simples como **`Pair`** y **`Triple`**, hasta construcciones m√°s robustas y expresivas como **registros definidos mediante `data class`**. Adem√°s, abordaremos c√≥mo estas construcciones promueven la **inmutabilidad, claridad y reutilizaci√≥n**, pilares clave del dise√±o funcional.

## üß≤ Pares

La forma m√°s simple de un tipo producto es el **par**. Un par, denotado como $(a, b)$ o formalmente como $A \times B$, es un tipo que contiene exactamente dos valores, posiblemente de tipos distintos. En Kotlin, los pares se representan mediante la clase `Pair` de la biblioteca est√°ndar.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="adt/src/main/kotlin/com/github/username/product/Pair.kt"
        "Two ways of creating a pair" {
            Pair(1, true) shouldBe (1 to true)
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="adt/src/main/kotlin/com/github/username/product/Pair.kt"
        package com.github.username.product

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class PairTest : FreeSpec({
            "Two ways of creating a pair" {
                Pair(1, true) shouldBe (1 to true)
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo mostramos dos formas equivalentes de construir un par en Kotlin:
    usando `Pair(1, true)` y utilizando el operador infijo `to`, que crea internamente una instancia de `Pair`.
</Explanation>

El t√©rmino *tipo producto* proviene de las matem√°ticas: si un tipo $A$ tiene $|A|$ valores posibles y otro tipo $B$ tiene $|B|$, entonces el tipo compuesto $A \times B$ tiene $|A| \cdot |B|$ combinaciones posibles. 

Por ejemplo, el tipo $(\mathrm{Int} \times \mathrm{Boolean})$ tiene $2^{32} \cdot 2 = 2^{33}$ valores distintos, ya que $\mathrm{Int}$ tiene $2^{32}$ posibles valores y $\mathrm{Boolean}$ tiene 2.

## üì¶ Tuplas

Aunque cualquier tipo puede ser representado como una composici√≥n de pares, como $A \times (B \times C)$, una alternativa m√°s directa es el uso de **tuplas**. Una tupla es un tipo producto que contiene un n√∫mero fijo de valores de diferentes tipos. Cada valor en la tupla puede ser de un tipo distinto, y la cantidad de valores define la "dimensi√≥n" de la tupla (e.g., una tupla de tres elementos se conoce como **triple**).

En Kotlin, no existe un concepto general de tuplas, pero en esencia, cualquier clase que tenga varias propiedades puede actuar como una tupla de $n$ valores. Un ejemplo com√∫n es la clase `Triple`, que representa una tupla de tres elementos:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="adt/src/main/kotlin/com/github/username/product/Triple.kt"
        class Triple<A, B, C>(val first: A, val second: B, val third: C)
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="adt/src/main/kotlin/com/github/username/product/Triple.kt"
        package com.github.username.product

        class Triple<A, B, C>(val first: A, val second: B, val third: C)
        ```

        ```kotlin showLineNumbers title="adt/src/test/kotlin/com/github/username/product/TripleTest.kt"
        package com.github.username.product

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class TripleTest : FreeSpec({
            "A triple" - {
                "can be created" {
                    Triple(1, true, "hello").run {
                        first shouldBe 1
                        second shouldBe true
                        third shouldBe "hello"
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Aqu√≠ definimos una clase gen√©rica `Triple` que representa una tupla de tres elementos.
    Cada campo (`first`, `second`, `third`) tiene un tipo independiente (`A`, `B`, `C`), lo que permite
    combinar distintos tipos de datos en una misma estructura.

    La prueba demuestra c√≥mo crear una instancia de esta tupla y acceder a sus valores.
    Este patr√≥n generaliza la idea del `Pair` y muestra c√≥mo extender los tipos producto
    m√°s all√° de dos componentes. Aunque Kotlin no ofrece una sintaxis nativa para tuplas arbitrarias,
    estructuras como esta cubren la mayor√≠a de los casos pr√°cticos.
</Explanation>

:::note[Nota]

En la biblioteca est√°ndar de Kotlin ya existe una clase Triple, pero aqu√≠ la reimplementamos como ejercicio.

:::

Por lo tanto, una tupla de tres valores en Kotlin podr√≠a ser representada con esta clase, donde cada elemento de la tupla tiene un tipo espec√≠fico y puede ser accedido mediante las propiedades `first`, `second`, y `third`.

## üóÇÔ∏è Registros en Kotlin

Los **registros** son tipos de datos que agrupan un conjunto fijo de campos con nombres expl√≠citos. Tambi√©n se conocen como **tuplas nombradas**, ya que combinan la estructura de una tupla con la claridad de campos identificables.

En Kotlin, los registros se implementan de manera sencilla mediante **data classes**. Estas clases est√°n dise√±adas para representar datos de forma concisa y expresiva, eliminando la necesidad de definir manualmente m√©todos repetitivos como `equals()`, `hashCode()`, `toString()`, y `copy()`.

### üèóÔ∏è Definici√≥n de un Registro

```kotlin showLineNumbers title="adt/src/main/kotlin/com/github/username/product/Person.kt"
package com.github.username.product

data class Person(val name: String, val age: Int)
```

<Explanation>
    En este ejemplo, `Person` es un registro que contiene dos campos: `name` y `age`. Este tipo de clase es ideal para representar objetos de dominio en aplicaciones que requieren un conjunto fijo de propiedades.
</Explanation>

### ‚öôÔ∏è Caracter√≠sticas Autom√°ticas de las Data Classes

Kotlin proporciona varias funcionalidades autom√°ticamente al declarar una clase como `data class`:

- **`equals()`**: Compara instancias bas√°ndose en los valores de sus propiedades.
- **`hashCode()`**: Genera un c√≥digo hash derivado de los valores de sus campos.
- **`toString()`**: Devuelve una representaci√≥n legible que incluye el nombre de la clase y los valores de sus propiedades.
- **`copy()`**: Crea una copia de la instancia, permitiendo modificar uno o m√°s valores.
- **`componentN()`**: Permite desestructurar la clase en variables individuales.

Estas funcionalidades equivalen a escribir manualmente una clase como la siguiente:

```kotlin showLineNumbers
class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false
        other as Person
        return name == other.name && age == other.age
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + age
        return result
    }

    override fun toString() = "Person(name='$name', age=$age)"

    fun copy(name: String = this.name, age: Int = this.age) = Person(name, age)

    operator fun component1() = name
    operator fun component2() = age
}
```

### üß™ Uso de los Registros en Kotlin

Crear y manipular instancias de un registro en Kotlin es simple y expresivo. A continuaci√≥n, se muestran algunas operaciones comunes que las **data classes** permiten realizar de forma autom√°tica:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        "can be created" {
            Person("John", 30).run {
                name shouldBe "John"
                age shouldBe 30
            }
        }

        "can be compared" {
            val person1 = Person("John", 30)
            val person2 = Person("John", 30)
            person1 shouldBe person2
        }

        "can be copied" {
            val person1 = Person("John", 30)
            val person2 = person1.copy(name = "Jane")
            person1 shouldBe Person("John", 30)
            person2 shouldBe Person("Jane", 30)
        }

        "can be destructured" {
            val (name, age) = Person("John", 30)
            name shouldBe "John"
            age shouldBe 30
        }

        "can be converted to a string" {
            Person("John", 30).toString() shouldBe "Person(name=John, age=30)"
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        package com.github.username.product

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class PersonTest : FreeSpec({
            "A person" - {
                "can be created" {
                    Person("John", 30).run {
                        name shouldBe "John"
                        age shouldBe 30
                    }
                }

                "can be compared" {
                    val person1 = Person("John", 30)
                    val person2 = Person("John", 30)
                    person1 shouldBe person2
                }

                "can be copied" {
                    val person1 = Person("John", 30)
                    val person2 = person1.copy(name = "Jane")
                    person1 shouldBe Person("John", 30)
                    person2 shouldBe Person("Jane", 30)
                }

                "can be destructured" {
                    val (name, age) = Person("John", 30)
                    name shouldBe "John"
                    age shouldBe 30
                }

                "can be converted to a string" {
                    Person("John", 30).toString() shouldBe "Person(name=John, age=30)"
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este bloque de pruebas se ejercitan varias funcionalidades clave de las `data class`: creaci√≥n, comparaci√≥n estructural, copia con modificaci√≥n, desestructuraci√≥n y conversi√≥n a cadena. Estas operaciones son generadas autom√°ticamente por el compilador, reduciendo el c√≥digo repetitivo y favoreciendo la claridad.
</Explanation>

:::warning

Aunque es posible definir los campos de una `data class` como `var`, se recomienda utilizar `val` para mantener la inmutabilidad.  
La forma idiom√°tica de modificar un registro es utilizando la funci√≥n `copy()` con los nuevos valores deseados.

:::

## üéØ Conclusiones

A lo largo de esta lecci√≥n exploramos los **tipos producto**, una construcci√≥n esencial tanto en teor√≠a de tipos como en programaci√≥n funcional. A trav√©s de ejemplos en Kotlin, vimos c√≥mo representar y trabajar con este tipo de estructuras, partiendo de pares y tuplas hasta llegar a registros definidos con `data class`.

Entender los tipos producto nos ayuda a dise√±ar **estructuras de datos claras y precisas**, modelando entidades reales con m√∫ltiples atributos. Tambi√©n nos permite razonar sobre el comportamiento y la complejidad de nuestros programas, al considerar cu√°ntas combinaciones posibles existen para un tipo determinado.

Ya sea que trabajes con estructuras simples como `Pair`, con tuplas gen√©ricas como `Triple`, o con registros expresivos como `Person`, dominar los tipos producto te permite **expresar relaciones entre datos de forma segura, reutilizable y mantenible**.

### üîë Puntos clave

- Los **tipos producto** combinan varios valores en una sola unidad, aumentando el espacio de posibilidades en funci√≥n del producto cartesiano de sus componentes.
- En Kotlin, los pares (`Pair`) y tuplas (`Triple`) ofrecen una representaci√≥n directa y pr√°ctica de estos tipos.
- Las **data classes** implementan registros, que son tuplas nombradas con m√∫ltiples ventajas como inmutabilidad, comparaci√≥n estructural y desestructuraci√≥n.
- La inmutabilidad, facilitada por `val` y la funci√≥n `copy()`, es un principio clave en el dise√±o de registros robustos.
- Aunque Kotlin no tiene un sistema de tipos algebraicos completo como otros lenguajes funcionales, ofrece suficientes herramientas para representar tipos producto de manera efectiva y expresiva.

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° del c√≥digo, esta lecci√≥n nos deja una forma de pensar los datos: como combinaciones estructuradas que revelan relaciones, roles y significado. Usar tipos producto no es solo una decisi√≥n t√©cnica, sino una manera de **hacer visible la estructura de nuestra aplicaci√≥n**.

Cuando nombramos campos, limitamos mutabilidad y aprovechamos las propiedades de las `data class`, estamos construyendo modelos mentales claros que nos ayudan a razonar mejor sobre el c√≥digo. Y eso ‚Äîen dise√±o funcional y en ingenier√≠a de software en general‚Äî es una de las claves para construir sistemas s√≥lidos y comprensibles.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Logo_C_sharp.svg/1200px-Logo_C_sharp.svg.png"
        language="C#"
        link="product/csharp"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/1200px-Haskell-Logo.svg.png"
        language="Haskell"
        link="product/haskell"
    />
    <LanguageCard
        logoSrc="https://cdn-icons-png.flaticon.com/512/3984/3984314.png"
        language="Swift"
        link="product/swift"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

- üìö Product Types. (2016). En R. Harper, Practical foundations for programming languages (2nd ed, pp. 79‚Äì84). Cambridge university press.
