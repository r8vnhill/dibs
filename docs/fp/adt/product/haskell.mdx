---
title: Tipos producto en Haskell
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="haskell-dibs" />

En Haskell, la idea de tipos producto también está muy presente. El equivalente a los **pares** y **tuplas** de Kotlin en Haskell se representa de una forma bastante similar.

## Pares en Haskell

En Haskell, un par es simplemente un valor que contiene dos elementos. El tipo se denota como `(A, B)`, donde `A` y `B` son los tipos de los dos elementos:

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```haskell showLineNumbers
        pair :: (Int, Bool)
        pair = (420, True)
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```haskell showLineNumbers
        pair :: (Int, Bool)
        pair = (420, True)

        -- Ejecución de las pruebas
        main :: IO ()
        main = do
            print $ fst pair
            print $ snd pair
            {- Output:
            420
            True
            }
        ```
    </TabItem>
</BoxedTabs>

## Tuplas en Haskell

Haskell permite la creación de tuplas con más de dos valores de una manera muy directa. Por ejemplo, una tupla de tres elementos se representa como:

```haskell
let triple = (1, "Hello", True)
```

## Registros en Haskell

En Haskell, los **registros** se implementan utilizando **data types** con campos nombrados, lo que es equivalente a las **data classes** en Kotlin. Un ejemplo de un registro en Haskell sería:

```haskell
data Person = Person { name :: String, age :: Int }
```

## Desestructuración de Registros en Haskell

Al igual que en Kotlin, Haskell permite la **desestructuración** de registros, lo que facilita el acceso a sus valores de forma directa. En Haskell, se puede desestructurar un registro al extraer sus campos:

```haskell
let Person { name = n, age = a } = Person "Alice" 30
```

Esto es similar a cómo se realiza la desestructuración en Kotlin:

```kotlin
val person = Person("Alice", 30)
val (name, age) = person
```

## Semejanzas y Diferencias

### Semejanzas
- Ambos lenguajes permiten la creación de pares y tuplas, aunque Haskell admite tuplas de cualquier tamaño de forma nativa, mientras que Kotlin solo ofrece soporte limitado a través de clases como `Pair` y `Triple`.
- Tanto en Haskell como en Kotlin, los **registros** se pueden desestructurar para acceder a los valores de los campos de manera más directa.
- Tanto Haskell como Kotlin ofrecen formas concisas de definir y trabajar con registros, proporcionando características como acceso a campos por nombre.

### Diferencias

- En Haskell, las tuplas se tratan como un tipo primitivo, y se pueden crear tuplas de cualquier número de elementos sin clases especiales. En Kotlin, si se necesita una tupla con más de tres elementos, se deben crear clases personalizadas.
- En Haskell, no existe una distinción entre `var` y `val`, ya que Haskell es un lenguaje puramente funcional con inmutabilidad por defecto. En Kotlin, la mutabilidad puede controlarse explícitamente usando `var` para variables mutables y `val` para inmutables.

En resumen, Haskell y Kotlin ofrecen maneras muy similares de trabajar con tipos producto, aunque Haskell proporciona un soporte más nativo y flexible para tuplas. Kotlin, por su parte, compensa esto con una sintaxis más orientada a objetos y herramientas como **data classes** para manejar registros.
