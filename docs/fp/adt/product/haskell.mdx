
# Tipos producto en Haskell

En Haskell, la idea de tipos producto también está muy presente. El equivalente a los **pares** y **tuplas** de Kotlin en Haskell se representa de una forma bastante similar.

## Pares en Haskell

En Haskell, un par es simplemente un valor que contiene dos elementos. El tipo se denota como `(A, B)`, donde `A` y `B` son los tipos de los dos elementos:

```haskell
let pair = (1, True)
```

## Tuplas en Haskell

Haskell permite la creación de tuplas con más de dos valores de una manera muy directa. Por ejemplo, una tupla de tres elementos se representa como:

```haskell
let triple = (1, "Hello", True)
```

## Registros en Haskell

En Haskell, los **registros** se implementan utilizando **data types** con campos nombrados, lo que es equivalente a las **data classes** en Kotlin. Un ejemplo de un registro en Haskell sería:

```haskell
data Person = Person { name :: String, age :: Int }
```

## Desestructuración de Registros en Haskell

Al igual que en Kotlin, Haskell permite la **desestructuración** de registros, lo que facilita el acceso a sus valores de forma directa. En Haskell, se puede desestructurar un registro al extraer sus campos:

```haskell
let Person { name = n, age = a } = Person "Alice" 30
```

Esto es similar a cómo se realiza la desestructuración en Kotlin:

```kotlin
val person = Person("Alice", 30)
val (name, age) = person
```

## Semejanzas y Diferencias

### Semejanzas
- Ambos lenguajes permiten la creación de pares y tuplas, aunque Haskell admite tuplas de cualquier tamaño de forma nativa, mientras que Kotlin solo ofrece soporte limitado a través de clases como `Pair` y `Triple`.
- Tanto en Haskell como en Kotlin, los **registros** se pueden desestructurar para acceder a los valores de los campos de manera más directa.
- Tanto Haskell como Kotlin ofrecen formas concisas de definir y trabajar con registros, proporcionando características como acceso a campos por nombre.

### Diferencias

- En Haskell, las tuplas se tratan como un tipo primitivo, y se pueden crear tuplas de cualquier número de elementos sin clases especiales. En Kotlin, si se necesita una tupla con más de tres elementos, se deben crear clases personalizadas.
- En Haskell, no existe una distinción entre `var` y `val`, ya que Haskell es un lenguaje puramente funcional con inmutabilidad por defecto. En Kotlin, la mutabilidad puede controlarse explícitamente usando `var` para variables mutables y `val` para inmutables.

En resumen, Haskell y Kotlin ofrecen maneras muy similares de trabajar con tipos producto, aunque Haskell proporciona un soporte más nativo y flexible para tuplas. Kotlin, por su parte, compensa esto con una sintaxis más orientada a objetos y herramientas como **data classes** para manejar registros.
