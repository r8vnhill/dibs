---
title: Tipos producto en otros lenguajes
---

## Haskell

En Haskell, la idea de tipos producto también está muy presente. El equivalente a los **pares** y **tuplas** de Kotlin en Haskell se representa de una forma bastante similar.

### Pares en Haskell

En Haskell, un par es simplemente un valor que contiene dos elementos. El tipo se denota como `(A, B)`, donde `A` y `B` son los tipos de los dos elementos:

```haskell
let pair = (1, True)
```

### Tuplas en Haskell

Haskell permite la creación de tuplas con más de dos valores de una manera muy directa. Por ejemplo, una tupla de tres elementos se representa como:

```haskell
let triple = (1, "Hello", True)
```

### Registros en Haskell

En Haskell, los **registros** se implementan utilizando **data types** con campos nombrados, lo que es equivalente a las **data classes** en Kotlin. Un ejemplo de un registro en Haskell sería:

```haskell
data Person = Person { name :: String, age :: Int }
```

### Desestructuración de Registros en Haskell

Al igual que en Kotlin, Haskell permite la **desestructuración** de registros, lo que facilita el acceso a sus valores de forma directa. En Haskell, se puede desestructurar un registro al extraer sus campos:

```haskell
let Person { name = n, age = a } = Person "Alice" 30
```

Esto es similar a cómo se realiza la desestructuración en Kotlin:

```kotlin
val person = Person("Alice", 30)
val (name, age) = person
```

### Semejanzas y Diferencias

#### Semejanzas
- Ambos lenguajes permiten la creación de pares y tuplas, aunque Haskell admite tuplas de cualquier tamaño de forma nativa, mientras que Kotlin solo ofrece soporte limitado a través de clases como `Pair` y `Triple`.
- Tanto en Haskell como en Kotlin, los **registros** se pueden desestructurar para acceder a los valores de los campos de manera más directa.
- Tanto Haskell como Kotlin ofrecen formas concisas de definir y trabajar con registros, proporcionando características como acceso a campos por nombre.

#### Diferencias

- En Haskell, las tuplas se tratan como un tipo primitivo, y se pueden crear tuplas de cualquier número de elementos sin clases especiales. En Kotlin, si se necesita una tupla con más de tres elementos, se deben crear clases personalizadas.
- En Haskell, no existe una distinción entre `var` y `val`, ya que Haskell es un lenguaje puramente funcional con inmutabilidad por defecto. En Kotlin, la mutabilidad puede controlarse explícitamente usando `var` para variables mutables y `val` para inmutables.

En resumen, Haskell y Kotlin ofrecen maneras muy similares de trabajar con tipos producto, aunque Haskell proporciona un soporte más nativo y flexible para tuplas. Kotlin, por su parte, compensa esto con una sintaxis más orientada a objetos y herramientas como **data classes** para manejar registros.

## Swift

En **Swift**, los tipos producto se implementan principalmente a través de **tuplas** y **structs**. Estos mecanismos permiten agrupar varios valores en una única entidad, similar a cómo Kotlin utiliza `Pair`, `Triple` o **data classes**.

### Tuplas en Swift

Las **tuplas** en Swift son una forma simple de agrupar varios valores, de distintos tipos, en una sola unidad. Al igual que en Kotlin, una tupla puede contener dos o más valores. A diferencia de Kotlin, en Swift puedes tener tuplas con nombres de elementos, lo que las hace más expresivas.

```swift
let person: (String, Int) = ("Alice", 30)
let namedPerson: (name: String, age: Int) = (name: "Alice", age: 30)
```

En este ejemplo:
- La primera tupla contiene una cadena (`String`) y un número entero (`Int`), similar a un `Pair` en Kotlin.
- La segunda tupla tiene nombres para sus elementos, lo que la hace comparable a una **data class** con propiedades.

#### Acceso a Elementos de la Tupla

Al igual que en Kotlin, los elementos de la tupla se pueden acceder por posición:

```swift
print(person.0) // Alice
print(person.1) // 30
```

Cuando se utilizan nombres para los elementos, se puede acceder por nombre:

```swift
print(namedPerson.name) // Alice
print(namedPerson.age) // 30
```

### Diferencias con Kotlin

A diferencia de Kotlin, donde los tipos producto más avanzados (como las **data classes**) incluyen métodos como `copy()` o `toString()` automáticamente, en Swift las tuplas no ofrecen este nivel de funcionalidad. Las tuplas en Swift son más comparables a los **pares** y **triples** en Kotlin en términos de simplicidad.

### Structs en Swift

Para una estructura más avanzada y rica, similar a las **data classes** de Kotlin, Swift proporciona las **structs**. Las structs permiten definir tipos de datos con propiedades y métodos, y se comportan de manera similar a los registros o las **data classes** en Kotlin.

```swift
struct Person {
    let name: String
    var age: Int
}
```

En este ejemplo, `Person` es una **struct** con dos propiedades, `name` y `age`. Las structs en Swift, al igual que las **data classes** de Kotlin, proporcionan de manera automática:
- Un **inicializador** que toma todas las propiedades.
- Soporte para comparar instancias con `==` si todas las propiedades también lo soportan.
- Un método `description` implícito que representa la instancia como una cadena.

#### Inmutabilidad

Al igual que las **data classes** en Kotlin, puedes hacer que las propiedades de una **struct** sean inmutables utilizando `let` en lugar de `var`. Esto asegura que la instancia sea inmutable una vez inicializada, promoviendo un diseño más seguro y consistente.

### Destructuración en Swift

Al igual que Kotlin admite destructuración de **data classes**, Swift admite la destructuración de tuplas. Esto permite descomponer una tupla en sus componentes individuales:

```swift
let (name, age) = namedPerson
print(name) // Alice
print(age)  // 30
```

### Similitudes y Diferencias

- **Similitudes con Kotlin**: Ambos lenguajes admiten tipos producto simples como tuplas, así como estructuras más avanzadas como **structs** en Swift o **data classes** en Kotlin. Ambas estructuras son inmutables por defecto si se utilizan propiedades `let` o `val`.

- **Diferencias**: Las tuplas en Swift pueden tener nombres para los elementos, mientras que en Kotlin no existe un mecanismo de tuplas con nombres. Además, las **structs** en Swift no proporcionan automáticamente métodos como `copy()`, mientras que las **data classes** en Kotlin sí.
