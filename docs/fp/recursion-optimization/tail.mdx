---

title: Recursión por la Cola

---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../../src/components/ReadingTime';

<ReadingTime />

La **recursión por la cola** es un tipo específico de recursión en la que la **llamada recursiva es la última operación** realizada por la función. Este tipo de recursión es especialmente útil en lenguajes que admiten la **optimización de la cola**, como Kotlin y Scala. Cuando el compilador detecta una recursión por la cola, puede optimizar la función convirtiéndola en un bucle iterativo, lo que mejora significativamente el rendimiento y evita el desbordamiento de pila.

En Kotlin, podemos indicar que una función debe ser optimizada como recursión por la cola utilizando la palabra clave `tailrec`. Esto garantiza que el compilador aplique la optimización.

### Ejemplo: Factorial con Recursión por la Cola

```kotlin
tailrec fun factorial(n: Int, acc: Int): Int =
    if (n == 0) {
        acc
    } else {
        factorial(n - 1, acc * n)
    }
```

En este ejemplo, la función `factorial` utiliza un **acumulador** (`acc`) que lleva el resultado parcial de la operación, y la llamada recursiva es la última operación en la función, lo que permite la optimización.

:::tip Ejercicio: Identificar Recursión por la Cola

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Analiza las siguientes funciones y determina si son recursivas por la cola:
        ```kotlin
        fun sum(n: Int, acc: Int = 0) = if (n == 0) acc else sum(n - 1, acc + n)
        ```

        ```kotlin
        fun factorial(n: Int): Long = if (n == 0) {
            1
        } else {
            n * factorial(n - 1)
        }
        ```

        ```kotlin
        fun countdown(n: Int) {
            if (n == 0) {
                return
            } else {
                println(n)
                countdown(n - 1)
            }
        }
        ```
    </TabItem>
    <TabItem value="Solución" label="Solución">
        1. Sí, es recursiva por la cola.
        2. No, la última operación es una multiplicación, no la llamada recursiva.
        3. Sí, la llamada recursiva es la última operación.
    </TabItem>
</Tabs>
:::

### Problema: Factorial sin Recursión por la Cola

El problema con nuestra segunda implementación de `factorial` es que la **última operación** que realiza es la **multiplicación**, no la llamada recursiva. Esto impide que el compilador optimice la recursión.

### Solución: Uso de una Función Auxiliar y Acumulador

Para solucionar este problema, podemos usar una **función auxiliar** que maneje el acumulador:

```kotlin
fun factorial(n: Int): Int {
    tailrec fun aux(n: Int, acc: Int): Int =
        if (n == 0) {
            acc
        } else {
            aux(n - 1, acc * n)
        }
    return aux(n, 1)
}
```

En este caso, la función `aux` realiza la recursión, y como la llamada recursiva es la última operación, el compilador puede optimizarla.

### Solución Alternativa: Uso de Parámetros por Defecto

Otra opción es utilizar **parámetros por defecto** para lograr el mismo resultado sin necesidad de una función auxiliar:

```kotlin
tailrec fun factorial(n: Int, acc: Int = 1): Int = if (n == 0) {
    acc
} else {
    factorial(n - 1, acc * n)
}
```

Este enfoque es más conciso y aprovecha los parámetros por defecto de Kotlin para manejar el acumulador.

:::tip Ejercicio: Suma de Dígitos con Recursión por la Cola

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Implementa una función que tome un número y retorne la suma de sus dígitos. Optimiza la función utilizando recursión por la cola y una función auxiliar.

        **Hint**: Para obtener el último dígito de un número, puedes utilizar `n % 10`.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun sumDigits(n: Int): Int {
            tailrec fun aux(n: Int, sum: Int): Int = if (n == 0) {
                sum
            } else {
                val lastDigit = n % 10
                aux(n / 10, sum + lastDigit)
            }
            return aux(n, 0)
        }
        ```
    </TabItem>
</Tabs>
:::
