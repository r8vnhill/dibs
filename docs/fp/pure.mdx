---
title: Funciones Puras y Efectos Secundarios
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Definition from "../../src/components/Definition";
import ReadingTime from '../../src/components/ReadingTime';
import Corollary from "../../src/components/Corollary";

<ReadingTime />

## Funciones Puras

<Definition title="Transparencia Referencial">
    Una expresión $e$ es referencialmente transparente si, en cualquier programa $p$, todas las ocurrencias de $e$ en $p$ pueden ser reemplazadas por el resultado de evaluar $e$ sin cambiar el significado de $p$.
</Definition>

<Definition title="Función Pura">
    Una función $f$ es pura si, para todos los $x$ que son referencialmente transparentes, la expresión $f(x)$ también lo es.
</Definition>

<Corollary>
    Una función es pura si su único efecto observable dentro de la ejecución del programa es procesar el input para producir un output, sin causar ningún otro cambio en el estado del programa.
</Corollary>

### Efectos Secundarios

También conocidos como **side-effects**, los efectos secundarios son cualquier operación que una función realice además de retornar un valor. Un efecto secundario puede ser modificar una variable global, escribir en un archivo, o interactuar con la interfaz de usuario. Cuando una función tiene efectos secundarios, se la considera **impura**.

<Corollary>
    Una función es impura si tiene efectos secundarios, es decir, si modifica algo fuera de su propio ámbito o entorno.
</Corollary>

### Ejemplos de Funciones Puras e Impuras

A continuación, analizamos algunos ejemplos para identificar funciones puras e impuras.

:::tip Ejercicio: Identificar Funciones Puras

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Identifica si las siguientes funciones son puras o impuras:

        1.
        ```kotlin
        fun add(a: Int, b: Int): Int = a + b
        ```
        2.
        ```kotlin
        fun addCurried(): (Int) -> (Int) -> Int = { a -> { b -> a + b } }
        ```
        3.
        ```kotlin
        fun greet(name: String): Unit = println("Hello, $name!")
        ```
        4.
        ```kotlin
        fun incrementArray(array: Array<Int>): Unit {
            for (i in array.indices) {
                array[i]++
            }
        }
        ```
    </TabItem>
    <TabItem value="Solución" label="Solución">
        1. **Pura**: No tiene efectos secundarios y solo realiza una operación matemática.
        2. **Pura**: Es una función currificada que no tiene efectos secundarios.
        3. **Impura**: Tiene un efecto secundario al imprimir en la consola.
        4. **Impura**: Modifica el array original, lo que implica un efecto secundario.
    </TabItem>
</Tabs>
:::

<Corollary>
    En general, si una función retorna `Unit`, es un indicio de que podría tener efectos secundarios.
</Corollary>

### Mitigando Efectos Secundarios

Cuando una función es impura debido a que modifica el estado del programa, como en el siguiente ejemplo, se puede refactorizar para evitar esos efectos.

### Ejemplo de función impura:

```kotlin
fun incrementArray(array: Array<Int>): Unit {
    for (i in array.indices) {
        array[i]++
    }
}
```

El código anterior es impuro porque **modifica directamente el arreglo** pasado como argumento. Esto genera efectos secundarios, lo que hace que el comportamiento de la función dependa del estado externo.

Para hacer que la función sea pura, debemos **evitar modificar el arreglo original**. En su lugar, vamos a devolver un **nuevo arreglo** con los valores incrementados. A continuación, utilizamos recursión para lograr esto:

```kotlin
fun incrementArray(array: Array<Int>, index: Int = 0): Array<Int> =
    if (index >= array.size) {
        arrayOf()   // (1)
    } else {
        arrayOf(array[index] + 1) + incrementArray(array, index + 1)    // (2)
    }
```

1. **Caso Base**: El caso base ocurre cuando el índice ha recorrido todos los elementos del arreglo (`index >= array.size`). En este caso, la función retorna un **arreglo vacío**, lo cual sirve como punto de finalización de la recursión.
2. **Caso Recursivo**:
    - En cada paso de la recursión, se crea un **nuevo arreglo** que contiene el valor incrementado del elemento actual, y luego se concatena con el resultado de la llamada recursiva para los elementos restantes.
    - Esto genera un nuevo arreglo sin modificar el original.

### Ejemplo de Función Impura: Cálculo de Intereses Compuestos

En el código original, el uso de `println` para mostrar los balances en cada iteración es un **efecto secundario** que lo hace impuro:

```kotlin
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Double {
    var balance = principal
    for (year in 1..years) {
        balance += balance * rate
        // highlight-next-line
        println("Año $year: Balance = $balance")
    }
    return balance
}
```

Para hacer la función **pura**, eliminamos los efectos secundarios (la impresión) y almacenamos el historial de balances en una lista que será parte del resultado. Utilizaremos **recursión** con parámetros por defecto para simplificar el diseño:

```kotlin
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Pair<Double, List<String>> {
    fun calculateRecursive(
        currentYear: Int,
        currentBalance: Double,
        history: List<String>
    ): Pair<Double, List<String>> = if (currentYear > years) {
        currentBalance to history
    } else {
        val newBalance = currentBalance + currentBalance * rate
        val newHistory = history + "Año $currentYear: Balance = $newBalance"
        calculateRecursive(currentYear + 1, newBalance, newHistory)
    }
    return calculateRecursive(1, principal, emptyList())
}
```

:::note
Usamos una **función auxiliar** en lugar de parámetros por defecto para evitar sobrecargar la función principal con demasiados parámetros, lo que afectaría su claridad. La función auxiliar maneja el estado interno, manteniendo la **simplicidad** y **legibilidad**, mientras que la función principal se enfoca solo en los parámetros esenciales. Esto sigue el principio de mantener las funciones con la menor cantidad de parámetros posible.
:::

:::tip Ejercicio: Eliminar Efectos Secundarios

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        En el siguiente ejemplo, la función `transferirFondos` tiene efectos secundarios, ya que modifica el estado de las cuentas y la base de datos:

        ```kotlin
        object Database {
            fun update(cuenta: Cuenta): Unit = TODO()
        }

        fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
            if (cuentaOrigen.saldo >= monto) {
                cuentaOrigen.saldo -= monto
                cuentaDestino.saldo += monto
                database.update(cuentaOrigen)
                database.update(cuentaDestino)
                true
            } else {
                false
            }
        ```

        Modifica la función `transferirFondos` para eliminar los efectos secundarios. En lugar de modificar directamente las cuentas, devuelve un objeto que describa el resultado de la operación. **Hint**: Utiliza una `data class` para representar el resultado de la transferencia.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        data class TransferenciaResultado(
            val cuentaOrigenActualizada: Cuenta,
            val cuentaDestinoActualizada: Cuenta,
            val exito: Boolean
        )
        ```

        ```kotlin
        fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
            if (cuentaOrigen.saldo >= monto) {
                val nuevaCuentaOrigen = cuentaOrigen.copy(saldo = cuentaOrigen.saldo - monto)
                val nuevaCuentaDestino = cuentaDestino.copy(saldo = cuentaDestino.saldo + monto)
                TransferenciaResultado(nuevaCuentaOrigen, nuevaCuentaDestino, true)
            } else {
                TransferenciaResultado(cuentaOrigen, cuentaDestino, false)
            }
        ```
    </TabItem>
</Tabs>
:::
