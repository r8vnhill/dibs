---
title: Funciones Lambda en TypeScript
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import {ProCons, Pros, Cons} from '/src/components/cajitas/ProCons';

<ReadingTime/>

En **TypeScript**, las funciones lambda, también conocidas como **arrow functions**, se utilizan de manera similar a Kotlin. Ambas ofrecen una forma concisa de escribir funciones anónimas, pero hay diferencias en la sintaxis y las características que cada lenguaje ofrece.

## Definición de Funciones Lambda en TypeScript

En TypeScript, las **arrow functions** son equivalentes a las lambdas en Kotlin. La sintaxis básica es:

```typescript showLineNumbers
const add = (a: number, b: number): number => a + b;
```

:::info Explicación del código

- La función `add` toma dos parámetros `a` y `b`, ambos de tipo `number`, y devuelve su suma.
- La flecha `=>` separa los parámetros del cuerpo de la función.

:::

Esta sintaxis permite crear funciones de manera más breve y directa en comparación con las funciones tradicionales en TypeScript.

## Lambdas en TypeScript con Funciones de Orden Superior

Al igual que en Kotlin, en TypeScript podemos usar lambdas como parámetros en funciones de orden superior. Por ejemplo, una función `filter` que toma una lambda como predicado:

```typescript showLineNumbers
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(n => n % 2 === 0);
console.log(evenNumbers);  // Output: [2, 4]
```

Aquí, `filter` recibe una lambda que evalúa si un número es par. Esto es equivalente al ejemplo en Kotlin, y muestra cómo ambos lenguajes manejan de manera similar la programación funcional.

## Contexto de `this` en TypeScript

Una diferencia importante entre TypeScript y Kotlin es cómo se maneja el contexto de `this` en lambdas:
- **En TypeScript**, las **arrow functions** capturan automáticamente el contexto de `this` en el que fueron definidas, lo que es útil para manejar callbacks y métodos de objetos.
- **En Kotlin**, las lambdas no capturan automáticamente el contexto de `this`; en su lugar, es necesario referirse a él explícitamente o usar funciones de alcance como `apply` o `run`.

## Desestructuración en Lambdas de TypeScript

TypeScript admite desestructuración en los parámetros de las funciones lambda, de forma similar a Kotlin:

```typescript showLineNumbers
const printPerson = ({ name, age }: { name: string; age: number }) => {
    console.log(`Name: ${name}, Age: ${age}`);
};

printPerson({ name: "Alice", age: 29 });  // Output: Name: Alice, Age: 29
```

Esto permite extraer valores directamente desde un objeto y utilizarlos en la lambda, mejorando la claridad y reduciendo la necesidad de código adicional para acceder a las propiedades.

## Desestructuración en Listas y Estructuras Complejas

TypeScript permite la desestructuración en listas y tuplas, lo que es similar a Kotlin, pero con algunas diferencias en cómo se manejan las estructuras anidadas:

```typescript showLineNumbers
const [first, second] = [1, 2];
console.log(first, second);  // Output: 1 2
```

En este caso, TypeScript permite extraer elementos individuales de una lista o tupla directamente, similar a Kotlin. Sin embargo, para estructuras más complejas, Kotlin ofrece un manejo más explícito al desestructurar objetos y clases personalizadas.

## Comparación Final

| **Característica**               | **TypeScript**                                                                                | **Kotlin**                                                                                                 |
|----------------------------------|-----------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| **Sintaxis de Lambdas**          | Utiliza `=>` para definir funciones lambda.                                                   | Utiliza `{}` y `->` para definir lambdas.                                                                  |
| **Captura de `this`**            | Captura automáticamente el contexto de `this` en el que fueron definidas.                     | No captura automáticamente; se debe referenciar `this` explícitamente o usar funciones de alcance.         |
| **Tipado de Parámetros**         | Los tipos se declaran explícitamente en los parámetros y el retorno.                          | Los tipos pueden inferirse o declararse explícitamente, lo que permite mayor flexibilidad.                 |
| **Desestructuración**            | Admite desestructuración en parámetros de lambdas y variables, incluso en objetos y arrays.   | Admite desestructuración en lambdas y variables, incluyendo clases personalizadas y estructuras complejas. |
| **Funciones Anónimas**           | Solo se usa una forma (arrow functions) para definir funciones sin nombre.                    | Ofrece tanto lambdas como funciones anónimas, cada una con diferencias sutiles en su uso y sintaxis.       |
| **Evaluación Perezosa**          | No tiene evaluación perezosa nativa; requiere bibliotecas o implementación manual.            | Soporte nativo para evaluación perezosa a través de lambdas y funciones inline.                            |
| **Funciones de Orden Superior**  | Admite el uso de lambdas en funciones de orden superior, como `map`, `filter`, etc.           | Soporta funciones de orden superior con una sintaxis concisa, incluyendo trailing lambdas.                 |
| **Desestructuración en Lambdas** | Permite desestructuración en parámetros de lambdas, pero es limitada en estructuras anidadas. | Ofrece un soporte robusto para desestructuración en lambdas, pero no soporta anidamiento directo.          |

### Ventajas y Desventajas de Funciones Lambda en TypeScript

<ProCons>
    <Pros>
        - **Captura Automática de `this`**: TypeScript permite que las arrow functions capturen automáticamente el contexto de `this`, lo que facilita el manejo de callbacks y evita problemas comunes relacionados con el contexto en JavaScript.
        - **Sintaxis Concisa y Familiar**: Las arrow functions en TypeScript utilizan una sintaxis clara y familiar (`=>`), que se ha vuelto estándar en muchos lenguajes modernos, facilitando la transición de desarrolladorxs que provienen de otros lenguajes.
        - **Tipado Explícito y Flexible**: TypeScript permite especificar los tipos de parámetros y el valor de retorno en las funciones lambda, mejorando la seguridad del código y la autocompletación en entornos de desarrollo.
        - **Soporte de Desestructuración**: TypeScript admite desestructuración en parámetros de lambdas, lo que simplifica el acceso a propiedades de objetos y mejora la legibilidad.
    </Pros>
    <Cons>
        - **Falta de Evaluación Perezosa Nativa**: A diferencia de Kotlin, TypeScript no ofrece evaluación perezosa nativa en sus lambdas, lo que requiere bibliotecas externas o soluciones manuales para lograr este comportamiento.
        - **Limitaciones en Desestructuración de Estructuras Anidadas**: La desestructuración en TypeScript es limitada en comparación con Kotlin cuando se trata de estructuras anidadas, lo que puede hacer que el código sea más extenso en estos casos.
        - **Única Forma de Definir Funciones Anónimas**: En TypeScript, solo se utilizan arrow functions para definir funciones sin nombre, mientras que en Kotlin hay más flexibilidad para elegir entre funciones anónimas y lambdas según el caso.
        - **Menor Control sobre `this` en Funciones Tradicionales**: Aunque la captura automática de `this` es ventajosa en muchos casos, puede ser un inconveniente en situaciones donde se desea un mayor control sobre el contexto, lo que requiere definir funciones tradicionales en lugar de arrow functions.
    </Cons>
</ProCons>

## ¿Qué Aprendimos?

En esta lección, exploramos cómo las **funciones lambda** (o **arrow functions**) en TypeScript se comparan con las lambdas en Kotlin, identificando similitudes y diferencias clave. Algunos puntos importantes que discutimos incluyen:

1. **Definición y Sintaxis**: Vimos cómo las funciones lambda en TypeScript usan la sintaxis `=>` para definir funciones de manera concisa, similar a Kotlin, pero con diferencias en el uso de `{}` y `->`.
2. **Contexto de `this`**: Resaltamos que TypeScript captura automáticamente el contexto de `this` en las lambdas, lo que puede ser conveniente en ciertos casos, pero también puede limitar el control sobre el contexto en comparación con Kotlin.
3. **Desestructuración en Lambdas**: Analizamos cómo TypeScript admite la desestructuración en los parámetros de las funciones lambda, facilitando la extracción de valores de objetos y listas, aunque con algunas limitaciones en estructuras anidadas.
4. **Funciones de Orden Superior**: Ambos lenguajes soportan el uso de funciones lambda en funciones de orden superior, como `map` y `filter`, mostrando que la programación funcional es un concepto clave en ambos entornos.
5. **Evaluación Perezosa**: Notamos que Kotlin tiene soporte nativo para la evaluación perezosa, mientras que en TypeScript es necesario utilizar bibliotecas externas o implementarla manualmente.

### Principales Conclusiones

- **Flexibilidad en la Definición de Lambdas**: Kotlin ofrece más flexibilidad al proporcionar tanto lambdas como funciones anónimas, mientras que TypeScript se enfoca en un solo estilo con las arrow functions.
- **Soporte y Limitaciones en Desestructuración**: Aunque TypeScript permite la desestructuración en lambdas y listas, su capacidad para manejar estructuras complejas no es tan robusta como en Kotlin.
- **Diferencias en el Contexto**: La gestión de `this` es más automática en TypeScript, lo que simplifica ciertos casos, pero Kotlin proporciona más control directo y opciones para referenciar el contexto.

En general, aunque ambos lenguajes permiten un uso extensivo de las funciones lambda, las diferencias en cómo se manejan ciertos aspectos como el contexto de `this` y la desestructuración pueden influir en la forma en que se diseñan las aplicaciones.
