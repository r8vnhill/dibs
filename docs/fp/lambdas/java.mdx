---
title: Funciones Lambda en Java
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<ReadingTime/>

Java, al igual que Kotlin, soporta funciones lambda, aunque este soporte fue introducido más tarde, en Java 8. Las lambdas en Java permiten escribir código más conciso y legible, especialmente cuando se trata de funciones de orden superior o programación funcional. Sin embargo, la implementación y sintaxis de las funciones lambda en Java y Kotlin tienen algunas diferencias clave.

### Ejemplo en Java

```java
import java.util.function.BinaryOperator;

public class Main {
    public static void main(String[] args) {
        BinaryOperator<Integer> sumar = (a, b) -> a + b;
        int resultado = sumar.apply(5, 10);
        System.out.println(resultado);  // Output: 15
    }
}
```

### Comparación con Kotlin

- **Sintaxis:**
  - **Kotlin:** Utiliza `{ }` y `->` para definir funciones lambda.
  - **Java:** Utiliza `->` para definir lambdas, pero requiere el uso de interfaces funcionales, como `BinaryOperator`.
- **Uso de interfaces funcionales:**
  - **Kotlin:** Las lambdas no necesitan estar asociadas a interfaces específicas, pero pueden usarse con interfaces funcionales ([SAM](https://kotlinlang.org/docs/fun-interfaces.html)).
  - **Java:** Requiere interfaces funcionales predefinidas o personalizadas.

### Funciones de Orden Superior en Java

En Java, las funciones de orden superior (funciones que toman otras funciones como argumentos) se implementan utilizando **interfaces funcionales**. Aunque Java no soporta funciones como valores directamente, las interfaces funcionales como `Function`, `Predicate`, y `BinaryOperator` permiten un comportamiento similar.

### Ejemplo en Java

```java
import java.util.function.BiFunction;

public class Main {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> procesarEnteros = (a, b) -> a + b;
        int suma = procesarEnteros.apply(3, 4);
        System.out.println(suma);  // Output: 7
    }
}
```

### Comparación con Kotlin

- **Sintaxis:**
  - **Kotlin:** Escribe funciones de orden superior directamente, sin necesidad de interfaces funcionales.
  - **Java:** Necesita utilizar una interfaz funcional, como `BiFunction`, para pasar funciones como parámetros.

### Desestructuración en Java

A diferencia de Kotlin, **Java no soporta desestructuración** de manera nativa. Esto significa que en Java no se puede descomponer un objeto en varias variables directamente. Para lograr un comportamiento similar, se deben acceder manualmente a las propiedades de un objeto mediante métodos de acceso (`getters`).

## Comparación Final

| **Característica**              | **Kotlin**                                                                                                                 | **Java**                                                                                                                                    |
|---------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| **Sintaxis Lambda**             | Utiliza `{ }` y `->` para definir lambdas directamente sin necesidad de interfaces funcionales.                            | Utiliza `->`, pero requiere interfaces funcionales como `BinaryOperator`.                                                                   |
| **Interfaces Funcionales**      | No es necesario utilizar interfaces funcionales, aunque puede trabajar con SAMs.                                           | Las lambdas deben asociarse a interfaces funcionales predefinidas o personalizadas.                                                         |
| **Funciones de Orden Superior** | Se pueden escribir funciones de orden superior directamente.                                                               | Requiere interfaces funcionales como `BiFunction` para simular funciones de orden superior.                                                 |
| **Desestructuración**           | Soporta desestructuración nativa de objetos en múltiples variables.                                                        | No tiene soporte nativo para desestructuración; debe accederse manualmente a los atributos.                                                 |
| **Inmutabilidad y Colecciones** | Kotlin promueve el uso de colecciones inmutables por defecto y tiene funciones avanzadas como `map`, `filter`, y `reduce`. | Java usa colecciones mutables por defecto y las funciones como `map` y `filter` están disponibles solo a partir de Java 8 con `Stream API`. |
| **Tipo de Retorno Lambda**      | Las lambdas pueden inferir su tipo de retorno automáticamente.                                                             | El tipo de retorno debe ser compatible con el tipo de la interfaz funcional.                                                                |
| **Programación Funcional**      | Facilita la programación funcional con características como funciones de orden superior y lambdas concisas.                | Java admite programación funcional a través de `Stream API` y lambdas, pero con más verbosidad.                                             |

:::tip **Ventajas de Java**

- **Mayor uso en la industria**: Aunque Kotlin ha crecido en popularidad, Java sigue siendo ampliamente utilizado en grandes sistemas empresariales.
- **Compatibilidad amplia**: Java es compatible con una amplia gama de plataformas y bibliotecas, y se puede ejecutar en casi cualquier entorno.
- **Madurez del lenguaje**: Java tiene una larga historia y muchas herramientas de desarrollo, bibliotecas y recursos.

:::

:::danger **Desventajas de Java**

- **Verboso**: La sintaxis de Java tiende a ser más detallada y requiere más líneas de código que Kotlin.
- **Menos soporte funcional**: Aunque Java ha introducido lambdas y el `Stream API`, carece de las características funcionales avanzadas que ofrece Kotlin.
- **Sin soporte nativo para desestructuración**: A diferencia de Kotlin, no se puede descomponer objetos directamente.

:::

### ¿Qué Aprendimos?

En esta lección, hemos explorado las **lambdas** en **Java** y su comparación con **Kotlin**. Aunque Java introdujo el soporte para funciones lambda a partir de Java 8, su implementación es más verbosa y depende de **interfaces funcionales** como `Function` y `BiFunction`. En cambio, Kotlin ofrece una sintaxis más concisa y funcional, sin necesidad de utilizar estas interfaces.

Hemos aprendido a:

1. Escribir **lambdas** en Java y Kotlin, y las diferencias clave en su sintaxis.
2. Usar **interfaces funcionales** en Java, mientras que en Kotlin no son necesarias para escribir funciones lambda.
3. Comparar cómo cada lenguaje maneja las **funciones de orden superior**.
4. Ver las limitaciones de Java respecto a la **desestructuración** de objetos, que es una característica nativa en Kotlin.
5. Analizar cómo cada lenguaje aborda la **programación funcional**, con Kotlin proporcionando características más avanzadas y concisas, mientras que Java ofrece una funcionalidad similar a través de `Stream API` pero con mayor verbosidad.

Finalmente, entendimos las **ventajas** y **desventajas** de Java en comparación con Kotlin, lo que nos permite elegir el lenguaje adecuado para diferentes contextos y necesidades en el desarrollo de software.

<References references={[
    {
        title: "3. Lambda Expressions",
        bookTitle: "Modern Java in action: Lambdas, streams, functional and reactive programming",
        pages: "42–78",
        location: "Shelter Island, NY",
        publisher: "Manning Publications",
        year: "2019",
        type: "book",
        author: 'R.-G. Urma, M. Fusco, & A. Mycroft',
        edition: '1st',
    },
]}/>
