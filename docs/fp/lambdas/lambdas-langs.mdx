---
title: Funciones lambda en otros lenguajes
---

## Java

Java, al igual que Kotlin, soporta funciones lambda, aunque este soporte fue introducido más tarde, en Java 8. Las lambdas en Java permiten escribir código más conciso y legible, especialmente cuando se trata de funciones de orden superior o programación funcional. Sin embargo, la implementación y sintaxis de las funciones lambda en Java y Kotlin tienen algunas diferencias clave.

### Lambdas en Java

En Java, las **lambdas** son una forma concisa de expresar una implementación de una interfaz funcional (una interfaz que tiene un solo método abstracto). Las lambdas en Java pueden asignarse a variables y pasarse como argumentos, pero su sintaxis difiere de Kotlin.

#### Ejemplo en Java

```java
import java.util.function.BinaryOperator;

public class Main {
    public static void main(String[] args) {
        BinaryOperator<Integer> sumar = (a, b) -> a + b;
        int resultado = sumar.apply(5, 10);
        System.out.println(resultado);  // Output: 15
    }
}
```

#### Comparación con Kotlin

- **Sintaxis:**
    - **Kotlin:** Utiliza `{ }` y `->` para definir funciones lambda.
    - **Java:** Utiliza `->` para definir lambdas, pero requiere el uso de interfaces funcionales, como `BinaryOperator`.
- **Uso de interfaces funcionales:**
    - **Kotlin:** Las lambdas no necesitan estar asociadas a interfaces específicas, pero pueden usarse con interfaces funcionales ([SAM](https://kotlinlang.org/docs/fun-interfaces.html)).
    - **Java:** Requiere interfaces funcionales predefinidas o personalizadas.

### Funciones de Orden Superior en Java

En Java, las funciones de orden superior (funciones que toman otras funciones como argumentos) se implementan utilizando **interfaces funcionales**. Aunque Java no soporta funciones como valores directamente, las interfaces funcionales como `Function`, `Predicate`, y `BinaryOperator` permiten un comportamiento similar.

#### Ejemplo en Java

```java
import java.util.function.BiFunction;

public class Main {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> procesarEnteros = (a, b) -> a + b;
        int suma = procesarEnteros.apply(3, 4);
        System.out.println(suma);  // Output: 7
    }
}
```

#### Comparación con Kotlin

- **Sintaxis:**
    - **Kotlin:** Escribe funciones de orden superior directamente, sin necesidad de interfaces funcionales.
    - **Java:** Necesita utilizar una interfaz funcional, como `BiFunction`, para pasar funciones como parámetros.

### Desestructuración en Java

A diferencia de Kotlin, **Java no soporta desestructuración** de manera nativa. Esto significa que en Java no se puede descomponer un objeto en varias variables directamente. Para lograr un comportamiento similar, se deben acceder manualmente a las propiedades de un objeto mediante métodos de acceso (`getters`).

### Diferencias Clave entre Java y Kotlin

1. **Funciones Lambda:**
    - **Kotlin:** Soporte más flexible y nativo para funciones lambda sin necesidad de interfaces funcionales.
    - **Java:** Las lambdas están limitadas a **interfaces funcionales** (con un solo método abstracto).

2. **Desestructuración:**
    - **Kotlin:** Ofrece soporte nativo para la desestructuración de objetos.
    - **Java:** No soporta desestructuración nativa.

3. **Funciones de Orden Superior:**
    - **Kotlin:** Soporta funciones de orden superior de manera directa.
    - **Java:** Utiliza interfaces funcionales para simular funciones de orden superior.

## TypeScript

Al igual que Kotlin, TypeScript soporta **funciones lambda** (conocidas como **funciones flecha** o **arrow functions**) y **desestructuración**, permitiendo escribir código más conciso y expresivo.

### Funciones Lambda en TypeScript

En TypeScript, las funciones lambda se definen utilizando la sintaxis de flecha `=>`. Estas funciones pueden asignarse a variables, pasarse como argumentos y usarse de manera similar a como se hace en Kotlin.

**Ejemplo en TypeScript:**

```typescript
const sumar = (a: number, b: number): number => a + b;

const resultado = sumar(5, 10);  // 15
console.log(resultado);
```

**Comparación con Kotlin:**

- **Sintaxis:**
    - **Kotlin:** Utiliza `{ }` y `->` para definir lambdas.
    - **TypeScript:** Utiliza `=>` para definir funciones flecha.
- **Tipos de datos:**
    - Ambos lenguajes permiten definir los tipos de los parámetros y el tipo de retorno de la función.
- **Asignación y uso:**
    - En ambos casos, las funciones lambda pueden asignarse a variables y utilizarse posteriormente.

### Funciones de Orden Superior

TypeScript también soporta **funciones de orden superior**, permitiendo pasar funciones como argumentos y retornarlas.

**Ejemplo en TypeScript:**

```typescript
function procesarEnteros(a: number, b: number, operacion: (x: number, y: number) => number): number {
    return operacion(a, b);
}

const suma = procesarEnteros(3, 4, (x, y) => x + y);
console.log(suma);  // Output: 7
```

**Comparación con Kotlin:**

- La capacidad de pasar funciones como parámetros es similar en ambos lenguajes.
- La sintaxis para definir el tipo de la función es ligeramente diferente, pero conceptualmente equivalente.

### Desestructuración en TypeScript

TypeScript soporta la **desestructuración** de objetos y arreglos, lo que permite extraer valores y asignarlos a variables de manera concisa.

#### Desestructuración de Objetos

```typescript
interface Person {
    name: string;
    age: number;
}

const person: Person = { name: "Alice", age: 29 };
const { name, age } = person;

console.log(`Name: ${name}, Age: ${age}`);  // Output: Name: Alice, Age: 29
```

#### Desestructuración de Arreglos

```typescript
const numbers = [1, 2, 3];
const [first, second] = numbers;

console.log(first, second);  // Output: 1 2
```

#### Comparación con Kotlin

- **Sintaxis:**
    - **Kotlin:** Utiliza `val (name, age) = person` para desestructurar.
    - **TypeScript:** Utiliza `{ }` para desestructurar objetos y `[ ]` para desestructurar arreglos.
- **Capacidades:**
    - Ambos lenguajes permiten desestructurar objetos y colecciones.
    - TypeScript permite desestructuración anidada, lo que es una ventaja sobre Kotlin.

### Desestructuración en Parámetros de Funciones

TypeScript permite desestructurar parámetros directamente en la definición de la función, incluyendo en funciones flecha.

#### Ejemplo en TypeScript

```typescript
const sumPair = ({ a, b }: { a: number; b: number }): number => a + b;

console.log(sumPair({ a: 3, b: 4 }));  // Output: 7
```

#### Comparación con Kotlin

- **Kotlin:** Permite desestructuración en lambdas si los operadores `componentN` están definidos.
- **TypeScript:** Permite desestructuración de objetos directamente en los parámetros.

### Diferencias Clave

- **Desestructuración Anidada:**
    - **TypeScript:** Soporta desestructuración anidada de objetos y arreglos.
        ```typescript
        const person = { name: "Alice", address: { city: "Wonderland" } };
        const { address: { city } } = person;
        console.log(city);  // Output: Wonderland
        ```
    - **Kotlin:** No soporta desestructuración anidada directamente; se requiere desestructurar manualmente cada nivel.
- **Sintaxis de Lambdas:**
    - **Kotlin:** Utiliza `{ }` y `->`, y permite inferencia de tipos en muchos casos.
    - **TypeScript:** Utiliza `=>` y requiere tipos explícitos o inferencia basada en el contexto.
- **Funciones de Orden Superior:**
    - Ambos lenguajes soportan funciones de orden superior, pero Kotlin tiene una integración más profunda con características funcionales, como la posibilidad de utilizar **trailing lambdas** y una sintaxis más concisa.
