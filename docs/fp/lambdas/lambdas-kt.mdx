---
title: Funciones lambda
---

import References from "../../../src/components/ReferencesComponent";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../../src/components/ReadingTime';

<ReadingTime />

Las **funciones lambda**, tambi√©n conocidas como funciones an√≥nimas, son una forma concisa y flexible de representar funciones **sin un nombre expl√≠cito**. Son especialmente √∫tiles cuando necesitamos una funci√≥n que se puede pasar como argumento, o cuando queremos escribir una funci√≥n de manera breve sin necesidad de definirla previamente. En su forma m√°s simple, una funci√≥n lambda es un **bloque de c√≥digo sin nombre** que puede ser asignado a una variable o pasado como par√°metro a otras funciones, permitiendo una gran flexibilidad en la escritura de c√≥digo.

:::info Funciones an√≥nimas en _Kotlin_
En **_Kotlin_**, las **funciones an√≥nimas** y las **lambdas** son similares, pero no exactamente iguales. La diferencia radica principalmente en la **sintaxis** y en c√≥mo se manejan ciertas caracter√≠sticas como los retornos. Sin embargo, ambas pueden usarse de manera intercambiable en la mayor√≠a de los casos.
Las funciones an√≥nimas tienen una sintaxis m√°s "tradicional", similar a una funci√≥n regular, y permite declarar el tipo de retorno. Ejemplo:

```kotlin
val sumar = fun(a: Int, b: Int): Int {
    return a + b
}
```

En la pr√°ctica usar una u otra ser√° un tema de preferencia, pero es m√°s com√∫n ver **lambdas** en el c√≥digo de _Kotlin_.
:::

### Definici√≥n

Una **funci√≥n lambda** es una funci√≥n sin nombre que puede tomar argumentos y devolver un valor. Es una instancia de un tipo de funci√≥n que puede ser tratada como un valor. A menudo se usan para expresar bloques de c√≥digo que se ejecutar√°n m√°s adelante, como en el caso de funciones de orden superior que toman funciones como par√°metros, la evaluaci√≥n perezosa o computaciones diferidas.

La sintaxis general de una funci√≥n lambda en Kotlin es:

```kotlin
val lambdaName: (T, S, ...) -> R = { t, s, ... -> body }
```

Donde:
- **``lambdaName``**: Nombre de la variable que almacena la funci√≥n lambda.
- **``T, S, ...``**: Tipos de los argumentos de la funci√≥n lambda (``...`` indica que puede haber m√°s de un argumento, pero se presenta como pseudoc√≥digo y no es sint√°xis v√°lida).
- **``R``**: Tipo de retorno de la funci√≥n lambda.
- **``t, s, ...``**: Nombres de los argumentos de la funci√≥n lambda (nuevamente ``...`` indica que puede haber m√°s de un argumento, pero es pseudoc√≥digo).
- **``body``**: Cuerpo de la funci√≥n lambda.

Por ejemplo, si quisi√©ramos definir una funci√≥n lambda que suma dos n√∫meros:

```kotlin
val sumar: (Int, Int) -> Int = { a, b -> a + b }
```

Podemos llamar a esta lambda de la siguiente manera:

```kotlin
val resultado = sumar(5, 10)  // 15
```

<details>
    <summary>Breve historia y teor√≠a</summary>

    El concepto de **funciones lambda** proviene del **C√°lculo Lambda**, una formalizaci√≥n matem√°tica desarrollada por Alonzo Church en la d√©cada de 1930. Esta notaci√≥n sent√≥ las bases para la **programaci√≥n funcional**, que influy√≥ en el dise√±o de muchos lenguajes modernos como Kotlin, Scala, JavaScript y Python.

    El **C√°lculo Lambda** introdujo una manera de definir y aplicar funciones de manera concisa, lo que permiti√≥ que los lenguajes de programaci√≥n funcional adoptaran funciones como ciudadanos de primera clase. Esto significa que las funciones pueden ser asignadas a variables, pasadas como argumentos o retornadas desde otras funciones.

    ### Elementos clave del C√°lculo Lambda
    1. **Variable ($x$)**: Un s√≠mbolo que representa un par√°metro o valor.
    2. **Abstracci√≥n ($\lambda x.M$)**: Una funci√≥n an√≥nima que toma un par√°metro $x$ y eval√∫a una expresi√≥n $M$.
    3. **Aplicaci√≥n ($M\ N$)**: La aplicaci√≥n de una funci√≥n $M$ a un argumento $N$. Tanto $M$ como $N$ pueden ser variables, abstracciones u otras aplicaciones.

    ### Operaciones de reducci√≥n
    - **$\alpha$-conversi√≥n**: $(\lambda x.M[x] \to \lambda y.M[y])$ ‚Äî Cambiar el nombre de un par√°metro.
    - **$\beta$-reducci√≥n**: $(\lambda x.M)N \to M[x := N]$ ‚Äî Sustituir el par√°metro de la funci√≥n por el argumento en su cuerpo.

    Kotlin adopt√≥ las funciones lambda para ofrecer una **sintaxis concisa y flexible** que facilita el uso de funciones de orden superior y la programaci√≥n funcional, eliminando la necesidad de definir expl√≠citamente funciones con nombre.

    :::note üå≠ Turing Completo üå≠
    El C√°lculo Lambda es **Turing completo**, lo que significa que puede expresar cualquier algoritmo computacional. Este hecho lo convierte en un modelo de computaci√≥n poderoso y vers√°til.
    :::
</details>


### Lambdas en _Kotlin_ con funciones de orden superior

Las **funciones lambda** son especialmente √∫tiles cuando se combinan con **funciones de orden superior**.

A continuaci√≥n, veremos un ejemplo usando `filter`, una funci√≥n de orden superior que toma una lambda como argumento:

```kotlin
val numeros = listOf(1, 2, 3, 4, 5)
// Aplicamos filter para obtener solo los n√∫meros pares
val numerosPares = filter(numeros) { it % 2 == 0 }
println(numerosPares)  // Output: [2, 4]
```

En este caso, la funci√≥n `filter` recibe una lambda que eval√∫a si un n√∫mero es par.

:::info Trailing lambda
En **Kotlin**, si el √∫ltimo par√°metro de una funci√≥n es una lambda, es buena pr√°ctica mover la lambda fuera de los par√©ntesis. Esto se conoce como **trailing lambda** y mejora la legibilidad del c√≥digo. Las siguientes dos llamadas son equivalentes:

```kotlin
val numerosPares = filter(numeros, { it % 2 == 0 })
val numerosPares = filter(numeros) { it % 2 == 0 }
```
:::

### Aplicando lambdas en funciones de orden superior

Puedes crear tus propias funciones de orden superior que acepten lambdas como par√°metros. Aqu√≠ hay un ejemplo simple:

```kotlin
fun procesarEnteros(a: Int, b: Int, operacion: (Int, Int) -> Int) =
    operacion(a, b)

val suma = procesarEnteros(3, 4) { x, y -> x + y }
println(suma)  // Output: 7
```

En este ejemplo:
- La funci√≥n `procesarEnteros` acepta dos enteros y una lambda que define c√≥mo operarlos.
- Al llamar a `procesarEnteros`, proporcionamos una lambda que suma los dos n√∫meros.


## Destructuring declarations

Las **declaraciones de desestructuraci√≥n** permiten descomponer objetos complejos en componentes individuales, asign√°ndolos a variables separadas en una sola declaraci√≥n. Esto simplifica la extracci√≥n de valores de estructuras como **pares**, **listas**, **diccionarios** o **tipos de datos personalizados**, facilitando su manipulaci√≥n.

### Ventajas
- **Sintaxis concisa**: Permite extraer varios valores de un objeto en una √∫nica l√≠nea de c√≥digo.
- **Vers√°til**: Se puede utilizar en diferentes contextos, como asignaciones de variables, bucles de iteraci√≥n y par√°metros de funciones.
- **Legibilidad**: Mejora la claridad del c√≥digo al eliminar la necesidad de m√∫ltiples llamadas a getters.

### Ejemplo

```kotlin
data class Person(val name: String, val age: Int)

val person = Person("Alice", 29)
val (name, age) = person
println("Name: $name, Age: $age")  // Output: Name: Alice, Age: 29
```

En este ejemplo, descomponemos el objeto `person` en sus componentes `name` y `age` utilizando la sintaxis de desestructuraci√≥n: `val (component1, component2, ...)`. Esta t√©cnica se puede aplicar en diversos escenarios, mejorando la simplicidad y eficiencia en la manipulaci√≥n de datos.

```kotlin
val (first, second) = listOf(1, 2)  // Tambi√©n funciona con listas
```

### Under the Hood

En Kotlin, todas las **data classes** autom√°ticamente declaran operadores `componentN` para cada una de las variables de la clase, lo que permite la desestructuraci√≥n de sus propiedades de manera sencilla. Sin embargo, tambi√©n es posible personalizar este comportamiento en clases no marcadas como `data`, definiendo manualmente los m√©todos `componentN`.

Por ejemplo, podemos desestructurar una clase personalizada como `Point` definiendo los operadores correspondientes:

```kotlin
class Point(val x: Int, val y: Int) {
    operator fun component1() = x
    operator fun component2() = y
}

val (x, y) = Point(10, 20)
println("x: $x, y: $y")  // Output: x: 10, y: 20
```

Este enfoque te permite controlar expl√≠citamente c√≥mo se descomponen las propiedades de la clase, incluso en aquellas que no son `data classes`.

:::tip Ejercicio
<Tabs>
    <TabItem value={"Enunciado"} label={"Enunciado"}>
        ¬øCu√°les son los tipos de ``head`` y ``tail``?

        1. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss")``
        2. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss", "FLCL")``
    </TabItem>
    <TabItem value={"Soluci√≥n"} label={"Soluci√≥n"}>
        1. En el primer caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``String``.
        2. En el segundo caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``List<String>``.
    </TabItem>
</Tabs>
:::

### Desestructuraci√≥n en Lambdas

En Kotlin, una lambda puede desestructurar cualquier estructura que tenga definidos sus operadores `componentN`. Esto permite acceder f√°cilmente a los valores de un objeto directamente dentro de la lambda, mejorando la legibilidad y la simplicidad del c√≥digo.

```kotlin
val sumPair = { (a, b): Pair<Int, Int> -> a + b }
val increasePairBy = { (a, b): Pair<Int, Int>, n: Int -> Pair(a + n, b + n) }

println(sumPair(3 to 4))  // Output: 7
println(increasePairBy(3 to 4, 2))  // Output: (5, 6)
```

En estos ejemplos:
- `sumPair` desestructura el par `(a, b)` y devuelve la suma de sus componentes.
- `increasePairBy` desestructura el par `(a, b)` y devuelve un nuevo par donde ambos valores han sido incrementados por `n`.

Este uso de desestructuraci√≥n en lambdas es particularmente √∫til cuando trabajamos con estructuras de datos m√°s complejas y deseamos acceder a sus valores de manera directa y concisa.

:::warning Estructuras anidadas
La desestructuraci√≥n en _Kotlin_ no es compatible con estructuras anidadas, como pares de pares o listas de pares. Para descomponer estructuras anidadas, es necesario realizar la desestructuraci√≥n de forma manual.
:::

:::tip Ejercicio
<Tabs>
    <TabItem value={"Enunciado"} label={"Enunciado"}>
        Indica el n√∫mero de par√°metros que recibe cada una de las siguientes lambdas:

        1. ``val f1 = { a: Int, b: Int -> /* ... */ }``
        2. ``val f2 = { (a, b): Pair<Int, Int> -> /* ... */ }``
        3. ``val f3 = { a: Int, (b, c): Pair<Int, Int> -> /* ... */ }``
        4. ``val f4 = { (a, b): Pair<Int, Int>, (c, d): Pair<Int, Int> -> /* ... */ }``
    </TabItem>
    <TabItem value={"Soluci√≥n"} label={"Soluci√≥n"}>
        1. ``f1`` recibe dos par√°metros: ``a`` y ``b``.
        2. ``f2`` recibe un par√°metro de tipo ``Pair<Int, Int>``.
        3. ``f3`` recibe dos par√°metros: un entero ``a`` y un par de enteros ``b`` y ``c``.
        4. ``f4`` recibe dos pares de enteros.
    </TabItem>
</Tabs>
:::

## En conclusi√≥n

Las **funciones lambda** en Kotlin ofrecen una forma concisa y poderosa de trabajar con funciones como valores, lo que facilita el uso de la **programaci√≥n funcional** y mejora la expresividad del c√≥digo. Junto con caracter√≠sticas como las **declaraciones de desestructuraci√≥n** y su integraci√≥n en **funciones de orden superior**, las lambdas permiten un c√≥digo m√°s limpio y flexible. Adem√°s, su origen en el **C√°lculo Lambda** refuerza su importancia como una herramienta vers√°til y fundamental en el desarrollo moderno. La capacidad de pasar, almacenar y devolver funciones, junto con la concisi√≥n y claridad de las lambdas, hace que sean un recurso invaluable en Kotlin, promoviendo un estilo de programaci√≥n m√°s declarativo y expresivo.

<References references={[
    {
        title: "5. Programming with Lambdas",
        type: "book",
        bookTitle: "Kotlin in Action",
        pages: "103‚Äì132",
        author: "Dmitry Jemerov, Svetlana Isakova",
        publisher: "Manning Publications Co",
        year: "2017",
    },
    {
        title: "Lambda Calculus",
        type: "web",
        accessedDate: "September 23, 2024",
        url: "https://en.wikipedia.org/w/index.php?title=Lambda_calculus&oldid=1245353579",
        siteOrAuthor: "Wikipedia",
    },
    {
        title: "Higher-Order Functions and Lambdas | Kotlin",
        type: "web",
        accessedDate: "September 23, 2024",
        url: "https://kotlinlang.org/docs/lambdas.html",
        siteOrAuthor: "Kotlin Help",
    }
]} />
