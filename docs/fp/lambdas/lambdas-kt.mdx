---
title: Funciones lambda
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="functional-programming-kt" />

<details>
    <summary>
        Comencemos por crear un m√≥dulo para la lecci√≥n...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "lambdas" -ItemType "Directory"
            "// Intentionally left blank" > "lambdas\build.gradle.kts"
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            mkdir "lambdas"
            "// Intentionally left blank" > "lambdas\build.gradle.kts"
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            mkdir "lambdas"
            echo "// Intentionally left blank" > "lambdas/build.gradle.kts" 
            ```
        </TabItem>
    </BoxedTabs>

    Recuerda agregar el nuevo m√≥dulo al archivo `settings.gradle.kts`.
</details>

Las **funciones lambda**, tambi√©n conocidas como funciones an√≥nimas, son una forma concisa y flexible de representar funciones **sin un nombre expl√≠cito**. Son especialmente √∫tiles cuando necesitamos una funci√≥n que se puede pasar como argumento, o cuando queremos escribir una funci√≥n de manera breve sin necesidad de definirla previamente. En su forma m√°s simple, una funci√≥n lambda es un **bloque de c√≥digo sin nombre** que puede ser asignado a una variable o pasado como par√°metro a otras funciones, permitiendo una gran flexibilidad en la escritura de c√≥digo.

<details>
    <summary>
        Funciones an√≥nimas en Kotlin
    </summary>

    En Kotlin, las funciones an√≥nimas y las lambdas son similares, pero no exactamente iguales. La diferencia radica principalmente en la sintaxis y en c√≥mo se manejan ciertas caracter√≠sticas como los retornos. Sin embargo, ambas pueden usarse de manera intercambiable en la mayor√≠a de los casos.

    Las funciones an√≥nimas tienen una sintaxis m√°s "tradicional", similar a una funci√≥n regular, y permite declarar el tipo de retorno. Ejemplo:

    ```kotlin showLineNumbers
    val sumar = fun(a: Int, b: Int): Int {
        return a + b
    }
    ```

    En la pr√°ctica usar una u otra ser√° un tema de preferencia, pero es m√°s com√∫n ver lambdas en el c√≥digo de Kotlin.
</details>

### Definici√≥n

Una **funci√≥n lambda** es una funci√≥n sin nombre que puede tomar argumentos y devolver un valor. Es una instancia de un tipo de funci√≥n que puede ser tratada como un valor. A menudo se usan para expresar bloques de c√≥digo que se ejecutar√°n m√°s adelante, como en el caso de funciones de orden superior que toman funciones como par√°metros o la [evaluaci√≥n perezosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

La sintaxis general de una funci√≥n lambda en Kotlin es:

```kotlin showLineNumbers
val lambdaName: (T, S, ...) -> R = { t, s, ... -> body }
```

Donde:
- **``lambdaName``**: Nombre de la variable que almacena la funci√≥n lambda.
- **``T, S, ...``**: Tipos de los argumentos de la funci√≥n lambda (``...`` indica que puede haber m√°s de un argumento, pero se presenta como pseudoc√≥digo y no es sint√°xis v√°lida).
- **``R``**: Tipo de retorno de la funci√≥n lambda.
- **``t, s, ...``**: Nombres de los argumentos de la funci√≥n lambda (nuevamente ``...`` indica que puede haber m√°s de un argumento, pero es pseudoc√≥digo).
- **``body``**: Cuerpo de la funci√≥n lambda.

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            $Group = "com\github\username"
            ```

            ```powershell
            $LambdaTestDir = "lambdas\src\test\kotlin\$Group\lambdas"
            New-Item -Path "$LambdaTestDir\SumTest.kt" -ItemType "file" -Force
            $LambdaMainDir = "lambdas\src\main\kotlin\$Group\lambdas"
            New-Item -Path "$LambdaMainDir\Sum.kt" -ItemType "file" -Force
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell	
            $Group = "com\github\username"
            ```

            ```powershell
            $LambdaTestDir = "lambdas\src\test\kotlin\$Group\lambdas"
            ni "$LambdaTestDir\SumTest.kt" -i f -f
            $LambdaMainDir = "lambdas\src\main\kotlin\$Group\lambdas"
            ni "$LambdaMainDir\Sum.kt" -i f -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash	
            GROUP="com/github/username"
            ```

            ```bash
            LAMBDA_TEST_DIR="lambdas/src/test/kotlin/$GROUP/lambdas"
            mkdir -p "$LAMBDA_TEST_DIR"
            touch "$LAMBDA_TEST_DIR/SumTest.kt"
            LAMBDA_MAIN_DIR="lambdas/src/main/kotlin/$GROUP/lambdas"
            mkdir -p "$LAMBDA_MAIN_DIR"
            touch "$LAMBDA_MAIN_DIR/Sum.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

Por ejemplo, si quisi√©ramos definir una funci√≥n lambda que suma dos n√∫meros:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/lambdas/Sum.kt"
        val add: (Int, Int) -> Int = { a, b -> a + b }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/lambdas/SumTest.kt"
        add(3, 4) shouldBe 7
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/lambdas/Sum.kt"
        package com.github.username.lambdas

        val add: (Int, Int) -> Int = { a, b -> a + b }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/lambdas/SumTest.kt"
        package com.github.username.lambdas

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class SumTest : FreeSpec({
            "An add function" - {
                "can sum two numbers" {
                    add(3, 4) shouldBe 7
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<details>
    <summary>Breve historia y teor√≠a</summary>

    El concepto de **funciones lambda** proviene del **C√°lculo Lambda**, una formalizaci√≥n matem√°tica desarrollada por Alonzo Church en la d√©cada de 1930. Esta notaci√≥n sent√≥ las bases para la **programaci√≥n funcional**, que influy√≥ en el dise√±o de muchos lenguajes modernos como Kotlin, Scala, JavaScript y Python.

    El **C√°lculo Lambda** introdujo una manera de definir y aplicar funciones de manera concisa, lo que permiti√≥ que los lenguajes de programaci√≥n funcional adoptaran funciones como ciudadanos de primera clase. Esto significa que las funciones pueden ser asignadas a variables, pasadas como argumentos o retornadas desde otras funciones.

    ### Elementos clave del C√°lculo Lambda
    1. **Variable ($x$)**: Un s√≠mbolo que representa un par√°metro o valor.
    2. **Abstracci√≥n ($\lambda x.M$)**: Una funci√≥n an√≥nima que toma un par√°metro $x$ y eval√∫a una expresi√≥n $M$.
    3. **Aplicaci√≥n ($M\ N$)**: La aplicaci√≥n de una funci√≥n $M$ a un argumento $N$. Tanto $M$ como $N$ pueden ser variables, abstracciones u otras aplicaciones.

    ### Operaciones de reducci√≥n
    - **$\alpha$-conversi√≥n**: $(\lambda x.M[x] \to \lambda y.M[y])$ ‚Äî Cambiar el nombre de un par√°metro.
    - **$\beta$-reducci√≥n**: $(\lambda x.M)N \to M[x := N]$ ‚Äî Sustituir el par√°metro de la funci√≥n por el argumento en su cuerpo.

    Kotlin adopt√≥ las funciones lambda para ofrecer una **sintaxis concisa y flexible** que facilita el uso de funciones de orden superior y la programaci√≥n funcional, eliminando la necesidad de definir expl√≠citamente funciones con nombre.

    :::note üå≠ Turing Completo üå≠
    El C√°lculo Lambda es **Turing completo**, lo que significa que puede expresar cualquier algoritmo computacional. Este hecho lo convierte en un modelo de computaci√≥n poderoso y vers√°til.
    :::
</details>


### Lambdas en _Kotlin_ con funciones de orden superior

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "$LambdaTestDir\ParityTest.kt" -ItemType "file"
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            ni "$LambdaTestDir\ParityTest.kt" -i f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            touch "$LAMBDA_TEST_DIR/ParityTest.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

Las **funciones lambda** son especialmente √∫tiles cuando se combinan con **funciones de orden superior**.

A continuaci√≥n, veremos un ejemplo usando `filter`, una funci√≥n de orden superior que toma una lambda como argumento:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
        numbers.filter { it % 2 == 0 } shouldBe listOf(2, 4, 6, 8, 10)
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        package cl.ravenhill.lambdas

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class ParityTest : FreeSpec({
            "A list can be filtered by parity" {
                val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                numbers.filter { it % 2 == 0 } shouldBe listOf(2, 4, 6, 8, 10)
            }
        })
        ```
    </TabItem>
</BoxedTabs>

En este caso, la funci√≥n `filter` recibe una lambda que eval√∫a si un n√∫mero es par.

:::info Trailing lambda
En **Kotlin**, si el √∫ltimo par√°metro de una funci√≥n es una lambda, es buena pr√°ctica mover la lambda fuera de los par√©ntesis. Esto se conoce como **trailing lambda** y mejora la legibilidad del c√≥digo. Las siguientes dos llamadas son equivalentes:

```kotlin showLineNumbers
val numerosPares = filter(numeros, { it % 2 == 0 })
val numerosPares = filter(numeros) { it % 2 == 0 }
```
:::

### Aplicando lambdas en funciones de orden superior

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "$LambdaTestDir\IntProcessingTest.kt" -ItemType "file"
            New-Item -Path "$LambdaMainDir\IntProcessing.kt" -ItemType "file"
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            ni "$LambdaTestDir\IntProcessingTest.kt" -i f
            ni "$LambdaMainDir\IntProcessing.kt" -i f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            touch "$LAMBDA_TEST_DIR/IntProcessingTest.kt"
            touch "$LAMBDA_MAIN_DIR/IntProcessing.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

Puedes crear tus propias funciones de orden superior que acepten lambdas como par√°metros. Aqu√≠ hay un ejemplo simple:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/lambdas/IntProcessing.kt"
        fun processInts(a: Int, b: Int, operation: (Int, Int) -> Int) =
            operation(a, b)
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/lambdas/IntProcessingTest.kt"
        processInts(3, 4) { a, b -> a + b } shouldBe 7
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        package com.github.username.lambdas

        fun processInts(a: Int, b: Int, operation: (Int, Int) -> Int) =
            operation(a, b)
        ```

        ```kotlin showLineNumbers
        package cl.ravenhill.lambdas

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class IntProcessingTest : FreeSpec({
            "Two integers can be combined with an add operation" {
                processInts(3, 4) { a, b -> a + b } shouldBe 7
            }
        })
        ```
    </TabItem>
</BoxedTabs>

:::info ¬øQu√© acabamos de hacer?

- Definimos una funci√≥n `processInts` que toma dos enteros y una funci√≥n lambda como argumentos.
- La funci√≥n `processInts` aplica la funci√≥n lambda a los dos enteros y devuelve el resultado.
- En el test, pasamos una lambda que suma los dos enteros `3` y `4` a la funci√≥n `processInts` y comprobamos que el resultado es `7`.

:::

### Ventajas y desventajas de las funciones lambda

<ProCons>
    <Pros>
        - **Concisi√≥n y legibilidad**: Las funciones lambda permiten escribir c√≥digo de manera m√°s breve y clara, eliminando la necesidad de declarar y definir funciones completas cuando solo se requiere una l√≥gica simple.
        - **Flexibilidad**: Las lambdas se pueden pasar como argumentos a otras funciones, lo que las hace extremadamente √∫tiles para funciones de orden superior, como `map`, `filter` y `fold`.
        - **Funcionalidad modular**: Facilitan la creaci√≥n de c√≥digo modular y reutilizable al encapsular peque√±os fragmentos de l√≥gica que pueden ser f√°cilmente combinados y reutilizados.
        - **Compatibilidad con la programaci√≥n funcional**: Kotlin adopta elementos de la programaci√≥n funcional, y las lambdas son un componente central de este paradigma, permitiendo un estilo de programaci√≥n expresivo y efectivo.
    </Pros>
    <Cons>
        - **Dificultad de depuraci√≥n**: El uso intensivo de lambdas puede hacer que el c√≥digo sea m√°s dif√≠cil de depurar, ya que las funciones an√≥nimas no tienen nombre y los errores pueden no se√±alar directamente la fuente del problema.
        - **Complejidad en casos avanzados**: Las lambdas son f√°ciles de usar en casos simples, pero pueden volverse complicadas cuando se manejan tipos complejos o m√∫ltiples par√°metros, lo que puede afectar la claridad del c√≥digo.
        - **Sobrecarga de uso**: Aunque son concisas, el uso excesivo de lambdas puede resultar en un c√≥digo menos legible, especialmente si se anidan lambdas o se utilizan sin contexto suficiente.
        - **Rendimiento**: En algunos casos, las lambdas pueden introducir un peque√±o overhead debido a la creaci√≥n de objetos adicionales en tiempo de ejecuci√≥n, lo que podr√≠a impactar en el rendimiento si no se utilizan con cuidado.
    </Cons>
</ProCons>

## Destructuring declarations

Las **declaraciones de desestructuraci√≥n** permiten descomponer objetos complejos en componentes individuales, asign√°ndolos a variables separadas en una sola declaraci√≥n. Esto simplifica la extracci√≥n de valores de estructuras como **pares**, **listas**, **diccionarios** o **tipos de datos personalizados**, facilitando su manipulaci√≥n.

### Ejemplo

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "$LambdaTestDir\destructuring\PersonTest.kt" `
                -ItemType "file" -Force
            New-Item -Path "$LambdaMainDir\Person.kt" `
                -ItemType "file" -Force
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            ni "$LambdaTestDir\destructuring\PersonTest.kt" -i f -f
            ni "$LambdaMainDir\Person.kt" -i f -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            mkdir -p "$LAMBDA_TEST_DIR/destructuring"
            touch "$LAMBDA_TEST_DIR/destructuring/PersonTest.kt"
            touch "$LAMBDA_MAIN_DIR/Person.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/Person.kt"
        data class Person(val name: String, val age: Int)
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PersonTest.kt"
        val person = Person("Alice", 29)
        val (name, age) = person
        name shouldBe "Alice"
        age shouldBe 29
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/Person.kt"
        package com.github.username.destructuring

        data class Person(val name: String, val age: Int)
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PersonTest.kt"
        package cl.ravenhill.destructuring

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class PersonTest : FreeSpec({
            "A person object" - {
                "can be destructured into name and age" {
                    val person = Person("Alice", 29)
                    val (name, age) = person
                    name shouldBe "Alice"
                    age shouldBe 29
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

:::info ¬øQu√© acabamos de hacer?

En este ejemplo, descomponemos el objeto `person` en sus componentes `name` y `age` utilizando la sintaxis de desestructuraci√≥n: `val (component1, component2, ...)`. Esta t√©cnica se puede aplicar en diversos escenarios, mejorando la simplicidad y eficiencia en la manipulaci√≥n de datos.

:::

```kotlin showLineNumbers
val (first, second) = listOf(1, 2)  // Tambi√©n funciona con listas
first shouldBe 1
second shouldBe 2
```

### Under the Hood

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "$LambdaMainDir\destructuring\Point.kt" `
                -ItemType "file" -Force
            New-Item -Path "$LambdaTestDir\destructuring\PointTest.kt" `
                -ItemType "file" -Force
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            ni "$LambdaMainDir\destructuring\Point.kt" -i f -f
            ni "$LambdaTestDir\destructuring\PointTest.kt" -i f -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            touch "$LAMBDA_MAIN_DIR/destructuring/Point.kt"
            touch "$LAMBDA_TEST_DIR/destructuring/PointTest.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

En Kotlin, todas las **data classes** autom√°ticamente declaran operadores `componentN` para cada una de las variables de la clase, lo que permite la desestructuraci√≥n de sus propiedades de manera sencilla. Sin embargo, tambi√©n es posible personalizar este comportamiento en clases no marcadas como `data`, definiendo manualmente los m√©todos `componentN`.

Por ejemplo, podemos desestructurar una clase personalizada como `Point` definiendo los operadores correspondientes:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/Point.kt"
        class Point(val x: Int, val y: Int) {
            operator fun component1() = x
            operator fun component2() = y
        }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PointTest.kt"
        val (x, y) = Point(10, 20)
        x shouldBe 10
        y shouldBe 20
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/Point.kt"
        package com.github.username.destructuring

        class Point(val x: Int, val y: Int) {
            operator fun component1() = x
            operator fun component2() = y
        }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PointTest.kt"
        package cl.ravenhill.destructuring

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class PointTest : FreeSpec({
            "A Point object" - {
                "can be destructured into x and y" {
                    val (x, y) = Point(10, 20)
                    x shouldBe 10
                    y shouldBe 20
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

Este enfoque te permite controlar expl√≠citamente c√≥mo se descomponen las propiedades de la clase, incluso en aquellas que no son `data classes`.

<Exercise title={"Desestructuraci√≥n de listas"}>
    ¬øCu√°les son los tipos de ``head`` y ``tail``?

    1. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss")``
    2. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss", "FLCL")``

    <Solution>
        1. En el primer caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``String``.
        2. En el segundo caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``List<String>``.
    </Solution>
</Exercise>

### Desestructuraci√≥n en Lambdas

<details>
    <summary>
        Si quieres crear el archivo desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "$LambdaMainDir\destructuring\PairProcessing.kt" `
                -ItemType "file" -Force
            New-Item -Path "$LambdaTestDir\destructuring\PairProcessingTest.kt" `
                -ItemType "file" -Force
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            ni "$LambdaMainDir\destructuring\PairProcessing.kt" -i f -f
            ni "$LambdaTestDir\destructuring\PairProcessingTest.kt" -i f -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            touch "$LAMBDA_MAIN_DIR/destructuring/PairProcessing.kt"
            touch "$LAMBDA_TEST_DIR/destructuring/PairProcessingTest.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

En Kotlin, una lambda puede desestructurar cualquier estructura que tenga definidos sus operadores `componentN`. Esto permite acceder f√°cilmente a los valores de un objeto directamente dentro de la lambda, mejorando la legibilidad y la simplicidad del c√≥digo.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/PairProcessing.kt"
        val sumPair = { (a, b): Pair<Int, Int> -> a + b }
        val increasePairBy = { (a, b): Pair<Int, Int>, n: Int -> 
            (a + n) to (b + n)
        }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PairProcessingTest.kt"
        sumPair(3 to 4) shouldBe 7
        increasePairBy(3 to 4, 2) shouldBe (5 to 6)
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="lambdas/src/main/kotlin/com/github/username/destructuring/PairProcessing.kt"
        package com.github.username.destructuring

        val sumPair = { (a, b): Pair<Int, Int> -> a + b }

        val increasePairBy = { (a, b): Pair<Int, Int>, n: Int ->
            (a + n) to (b + n)
        }
        ```

        ```kotlin showLineNumbers title="lambdas/src/test/kotlin/com/github/username/destructuring/PairProcessingTest.kt"
        package cl.ravenhill.lambdas.destructuring

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        class PairProcessingTest : FreeSpec({
            "A pair can be destructured by a lambda" {
                sumPair(3 to 4) shouldBe 7
                increasePairBy(3 to 4, 2) shouldBe (5 to 6)
            }
        })
        ```
    </TabItem>
</BoxedTabs>

:::info ¬øQu√© acabamos de hacer?

- `sumPair` desestructura el par `(a, b)` y devuelve la suma de sus componentes.
- `increasePairBy` desestructura el par `(a, b)` y devuelve un nuevo par donde ambos valores han sido incrementados por `n`.

:::

Este uso de desestructuraci√≥n en lambdas es particularmente √∫til cuando trabajamos con estructuras de datos m√°s complejas y deseamos acceder a sus valores de manera directa y concisa.

:::warning Estructuras anidadas

La desestructuraci√≥n en _Kotlin_ no es compatible con estructuras anidadas, como pares de pares o listas de pares. Para descomponer estructuras anidadas, es necesario realizar la desestructuraci√≥n de forma manual.

:::

<Exercise title={"Desestructuraci√≥n en lambdas"}>
    Indica el n√∫mero de par√°metros que recibe cada una de las siguientes lambdas:

    1. ``val f1 = { a: Int, b: Int -> TODO() }``
    2. ``val f2 = { (a, b): Pair<Int, Int> -> TODO() }``
    3. ``val f3 = { a: Int, (b, c): Pair<Int, Int> -> TODO() }``
    4. ``val f4 = { (a, b): Pair<Int, Int>, (c, d): Pair<Int, Int> -> TODO() }``

    <Solution>
        1. ``f1`` recibe dos par√°metros: ``a`` y ``b``.
        2. ``f2`` recibe un par√°metro de tipo ``Pair<Int, Int>``.
        3. ``f3`` recibe dos par√°metros: un entero ``a`` y un par de enteros ``b`` y ``c``.
        4. ``f4`` recibe dos pares de enteros.
    </Solution>
</Exercise>

### Ventajas y desventajas de la desestructuraci√≥n

<ProCons>
    <Pros>
        - **Simplicidad y legibilidad**: Permite descomponer estructuras de datos complejas en elementos individuales de manera clara y concisa, mejorando la legibilidad del c√≥digo.
        - **Acceso directo a datos**: Facilita el acceso directo a los componentes de un objeto sin necesidad de m√©todos adicionales, lo que hace que la manipulaci√≥n de datos sea m√°s eficiente.
        - **Flexibilidad**: La desestructuraci√≥n se puede aplicar a m√∫ltiples tipos de estructuras, como listas, pares, y clases de datos, haciendo que sea una herramienta vers√°til para manejar datos en diversas situaciones.
        - **Compatibilidad con lambdas**: Se puede usar en funciones lambda, lo que permite escribir expresiones de manera m√°s natural y reducir la necesidad de usar referencias expl√≠citas a las propiedades de un objeto.
    </Pros>
    <Cons>
        - **Dificultad de depuraci√≥n**: En casos complejos o cuando se usa en exceso, puede hacer que el seguimiento de errores sea m√°s dif√≠cil, ya que los valores se descomponen directamente y no siempre queda claro de d√≥nde provienen.
        - **Limitaciones en estructuras anidadas**: La desestructuraci√≥n no soporta estructuras de datos anidadas de forma autom√°tica, lo que obliga a realizar la descomposici√≥n de manera manual o con m√∫ltiples pasos adicionales.
        - **Potencial de ambig√ºedad**: Cuando se utiliza con estructuras similares, puede ser confuso determinar qu√© elementos est√°n siendo desestructurados, especialmente si se utiliza en contextos con nombres de variables poco descriptivos.
        - **Sobrecarga en el rendimiento**: En algunos casos, la desestructuraci√≥n puede introducir una peque√±a sobrecarga en tiempo de ejecuci√≥n, especialmente si se utiliza con frecuencia en bucles o en operaciones cr√≠ticas de rendimiento.
    </Cons>
</ProCons>

### ¬øQu√© aprendimos?

En esta lecci√≥n, exploramos en profundidad el concepto de **funciones lambda** en Kotlin, su definici√≥n y uso, as√≠ como su relevancia en la programaci√≥n funcional y en las funciones de orden superior. Repasamos la sintaxis y las ventajas que ofrecen, como la **concisi√≥n**, **flexibilidad**, y **compatibilidad** con paradigmas funcionales. Tambi√©n analizamos las **declaraciones de desestructuraci√≥n**, destacando su utilidad para simplificar el acceso a los datos y c√≥mo se integran de manera eficiente en lambdas para mejorar la legibilidad y modularidad del c√≥digo.

Adem√°s, abordamos las **ventajas** y **desventajas** tanto de las funciones lambda como de la desestructuraci√≥n, discutiendo c√≥mo su uso adecuado puede mejorar la legibilidad y flexibilidad del c√≥digo, pero tambi√©n los desaf√≠os que presentan, como la depuraci√≥n y limitaciones en casos complejos o anidados.

A partir de este conocimiento, lxs desarrolladorxs pueden aprovechar estas caracter√≠sticas para escribir c√≥digo m√°s limpio y eficiente, manteniendo un enfoque en la programaci√≥n funcional y modular, que es central en Kotlin.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/184143/java.svg"
        language="Java"
        link="/docs/fp/lambdas/java"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/800px-Python-logo-notext.svg.png"
        language="Python"
        link="/docs/fp/lambdas/python"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="/docs/fp/lambdas/scala"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/800px-Typescript_logo_2020.svg.png"
        language="TypeScript"
        link="/docs/fp/lambdas/typescript"
    />
</div>

<References references={[
    {
        title: "5. Programming with lambdas",
        bookTitle: "Kotlin in action",
        pages: "103‚Äì132",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
        edition: '1st',
    },
]}/>
