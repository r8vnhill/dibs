---
title: Funciones lambda
---
import LanguageCard from "../../../src/components/cards/LanguageCard";
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';
import Exercise from '@site/src/components/exercise/Exercise';
import Solution from '@site/src/components/exercise/Solution';

<ReadingTime />

Las **funciones lambda**, tambi√©n conocidas como funciones an√≥nimas, son una forma concisa y flexible de representar funciones **sin un nombre expl√≠cito**. Son especialmente √∫tiles cuando necesitamos una funci√≥n que se puede pasar como argumento, o cuando queremos escribir una funci√≥n de manera breve sin necesidad de definirla previamente. En su forma m√°s simple, una funci√≥n lambda es un **bloque de c√≥digo sin nombre** que puede ser asignado a una variable o pasado como par√°metro a otras funciones, permitiendo una gran flexibilidad en la escritura de c√≥digo.

<details>
    <summary>
        Funciones an√≥nimas en Kotlin
    </summary>

    En Kotlin, las funciones an√≥nimas y las lambdas son similares, pero no exactamente iguales. La diferencia radica principalmente en la sintaxis y en c√≥mo se manejan ciertas caracter√≠sticas como los retornos. Sin embargo, ambas pueden usarse de manera intercambiable en la mayor√≠a de los casos.

    Las funciones an√≥nimas tienen una sintaxis m√°s "tradicional", similar a una funci√≥n regular, y permite declarar el tipo de retorno. Ejemplo:

    ```kotlin showLineNumbers
    val sumar = fun(a: Int, b: Int): Int {
        return a + b
    }
    ```

    En la pr√°ctica usar una u otra ser√° un tema de preferencia, pero es m√°s com√∫n ver lambdas en el c√≥digo de Kotlin.
</details>

### Definici√≥n

Una **funci√≥n lambda** es una funci√≥n sin nombre que puede tomar argumentos y devolver un valor. Es una instancia de un tipo de funci√≥n que puede ser tratada como un valor. A menudo se usan para expresar bloques de c√≥digo que se ejecutar√°n m√°s adelante, como en el caso de funciones de orden superior que toman funciones como par√°metros o la [evaluaci√≥n perezosa](https://en.wikipedia.org/wiki/Lazy_evaluation).

La sintaxis general de una funci√≥n lambda en Kotlin es:

```kotlin showLineNumbers
val lambdaName: (T, S, ...) -> R = { t, s, ... -> body }
```

Donde:
- **``lambdaName``**: Nombre de la variable que almacena la funci√≥n lambda.
- **``T, S, ...``**: Tipos de los argumentos de la funci√≥n lambda (``...`` indica que puede haber m√°s de un argumento, pero se presenta como pseudoc√≥digo y no es sint√°xis v√°lida).
- **``R``**: Tipo de retorno de la funci√≥n lambda.
- **``t, s, ...``**: Nombres de los argumentos de la funci√≥n lambda (nuevamente ``...`` indica que puede haber m√°s de un argumento, pero es pseudoc√≥digo).
- **``body``**: Cuerpo de la funci√≥n lambda.

Por ejemplo, si quisi√©ramos definir una funci√≥n lambda que suma dos n√∫meros:

```kotlin showLineNumbers
val sumar: (Int, Int) -> Int = { a, b -> a + b }
```

Podemos llamar a esta lambda de la siguiente manera:

```kotlin showLineNumbers
val resultado = sumar(5, 10)  // 15
```

<details>
    <summary>Breve historia y teor√≠a</summary>

    El concepto de **funciones lambda** proviene del **C√°lculo Lambda**, una formalizaci√≥n matem√°tica desarrollada por Alonzo Church en la d√©cada de 1930. Esta notaci√≥n sent√≥ las bases para la **programaci√≥n funcional**, que influy√≥ en el dise√±o de muchos lenguajes modernos como Kotlin, Scala, JavaScript y Python.

    El **C√°lculo Lambda** introdujo una manera de definir y aplicar funciones de manera concisa, lo que permiti√≥ que los lenguajes de programaci√≥n funcional adoptaran funciones como ciudadanos de primera clase. Esto significa que las funciones pueden ser asignadas a variables, pasadas como argumentos o retornadas desde otras funciones.

    ### Elementos clave del C√°lculo Lambda
    1. **Variable ($x$)**: Un s√≠mbolo que representa un par√°metro o valor.
    2. **Abstracci√≥n ($\lambda x.M$)**: Una funci√≥n an√≥nima que toma un par√°metro $x$ y eval√∫a una expresi√≥n $M$.
    3. **Aplicaci√≥n ($M\ N$)**: La aplicaci√≥n de una funci√≥n $M$ a un argumento $N$. Tanto $M$ como $N$ pueden ser variables, abstracciones u otras aplicaciones.

    ### Operaciones de reducci√≥n
    - **$\alpha$-conversi√≥n**: $(\lambda x.M[x] \to \lambda y.M[y])$ ‚Äî Cambiar el nombre de un par√°metro.
    - **$\beta$-reducci√≥n**: $(\lambda x.M)N \to M[x := N]$ ‚Äî Sustituir el par√°metro de la funci√≥n por el argumento en su cuerpo.

    Kotlin adopt√≥ las funciones lambda para ofrecer una **sintaxis concisa y flexible** que facilita el uso de funciones de orden superior y la programaci√≥n funcional, eliminando la necesidad de definir expl√≠citamente funciones con nombre.

    :::note üå≠ Turing Completo üå≠
    El C√°lculo Lambda es **Turing completo**, lo que significa que puede expresar cualquier algoritmo computacional. Este hecho lo convierte en un modelo de computaci√≥n poderoso y vers√°til.
    :::
</details>


### Lambdas en _Kotlin_ con funciones de orden superior

Las **funciones lambda** son especialmente √∫tiles cuando se combinan con **funciones de orden superior**.

A continuaci√≥n, veremos un ejemplo usando `filter`, una funci√≥n de orden superior que toma una lambda como argumento:

```kotlin showLineNumbers
val numeros = listOf(1, 2, 3, 4, 5)
// Aplicamos filter para obtener solo los n√∫meros pares
val numerosPares = filter(numeros) { it % 2 == 0 }
println(numerosPares)  // Output: [2, 4]
```

En este caso, la funci√≥n `filter` recibe una lambda que eval√∫a si un n√∫mero es par.

:::info Trailing lambda
En **Kotlin**, si el √∫ltimo par√°metro de una funci√≥n es una lambda, es buena pr√°ctica mover la lambda fuera de los par√©ntesis. Esto se conoce como **trailing lambda** y mejora la legibilidad del c√≥digo. Las siguientes dos llamadas son equivalentes:

```kotlin showLineNumbers
val numerosPares = filter(numeros, { it % 2 == 0 })
val numerosPares = filter(numeros) { it % 2 == 0 }
```
:::

### Aplicando lambdas en funciones de orden superior

Puedes crear tus propias funciones de orden superior que acepten lambdas como par√°metros. Aqu√≠ hay un ejemplo simple:

```kotlin showLineNumbers
fun procesarEnteros(a: Int, b: Int, operacion: (Int, Int) -> Int) =
    operacion(a, b)

val suma = procesarEnteros(3, 4) { x, y -> x + y }
println(suma)  // Output: 7
```

En este ejemplo:
- La funci√≥n `procesarEnteros` acepta dos enteros y una lambda que define c√≥mo operarlos.
- Al llamar a `procesarEnteros`, proporcionamos una lambda que suma los dos n√∫meros.


## Destructuring declarations

Las **declaraciones de desestructuraci√≥n** permiten descomponer objetos complejos en componentes individuales, asign√°ndolos a variables separadas en una sola declaraci√≥n. Esto simplifica la extracci√≥n de valores de estructuras como **pares**, **listas**, **diccionarios** o **tipos de datos personalizados**, facilitando su manipulaci√≥n.

### Ventajas
- **Sintaxis concisa**: Permite extraer varios valores de un objeto en una √∫nica l√≠nea de c√≥digo.
- **Vers√°til**: Se puede utilizar en diferentes contextos, como asignaciones de variables, bucles de iteraci√≥n y par√°metros de funciones.
- **Legibilidad**: Mejora la claridad del c√≥digo al eliminar la necesidad de m√∫ltiples llamadas a getters.

### Ejemplo

```kotlin showLineNumbers
data class Person(val name: String, val age: Int)

val person = Person("Alice", 29)
val (name, age) = person
println("Name: $name, Age: $age")  // Output: Name: Alice, Age: 29
```

En este ejemplo, descomponemos el objeto `person` en sus componentes `name` y `age` utilizando la sintaxis de desestructuraci√≥n: `val (component1, component2, ...)`. Esta t√©cnica se puede aplicar en diversos escenarios, mejorando la simplicidad y eficiencia en la manipulaci√≥n de datos.

```kotlin showLineNumbers
val (first, second) = listOf(1, 2)  // Tambi√©n funciona con listas
```

### Under the Hood

En Kotlin, todas las **data classes** autom√°ticamente declaran operadores `componentN` para cada una de las variables de la clase, lo que permite la desestructuraci√≥n de sus propiedades de manera sencilla. Sin embargo, tambi√©n es posible personalizar este comportamiento en clases no marcadas como `data`, definiendo manualmente los m√©todos `componentN`.

Por ejemplo, podemos desestructurar una clase personalizada como `Point` definiendo los operadores correspondientes:

```kotlin showLineNumbers
class Point(val x: Int, val y: Int) {
    operator fun component1() = x
    operator fun component2() = y
}

val (x, y) = Point(10, 20)
println("x: $x, y: $y")  // Output: x: 10, y: 20
```

Este enfoque te permite controlar expl√≠citamente c√≥mo se descomponen las propiedades de la clase, incluso en aquellas que no son `data classes`.

<Exercise title={"Desestructuraci√≥n de listas"}>
    ¬øCu√°les son los tipos de ``head`` y ``tail``?

    1. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss")``
    2. ``val (head, tail) = listOf("D.Gray-Man", "Made in Abyss", "FLCL")``

    <Solution>
        1. En el primer caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``String``.
        2. En el segundo caso, ``head`` es de tipo ``String`` y ``tail`` es de tipo ``List<String>``.
    </Solution>
</Exercise>

### Desestructuraci√≥n en Lambdas

En Kotlin, una lambda puede desestructurar cualquier estructura que tenga definidos sus operadores `componentN`. Esto permite acceder f√°cilmente a los valores de un objeto directamente dentro de la lambda, mejorando la legibilidad y la simplicidad del c√≥digo.

```kotlin showLineNumbers
val sumPair = { (a, b): Pair<Int, Int> -> a + b }
val increasePairBy = { (a, b): Pair<Int, Int>, n: Int -> Pair(a + n, b + n) }

println(sumPair(3 to 4))  // Output: 7
println(increasePairBy(3 to 4, 2))  // Output: (5, 6)
```

En estos ejemplos:
- `sumPair` desestructura el par `(a, b)` y devuelve la suma de sus componentes.
- `increasePairBy` desestructura el par `(a, b)` y devuelve un nuevo par donde ambos valores han sido incrementados por `n`.

Este uso de desestructuraci√≥n en lambdas es particularmente √∫til cuando trabajamos con estructuras de datos m√°s complejas y deseamos acceder a sus valores de manera directa y concisa.

:::warning Estructuras anidadas
La desestructuraci√≥n en _Kotlin_ no es compatible con estructuras anidadas, como pares de pares o listas de pares. Para descomponer estructuras anidadas, es necesario realizar la desestructuraci√≥n de forma manual.
:::

<Exercise title={"Desestructuraci√≥n en lambdas"}>
    Indica el n√∫mero de par√°metros que recibe cada una de las siguientes lambdas:

    1. ``val f1 = { a: Int, b: Int -> /* ... */ }``
    2. ``val f2 = { (a, b): Pair<Int, Int> -> /* ... */ }``
    3. ``val f3 = { a: Int, (b, c): Pair<Int, Int> -> /* ... */ }``
    4. ``val f4 = { (a, b): Pair<Int, Int>, (c, d): Pair<Int, Int> -> /* ... */ }``

    <Solution>
        1. ``f1`` recibe dos par√°metros: ``a`` y ``b``.
        2. ``f2`` recibe un par√°metro de tipo ``Pair<Int, Int>``.
        3. ``f3`` recibe dos par√°metros: un entero ``a`` y un par de enteros ``b`` y ``c``.
        4. ``f4`` recibe dos pares de enteros.
    </Solution>
</Exercise>

## ¬øQu√© aprendimos?

En esta lecci√≥n, exploramos el concepto de **funciones lambda** y c√≥mo estas ofrecen una manera concisa y flexible de representar funciones en Kotlin. Vimos c√≥mo las lambdas nos permiten escribir funciones sin nombre, lo que es especialmente √∫til en casos donde las funciones se utilizan como par√°metros o se eval√∫an en un contexto perezoso.

Algunos puntos clave que cubrimos:

1. **Definici√≥n y uso** de lambdas en Kotlin, utilizando su sintaxis concisa para escribir funciones de manera m√°s simple.
2. **Diferencias con las funciones an√≥nimas**, resaltando la flexibilidad de las lambdas para casos comunes.
3. **Uso de lambdas con funciones de orden superior**, demostrando c√≥mo podemos pasar lambdas como par√°metros para modificar el comportamiento de una funci√≥n.
4. **Declaraciones de desestructuraci√≥n**, que permiten extraer componentes individuales de objetos complejos de manera m√°s clara y sencilla.
5. **Desestructuraci√≥n en lambdas**, lo cual simplifica la manipulaci√≥n de estructuras de datos como pares o clases personalizadas, permitiendo acceder a los componentes de manera directa dentro del cuerpo de la lambda.

Finalmente, con las **declaraciones de desestructuraci√≥n** y las lambdas, vimos c√≥mo estas caracter√≠sticas no solo mejoran la legibilidad del c√≥digo, sino que tambi√©n promueven un enfoque m√°s funcional y eficiente al manipular datos.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="scala"
    />
</div>

<References references={[
    {
        title: "5. Programming with lambdas",
        bookTitle: "Kotlin in action",
        pages: "103‚Äì132",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
        edition: '1st',
    },
]}/>
