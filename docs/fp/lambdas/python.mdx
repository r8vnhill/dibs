---
title: Funciones lambda en Python
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

En **Python**, las **funciones lambda** son también una forma de definir funciones anónimas, permitiendo crear bloques de código simples que se pueden asignar a variables o pasar como parámetros, similar a Kotlin. Sin embargo, hay diferencias significativas en la implementación y capacidades entre ambos lenguajes.

## Sintaxis

En **Python**, las lambdas utilizan una sintaxis compacta que se limita a expresiones simples. La sintaxis es la siguiente:

```python showLineNumbers
lambda argumentos: expresión
```

:::warning Limitaciones

Las lambdas se limitan a una única expresión y no permiten múltiples líneas o bloques complejos. Esto las hace ideales para operaciones simples, pero menos flexibles comparadas con las lambdas de Kotlin, que pueden tener varias líneas y acceder a un contexto más amplio.

:::

## Acceso y Captura de Variables

Las lambdas en **Python** pueden acceder a variables del contexto en el que se definen (clausuras), pero con algunas restricciones cuando se trata de modificar variables externas:

```python showLineNumbers
count = 0

increment = lambda x: x + count

count = 10
print(increment(5))  # Output: 15
```

En este ejemplo, la lambda en Python captura el valor de `count` en el momento en que se ejecuta, no en el momento en que se define. **Kotlin**, en cambio, permite un control más explícito sobre qué se captura y cuándo.

## Compatibilidad con Desestructuración

En **Python**, la desestructuración se soporta en algunas estructuras como listas y tuplas, pero no se aplica en las lambdas de la misma manera que en Kotlin:

```python showLineNumbers
points = [(1, 2), (3, 4), (5, 6)]
sums = list(map(lambda point: point[0] + point[1], points))
print(sums)  # Output: [3, 7, 11]
```

En **Kotlin**, se puede desestructurar directamente dentro de la lambda si se define un `componentN` o se trabaja con una `data class`, lo cual mejora la legibilidad y simplifica el acceso a componentes específicos.

## Uso en Funciones de Orden Superior

Ambos lenguajes admiten el uso de lambdas como argumentos en funciones de orden superior, pero la sintaxis y capacidades varían:

En **Python**, las funciones de orden superior como `map`, `filter` o `reduce` son comunes y se utilizan con lambdas. No obstante, la estructura limitada de las lambdas puede requerir definir funciones anónimas más detalladas o recurrir a funciones regulares (`def`).

```python showLineNumbers
numbers = [1, 2, 3, 4, 5]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)  # Output: [2, 4]
```

## Comparación Final

| **Característica**              | **Python**                                                                                                                | **Kotlin**                                                                                                                                |
|--------------------------------|----------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|
| **Sintaxis Lambda**             | Utiliza `lambda` seguido de `argumentos: expresión`, pero se limita a expresiones simples.                                  | Utiliza `{ }` y `->` para definir lambdas, permite múltiples líneas y bloques complejos, ofreciendo mayor flexibilidad.                    |
| **Captura de Variables**        | Captura variables en el momento de ejecución, lo que puede llevar a comportamientos inesperados si las variables cambian.  | Captura variables externas con control explícito sobre cuándo y cómo se capturan, permitiendo mayor precisión en su uso.                   |
| **Desestructuración**           | Soporta desestructuración en estructuras como listas y tuplas, pero no se aplica directamente en lambdas.                  | Permite desestructuración directa dentro de lambdas para acceder a componentes de forma sencilla, especialmente con `data classes`.        |
| **Funciones de Orden Superior** | Admite el uso de funciones de orden superior (`map`, `filter`, `reduce`), pero las lambdas se limitan a una única expresión. | Soporta funciones de orden superior con lambdas complejas, y es compatible con trailing lambdas, mejorando la legibilidad del código.     |
| **Compatibilidad**              | Compatible con versiones más antiguas de Python, asegurando aplicabilidad en proyectos legacy.                              | Integra lambdas en una estructura moderna de programación funcional, optimizando su uso en entornos avanzados y con características más robustas. |

<ProCons>
    <Pros>
        - **Simplicidad en la Sintaxis**: Las lambdas en Python tienen una sintaxis simple y directa, ideal para operaciones pequeñas y rápidas.
        - **Compatibilidad con Proyectos Legacy**: Dado que Python es compatible con versiones más antiguas, las lambdas se pueden utilizar sin preocuparse por problemas de compatibilidad, lo cual es útil en proyectos heredados.
        - **Facilidad de Uso en Funciones de Orden Superior**: Python cuenta con funciones de orden superior como `map`, `filter` y `reduce` que facilitan el uso de lambdas para manipular y transformar datos de manera sencilla.
        - **Desestructuración Flexible**: Aunque la desestructuración en lambdas no es tan avanzada como en Kotlin, Python permite desestructurar listas y tuplas en otros contextos, lo cual sigue siendo útil para simplificar el acceso a datos.
    </Pros>
    <Cons>
        - **Limitaciones en Expresiones**: Las lambdas en Python solo soportan expresiones de una línea, lo que limita su uso en casos donde se requiere lógica más compleja o múltiple.
        - **Menos Control en la Captura de Variables**: La captura de variables en Python ocurre en el momento de ejecución, lo que puede causar comportamientos inesperados si las variables cambian, a diferencia de Kotlin, que ofrece un control más preciso.
        - **Falta de Desestructuración en Lambdas**: La falta de soporte para desestructuración directa en lambdas limita la legibilidad y simplicidad del código en comparación con Kotlin, que permite desestructurar dentro de la propia lambda.
        - **Menor Flexibilidad para Funciones Complejas**: La estructura limitada de las lambdas en Python puede obligar a definir funciones `def` adicionales cuando se necesitan operaciones más complejas, lo que incrementa la verbosidad y reduce la concisión.
    </Cons>
</ProCons>

## ¿Qué Aprendimos?

En esta lección, exploramos cómo las **funciones lambda** se implementan en **Python** y las comparamos con **Kotlin**, destacando las diferencias clave y las limitaciones de cada enfoque.

### Puntos Clave

1. **Sintaxis y Limitaciones**: Vimos que Python ofrece una sintaxis simple para las lambdas, pero está limitada a expresiones de una sola línea, lo cual puede ser insuficiente para funciones más complejas, a diferencia de Kotlin, que permite bloques de múltiples líneas.
2. **Captura de Variables**: En Python, las lambdas capturan variables en el momento de ejecución, lo que puede llevar a comportamientos inesperados si las variables cambian después de definir la lambda. Kotlin, en cambio, ofrece un control más preciso sobre la captura de variables, proporcionando mayor estabilidad y predictibilidad en su comportamiento.
3. **Desestructuración**: Mientras que Python permite desestructurar listas y tuplas en algunos contextos, esta capacidad no se extiende a las lambdas. Kotlin, en cambio, permite la desestructuración directamente dentro de las lambdas, lo cual mejora la legibilidad y simplifica el acceso a los componentes de estructuras complejas como `data classes`.
4. **Funciones de Orden Superior**: Ambos lenguajes admiten el uso de funciones de orden superior, pero las capacidades de las lambdas en Python se limitan a casos simples debido a la restricción de una única expresión. Kotlin permite utilizar lambdas más complejas y soporta trailing lambdas, lo que mejora la legibilidad y flexibilidad del código.
5. **Compatibilidad y Uso en Proyectos Legacy**: Python mantiene una amplia compatibilidad con versiones anteriores, haciendo que sus lambdas sean útiles en proyectos heredados. Kotlin, por otro lado, se enfoca en proporcionar un entorno moderno para programación funcional, con características más robustas pero menos aplicabilidad en versiones de lenguajes anteriores.

---

Con estas diferencias en mente, hemos aprendido a evaluar cuándo usar lambdas en Python o Kotlin, según las capacidades, limitaciones y necesidades específicas de nuestros proyectos.

<References references={[
    {
        title: "7. Functions as First-Class Objects",
        bookTitle: "Fluent Python: Clear, concise, and effective programming",
        publisher: "O’Reilly",
        location: "Beijing Boston Farnham Sebastopol Tokyo",
        pages: "231–252",
        year: "2022",
        author: "Luciano Ramalho",
        type: "book",
    },
]}/>
