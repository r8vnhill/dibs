---
title: Funciones lambda en otros lenguajes
---

## Python

En **Python**, las funciones lambda y la desestructuración son soportadas de manera nativa, aunque presentan algunas diferencias en comparación con Kotlin y otros lenguajes modernos. Python permite definir **lambdas** con una sintaxis sencilla y realizar **desestructuración** de listas, tuplas y diccionarios, pero tiene limitaciones en cuanto a la flexibilidad de las lambdas.

### Lambdas en Python

Las lambdas en Python son funciones anónimas que pueden asignarse a variables o pasarse como parámetros. Su sintaxis es más limitada que en Kotlin, ya que solo permite una sola expresión.

#### Ejemplo en Python (con anotaciones de tipo)

```python showLineNumbers
sumar: callable = lambda a: int, b: int: a + b
resultado: int = sumar(5, 10)
print(resultado)  # Output: 15
```

**Comparación con Kotlin:**
- **Kotlin:** Usa `{ }` y `->` para definir lambdas con múltiples líneas de código y permite inferencia de tipos.
- **Python:** Usa `lambda` para definir una función anónima que está limitada a una sola expresión.

### Funciones de Orden Superior en Python

Python permite trabajar con funciones de orden superior de manera directa, ya que las funciones son objetos de primera clase. Esto significa que pueden ser asignadas a variables, pasadas como parámetros y devueltas como resultados.

#### Ejemplo en Python (con anotaciones de tipo)

```python showLineNumbers
from typing import Callable

def procesar_enteros(a: int, b: int, operacion: Callable[[int, int], int]) -> int:
    return operacion(a, b)

suma: int = procesar_enteros(3, 4, lambda x, y: x + y)
print(suma)  # Output: 7
```

**Comparación con Kotlin:**
- **Kotlin:** Las funciones de orden superior son de primera clase y se escriben directamente sin necesidad de definir interfaces.
- **Python:** Requiere la definición del tipo usando `Callable` para declarar que la función acepta otra función como parámetro.

### Desestructuración en Python

Python soporta desestructuración limitada a listas, tuplas y diccionarios, lo que permite asignar múltiples variables a partir de una colección.

#### Desestructuración de listas

```python showLineNumbers
numeros: list[int] = [1, 2, 3]
primero: int
segundo: int
tercero: int
primero, segundo, tercero = numeros
print(primero, segundo, tercero)  # Output: 1 2 3
```

#### Desestructuración de diccionarios

```python showLineNumbers
from typing import TypedDict

class Persona(TypedDict):
    nombre: str
    edad: int

persona: Persona = {"nombre": "Alice", "edad": 29}
nombre: str = persona["nombre"]
edad: int = persona["edad"]
print(f"Nombre: {nombre}, Edad: {edad}")  # Output: Nombre: Alice, Edad: 29
```

**Comparación con Kotlin:**
- **Kotlin:** Usa `val (name, age) = person` para desestructurar objetos.
- **Python:** Usa `TypedDict` para describir la estructura del diccionario y `list` para desestructurar listas.

### Desestructuración en Parámetros de Funciones

A diferencia de Kotlin, **Python no soporta la desestructuración directamente en los parámetros de las funciones**. Sin embargo, se puede lograr un comportamiento similar desempaquetando los valores dentro del cuerpo de la función o utilizando `*args` para listas/tuplas y `**kwargs` para diccionarios.

#### Ejemplo en Python (con anotaciones de tipo)

```python
from typing import Tuple

def sumar_pares(pares: Tuple[int, int]) -> int:
    a, b = pares  # Desestructuración en el cuerpo de la función
    return a + b

resultado: int = sumar_pares((3, 4))
print(resultado)  # Output: 7
```

En este ejemplo, aunque los valores de la tupla `pares` son desestructurados dentro del cuerpo de la función, **no es posible** desestructurar directamente en los parámetros de la función, como sí ocurre en Kotlin.

#### Comparación con Kotlin

- **Kotlin:** Permite la desestructuración directamente en la declaración de parámetros de las lambdas o funciones, siempre que estén definidos los operadores `componentN`.
- **Python:** No soporta desestructuración en la declaración de parámetros. La desestructuración debe realizarse en el cuerpo de la función, como en el ejemplo anterior.

### Comparación entre Kotlin y Python

| **Aspecto**                         | **Kotlin**                              | **Python**                                   |
|-------------------------------------|-----------------------------------------|----------------------------------------------|
| **Lambdas**                         | `{ }` y `->`, múltiples expresiones     | `lambda`, limitado a una sola expresión      |
| **Funciones de Orden Superior**     | Soporte directo                         | Soporte directo con `Callable`               |
| **Trailing Lambdas**                | Soportado, permite sintaxis concisa     | No soportado                                 |
| **Desestructuración de Parámetros** | Soporta desestructuración en parámetros | No soportado, desestructuración en el cuerpo |

## TypeScript

Al igual que Kotlin, TypeScript soporta **funciones lambda** (conocidas como **funciones flecha** o **arrow functions**) y **desestructuración**, permitiendo escribir código más conciso y expresivo.

### Funciones Lambda en TypeScript

En TypeScript, las funciones lambda se definen utilizando la sintaxis de flecha `=>`. Estas funciones pueden asignarse a variables, pasarse como argumentos y usarse de manera similar a como se hace en Kotlin.

**Ejemplo en TypeScript:**

```typescript
const sumar = (a: number, b: number): number => a + b;

const resultado = sumar(5, 10);  // 15
console.log(resultado);
```

**Comparación con Kotlin:**

- **Sintaxis:**
    - **Kotlin:** Utiliza `{ }` y `->` para definir lambdas.
    - **TypeScript:** Utiliza `=>` para definir funciones flecha.
- **Tipos de datos:**
    - Ambos lenguajes permiten definir los tipos de los parámetros y el tipo de retorno de la función.
- **Asignación y uso:**
    - En ambos casos, las funciones lambda pueden asignarse a variables y utilizarse posteriormente.

### Funciones de Orden Superior

TypeScript también soporta **funciones de orden superior**, permitiendo pasar funciones como argumentos y retornarlas.

**Ejemplo en TypeScript:**

```typescript
function procesarEnteros(a: number, b: number, operacion: (x: number, y: number) => number): number {
    return operacion(a, b);
}

const suma = procesarEnteros(3, 4, (x, y) => x + y);
console.log(suma);  // Output: 7
```

**Comparación con Kotlin:**

- La capacidad de pasar funciones como parámetros es similar en ambos lenguajes.
- La sintaxis para definir el tipo de la función es ligeramente diferente, pero conceptualmente equivalente.

### Desestructuración en TypeScript

TypeScript soporta la **desestructuración** de objetos y arreglos, lo que permite extraer valores y asignarlos a variables de manera concisa.

#### Desestructuración de Objetos

```typescript
interface Person {
    name: string;
    age: number;
}

const person: Person = { name: "Alice", age: 29 };
const { name, age } = person;

console.log(`Name: ${name}, Age: ${age}`);  // Output: Name: Alice, Age: 29
```

#### Desestructuración de Arreglos

```typescript
const numbers = [1, 2, 3];
const [first, second] = numbers;

console.log(first, second);  // Output: 1 2
```

#### Comparación con Kotlin

- **Sintaxis:**
    - **Kotlin:** Utiliza `val (name, age) = person` para desestructurar.
    - **TypeScript:** Utiliza `{ }` para desestructurar objetos y `[ ]` para desestructurar arreglos.
- **Capacidades:**
    - Ambos lenguajes permiten desestructurar objetos y colecciones.
    - TypeScript permite desestructuración anidada, lo que es una ventaja sobre Kotlin.

### Desestructuración en Parámetros de Funciones

TypeScript permite desestructurar parámetros directamente en la definición de la función, incluyendo en funciones flecha.

#### Ejemplo en TypeScript

```typescript
const sumPair = ({ a, b }: { a: number; b: number }): number => a + b;

console.log(sumPair({ a: 3, b: 4 }));  // Output: 7
```

#### Comparación con Kotlin

- **Kotlin:** Permite desestructuración en lambdas si los operadores `componentN` están definidos.
- **TypeScript:** Permite desestructuración de objetos directamente en los parámetros.

### Diferencias Clave

- **Desestructuración Anidada:**
    - **TypeScript:** Soporta desestructuración anidada de objetos y arreglos.
        ```typescript
        const person = { name: "Alice", address: { city: "Wonderland" } };
        const { address: { city } } = person;
        console.log(city);  // Output: Wonderland
        ```
    - **Kotlin:** No soporta desestructuración anidada directamente; se requiere desestructurar manualmente cada nivel.
- **Sintaxis de Lambdas:**
    - **Kotlin:** Utiliza `{ }` y `->`, y permite inferencia de tipos en muchos casos.
    - **TypeScript:** Utiliza `=>` y requiere tipos explícitos o inferencia basada en el contexto.
- **Funciones de Orden Superior:**
    - Ambos lenguajes soportan funciones de orden superior, pero Kotlin tiene una integración más profunda con características funcionales, como la posibilidad de utilizar **trailing lambdas** y una sintaxis más concisa.
