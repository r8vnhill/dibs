---
title: Functor funci√≥n en Haskell
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

Ya viste en Kotlin c√≥mo una funci√≥n `(T) -> R` puede comportarse como un **funtor** al permitir transformar su salida sin alterar su entrada. Esta idea se implementaba mediante una funci√≥n de extensi√≥n `map`, lo que te permiti√≥ encadenar transformaciones de forma declarativa sobre el resultado de una funci√≥n.

En **Haskell**, este concepto se formaliza a√∫n m√°s: el tipo `(->) r` (funciones que reciben un valor de tipo `r`) es **una instancia nativa del tipo de clase `Functor`**. Es decir, **todas las funciones que comparten el mismo tipo de entrada son autom√°ticamente funtores en su salida**.

Esto implica que puedes usar `fmap` directamente sobre funciones, sin necesidad de definir manualmente una operaci√≥n `map`. Esta integraci√≥n directa en el sistema de tipos permite composiciones m√°s expresivas y verificables, y nos abre la puerta a herramientas como **QuickCheck**, que permiten verificar autom√°ticamente que las leyes del funtor se cumplen.

En esta lecci√≥n, ver√°s c√≥mo aprovechar esa integraci√≥n, c√≥mo se compara con Kotlin, y qu√© ventajas te ofrece Haskell al trabajar con el funtor funci√≥n.

## Instancia Functor para funciones en Haskell

```haskell
instance Functor ((->) r) where
    fmap f g = \x -> f (g x)
```

Esto quiere decir que si tienes una funci√≥n `g :: r -> a`, y una transformaci√≥n `f :: a -> b`, entonces `fmap f g` te da una nueva funci√≥n `r -> b`. Esta operaci√≥n es exactamente la misma que en Kotlin con `map`.

## ‚úÖ Verificando las leyes del funtor con QuickCheck

Una ventaja de Haskell es que puedes **verificar autom√°ticamente** las leyes del funtor utilizando pruebas **propiedadales** con [QuickCheck](https://hackage.haskell.org/package/QuickCheck).

### üìê Ley de Identidad

```haskell
prop_identity :: (Eq b, Show r, Arbitrary r) => Fun r b -> r -> Bool
prop_identity (Fun _ f) x = (fmap id f) x == f x
```

Este test genera funciones arbitrarias `f :: r -> b` y verifica que `fmap id f ‚â° f`.

### üìê Ley de Composici√≥n

```haskell
prop_composition :: (Eq c, Show r, Arbitrary r) => Fun b c -> Fun a b -> Fun r a -> r -> Bool
prop_composition (Fun _ f) (Fun _ g) (Fun _ h) x =
  (fmap f (fmap g h)) x == (fmap (f . g) h) x
```

Esto prueba que aplicar dos veces `fmap` equivale a aplicar una sola vez con la composici√≥n de funciones: `fmap f . fmap g ‚â° fmap (f . g)`.

### üß™ Ejemplo de ejecuci√≥n

```haskell
import Test.QuickCheck
import Test.QuickCheck.Function

main :: IO ()
main = do
  quickCheck (prop_identity :: Fun Int String -> Int -> Bool)
  quickCheck (prop_composition :: Fun Bool Char -> Fun Int Bool -> Fun String Int -> String -> Bool)
```

Haskell infiere los tipos y genera autom√°ticamente las funciones y datos necesarios para verificar las propiedades. Este nivel de automatizaci√≥n no es posible en Kotlin de forma directa.

---

## üîÑ Diferencias clave con Kotlin

| Caracter√≠stica                     | Kotlin                                      | Haskell                                        |
|----------------------------------|---------------------------------------------|-----------------------------------------------|
| Sintaxis                         | Manual: se implementa `map` como extensi√≥n  | Autom√°tica: `(->) r` es instancia de `Functor` |
| Verificaci√≥n de leyes            | Manual (Kotest, assert)                     | Autom√°tica (QuickCheck)                       |
| Composici√≥n de funciones         | `.map(f).map(g)`                            | `fmap g . fmap f`                             |
| Generalidad                      | Solo si se define expl√≠citamente            | Autom√°tica por el sistema de tipos            |
| Contrafuntores (`Contravariant`) | Manual (`contramap`)                        | Instancia de `Contravariant` disponible       |

---

<Definition>
En Haskell, gracias a su sistema de clases de tipos, las funciones son funtores de forma nativa, y las leyes del funtor se pueden verificar autom√°ticamente con herramientas como QuickCheck. En Kotlin, aunque se puede definir una operaci√≥n `map` equivalente, no existe soporte autom√°tico para validar las leyes del funtor: deben probarse de forma manual.
</Definition>
