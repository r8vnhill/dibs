---
title: Functores en Kotlin
---

import ReadingTime from '@site/src/components/ReadingTime';
import References from "@site/src/components/ReferencesComponent";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

<ReadingTime/>

En esta lección, exploraremos el concepto de **functores** en Kotlin y cómo implementarlos, basándonos en lo que aprendimos sobre **Higher-Kinded Types** en la lección anterior.

## ¿Qué es un Functor?

En programación funcional, un **functor** es una abstracción que representa tipos de datos que pueden ser mapeados. Es decir, un functor es una estructura que soporta una operación que aplica una función a los valores que contiene sin alterar su estructura.

### Intuición Básica

Si tienes una estructura de datos como una lista, un árbol o un `Box`, y puedes aplicar una función a cada elemento dentro de esa estructura sin modificar la forma de la estructura, entonces esa estructura es un functor.

### Leyes de los Functores

Para que una estructura sea considerada un functor, debe cumplir dos leyes:

1. **Ley de Identidad**: Aplicar la función identidad no debe cambiar el functor.

    $
    \text{map}(\text{id}) = \text{id}
    $

2. **Ley de Composición**: Mapear la composición de dos funciones es lo mismo que mapear una función y luego mapear la otra.
    $
    \text{map}(f \circ g) = \text{map}(f) \circ \text{map}(g)
    $

## Implementando Functores en Kotlin

<details>
    <summary>
        Comencemos por crear un módulo para la lección...
    </summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path 'functors\src\main\kotlin' -ItemType Directory -Force
            New-Item -Path 'functors\build.gradle.kts' -ItemType File -Force
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            mkdir -p 'functors\src\main\kotlin'
            ni 'functors\build.gradle.kts' -i 'f' -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            mkdir -p functors/src/main/kotlin
            touch functors/build.gradle.kts
            ```
        </TabItem>
    </Tabs>

    También necesitaremos añadir el módulo ``hkt`` al archivo ``build.gradle.kts`` del módulo ``functors``:

    ```kotlin showLineNumbers title="functors/build.gradle.kts"
    dependencies {
        implementation(project(":hkt"))
    }
    ```
</details>

Como vimos en la lección anterior, Kotlin no soporta **Higher-Kinded Types** de forma nativa. Sin embargo, podemos simular este comportamiento utilizando el patrón `Kind`.

### Definición de la Interfaz `Functor`

<details>
    <summary>
        Si prefieres crear el archivo desde la terminal...
    </summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            $BaseDir = 'com\github\username'
            $FunctorsDir = "functors\src\main\kotlin\$BaseDir"
            New-Item -Path "$FunctorsDir\functor\Functor.kt" -ItemType 'File' -Force
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            $BaseDir = 'com\github\username'
            $FunctorsDir = "functors\src\main\kotlin\$BaseDir"
            ni "$FunctorsDir\functor\Functor.kt" -i 'f' -f
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            BASE_DIR="com/github/username"
            FUNCTORS_DIR="functors/src/main/kotlin/$BASE_DIR"
            touch "$FUNCTORS_DIR/functor/Functor.kt"
            ```
        </TabItem>
    </Tabs>
</details>

Primero, definamos una interfaz `Functor` que trabaja sobre un constructor de tipos `F`.

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers title="functors/src/main/kotlin/com/github/username/functors/Functor.kt"
        interface Functor<F> {
            fun <A, B> Kind<F, A>.map(f: (A) -> B): Kind<F, B>
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="functors/src/main/kotlin/com/github/username/functors/Functor.kt"
        package com.github.username.functors

        import com.github.username.kinds.Kind

        interface Functor<F> {
            fun <A, B> Kind<F, A>.map(f: (A) -> B): Kind<F, B>
        }
        ```
    </TabItem>
</Tabs>

:::info Explicación del Código

- **`F`**: Representa el constructor de tipos (como `List`, `Box`, etc.).
- **`map`**: Es una extensión sobre `Kind<F, A>` que aplica una función `f` al valor contenido y devuelve un `Kind<F, B>`.

:::

### Nuestra Clase `Box` como Functor

Usaremos la clase `Box` que definimos anteriormente.

```kotlin showLineNumbers title="hkt/src/main/kotlin/com/github/username/kinds/Box.kt"
package com.github.username.kinds

data class Box<out A>(val value: A) : Kind<Box.Of, A> {
    object Of
}
```

### Implementando el Functor para `Box`

    <details>
        <summary>
            Si prefieres crear el archivo desde la terminal...
        </summary>

        <Tabs groupId={"os"}>
            <TabItem value="Windows" label="Windows">
                ```powershell
                New-Item -Path "$FunctorsDir\functor\Bo
                ```
            </TabItem>
            <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
                ```powershell
                ni "$FunctorsDir\functor\Functor.kt" -i 'f' -f
                ```
            </TabItem>
            <TabItem value="Linux/Mac" label="Linux/Mac">
                ```bash
                touch "$FUNCTORS_DIR/functor/Functor.kt"
                ```
            </TabItem>
        </Tabs>
    </details>

Ahora, crearemos una instancia de `Functor` para `Box`.

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers title="functors/src/main/kotlin/com/github/username/functors/BoxFunctor.kt"
        class BoxFunctor : Functor<Box.Of> {
            override fun <A, B> Kind<Box.Of, A>.map(f: (A) -> B): Kind<Box.Of, B> {
                require(this is Box<A>) { "Invalid Box" }
                return Box(f(this.value))
            }
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="functors/src/main/kotlin/com/github/username/functors/BoxFunctor.kt"
        package com.github.username.functors

        import com.github.username.kinds.Box
        import com.github.username.kinds.Kind

        object BoxFunctor : Functor<Box.Of> {
            override fun <A, B> Kind<Box.Of, A>.map(f: (A) -> B): Kind<Box.Of, B> {
                require(this is Box<A>) { "Invalid Box" }
                return Box(f(this.value))
            }
        }
        ```
    </TabItem>
</Tabs>

:::info Explicación del Código

- **[3]** Verificamos que `this` sea una instancia de `Box<A>`.
- **[4]**: Aplicamos la función `f` al valor contenido y lo envolvemos en un nuevo `Box`.

:::

### Uso del Functor `BoxFunctor`

Veamos cómo utilizar nuestro functor en código.

<Tabs>
    <TabItem value={"Código esencial"} label={"Código esencial"}>
        ```kotlin showLineNumbers title="Main.kt"
        val box: Kind<Box.Of, Int> = Box(420)
        val result = with(BoxFunctor) {
            box.map { it * 2 }
        }
        println(result) // Debería imprimir: Box(value=840)
        ```
    </TabItem>
    <TabItem value={"Código completo"} label={"Código completo"}>
        ```kotlin showLineNumbers title="Main.kt"
        package com.github.username.main

        import com.github.username.kinds.Box
        import com.github.username.kinds.Kind
        import com.github.username.functors.BoxFunctor

        fun main() {
            val box: Kind<Box.Of, Int> = Box(420)

            val result = with(BoxFunctor) {
                box.map { it * 2 }
            }

            println(result) // Debería imprimir: Box(value=840)
        }
        ```
    </TabItem>
</Tabs>

:::info Explicación del Código

- **[1]**: Creamos un `Box` que contiene el número `420`.
- **[2-4]**: Usamos `with(BoxFunctor)` para acceder a la función `map`.
- **[5]**: Aplicamos una función que duplica el valor contenido.

:::

:::warning Limitaciones y Consideraciones

Al implementar functores en Kotlin usando este enfoque, enfrentamos las siguientes limitaciones:

- **Verificación Manual**: La verificación de tipos y la conversión de tipos deben hacerse manualmente.
- **Menor Seguridad de Tipos**: El compilador no puede garantizar al 100% la seguridad de tipos, lo que puede llevar a excepciones en tiempo de ejecución.
- **Verboso**: El código puede volverse más complejo y menos legible en comparación con lenguajes que soportan higher-kinded types nativamente.

:::
