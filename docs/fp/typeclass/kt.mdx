---
title: Typeclasses
---
import ReadingTime from '@site/src/components/ReadingTime';
import References from "@site/src/components/ReferencesComponent";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

<ReadingTime/>

Los **typeclasses** son un poderoso concepto en programación funcional que permiten definir comportamiento polimórfico ad-hoc. Esto significa que podemos definir operaciones genéricas que funcionan sobre una variedad de tipos, siempre que esos tipos implementen ciertas interfaces o contratos. En lenguajes como Haskell, las typeclasses son fundamentales para lograr código genérico y reutilizable.

En Kotlin, aunque no existe soporte nativo para typeclasses como en Haskell, podemos emular su comportamiento utilizando **context receivers**, una característica introducida en versiones recientes del lenguaje.

## ¿Qué son los Context Receivers?

Los **context receivers** en Kotlin permiten declarar que una función o propiedad requiere cierto contexto para ser llamada. Este contexto es provisto por uno o más tipos que actúan como receptores adicionales en el ámbito de la función. Los context receivers proporcionan una forma de acceder a miembros de estos contextos sin tener que pasarlos explícitamente como parámetros.

### Habilitando Context Receivers

Para habilitar la característica de context receivers en Kotlin, debes modificar la configuración del proyecto. Para esto, modificaremos el archivo ``convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts`` y agregaremos la siguiente configuración:

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
        kotlin {
            // ...
            compilerOptions {
                freeCompilerArgs = listOf("-Xcontext-receivers")
            }
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
        plugins {
            kotlin("jvm")
        }

        kotlin {
            jvmToolchain {
                languageVersion.set(JavaLanguageVersion.of(21))
            }

            compilerOptions {
                freeCompilerArgs = listOf("-Xcontext-receivers")
            }
        }
        ```
    </TabItem>
</Tabs>

### Sintaxis Básica

La sintaxis básica para declarar una función con context receivers es:

```kotlin showLineNumbers
context(ContextType)
fun functionName(parameters) {
    // We can use
}
```

Aquí, `ContextType` es el tipo que actúa como contexto para la función `functionName`. Dentro de la función, puedes acceder a los miembros de `ContextType` directamente.

## Typeclass

Una **typeclass** es un concepto en programación funcional que permite definir un conjunto de operaciones o funciones genéricas que pueden ser implementadas por diferentes tipos de datos. Formalmente, una typeclass es una abstracción que especifica un comportamiento (una interfaz) que los tipos pueden implementar para soportar ciertas operaciones, permitiendo así el **polimorfismo ad-hoc**.

### Características Principales:

- **Abstracción de Comportamiento**: Las typeclasses definen operaciones abstractas sin proporcionar una implementación concreta. Los tipos que desean soportar estas operaciones deben proporcionar sus propias implementaciones.

- **Polimorfismo Ad-hoc**: Permiten que una misma función opere sobre diferentes tipos, y que el comportamiento específico se determine en tiempo de compilación según la implementación de la typeclass para ese tipo.

- **Resolución en Tiempo de Compilación**: Las instancias de typeclass se resuelven en tiempo de compilación, lo que mejora la seguridad y eficiencia del código.

### Ejemplo en Haskell:

En Haskell, las typeclasses son una característica nativa y fundamental. Se definen utilizando la palabra clave `class`, y las instancias se crean con `instance`.

#### Definición de una Typeclass:

```haskell
class Eq a where
  (==) :: a -> a -> Bool
```

En este ejemplo:

- `Eq` es una typeclass que define la operación `(==)`.
- `a` es un tipo genérico.
- Cualquier tipo que sea una instancia de `Eq` debe proporcionar una implementación de `(==)`.

#### Instancia de una Typeclass:

```haskell
instance Eq Int where
  x == y = x `primEqInt` y
```

Aquí, estamos haciendo que el tipo `Int` sea una instancia de `Eq`, proporcionando una implementación específica de `(==)` para enteros.

### Propiedades Clave de las Typeclasses:

1. **Extensibilidad**: Se pueden añadir nuevas instancias de typeclasses para tipos existentes sin modificar el código original.

2. **Composición**: Las typeclasses pueden extender otras typeclasses, permitiendo la composición y reutilización de comportamientos.

3. **Resolución Implícita**: El compilador selecciona automáticamente la implementación correcta de una función basada en el tipo de los argumentos.

### Comparación con Interfaces en Kotlin:

Aunque las **interfaces** en Kotlin y las **typeclasses** comparten similitudes al definir contratos de comportamiento, hay diferencias clave:

- **Polimorfismo**:
    - **Interfaces**: Utilizan polimorfismo de subtipos (herencia). Un objeto debe declarar explícitamente que implementa una interfaz.
    - **Typeclasses**: Utilizan polimorfismo ad-hoc. La relación entre el tipo y la typeclass se establece fuera del tipo mismo, sin modificar su definición.

- **Resolución**:
    - **Interfaces**: La implementación se resuelve en tiempo de ejecución.
    - **Typeclasses**: La implementación se resuelve en tiempo de compilación.

### Emulación de Typeclasses en Kotlin con Context Receivers:

Dado que Kotlin no soporta typeclasses nativamente, podemos emular su comportamiento utilizando **context receivers** y **interfaces**. Al definir una interfaz que actúa como una typeclass y usar context receivers para proporcionar las implementaciones en el ámbito necesario, logramos:

- **Polimorfismo Ad-hoc**: Las funciones genéricas pueden operar sobre cualquier tipo que tenga una implementación de la interfaz requerida en el contexto.

- **Resolución en Tiempo de Compilación**: El compilador verifica que el contexto adecuado esté disponible y resuelve las implementaciones en tiempo de compilación.

#### Ejemplo Revisitado:

```kotlin showLineNumbers title="Semigroup.kt"
interface Semigroup<T> {
    fun combine(a: T, b: T): T
}
```

- **Semigroup** actúa como nuestra typeclass, definiendo la operación `combine`.

```kotlin showLineNumbers title="IntSemigroup.kt"
object IntSemigroup : Semigroup<Int> {
    override fun combine(a: Int, b: Int): Int = a + b
}
```

- **IntSemigroup** es una instancia de la typeclass para el tipo `Int`.

```kotlin showLineNumbers title="CombineAll.kt"
context(Semigroup<T>)
fun <T> combineAll(elements: List<T>): T {
    require(elements.isNotEmpty()) { "The list must not be empty" }
    return elements.reduce { acc, e -> combine(acc, e) }
}
```

- La función `combineAll` requiere un `Semigroup<T>` en su contexto, emulando así el comportamiento de una función que depende de una typeclass.

### Ventajas de Este Enfoque en Kotlin:

- **Flexibilidad**: Podemos definir comportamientos genéricos sin modificar los tipos originales.

- **Reutilización de Código**: Las mismas funciones genéricas pueden aplicarse a diferentes tipos siempre que exista una implementación adecuada en el contexto.

- **Claridad y Seguridad**: El uso de context receivers hace explícitas las dependencias de las funciones, mejorando la legibilidad y permitiendo al compilador verificar que se cumplen los contratos.

## Conclusión

Las **typeclasses** proporcionan una forma poderosa de lograr polimorfismo ad-hoc y definir comportamientos genéricos en programación funcional. Aunque Kotlin no las soporta de manera nativa, podemos emular su funcionalidad utilizando **context receivers** e **interfaces**. Este enfoque nos permite escribir código más abstracto y reutilizable, aprovechando las capacidades del lenguaje para acercarnos a patrones avanzados de programación funcional.

## Relación entre Context Receivers y Typeclasses

Los context receivers pueden utilizarse para emular el comportamiento de las typeclasses al permitir que una función requiera que cierto contexto (es decir, cierta implementación) esté disponible. Esto nos permite definir funciones genéricas que operan sobre tipos que implementan ciertos comportamientos, sin tener que pasarlos explícitamente como parámetros.

## Ejemplo: Definiendo una Typeclass para Semigrupo

Un **semigrupo** es una estructura algebraica que consta de un conjunto y una operación binaria asociativa. Podemos definir una typeclass `Semigroup` que encapsula esta operación.

### Paso 1: Definir la Interfaz de la Typeclass

```kotlin showLineNumbers title="Semigroup.kt"
interface Semigroup<T> {
    fun combine(a: T, b: T): T
}
```

Aquí, `Semigroup<T>` es una interfaz que define una operación `combine` para combinar dos elementos de tipo `T`.

### Paso 2: Crear Implementaciones para Tipos Específicos

Implementemos `Semigroup` para algunos tipos comunes, como `Int` y `String`.

```kotlin showLineNumbers title="IntSemigroup.kt"
object IntSemigroup : Semigroup<Int> {
    override fun combine(a: Int, b: Int): Int = a + b
}
```

```kotlin showLineNumbers title="StringSemigroup.kt"
object StringSemigroup : Semigroup<String> {
    override fun combine(a: String, b: String): String = a + b
}
```

### Paso 3: Utilizar Context Receivers para Funciones Genéricas

Ahora, definamos una función genérica que combine una lista de elementos utilizando el semigrupo adecuado.

```kotlin showLineNumbers title="CombineAll.kt"
context(Semigroup<T>)
fun <T> combineAll(elements: List<T>): T {
    require(elements.isNotEmpty()) { "The list must not be empty" }
    return elements.reduce { acc, e -> combine(acc, e) }
}
```

En esta función:

- **[1]** Declaramos que la función requiere un `Semigroup<T>` en su contexto.
- **[2]** Utilizamos `combine(acc, e)` para combinar los elementos de la lista, donde `combine` es la operación definida en el `Semigroup<T>` del contexto.

### Paso 4: Usar la Función con Diferentes Implementaciones

Ahora podemos utilizar `combineAll` con diferentes tipos, proporcionando el semigrupo adecuado en el contexto.

```kotlin showLineNumbers title="Main.kt"
fun main() {
    val intList = listOf(1, 2, 3, 4)
    val stringList = listOf("Hello, ", "World", "!")

    // Uso con Int
    val intResult = with(IntSemigroup) {
        combineAll(intList)
    }
    println("Int result: $intResult") // Output: Int result: 10

    // Uso con String
    val stringResult = with(StringSemigroup) {
        combineAll(stringList)
    }
    println("String result: $stringResult") // Output: String result: Hello, World!
}
```

En este ejemplo:

- Utilizamos `with(IntSemigroup)` para proporcionar el contexto `Semigroup<Int>` a la función `combineAll` cuando trabajamos con enteros.
- Hacemos lo mismo con `StringSemigroup` para trabajar con cadenas de texto.

## Explicación Detallada

### Cómo Funcionan los Context Receivers en Este Caso

Cuando declaramos `context(Semigroup<T>)` en la función `combineAll`, estamos especificando que esta función necesita un contexto que implemente `Semigroup<T>`. Dentro de la función, podemos acceder a los miembros de `Semigroup<T>` directamente, como la función `combine`.

Al usar `with(IntSemigroup)` o `with(StringSemigroup)`, estamos proporcionando el contexto necesario para la función. Esto es similar a cómo funcionan las typeclasses en Haskell, donde el compilador selecciona automáticamente la instancia adecuada de una typeclass basada en el tipo.

### Ventajas de Este Enfoque

- **Abstracción**: Podemos escribir código genérico que funciona con cualquier tipo que tenga una implementación de `Semigroup`.
- **Reutilización**: Evitamos duplicar código para cada tipo específico.
- **Claridad**: El uso de context receivers hace que el requisito de contexto sea explícito en la declaración de la función.

## Ejemplo Avanzado: Monoid

Un **monoid** es una extensión de un semigrupo que incluye un elemento neutro. Podemos definir una typeclass `Monoid` que hereda de `Semigroup` e incluye el elemento neutro.

### Definir la Interfaz de Monoid

```kotlin showLineNumbers title="Monoid.kt"
interface Monoid<T> : Semigroup<T> {
    val empty: T
}
```

### Implementaciones para Tipos Específicos

```kotlin showLineNumbers title="IntMonoid.kt"
object IntMonoid : Monoid<Int> {
    override fun combine(a: Int, b: Int): Int = a + b
    override val empty: Int = 0
}
```

```kotlin showLineNumbers title="StringMonoid.kt"
object StringMonoid : Monoid<String> {
    override fun combine(a: String, b: String): String = a + b
    override val empty: String = ""
}
```

### Función Genérica con Context Receiver

Podemos redefinir `combineAll` para utilizar el elemento neutro en caso de que la lista esté vacía.

```kotlin showLineNumbers title="CombineAllMonoid.kt"
context(Monoid<T>)
fun <T> combineAll(elements: List<T>): T {
    return elements.fold(empty) { acc, e -> combine(acc, e) }
}
```

### Uso en `main`

```kotlin showLineNumbers title="MainMonoid.kt"
fun main() {
    val intList = listOf<Int>()
    val stringList = listOf<String>()

    // Uso con Int
    val intResult = with(IntMonoid) {
        combineAll(intList)
    }
    println("Int result: $intResult") // Output: Int result: 0

    // Uso con String
    val stringResult = with(StringMonoid) {
        combineAll(stringList)
    }
    println("String result: $stringResult") // Output: String result:
}
```

## Limitaciones y Consideraciones

- **Visibilidad de los Miembros**: Los context receivers permiten acceder a los miembros públicos del contexto, pero no a los privados.
- **No Confundir con Herencia**: Este mecanismo no es una forma de herencia múltiple; es una forma de proporcionar contexto adicional a las funciones.
- **Compatibilidad**: Los context receivers están disponibles en versiones recientes de Kotlin y pueden requerir ajustes en la configuración del proyecto para habilitarlos.

## Conclusión

Los **context receivers** en Kotlin proporcionan una forma poderosa de emular **typeclasses**, permitiendo escribir código genérico y reutilizable que puede operar sobre diferentes tipos siempre que se proporcione el contexto adecuado. Este enfoque facilita la abstracción y mejora la claridad del código, acercando a Kotlin a las capacidades de lenguajes funcionales más especializados.

## ¿Qué hemos aprendido?

- **Context Receivers**: Hemos visto cómo funcionan y cómo pueden utilizarse para proporcionar contexto adicional a las funciones.
- **Emulación de Typeclasses**: Aprendimos a utilizar context receivers para emular typeclasses, permitiendo polimorfismo ad-hoc.
- **Aplicación Práctica**: Implementamos ejemplos prácticos con semigrupos y monoides, mostrando cómo combinar elementos genéricamente.

<References references={[
    {
        title: "Type Classes and Context Receivers in Kotlin",
        author: "JetBrains",
        year: "2022",
        type: "web",
        url: "https://kotlinlang.org/docs/context-receivers.html",
        accessedDate: "1 de octubre de 2024",
    },
    {
        title: "Context Receivers in Kotlin: A Deep Dive",
        author: "Kotlin Blog",
        year: "2022",
        type: "web",
        url: "https://blog.jetbrains.com/kotlin/2022/02/context-receivers-deep-dive/",
        accessedDate: "1 de octubre de 2024",
    },
    {
        title: "Functional Programming in Kotlin",
        bookTitle: "Functional Programming in Kotlin",
        pages: "470–480",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co. LLC",
        year: "2021",
        type: "book",
        author: 'Marco Vermeulen, Rúnar Bjarnason, and Paul Chiusano',
    },
]}/>