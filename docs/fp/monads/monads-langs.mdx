---
title: Mónadas en otros lenguajes
---

## Haskell

En **Haskell**, las mónadas son definidas utilizando la **typeclass `Monad`**, que especifica cómo deben comportarse los tipos monádicos. Al igual que en Kotlin, las mónadas en Haskell permiten manejar operaciones en contextos computacionales, como el manejo de errores o efectos secundarios, de manera estructurada y segura.

:::note Typeclass
Una **typeclass** en Haskell es un mecanismo que define un conjunto de funciones que deben ser implementadas por los tipos de datos que pertenecen a dicha typeclass. Es comparable a una interfaz en otros lenguajes, pero con mayor flexibilidad, ya que permite la definición de comportamientos compartidos sin modificar los tipos existentes.
:::

### Componentes de la typeclass `Monad` en Haskell

- **`return`**: Es equivalente a `pure` en Kotlin, utilizado para envolver un valor dentro de una mónada.
- **`>>=` (bind)**: Es equivalente a `flatMap` en Kotlin, usado para aplicar una función a un valor monádico y devolver una nueva mónada.

### Definición de la typeclass `Monad` en Haskell

```haskell
class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
```

La typeclass `Monad` define dos operaciones principales: `return`, que coloca un valor en la mónada, y `>>=`, que permite aplicar funciones que devuelven una nueva mónada.

### Implementación de una Mónada Genérica: `MyMonad`

A continuación, veremos cómo implementar una mónada genérica en Haskell, similar al ejemplo de `Monad` en Kotlin.

```haskell
data MyMonad a = MyValue a deriving Show

instance Monad MyMonad where
    return x = MyValue x
    (MyValue x) >>= f = f x
```

En esta implementación:
- **`MyValue`** encapsula el valor, similar a `Monad(value)` en Kotlin.
- **`>>=`** extrae el valor encapsulado en `MyValue`, aplica la función y devuelve un nuevo `MyValue`.

### Ejemplo de uso con `MyMonad`

Aquí está un ejemplo de cómo encadenar varias operaciones usando la mónada genérica `MyMonad`:

```haskell
example :: MyMonad Int
example = return 5 >>= \x ->
          return (x * 2) >>= \y ->
          return (y + 1) >>= \z ->
          return (z `div` 2)
```

El resultado será `MyValue 6`. Aquí, hemos aplicado una serie de transformaciones a un valor monádico de manera segura y sin perder el contexto de la mónada.

### Comparación entre Kotlin y Haskell

| Aspecto                   | Kotlin                  | Haskell                               |
|---------------------------|-------------------------|---------------------------------------|
| **Operaciones Monádicas** | `flatMap`, `pure`       | `>>=`, `return`                       |
| **Sintaxis**              | Notación con `flatMap`  | Operador `>>=` y notación `do`        |
| **Manejo de Contexto**    | Mónadas como `Monad<T>` | Typeclass `Monad` y su implementación |


## JavaScript/TypeScript

En **TypeScript**, aunque no existen mónadas nativas como en Kotlin o Haskell, podemos simular el comportamiento monádico mediante el uso de **Promises** y estructuras personalizadas. Similar a las Promesas en JavaScript, podemos encapsular un valor en un contexto y realizar transformaciones encadenadas utilizando funciones como `then`, que imita a `flatMap`.

### Mónadas en JS/TS: Promesas

Las **Promises** en TypeScript son equivalentes conceptualmente a las mónadas, ya que encapsulan un valor y permiten realizar operaciones sobre él mediante `then`, similar a cómo las mónadas operan en Kotlin con `flatMap`.

### Componentes en JS/TS

#### `pure` (o `unit`)
En TypeScript, podemos crear una función `pure` que envuelve un valor en una Promesa resuelta, de la misma manera que `pure` en Kotlin envuelve un valor en una mónada.

**Ejemplo en TypeScript:**

```typescript showLineNumbers
const pure = <T>(value: T): Promise<T> => Promise.resolve(value);
```

Esto crea una Promesa resuelta con el valor proporcionado, equivalente a `pure` en Kotlin.

#### `flatMap` (o `then`)

El método `then` en TypeScript se puede considerar equivalente a `flatMap` en Kotlin. Permite encadenar transformaciones sobre el valor encapsulado en la Promesa.

**Ejemplo en TypeScript:**

```typescript showLineNumbers
const flatMap = <A, B>(promise: Promise<A>, f: (value: A) => Promise<B>): Promise<B> =>
  promise.then(f);
```

Este `flatMap` toma una Promesa y una función `f` que transforma el valor de la Promesa, devolviendo una nueva Promesa.

### Ejemplo Completo en TypeScript

```typescript showLineNumbers
const pure = <T>(value: T): Promise<T> => Promise.resolve(value);

pure(5)
  .then((x) => pure(x * 2))
  .then((x) => pure(x + 1))
  .then((x) => pure(x / 2))
  .then((x) => pure(x + 1))
  .then(console.log); // Output: 6
```

Este ejemplo muestra cómo utilizar `Promise.resolve` y `then` como equivalentes a `pure` y `flatMap` en Kotlin para encadenar transformaciones de valores encapsulados.

### Tabla Comparativa

| **Característica**     | **Kotlin**                                               | **TypeScript (Promises)**                              |
|------------------------|----------------------------------------------------------|--------------------------------------------------------|
| **`pure`/`unit`**      | `pure` envuelve un valor en una mónada                   | `Promise.resolve` envuelve un valor en una Promesa     |
| **`flatMap`/`then`**   | `flatMap` aplica una función y devuelve una nueva mónada | `then` aplica una función y devuelve una nueva Promesa |
| **Manejo de Contexto** | Mónadas como `Monad<T>`                                  | Promesas como `Promise<T>`                             |

## Scala

En **Scala**, las mónadas se implementan utilizando la combinación de **traits** y métodos como `flatMap`, `map` y `pure`. Las mónadas en Scala se utilizan ampliamente en programación funcional, permitiendo manejar flujos de datos con efectos secundarios o contextos computacionales de manera limpia y eficiente.

### Componentes de las Mónadas en Scala

- **`pure`**: Inserta un valor en una mónada, similar a `pure` en Kotlin y `return` en Haskell.
- **`flatMap`**: Permite aplicar una función a un valor dentro de una mónada, similar a `flatMap` en Kotlin o `>>=` en Haskell.

### Implementación de una Mónada Genérica: `Monad`

En Scala, podemos definir una mónada genérica de la siguiente manera:

```scala
trait Monad[A](value: A) {
  def flatMap[B](f: A => Monad[B]): Monad[B] = f(value)
}

object Monad {
  def pure[A](value: A): Monad[A] = Monad(value)
}
```

En esta implementación:
- **`Monad`** encapsula un valor, similar a `Monad` en Kotlin o `MyMonad` en Haskell.
- **`flatMap`** permite encadenar operaciones que devuelven una nueva instancia de `MyMonad`, manteniendo el contexto monádico.

### Ejemplo de uso con `Monad`

A continuación se muestra cómo encadenar varias transformaciones usando la mónada genérica `Monad` en Scala:

```scala
val result = Monad.pure(5)
  .flatMap(x => Monad.pure(x * 2))
  .flatMap(y => Monad.pure(y + 1))
  .flatMap(z => Monad.pure(z / 2))

println(result) // Imprime: Monad(6)
```

Al igual que en Kotlin y Haskell, este código aplica una serie de transformaciones sobre un valor encapsulado en una mónada, devolviendo un resultado monádico sin perder el contexto.

### Comparación entre Kotlin y Scala

| Aspecto                     | Kotlin                  | Scala                                                                     |
|-----------------------------|-------------------------|---------------------------------------------------------------------------|
| **Operaciones Monádicas**   | `flatMap`, `pure`       | `flatMap`, `pure`                                                         |
| **Manejo de Contexto**      | Mónadas como `Monad<T>` | Mónadas como `Monad[A]`                                                   |
| **Uso de Traits/Typeclass** | No (en este caso)       | No (pero es común el uso de traits como `Monad` en bibliotecas como Cats) |
