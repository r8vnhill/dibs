---
title: Mónadas en otros lenguajes
---

## Haskell

En **Haskell**, las mónadas son definidas utilizando la **typeclass `Monad`**, que especifica cómo deben comportarse los tipos monádicos. Al igual que en Kotlin, las mónadas en Haskell permiten manejar operaciones en contextos computacionales, como el manejo de errores o efectos secundarios, de manera estructurada y segura.

:::note Typeclass
Una **typeclass** en Haskell es un mecanismo que define un conjunto de funciones que deben ser implementadas por los tipos de datos que pertenecen a dicha typeclass. Es comparable a una interfaz en otros lenguajes, pero con mayor flexibilidad, ya que permite la definición de comportamientos compartidos sin modificar los tipos existentes.
:::

### Componentes de la typeclass `Monad` en Haskell

- **`return`**: Es equivalente a `pure` en Kotlin, utilizado para envolver un valor dentro de una mónada.
- **`>>=` (bind)**: Es equivalente a `flatMap` en Kotlin, usado para aplicar una función a un valor monádico y devolver una nueva mónada.

### Definición de la typeclass `Monad` en Haskell

```haskell
class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
```

La typeclass `Monad` define dos operaciones principales: `return`, que coloca un valor en la mónada, y `>>=`, que permite aplicar funciones que devuelven una nueva mónada.

### Implementación de una Mónada Genérica: `MyMonad`

A continuación, veremos cómo implementar una mónada genérica en Haskell, similar al ejemplo de `Monad` en Kotlin.

```haskell
data MyMonad a = MyValue a deriving Show

instance Monad MyMonad where
    return x = MyValue x
    (MyValue x) >>= f = f x
```

En esta implementación:
- **`MyValue`** encapsula el valor, similar a `Monad(value)` en Kotlin.
- **`>>=`** extrae el valor encapsulado en `MyValue`, aplica la función y devuelve un nuevo `MyValue`.

### Ejemplo de uso con `MyMonad`

Aquí está un ejemplo de cómo encadenar varias operaciones usando la mónada genérica `MyMonad`:

```haskell
example :: MyMonad Int
example = return 5 >>= \x ->
          return (x * 2) >>= \y ->
          return (y + 1) >>= \z ->
          return (z `div` 2)
```

El resultado será `MyValue 6`. Aquí, hemos aplicado una serie de transformaciones a un valor monádico de manera segura y sin perder el contexto de la mónada.

### Comparación entre Kotlin y Haskell

| Aspecto                   | Kotlin                  | Haskell                               |
|---------------------------|-------------------------|---------------------------------------|
| **Operaciones Monádicas** | `flatMap`, `pure`       | `>>=`, `return`                       |
| **Sintaxis**              | Notación con `flatMap`  | Operador `>>=` y notación `do`        |
| **Manejo de Contexto**    | Mónadas como `Monad<T>` | Typeclass `Monad` y su implementación |

## Scala

En **Scala**, las mónadas se implementan utilizando la combinación de **traits** y métodos como `flatMap`, `map` y `pure`. Las mónadas en Scala se utilizan ampliamente en programación funcional, permitiendo manejar flujos de datos con efectos secundarios o contextos computacionales de manera limpia y eficiente.

### Componentes de las Mónadas en Scala

- **`pure`**: Inserta un valor en una mónada, similar a `pure` en Kotlin y `return` en Haskell.
- **`flatMap`**: Permite aplicar una función a un valor dentro de una mónada, similar a `flatMap` en Kotlin o `>>=` en Haskell.

### Implementación de una Mónada Genérica: `Monad`

En Scala, podemos definir una mónada genérica de la siguiente manera:

```scala
trait Monad[A](value: A) {
  def flatMap[B](f: A => Monad[B]): Monad[B] = f(value)
}

object Monad {
  def pure[A](value: A): Monad[A] = Monad(value)
}
```

En esta implementación:
- **`Monad`** encapsula un valor, similar a `Monad` en Kotlin o `MyMonad` en Haskell.
- **`flatMap`** permite encadenar operaciones que devuelven una nueva instancia de `MyMonad`, manteniendo el contexto monádico.

### Ejemplo de uso con `Monad`

A continuación se muestra cómo encadenar varias transformaciones usando la mónada genérica `Monad` en Scala:

```scala
val result = Monad.pure(5)
  .flatMap(x => Monad.pure(x * 2))
  .flatMap(y => Monad.pure(y + 1))
  .flatMap(z => Monad.pure(z / 2))

println(result) // Imprime: Monad(6)
```

Al igual que en Kotlin y Haskell, este código aplica una serie de transformaciones sobre un valor encapsulado en una mónada, devolviendo un resultado monádico sin perder el contexto.

### Comparación entre Kotlin y Scala

| Aspecto                     | Kotlin                  | Scala                                                                     |
|-----------------------------|-------------------------|---------------------------------------------------------------------------|
| **Operaciones Monádicas**   | `flatMap`, `pure`       | `flatMap`, `pure`                                                         |
| **Manejo de Contexto**      | Mónadas como `Monad<T>` | Mónadas como `Monad[A]`                                                   |
| **Uso de Traits/Typeclass** | No (en este caso)       | No (pero es común el uso de traits como `Monad` en bibliotecas como Cats) |
