---
title: Either en otros lenguajes
---

## Haskell

En **Haskell**, el manejo de errores se realiza comúnmente utilizando el tipo de datos `Either`, que es muy similar al que hemos implementado en Kotlin. En Haskell, `Either` se define de la siguiente manera:

```haskell
data Either a b = Left a | Right b
```

Este tipo es una definición estándar en Haskell y se utiliza para representar valores que pueden ser de un tipo u otro.

### Uso de `Either` en Haskell

A continuación, veamos cómo se podría utilizar `Either` en Haskell para manejar errores al leer un archivo:

```haskell
import System.IO.Error (tryIOError, IOError)

readFileEither :: FilePath -> IO (Either IOError String)
readFileEither path = tryIOError (readFile path)

processFile :: FilePath -> IO ()
processFile path = do
    result <- readFileEither path
    case result of
        Left err -> putStrLn $ "Error: " ++ show err
        Right content -> putStrLn content
```

En este ejemplo:

- **`tryIOError`** es una función que intenta ejecutar una acción de E/S y captura cualquier `IOError`, devolviendo un `Either IOError a`.
- La función `readFileEither` intenta leer un archivo y devuelve un `Either` que contiene un `IOError` en caso de fallo o el contenido del archivo en caso de éxito.
- En `processFile`, usamos una expresión `case` para manejar ambos casos de manera explícita.

### Comparación con Kotlin

- **Sintaxis y Tipado**: Mientras que en Kotlin necesitamos definir nuestro propio tipo `Either` o utilizar una biblioteca externa, en Haskell `Either` es parte de la biblioteca estándar. Además, Haskell, al ser un lenguaje puramente funcional con un sistema de tipos avanzado, facilita el manejo y composición de estos tipos.
- **Manejo de Errores**: Ambos lenguajes fomentan el manejo explícito de errores utilizando `Either`, evitando las excepciones y haciendo que los errores sean parte del tipo de retorno de las funciones.
- **Composición**: Haskell ofrece funciones integradas y operadores para trabajar con `Either`, permitiendo una composición más fluida de funciones que pueden fallar.

### Ventajas de `Either` en Haskell

1. **Soporte Nativo**: `Either` es un tipo de datos estándar en Haskell, lo que significa que no es necesario definirlo o importarlo de una biblioteca externa.
2. **Funciones Utilitarias**: Haskell proporciona numerosas funciones utilitarias para trabajar con `Either`, como `either`, `lefts`, `rights`, y patrones de uso con `Monad` y `Functor`.
3. **Integración con el Sistema de Tipos**: El sistema de tipos de Haskell permite aprovechar al máximo `Either` para manejar errores de forma segura y expresiva.

### Equivalencia con Kotlin

Aunque Kotlin no es un lenguaje puramente funcional, podemos aplicar los mismos principios utilizando `Either`. Sin embargo, debemos implementar algunas funcionalidades adicionales o utilizar bibliotecas como [**Arrow**](https://arrow-kt.io) para obtener soporte completo para operaciones funcionales con `Either`.

## Comparación con TypeScript

En **TypeScript**, aunque no existe un tipo `Either` nativo como en Haskell, podemos modelar un comportamiento similar utilizando **Unión de Tipos** y **objetos discriminados**. TypeScript permite definir tipos que pueden ser uno de varios valores, lo que nos permite imitar la semántica de `Either`.

### Implementación de `Either` en TypeScript

Podemos crear una implementación de `Either` en TypeScript utilizando una unión de tipos para representar `Left` y `Right`.

```typescript
type Either<L, R> =
  | { type: 'Left'; value: L }
  | { type: 'Right'; value: R };

function left<L, R>(value: L): Either<L, R> {
  return { type: 'Left', value };
}

function right<L, R>(value: R): Either<L, R> {
  return { type: 'Right', value };
}

function readFileEither(path: string | null): Either<Error, string> {
  if (!path) {
    return left(new Error("Invalid file path"));
  } else {
    return right("File content"); // Simulating file content
  }
}

function processFile(path: string | null) {
  const result = readFileEither(path);

  if (result.type === 'Left') {
    console.log(`Error: ${result.value.message}`);
  } else {
    console.log(result.value);
  }
}

// Usage
processFile(null); // Error: Invalid file path
processFile("validPath.txt"); // File content
```

### Comparación con Kotlin

- **Tipado Unificado vs Clases Selladas**: En Kotlin, `Either` se define como una clase sellada con los tipos `Left` y `Right`. En TypeScript, podemos lograr una representación similar utilizando **uniones de tipos** y **discriminadores** (con la propiedad `type`). Aunque el enfoque es diferente, ambos lenguajes permiten representar la idea de un valor que puede ser de uno de dos tipos.

- **Patrones de Manejo de Errores**: En TypeScript, es necesario usar comprobaciones condicionales (`if` o `switch`) para manejar `Left` y `Right`, mientras que en Kotlin, se puede utilizar `when` de forma más idiomática para patrones de coincidencia más expresivos.

- **Composición**: Aunque es posible componer funciones que devuelven `Either` en TypeScript, el lenguaje no ofrece funciones utilitarias como `flatMap` o `map` por defecto. En Kotlin, podemos implementar fácilmente estas funciones como métodos en `Either`, o utilizar bibliotecas como **Arrow** que ya proporcionan estas utilidades.

### Ventajas de `Either` en TypeScript

1. **Simplicidad**: En TypeScript, el sistema de tipos permite representar `Either` de forma sencilla con uniones de tipos sin necesidad de definir estructuras avanzadas.
2. **Flexibilidad**: TypeScript no impone un enfoque específico para el manejo de errores, lo que significa que puedes optar por usar `Either`, excepciones, o cualquier otro mecanismo adecuado para tu proyecto.
3. **Interoperabilidad**: El enfoque de `Either` en TypeScript puede integrarse bien con las API existentes, que a menudo devuelven `Promise` o utilizan otros mecanismos de manejo de errores.

### Desventajas en TypeScript

- **Falta de Soporte Nativo**: A diferencia de Kotlin (con bibliotecas funcionales como **Arrow**) o Haskell, TypeScript no ofrece un soporte nativo o herramientas funcionales avanzadas para trabajar con `Either`, por lo que algunos patrones pueden ser más verbosos o requerir bibliotecas externas.

### Equivalencia con Kotlin

Ambos lenguajes permiten manejar errores de manera explícita utilizando un enfoque funcional con `Either`. Sin embargo, mientras que Kotlin ofrece un soporte más robusto con clases selladas y herramientas adicionales, TypeScript logra un enfoque flexible usando uniones de tipos y objetos discriminados, aunque con menos capacidades funcionales nativas.
