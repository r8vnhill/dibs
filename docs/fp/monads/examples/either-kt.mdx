---
title: Either
---
import LanguageCard from "../../../../src/components/cards/LanguageCard";
import Exercise from "../../../../src/components/exercise/Exercise";
import GitHubRepoLink from "../../../../src/components/GithubRepoLink";
import ReadingTime from "../../../../src/components/ReadingTime";
import References from "../../../../src/components/ReferencesComponent";
import Solution from "../../../../src/components/exercise/Solution";
import CheckedExceptions from "../../../../src/pages/fp/monads/examples/checked-exceptions.mdx";
import LInvariance from "../../../../src/pages/fp/monads/examples/l-invariance.mdx";
import Tooltip from "../../../../src/components/Tooltip";

<ReadingTime/>
<GitHubRepoLink repo={"functional-programming-kt"} user={"r8vnhill"}/>

Como vimos en la lección sobre [tipos suma](docs/fp/adt/sum/index.mdx), **Either** es un tipo de dato que se utiliza para representar uno de dos posibles valores: `Left` o `Right`. Es comúnmente empleado para manejar operaciones que pueden tener dos resultados: un valor esperado (`Right`) o un error o situación inesperada (`Left`).

:::tip Nemotécnica
"``Right`` is right, ``Left`` is what's left."
:::

## El problema con las excepciones

> "But why do we consider throwing exceptions bad? Why is it not the desired effect? The answer has much to do with a loss of control."
> — *Vermeulen, et al. (2021)*

El <Tooltip text={"Al menos desde una perspectiva de programación funcional."} highlight={true}>problema con las excepciones</Tooltip> radica en que no son **referencialmente transparentes**. Esto significa que no se pueden reemplazar por su valor sin alterar el comportamiento del programa. Veamos un ejemplo:

```kotlin showLineNumbers
fun failingFn(i: Int): Int {
    val y: Int = throw Exception("boom")
    return try {
        val x = 420
        x + y
    } catch (e: Exception) {
        0
    }
}
```

En este caso, `y` no es referencialmente transparente, porque no podemos sustituir su valor por `throw Exception("boom")` dentro de la expresión `x + y` sin modificar el resultado del programa. Si lo hacemos, la excepción se lanzará inmediatamente dentro del bloque `try-catch`, cambiando el flujo de ejecución y, por ende, el comportamiento del código.

## Beneficios de `Either`

- **Manejo explícito de errores**: `Either` proporciona un enfoque más seguro y estructurado para el manejo de errores que las excepciones tipadas. Al incluir explícitamente el caso de éxito o error en el tipo, se fuerza a lxs desarrolladorxs a manejar ambos casos, evitando que los errores se "pierdan" o sean ignorados accidentalmente.
- **Facilidad de composición**: `Either` permite componer funciones que pueden fallar sin necesidad de capturar excepciones. En lugar de lanzar una excepción, las funciones pueden devolver un valor de tipo `Either`, lo que facilita el encadenamiento de operaciones sin necesidad de un manejo de errores explícito en cada paso.
- **Código más claro**: Utilizar `Either` hace que el flujo de datos sea más legible y el manejo de errores más evidente, en comparación con las excepciones, donde el flujo de errores puede ser implícito y difícil de seguir.

<details>
    <summary>Comparación con checked exceptions en Java</summary>

    <CheckedExceptions/>
</details>

## Implementación

Para implementar **Either** en Kotlin podemos utilizar una clase sellada para representar los dos posibles casos (`Left` y `Right`):

```kotlin
sealed class Either<L, out R> {
    inline fun <T> flatMap(f: (R) -> Either<L, T>): Either<L, T> = when (this) {
        is Left -> this
        is Right -> f(value)
    }

    companion object {
        fun <L, R> pure(value: R): Either<L, R> = Right(value)
    }
}
```

<details>
    <summary>¿Por qué `L` es invariante?</summary>

    <LInvariance/>
</details>

### Clases `Left` y `Right`

- **Left**: Representa el caso fallido o un error. Contiene un valor de tipo`L`.
    ```kotlin
    data class Left<L>(val value: L) : Either<L, Nothing>()
    ```

- **Right**: Representa el caso exitoso. Contiene un valor de tipo`R`.
    ```kotlin
    data class Right<R>(val value: R) : Either<Nothing, R>()
    ```

<Exercise title={`Uso de Nothing`}>
    ¿Por qué el primero y segundo parámetro de de ``Right`` y ``Left`` respectivamente son de tipo `Nothing`?

    <Solution>
        Es una forma de decir que el tipo de dato no se usa en ese caso. En el caso de `Left`, el valor de tipo `R` no se usa, por lo que se usa `Nothing` en su lugar. De manera similar, en el caso de `Right`, el valor de tipo `L` no se usa, por lo que se usa `Nothing`.
    </Solution>
</Exercise>

## Ejemplo de Uso

Supongamos que estamos trabajando con una operación que puede fallar. Queremos encapsular el éxito con `Right` y el error con `Left`:

```kotlin
fun readFileEither(path: String?): Either<Exception, String> = path?.let {
    Right("File content") // Simulando el contenido del archivo
} ?: Left(Exception("Invalid file path"))

fun processFile(path: String?) {
    val result = readFileEither(path)

    when (result) {
        is Left -> println("Error: ${result.value.message}")
        is Right -> println(result.value)
    }
}

// Uso
processFile(null) // Error: Invalid file path
processFile("validPath.txt") // File content
```

En este ejemplo:
- Si el `path` es `null`, `readFileEither` devuelve un `Left` con un mensaje de error.
- Si el `path` no es `null`, `readFileEither` devuelve un `Right` con el contenido del archivo.

:::note Uso de ``Exception``
En este caso, estamos utilizando `Exception` como tipo de error. En un escenario real, se recomienda definir un tipo de error más específico que proporcione más contexto sobre el fallo.
:::

## Comparación con `Option`

- **Either** permite manejar más casos de uso al tener dos posibles resultados (`Left` y`Right`), mientras que`Option` solo modela la presencia o ausencia de un valor.
- **Either** es preferido cuando es importante tener más contexto sobre el error o el resultado fallido, en lugar de solo saber si un valor está presente como en el caso de`Option`.

<Exercise title="Extendiendo Either">
    Implementa las funciones:
    - ``fold: (Either<A, B>, (A) -> C, (B) -> C): C``: Aplica una función a cada caso de `Either` y devuelve el resultado. Si es `Left`, aplica la primera función, si es `Right`, aplica la segunda.
    - ``swap: (Either<L, R>) -> Either<R, L>``: Intercambia los valores de `Left` y `Right`.

    <Solution>
        ```kotlin
        fun <L, R> fold(
            either: Either<L, R>,
            ifLeft: (L) -> Unit,
            ifRight: (R) -> Unit
        ) = when (either) {
            is Left -> ifLeft(either.value)
            is Right -> ifRight(either.value)
        }
        ```

        ```kotlin
        fun <L, R> swap(either: Either<L, R>): Either<R, L> = when (either) {
            is Left -> Right(either.value)
            is Right -> Left(either.value)
        }
        ```
    </Solution>
</Exercise>

## ¿Qué hemos aprendido?

En esta lección hemos explorado el uso de **Either** como una poderosa alternativa para manejar errores y representar casos de éxito o falla en operaciones que pueden tener más de un resultado posible.

### Puntos clave:
- **Either** proporciona una forma clara y explícita de manejar errores sin recurrir a excepciones.
- El uso de **Right** para el caso exitoso y **Left** para el caso fallido permite un manejo estructurado de los resultados.
- Con **Either**, evitamos el flujo implícito de errores que se puede producir con excepciones, forzando el manejo explícito de todos los casos posibles.
- Hemos comparado el enfoque de **Either** con el manejo de excepciones tipadas en Java, mostrando cómo Kotlin ofrece una solución más funcional y limpia.
- También hemos discutido cómo **Either** se diferencia de **Option**, siendo más adecuado cuando se necesita proporcionar contexto adicional en caso de error.

Con estas ideas, ahora puedes aplicar **Either** en escenarios que requieran un manejo explícito de errores y evitar la propagación oculta de fallos en tu código.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/6/66/F_Sharp_logo.svg"
        language="F#"
        link="/fp/monads/examples/either/fsharp"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/1200px-Haskell-Logo.svg.png"
        language="Haskell"
        link="/fp/monads/examples/either/haskell"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="/fp/monads/examples/either/scala"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/2048px-Typescript_logo_2020.svg.png"
        language="TypeScript"
        link="/fp/monads/examples/either/typescript"
    />
</div>

<References references={[
    {
        publisher: "Manning Publications",
        pages: "56–76",
        type: "book",
        title: "4. Handling errors without exceptions",
        author: "Marco Vermeulen, Rúnar Bjarnason, Paul Chiusano",
        year: 2021,
        bookTitle: "Functional Programming in Kotlin"
    },
    {
        title: "6. Simple Algebraic Data Types",
        type: "book",
        bookTitle: "Category Theory for Programmers",
        author: "Bartosz Milewski",
        pages: "55–68",
        publisher: "Millington Keynes",
        year: "2019",
        location: "Lightning Source UK",
    },
]}/>
