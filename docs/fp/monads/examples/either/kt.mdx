---
title: La m√≥nada Either
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import Tooltip from '@site/src/components/Tooltip'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="functional-programming-kt" />
<ModuleSetup module='either' task='setupEitherModule'>
    ```Kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupEitherModule") {
        description = "Creates the base module and files for the either lesson"
        module.set("monads:either")

        doLast {
            createFiles(
                "either",
                main to "Either.kt",
                main to "EitherMonad.kt",
                main to "validatePassword.kt",
                test to "EitherMonadTest.kt"
            )
        }
    }
    ```
</ModuleSetup>

Como vimos en la lecci√≥n sobre [tipos suma](docs/fp/adt/sum/index.mdx), **`Either`** es una construcci√≥n que representa un valor que puede tener **una de dos formas**: `Left` o `Right`. Este tipo es especialmente √∫til cuando una operaci√≥n puede **fallar o tener √©xito**, ya que permite capturar expl√≠citamente ambos casos en el tipo de retorno.

En la pr√°ctica funcional, `Either` se usa para modelar funciones que pueden devolver un resultado v√°lido (`Right`) o un error (`Left`) sin recurrir a excepciones, facilitando as√≠ un c√≥digo m√°s **seguro, predecible y composable**.

:::tip Nemot√©cnica

"``Right`` is right, ``Left`` is what's left."

:::

## üìâ El problema con las excepciones

> "¬øPero por qu√© consideramos que lanzar excepciones es algo negativo? ¬øPor qu√© no es el efecto deseado?
> La respuesta tiene mucho que ver con la p√©rdida de control."
> ‚Äî *Vermeulen, et al. (2021)*

El <Tooltip text={"Al menos desde una perspectiva de programaci√≥n funcional."} highlight={true}>problema con las excepciones</Tooltip> radica en que no son **referencialmente transparentes**. Esto significa que no se pueden reemplazar por su valor sin alterar el comportamiento del programa. Veamos un ejemplo:

```kotlin showLineNumbers
fun failingFn(): Int {
    val y: Int = throw Exception("boom")
    return try {
        val x = 420
        x + y
    } catch (e: Exception) {
        0
    }
}
```

En este caso, `y` no es referencialmente transparente, porque no podemos sustituir su valor por `throw Exception("boom")` dentro de la expresi√≥n `x + y` sin modificar el resultado del programa. Si lo hacemos, la excepci√≥n se lanzar√° inmediatamente dentro del bloque `try-catch`, cambiando el flujo de ejecuci√≥n y, por ende, el comportamiento del c√≥digo.

<details>
    <summary>Comparaci√≥n con checked exceptions en Java</summary>

    En **Java**, las **checked exceptions** imponen que cualquier funci√≥n que pueda lanzar una excepci√≥n verificada debe manejarse expl√≠citamente con un bloque `try-catch` o declararla en la firma del m√©todo usando `throws`. Este enfoque introduce complicaciones cuando se utilizan **funciones de orden superior**, ya que no es posible determinar si estas funciones, que pueden aceptar otras funciones como par√°metros o devolverlas, lanzar√°n una excepci√≥n verificada. Esto se debe a que el contexto donde se llama a la funci√≥n no puede prever ni manejar las excepciones que podr√≠an ser arrojadas. A continuaci√≥n, un ejemplo t√≠pico de **checked exceptions** en Java:

    ```java showLineNumbers
    public String readFile(String path) throws IOException {
        if (path == null) {
            throw new IOException("Invalid file path");
        }
        return "File content";
    }

    public void processFile(String path) {
        try {
            String content = readFile(path);
            System.out.println(content);
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
    ```

    En este ejemplo, el m√©todo `readFile` lanza una `IOException`, que es una excepci√≥n verificada, y el llamador de este m√©todo, `processFile`, debe manejar expl√≠citamente la excepci√≥n con `try-catch`.

    #### Problema con las Funciones de Orden Superior

    El uso de **checked exceptions** en combinaci√≥n con funciones de orden superior se vuelve problem√°tico porque no es posible saber si una funci√≥n pasar√° una excepci√≥n verificada cuando se llame desde un contexto distinto. Por ejemplo, si intentamos pasar una funci√≥n que arroja una excepci√≥n verificada a un m√©todo de orden superior, el compilador no puede inferir si ese m√©todo debe declarar la excepci√≥n o manejarla. Esto limita la flexibilidad de la programaci√≥n funcional en Java y otros lenguajes con excepciones verificadas.

    ```java showLineNumbers
    @FunctionalInterface
    interface FileProcessor {
        void process(String path) throws IOException;
    }

    public void handleFile(FileProcessor processor) {
        // How does the compiler know that "processor" throws a checked exception?
    }
    ```

    El compilador no puede verificar si `FileProcessor` lanzar√° una excepci√≥n verificada, lo que obliga a manejar manualmente las excepciones, lo que rompe la fluidez de la composici√≥n de funciones.

    #### Alternativa en Kotlin sin Excepciones Verificadas

    En **Kotlin**, no existen **checked exceptions**, lo que permite un enfoque m√°s flexible y funcional. Sin embargo, esto significa que se deben manejar las excepciones de manera expl√≠cita, por ejemplo, usando patrones de error como `Either`.
</details>

## üìú Leyes de las M√≥nadas

Para validar que nuestra implementaci√≥n cumple con las **leyes de las m√≥nadas**, definimos pruebas para las tres leyes: **identidad izquierda**, **identidad derecha**, y **asociatividad**. Estas pruebas nos aseguran que la estructura mon√°dica se comporta como se espera en cualquier caso.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>

        #### Ley de Asociatividad

        ```kotlin showLineNumbers
        checkAll(Arb.int(), Arb.int()) { a, b ->
            EitherMonad.run {
                val f: (Int) -> Either<Throwable, Int> = { pure(it * b) }
                val g: (Int) -> Either<Throwable, Int> = { pure(it + a) }
                pure<Throwable, Int>(a).flatMap(f).flatMap(g) shouldBe
                    pure<Throwable, Int>(a).flatMap { f(it).flatMap(g) }
            }
        }
        ```

        #### Ley de Identidad Derecha

        ```kotlin showLineNumbers
        checkAll(Arb.int()) { a ->
            EitherMonad.run {
                pure<Throwable, Int>(a).flatMap { pure(it) } shouldBe pure(a)
            }
        }
        ```

        #### Ley de Identidad Izquierda

        ```kotlin showLineNumbers
        checkAll(Arb.int(), Arb.int()) { a, b ->
            EitherMonad.run {
                val f: (Int) -> Either<Throwable, Int> = { pure(it * b) }
                pure<Throwable, Int>(a).flatMap(f) shouldBe f(a)
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="monads/either/src/test/kotlin/com/github/username/either/EitherMonadTest.kt"
        package com.github.username.either

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.int
        import io.kotest.property.checkAll

        class EitherMonadTest : FreeSpec({

            "Given a right" - {
                // Left identity
                "when a value is wrapped in the monadic context" - {
                    ("then chaining a function should yield the same result as " +
                            "directly applying the function") {
                        checkAll(Arb.int(), Arb.int()) { a, b ->
                            EitherMonad.run {
                                val f: (Int) -> Either<Throwable, Int> = { pure(it * b) }
                                pure<Throwable, Int>(a).flatMap(f) shouldBe f(a)
                            }
                        }
                    }
                }

                // Right identity
                "when chaining with a function that returns the original context" - {
                    "then the result should remain unchanged in the monadic context" {
                        checkAll(Arb.int()) { a ->
                            EitherMonad.run {
                                pure<Throwable, Int>(a).flatMap { pure(it) } shouldBe pure(a)
                            }
                        }
                    }
                }

                // Associativity
                "when chaining two functions sequentially" - {
                    ("then the result should be consistent with first chaining one " +
                            "function and then the next") {
                        checkAll(
                            Arb.int(),
                            Arb.int(),
                            Arb.int()
                        ) { a, b, c ->
                            EitherMonad.run {
                                val f: (Int) -> Either<Throwable, Int> = { pure(it * b) }
                                val g: (Int) -> Either<Throwable, Int> = { pure(it + c) }
                                pure<Throwable, Int>(a).flatMap(f).flatMap(g) shouldBe
                                        pure<Throwable, Int>(a).flatMap { f(it).flatMap(g) }
                            }
                        }
                    }
                }
            }

            "Given a left" - {
                "when mapping a function" - {
                    "then the result should be the same left" {
                        checkAll(Arb.int()) { a ->
                            EitherMonad.run {
                                val f: (Int) -> Int = { it * 2 }
                                Left(a).flatMap { Right(f(it)) } shouldBe Left(a)
                            }
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Ley de identidad izquierda**: Asegura que envolver un valor y luego aplicarle una funci√≥n es lo mismo que aplicar la funci√≥n directamente al valor.
    - **Ley de identidad derecha**: Garantiza que aplicar una funci√≥n que simplemente envuelve el valor no cambia el contexto original.
    - **Ley de asociatividad**: Verifica que la secuencia de aplicaci√≥n de funciones encadenadas produce el mismo resultado, independientemente del orden de agrupaci√≥n de las funciones.
</Explanation>

## üèóÔ∏è Implementaci√≥n

### ‚öñÔ∏è Implementando Either

Para implementar **Either** en Kotlin podemos utilizar una clase sellada para representar los dos posibles casos (`Left` y `Right`):

```kotlin showLineNumbers title="monads/src/main/kotlin/com/github/username/either/Either.kt"
package com.github.username.either

sealed class Either<out L, out R>

data class Left<L>(val value: L) : Either<L, Nothing>()

data class Right<R>(val value: R) : Either<Nothing, R>()
```

### üß© Implementando la m√≥nada Either

```kotlin showLineNumbers title="monads/src/main/kotlin/com/github/username/either/EitherMonad.kt"
package com.github.username.either

object EitherMonad {
    fun <L, R> pure(r: R): Either<L, R> = Right(r)

    fun <L, R, T> Either<L, R>.flatMap(f: (R) -> Either<L, T>): Either<L, T> = when (this) {
        is Left -> this
        is Right -> f(value)
    }
}
```

## üõ†Ô∏è Ejemplo de uso

En este ejemplo, vamos a implementar un caso sencillo de **`Either`** para manejar operaciones que pueden fallar, utilizando las funciones **`pure`** y **`flatMap`** para trabajar con la m√≥nada **`Either`**.

Imaginemos que tenemos dos funciones de validaci√≥n: una que verifica la longitud de una contrase√±a y otra que valida si la contrase√±a contiene al menos un n√∫mero. Nuestro objetivo es encadenar estas validaciones de manera que, si una falla, la otra no se ejecute. En este caso, devolveremos un `Left` con el mensaje de error apropiado. Si todas las validaciones se superan, obtendremos un `Right` con la contrase√±a v√°lida.

```kotlin showLineNumbers
package com.github.username.either

private fun validateLength(password: String) =
    if (password.length >= 8) Right(password)
    else Left("Password is too short")

private fun validateContainsNumber(password: String) =
    if (password.any { it.isDigit() }) Right(password)
    else Left("Password must contain a number")

fun validatePassword(password: String) = EitherMonad.run {
    pure<String, _>(password)
        .flatMap(::validateLength)
        .flatMap(::validateContainsNumber)
}

fun main() {
    println(validatePassword("1234567"))  // Left(value=Password is too short)
    println(validatePassword("12345678")) // Right(value=12345678)
}
```

Este patr√≥n es particularmente √∫til cuando queremos manejar flujos de operaciones secuenciales que pueden fallar, como validaciones, operaciones de entrada/salida, o cualquier proceso en el que preferimos evitar el uso de excepciones. Con **`Either`**, podemos modelar el √©xito o el fracaso de cada paso de forma segura y estructurada.

<Explanation>
    En este ejemplo, utilizamos la m√≥nada **`Either`** para validar una contrase√±a, aplicando dos funciones de validaci√≥n secuenciales. Si alguna de las validaciones falla, se devuelve un `Left` con un mensaje de error. Si todas las validaciones son exitosas, se devuelve un `Right` con la contrase√±a v√°lida.    
</Explanation>

## ‚úÖ Beneficios y ‚ùå limitaciones de Either

<ProCons>
    <Pros>
        - **Manejo expl√≠cito de errores**: Permite modelar los errores de manera clara y estructurada, evitando el uso de excepciones y haciendo que los errores sean parte del tipo de retorno.
        - **Mejor composici√≥n**: `Either` facilita la composici√≥n funcional de operaciones que pueden fallar, utilizando `flatMap` para encadenar transformaciones sin afectar el flujo del programa.
        - **Referencialmente transparente**: A diferencia de las excepciones, `Either` mantiene la predictibilidad de las funciones, ya que no altera el flujo de control de forma oculta.
        - **No propaga excepciones inesperadas**: Los errores se manejan expl√≠citamente mediante `Left`, lo que evita sorpresas en tiempo de ejecuci√≥n debido a excepciones no controladas.
        - **Facilita el testing**: Al hacer que los errores sean valores expl√≠citos, las pruebas pueden centrarse en los diferentes resultados posibles sin necesidad de depender de excepciones.
    </Pros>
    <Cons>
        - **Mayor verbosidad**: Requiere envoltura expl√≠cita en `Left` y `Right`, lo que puede hacer que el c√≥digo sea m√°s extenso en comparaci√≥n con el uso de excepciones o `Result`.
        - **Curva de aprendizaje**: Para quienes est√°n acostumbradxs a excepciones, puede tomar tiempo adoptar `Either` y acostumbrarse a su uso con funciones como `map` y `flatMap`.
        - **Puede ser innecesario en casos simples**: Para operaciones donde solo se necesita representar la ausencia de un valor, `Option` puede ser m√°s adecuado y menos verboso.
        - **No previene la omisi√≥n del manejo de errores**: Aunque obliga a manejar ambos casos (`Left` y `Right`), sigue siendo posible ignorar el error.
    </Cons>
</ProCons>

## ‚öñÔ∏è Comparaci√≥n con otras estructuras

### üîç Comparaci√≥n con `Option`

Tanto **Either** como **Option** son tipos algebraicos de datos en Kotlin que nos permiten manejar de manera segura operaciones que pueden no devolver un resultado exitoso. Aunque ambos sirven para modelar la ausencia o presencia de un valor, **Either** se utiliza principalmente cuando queremos capturar m√°s informaci√≥n sobre el fallo, mientras que **Option** es m√°s simple y se usa cuando el error no importa tanto.

#### Option

- **Prop√≥sito**: Modela la **presencia o ausencia** de un valor. Se usa en casos donde puede no haber un resultado, pero no nos importa mucho el por qu√©.
- **Construcci√≥n**: Puede ser **`Some`** (cuando el valor est√° presente) o **`None`** (cuando no hay valor).
- **Uso t√≠pico**: Se utiliza cuando el **fallo** o la **ausencia de valor** no es el punto central y no se necesita m√°s informaci√≥n sobre por qu√© no se devolvi√≥ un valor.
- **Manejo de la ausencia**: La falta de un valor en `Option` no contiene informaci√≥n adicional, simplemente indica que no hay nada.

#### Either

- **Prop√≥sito**: Modela dos resultados posibles: un **√©xito** o un **fallo**, representados por `Right` y `Left`, respectivamente.
- **Construcci√≥n**: Se construye con dos variantes: **`Left`** para el fallo y **`Right`** para el √©xito.
- **Uso t√≠pico**: Se usa cuando es importante conocer la raz√≥n por la cual no se obtuvo un resultado exitoso, proporcionando un mensaje de error o un c√≥digo que explique el fallo.
- **Manejo del fallo**: El uso de `Left` permite contener informaci√≥n √∫til sobre el error, lo que lo convierte en una opci√≥n m√°s poderosa para manejar fallos expl√≠citamente.

### ‚ö° Comparaci√≥n con `Result`

Al comparar **Either** y **Result**, encontramos que ambos tipos son √∫tiles para modelar resultados que pueden tener √©xito o fallar, pero existen diferencias clave en cuanto a su prop√≥sito, uso y c√≥mo gestionan los errores.

#### Either

- **Generalidad**: `Either` es un tipo gen√©rico que puede representar cualquier tipo de resultado, no solo √©xito o fallo. En el contexto de fallos, `Left` puede contener un error o una situaci√≥n inesperada, mientras que `Right` contiene el resultado exitoso.
- **Similitud con excepciones verificadas**: `Either` se puede comparar con las **excepciones verificadas** en lenguajes como Java, donde se requiere que los errores sean manejados expl√≠citamente. Al usar `Either`, debes manejar tanto el caso de `Left` como el de `Right`, obligando a quien desarrolla a tratar los errores de manera expl√≠cita.

#### Result

- **Especializaci√≥n**: `Result` est√° dise√±ado espec√≠ficamente para modelar operaciones que pueden tener √©xito o fallo. Al usar `Result`, los errores se manejan mediante excepciones, lo que hace que sea m√°s adecuado para capturar fallos inesperados, como errores de tiempo de ejecuci√≥n o fallos no planeados.
- **Similitud con excepciones no verificadas**: `Result` se asemeja a las **excepciones no verificadas** (unchecked exceptions) en lenguajes como Kotlin y Java, donde los errores pueden ser propagados sin ser manejados expl√≠citamente. Esto permite que el c√≥digo que usa `Result` sea m√°s fluido, pero tambi√©n significa que los errores pueden ser ignorados si no se manejan correctamente.

### üìä Resumen comparativo

| **Caracter√≠stica**            | **Either**                              | **Option**                            | **Result**                              |
|------------------------------|----------------------------------------|--------------------------------------|----------------------------------------|
| **Prop√≥sito**                | Modela √©xito (`Right`) o fallo (`Left`) | Modela presencia (`Some`) o ausencia (`None`) | Modela √©xito (`Success`) o fallo (`Failure`) |
| **Captura de errores**       | Expl√≠cita (`Left` contiene error)       | Impl√≠cita (`None` indica ausencia)  | Impl√≠cita (`Failure` encapsula excepci√≥n) |
| **Informaci√≥n del fallo**    | Rica (permite mensajes detallados)     | Nula (solo indica que no hay valor) | Rica (contiene la excepci√≥n lanzada)  |
| **Similitud con excepciones** | Similar a excepciones verificadas (checked) | No modela errores expl√≠citos        | Similar a excepciones no verificadas (unchecked) |
| **Casos de uso**             | Validaciones, errores controlados      | Valores opcionales, ausencia esperada | Operaciones propensas a fallos inesperados |

## üìù Ejercicio: Extendiendo Either

<Exercise>
    Implementa las funciones:
    - ``fold: (Either<A, B>, (A) -> C, (B) -> C): C``: Aplica una funci√≥n a cada caso de `Either` y devuelve el resultado. Si es `Left`, aplica la primera funci√≥n, si es `Right`, aplica la segunda.
    - ``swap: (Either<L, R>) -> Either<R, L>``: Intercambia los valores de `Left` y `Right`. Utiliza la funci√≥n `fold` para implementar `swap`.

    <Solution>
        ```kotlin title="monads/src/main/kotlin/com/github/username/either/EitherMonad.kt"
        fun <A, B, C> Either<A, B>.fold(
            ifLeft: (A) -> C,
            ifRight: (B) -> C
        ) = when (this) {
            is Left -> ifLeft(value)
            is Right -> ifRight(value)
        }
        ```

        ```kotlin title="monads/src/main/kotlin/com/github/username/either/EitherMonad.kt"
        fun <A, B> Either<A, B>.swap() = fold(
            ifLeft = ::Right,
            ifRight = ::Left
        )
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

La m√≥nada **Either** proporciona una alternativa clara y funcional para el manejo de errores en Kotlin sin recurrir a excepciones. Su enfoque basado en `Left` y `Right` permite representar tanto fallos como √©xitos de forma expl√≠cita, facilitando la composici√≥n de funciones y garantizando mayor seguridad en el flujo del programa.

A lo largo de la lecci√≥n, hemos explorado su implementaci√≥n, las **leyes mon√°dicas** que cumple, y su comparaci√≥n con estructuras similares como `Option` y `Result`. Tambi√©n hemos analizado sus beneficios y limitaciones, as√≠ como ejemplos pr√°cticos de uso.

### üîë Puntos clave

- **Manejo expl√≠cito de errores**: `Either` encapsula tanto el √©xito como el fallo dentro de su tipo de retorno, evitando excepciones inesperadas.
- **Composici√≥n funcional**: Facilita la aplicaci√≥n secuencial de operaciones mediante `flatMap`, permitiendo encadenar transformaciones de forma segura.
- **Referencialmente transparente**: A diferencia de las excepciones, el uso de `Either` no interrumpe el flujo del programa ni introduce efectos laterales inesperados.
- **Comparaci√≥n con otras estructuras**: Mientras que `Option` modela la presencia o ausencia de un valor y `Result` encapsula excepciones, `Either` es m√°s flexible y adecuado para manejar fallos de manera detallada.

### üß∞ ¬øQu√© nos llevamos?

El uso de `Either` en Kotlin nos invita a repensar la forma en que manejamos los errores y estructuramos nuestro c√≥digo. En lugar de depender de excepciones, que pueden ser dif√≠ciles de rastrear y manejar de manera segura, `Either` nos permite modelar expl√≠citamente tanto el √©xito como el fallo dentro del tipo de retorno de una funci√≥n. Esta aproximaci√≥n no solo mejora la predictibilidad y seguridad del c√≥digo, sino que tambi√©n promueve una composici√≥n m√°s clara y fluida.

Si bien `Either` puede parecer m√°s verboso en comparaci√≥n con otros enfoques, su capacidad para hacer que los errores sean expl√≠citos y tratables justifica su uso en contextos donde la confiabilidad y la claridad del flujo del programa son esenciales. Adoptarlo implica un cambio de mentalidad hacia un dise√±o m√°s declarativo, donde los errores no son interrupciones inesperadas, sino valores manejables dentro del propio lenguaje de nuestro c√≥digo.

Al finalizar esta lecci√≥n, queda claro que `Either` es m√°s que una alternativa a las excepciones: es una herramienta que nos permite escribir software m√°s robusto, predecible y alineado con los principios de la programaci√≥n funcional. Su uso consciente nos lleva a dise√±ar aplicaciones en las que el manejo de errores no es un obst√°culo, sino una parte integral del flujo de ejecuci√≥n. 

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/6/66/F_Sharp_logo.svg"
        language="F#"
        link="/docs/fp/monads/examples/either/fsharp"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/1200px-Haskell-Logo.svg.png"
        language="Haskell"
        link="/docs/fp/monads/examples/either/haskell"
    />
    <LanguageCard
        logoSrc="https://www.svgssrepo.com/show/373945/ocaml.svg"
        language="OCaml"
        link="/docs/fp/monads/examples/either/ocaml"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="/docs/fp/monads/examples/either/scala"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/2048px-Typescript_logo_2020.svg.png"
        language="TypeScript"
        link="/docs/fp/monads/examples/either/typescript"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

üìö Handling errors without exceptions. (2021). En Marco Vermeulen, R√∫nar Bjarnason, & Paul Chiusano, Functional Programming in Kotlin (pp. 56‚Äì76). Manning Publications Co. LLC.

### üîπ Adicionales

üåê Mark Seemann. (2022, mayo 9). An Either monad. https://blog.ploeh.dk/2022/05/09/an-either-monad/

üìÑ Dylus, S., Christiansen, J., & Teegen, F. (2019). One Monad to Prove Them All. The Art, Science, and Engineering of Programming, 3(3), 8. https://doi.org/10.22152/programming-journal.org/2019/3/8
