---
title: Registros
---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

El concepto de **registro** (en inglés, *record*) es una noción ampliamente utilizada en programación para representar estructuras de datos que agrupan varias propiedades o campos. Un registro encapsula datos relacionados en una única entidad, lo que permite manipular estos datos de manera coherente y organizada.

En **Kotlin**, este concepto se denomina **data class**, pero registros o estructuras similares están presentes en muchos otros lenguajes de programación, cada uno con su propio nombre y particularidades.

## Registros en Diferentes Lenguajes

- **Kotlin: Data Classes**
En Kotlin, las **data classes** son útiles para definir clases que contienen principalmente datos. Estas clases generan automáticamente métodos como `toString()`, `equals()`, `hashCode()`, y `copy()`, eliminando la necesidad de implementarlos manualmente.

```kotlin
data class Person(val name: String, val age: Int)
```

- **Java: Records**
A partir de **Java 14**, los **records** permiten definir clases inmutables de manera concisa. Los records generan automáticamente métodos esenciales, como `equals()`, `hashCode()`, y `toString()`.

```java
public record Person(String name, int age) {}
```

- **Scala: Case Classes**
En **Scala**, el concepto equivalente es la **case class**. Estas clases son inmutables por defecto y están diseñadas para contener datos, generando automáticamente métodos útiles y facilitando la integración con el patrón de coincidencia (*pattern matching*).

```scala
case class Person(name: String, age: Int)
```

- **C#: Records**
En **C#**, la versión 9.0 introdujo los **records**, que también proporcionan clases inmutables con métodos generados automáticamente, facilitando la manipulación de datos de manera segura y eficiente.

```csharp
public record Person(string Name, int Age);
```

- **Haskell: Data Types**
En **Haskell**, los **data types** cumplen una función similar a los registros, permitiendo la definición de estructuras de datos con múltiples campos.

```haskell
data Person = Person { name :: String, age :: Int }
```

- **Python: `@dataclass`**
En **Python**, el decorador `@dataclass` simplifica la creación de clases de datos. Al usar este decorador, se generan automáticamente métodos como `__init__()`, `__repr__()`, y `__eq__()` y se habilita la capacidad de utilizar pattern matching.

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
```

## Características Generales de los Registros

A pesar de las diferencias en nombres y sintaxis, los registros comparten varias características clave entre lenguajes:

- **Agrupación de Datos:** Un registro encapsula múltiples propiedades relacionadas en una sola entidad, lo que facilita el acceso y manejo de datos.
- **Inmutabilidad:** En la mayoría de los lenguajes, los registros son inmutables por defecto, asegurando que los valores no puedan cambiarse después de su creación, lo que contribuye a un manejo más seguro de los datos.
- **Métodos Generados Automáticamente:** Los lenguajes modernos generan automáticamente métodos como `toString()`, `equals()`, `hashCode()`, y en algunos casos, `copy()`. Esto permite comparar, serializar y clonar objetos sin escribir código adicional.

## Constructor Primario

Las **data classes** en Kotlin requieren un constructor primario. Aunque es posible usar `var` para propiedades mutables, es preferible usar `val` para propiedades inmutables. El método `copy` facilita la creación de nuevas instancias con valores modificados.

```kotlin
val person1 = Person("Alice", 29)
val person2 = person1.copy(age = 30)
```

En este ejemplo, `person2` es una copia de `person1` con una modificación en la edad.

## Descomposición de Data Classes

Las **data classes** en Kotlin permiten descomponer sus propiedades en variables individuales utilizando la sintaxis de desestructuración.

```kotlin
fun main() {
    val (name, age) = Person("Alice", 29)
    println("name = $name, age = $age")
}
```

Aquí, la clase `Person` se descompone en las variables `name` y `age`, permitiendo un acceso directo a sus valores.

Este enfoque facilita la manipulación de datos de forma más limpia y legible en el código.
