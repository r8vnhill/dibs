---
title: Interfaces
---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

## Interfaces en Kotlin

Una **interfaz** en Kotlin define un contrato que las clases deben cumplir al implementarla. Básicamente, una interfaz describe qué métodos y propiedades debe proporcionar una clase sin especificar cómo se deben implementar. Este mecanismo promueve la flexibilidad y la reutilización del código, ya que una clase puede cumplir con varias interfaces sin verse limitada por una única jerarquía de herencia.

## Características de las Interfaces

- **No instanciables:** No se puede crear una instancia de una interfaz directamente. Las interfaces son solo planos que las clases deben seguir.
- **Sin estado:** No almacenan datos por sí mismas, aunque desde Kotlin 1.1 se permite que las interfaces tengan implementaciones por defecto para algunos métodos.

## Definición de una Interfaz

A continuación, se muestra un ejemplo de una interfaz simple que define dos propiedades de solo lectura, lo que significa que no pueden ser modificadas desde fuera de la clase que las implementa:

```kotlin
interface ReadPlayer {
    val name: String
    val lifePoints: Int
}
```

En este ejemplo, `ReadPlayer` define un contrato para cualquier clase que lo implemente. Las clases que implementen esta interfaz deberán proporcionar una implementación para las propiedades `name` y `lifePoints`.

## Extensión de Interfaces

Al igual que las clases, las interfaces en Kotlin pueden heredar de otras interfaces. Cuando una interfaz hereda de otra, puede sobrescribir los miembros de la interfaz base, y si lo desea, cambiar las propiedades de solo lectura a mutables.

```kotlin
interface ReadWritePlayer : ReadPlayer {
    override var lifePoints: Int
}
```

Aquí, `ReadWritePlayer` extiende `ReadPlayer`, sobrescribiendo la propiedad `lifePoints` para hacerla mutable (es decir, se puede modificar después de ser asignada).

## Aspectos Importantes de la Herencia y Sobrescritura

- **Herencia:** En Kotlin, tanto para clases como para interfaces, la herencia se declara usando `:` seguido del nombre de la interfaz o clase base.
- **Sobrescritura explícita:** En Kotlin, cualquier miembro heredado que se sobrescriba debe ser marcado con la palabra clave `override`. Esto asegura que las sobrescrituras sean explícitas y claras para evitar errores accidentales.

## Ejemplo Práctico

A continuación, se presenta un ejemplo práctico de cómo una clase puede implementar la interfaz `ReadWritePlayer`, proporcionando implementaciones concretas para sus propiedades y agregando funcionalidades adicionales:

```kotlin
class Player(override val name: String, override var lifePoints: Int) : ReadWritePlayer {
    fun updateLifePoints(points: Int) {
        lifePoints += points
    }
}
```

En este ejemplo:
- **Clase `Player`:** Implementa la interfaz `ReadWritePlayer`, proporcionando valores concretos para las propiedades `name` y `lifePoints`.
- **Método `updateLifePoints`:** Esta función permite modificar los puntos de vida del jugador, incrementándolos en base al valor proporcionado.

Este patrón es útil en situaciones donde las clases deben cumplir con ciertos comportamientos (definidos por la interfaz) pero pueden agregar su propia lógica o métodos adicionales. La interfaz actúa como una "guía" para garantizar que las clases sigan ciertas reglas, pero les da libertad para implementar los detalles.