---
title: Clases Selladas
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime/>

## Clases e Interfaces Selladas

Las **clases e interfaces selladas** son clases abstractas que restringen la herencia a un conjunto específico de subclases, controlando las posibles extensiones. Esto las hace ideales para escenarios donde se quiere limitar las variantes posibles, como cuando se modelan estados finitos o se define una jerarquía cerrada de tipos.

### Características Clave

- **Clases e Interfaces Selladas**:
- **Propósito**: Controlar y restringir la jerarquía de tipos. Solo las subclases definidas en el mismo paquete y módulo pueden extenderlas.
- **Restricciones**: Las subclases deben estar dentro del mismo paquete y módulo que la clase o interfaz sellada.

- **Beneficios**:
- **Seguridad de Tipos**: Garantiza que todas las posibles subclases estén controladas y conocidas en tiempo de compilación.
- **Patrones Exhaustivos**: Facilita el uso de `when` exhaustivos, mejorando la legibilidad y evitando errores de estado no manejados.
- **Mantenimiento**: Simplifica el mantenimiento del código, ya que no se puede extender la clase fuera de su contexto definido.

### Ejemplo: Sistema de Pagos

```kotlin
sealed interface Payment
data class CreditCard(val number: String) : Payment
data class Cash(val amount: Int) : Payment
data object Unpaid : Payment
```

Aquí, `Payment` es una interfaz sellada que permite solo tres implementaciones posibles: `CreditCard`, `Cash` y `Unpaid`. Este enfoque garantiza que, al manejar pagos, siempre sabrás qué opciones pueden estar presentes.

### Tercer Enfoque: Modelado de Estados con Clases Selladas

Las clases selladas también son muy útiles para modelar estados de un sistema. Veamos un ejemplo donde se modelan los estados de un pedido en una tienda en línea:

```kotlin
sealed class DeliveryState {
    abstract fun signal(): String
    open fun isFinalState() = false
}

data object Pending : DeliveryState() {
    override fun signal() = "Order is pending"
}

data object Paid : DeliveryState() {
    override fun signal() = "Order is paid"
}

data class Shipped(val trackingNumber: String) : DeliveryState() {
    override fun signal() = "Order is shipped with tracking number $trackingNumber"
}

data object Delivered : DeliveryState() {
    override fun signal() = "Order is delivered"
    override fun isFinalState() = true
}

data class Cancelled(val reason: String) : DeliveryState() {
    override fun signal() = "Order is cancelled because $reason"
    override fun isFinalState() = true
}
```

### Manejo con `when` Exhaustivo

El uso de un `when` exhaustivo asegura que todos los posibles estados sean manejados, lo que ayuda a evitar errores en tiempo de ejecución.

```kotlin
fun handleOrderState(state: DeliveryState) = when (state) {
    is Pending -> println(state.signal())
    is Paid -> println(state.signal())
    is Shipped -> println(state.signal())
    is Delivered -> println(state.signal())
    is Cancelled -> println(state.signal())
}
```

### Ejemplo de Uso

```kotlin
fun main() {
    handleOrderState(Pending)
    handleOrderState(Paid)
    handleOrderState(Shipped("123"))
    handleOrderState(Delivered)
    handleOrderState(Cancelled("no stock"))
}
```

### Uso de Reflexión con Clases Selladas

Para obtener las subclases de una clase o interfaz sellada en Kotlin, puedes usar reflexión. Para ello, es necesario añadir la dependencia de reflexión en el archivo `build.gradle.kts`:

```kotlin
dependencies {
    implementation(kotlin("reflect"))
}
```

Y luego puedes listar las subclases selladas:

```kotlin
fun listOrderStates() = DeliveryState::class.sealedSubclasses
```

:::tip Ejercicio: Sistema Multimedia

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">

        Desarrolla un sistema que maneje distintos tipos de contenido multimedia. Define una interfaz sellada `Media`
        que represente diferentes tipos de contenido, como `Music` y `Video`. La interfaz debe incluir dos métodos:
        `play()` y `pause()`.

        Instrucciones:

        1. **Interfaz `Media`**:
        - Define una interfaz sellada `Media` con los métodos `play()` y `pause()`.

        2. **Clases `Music` y `Video`**:
        - Implementa dos clases: `Music`, que tendrá un método adicional `skip()`, y `Video`, con un método
        `fastForward()`.

        ### Ejemplo de Uso

        ```kotlin
        fun main() {
        val mediaList: List<Media> = listOf(
        Music("Ace of Spades", "Motörhead"),
        Music("MANIAC", "Stray Kids"),
        Video("Le Locataire", duration = 125)
        )

        mediaList.forEach {media ->
        media.play()
        media.pause()

        when (media) {
        is Music -> media.skip()
        is Video -> media.fastForward()
    }
    }

        println("Media types: ${listMediaTypes()}")
    }
        ```
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        sealed interface Media {
        fun play()
        fun pause()
    }

        data class Music(val title: String, val artist: String) : Media {
        override fun play() = println("Playing $title by $artist")

        override fun pause() = println("Pausing $title by $artist")

        fun skip() = println("Skipping $title by $artist")
    }

        data class Video(val title: String, val duration: Int) : Media {
        override fun play() = println("Playing $title")

        override fun pause() = println("Pausing $title")

        fun fastForward() = println("Fast forwarding $title")
    }
        ```
    </TabItem>
</Tabs>

:::

### Clases Selladas en Java

A partir de **Java 15**, se introdujo el concepto de **clases selladas** como parte del Proyecto Amber. Este mecanismo permite restringir qué otras clases pueden extender una clase sellada, ofreciendo mayor control sobre la jerarquía de herencia. Las clases que extienden una clase sellada deben declararse explícitamente, y el compilador garantiza que no haya más subclases de las permitidas.

#### Ejemplo en Java

```java
public sealed class Payment permits CreditCard, Cash, Unpaid {}

public final class CreditCard extends Payment {
    private final String number;
    public CreditCard(String number) {
        this.number = number;
    }
}

public final class Cash extends Payment {
    private final int amount;
    public Cash(int amount) {
        this.amount = amount;
    }
}

public final class Unpaid extends Payment {}
```

En este ejemplo:
- La clase `Payment` es sellada (sealed) y solo puede ser extendida por `CreditCard`, `Cash`, y `Unpaid`, tal como lo indica la palabra clave `permits`.
- Las clases que extienden `Payment` deben ser explícitamente finales (`final`), selladas(`sealed`), o no selladas (`non-sealed`).

### Clases Selladas en Scala

En **Scala**, las clases selladas han existido desde hace tiempo y ofrecen una manera poderosa de modelar jerarquías de tipos finitas. Al igual que en Kotlin, una clase o interfaz sellada en Scala permite controlar qué subclases pueden derivar de ella, y todas deben estar definidas en el mismo archivo fuente.

#### Ejemplo en Scala

```scala
sealed trait Payment
case class CreditCard(number: String) extends Payment
case class Cash(amount: Int) extends Payment
case object Unpaid extends Payment
```

En este ejemplo:
- `Payment` es un `trait` sellado (sealed), lo que significa que solo puede ser implementado por las subclases que están en el mismo archivo.
- `CreditCard`, `Cash` y `Unpaid` son las únicas implementaciones de `Payment`, y el compilador garantiza que no se puedan agregar más subclases en otros archivos.

## Clases Selladas: Comparación entre Kotlin, Java y Scala

| Característica | **Kotlin** | **Java** (Desde Java 15)                               | **Scala**                                           |
|---------------------------------- | ---------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------- |
| Sintaxis | `sealed class` / `sealed interface` | `sealed class` | `sealed trait` / `sealed class` |
| Subclases Permitidas | Deben estar en el mismo módulo y paquete | Deben declararse explícitamente con `permits` | Deben estar en el mismo archivo fuente |
| Uso Común | Modelado de jerarquías finitas, como estados | Modelado de tipos finitos, patrones exhaustivos | Modelado algebraico de tipos, patrones exhaustivos |
| Exhaustividad en`when` / `match` | `when` exhaustivo | No tiene `when` exhaustivo, se usa `switch` clásico | `match` exhaustivo |

### Clases Selladas en el Contexto General

La idea detrás de las **clases selladas** es la misma en todos estos lenguajes: proporcionar una manera de controlar la jerarquía de tipos para garantizar la seguridad y exhaustividad en el código. Modelan sistemas donde los tipos deben estar limitados y completamente controlados.

Por ejemplo, en un **sistema de pagos**, solo debería haber un conjunto fijo de formas de pago, como **tarjeta de crédito**, **efectivo** o **no pagado**. Las clases selladas garantizan que no se introduzcan nuevas formas de pago accidentalmente sin haber sido planeadas, lo que ayuda a reducir errores y a mejorar la legibilidad del código.

## Tipos de Datos Algebraicos y Lenguajes Funcionales

En lenguajes funcionales, los **tipos de datos algebraicos** (ADTs, por sus siglas en inglés) son un mecanismo muy similar a las **clases selladas**. Estos lenguajes permiten definir tipos de datos con un conjunto fijo de variantes, lo que facilita el modelado de estructuras de datos complejas y garantiza la exhaustividad en el manejo de las variantes.

### Haskell

Haskell es un lenguaje funcional que ofrece **tipos de datos algebraicos** para representar estructuras de datos que tienen varias variantes, de manera similar a las **clases selladas**. Los ADTs en Haskell se definen mediante el uso de la palabra clave `data` y permiten definir varios constructores de datos dentro de un mismo tipo.

#### Ejemplo en Haskell

```haskell
data DeliveryState
    = Pending
    | Shipped String
    | Delivered
    | Cancelled String
```

En este ejemplo, `DeliveryState` es un tipo de dato algebraico con cuatro variantes: `Pending`, `Shipped`, `Delivered` y`Cancelled`. Cada una de estas variantes puede contener o no información adicional (por ejemplo, `Shipped` contiene un número de seguimiento).

El manejo exhaustivo de estos tipos en Haskell se realiza mediante `case`:

```haskell
handleOrderState :: DeliveryState -> String
handleOrderState state = case state of
    Pending -> "Order is pending"
    Shipped tracking -> "Order is shipped with tracking number " ++ tracking
    Delivered -> "Order is delivered"
    Cancelled reason -> "Order is cancelled because " ++ reason
```

### OCaml

OCaml también ofrece **tipos de datos algebraicos** y patrones exhaustivos para asegurar que todos los casos posibles se manejen adecuadamente.

#### Ejemplo en OCaml

```ocaml
type delivery_state =
    | Pending
    | Shipped of string
    | Delivered
    | Cancelled of string
```

```ocaml
let handle_order_state state = match state with
    | Pending -> "Order is pending"
    | Shipped tracking -> "Order is shipped with tracking number " ^ tracking
    | Delivered -> "Order is delivered"
    | Cancelled reason -> "Order is cancelled because " ^ reason
```

## Rust: Enums y Pattern Matching

En **Rust**, los **enums** se comportan de manera similar a los tipos de datos algebraicos y a las clases selladas de Kotlin. Los enums de Rust permiten definir variantes que pueden contener datos adicionales, y el uso de **pattern matching** garantiza que todas las variantes se manejen exhaustivamente.

#### Ejemplo en Rust

```rust
enum DeliveryState {
    Pending,
    Shipped(String),
    Delivered,
    Cancelled(String),
}

fn handle_order_state(state: DeliveryState) -> String {
    match state {
        DeliveryState::Pending => String::from("Order is pending"),
        DeliveryState::Shipped(tracking) => format!("Order is shipped with tracking number {}", tracking),
        DeliveryState::Delivered => String::from("Order is delivered"),
        DeliveryState::Cancelled(reason) => format!("Order is cancelled because {}", reason),
    }
}
```

Rust garantiza que cada caso del`match` cubra todas las posibles variantes del enum, evitando errores de manejo de estados no contemplados.

## F# y Discriminated Unions

En **F#**, se usan las **discriminated unions**, que permiten definir variantes de un tipo de dato similar a las clases selladas o a los ADTs en lenguajes funcionales. Esto garantiza que cada variante tenga un comportamiento específico, y el compilador asegura que todas las variantes se manejen exhaustivamente.

#### Ejemplo en F#

```fsharp
type DeliveryState =
    | Pending
    | Shipped of string
    | Delivered
    | Cancelled of string

let handleOrderState state =
    match state with
    | Pending -> "Order is pending"
    | Shipped tracking -> sprintf "Order is shipped with tracking number %s" tracking
    | Delivered -> "Order is delivered"
    | Cancelled reason -> sprintf "Order is cancelled because %s" reason
```

En este ejemplo, `DeliveryState` es un **union type** que contiene diferentes variantes, y el `match` garantiza que se manejen todas las posibilidades.

## Swift: Enums con Associated Values

En **Swift**, los enums pueden tener **valores asociados**, lo que los hace similares a los tipos algebraicos y a las clases selladas. Cada caso del enum puede tener un valor adjunto, y al usar `switch`, Swift obliga a manejar todas las variantes posibles.

#### Ejemplo en Swift

```swift
enum DeliveryState {
    case pending
    case shipped(trackingNumber: String)
    case delivered
    case cancelled(reason: String)
}

func handleOrderState(state: DeliveryState) -> String {
    switch state {
    case .pending:
        return "Order is pending"
    case .shipped(let trackingNumber):
        return "Order is shipped with tracking number \(trackingNumber)"
    case .delivered:
        return "Order is delivered"
    case .cancelled(let reason):
        return "Order is cancelled because \(reason)"
    }
}
```

En Swift, el `switch` debe ser exhaustivo y manejar todos los casos del enum, lo que garantiza la seguridad en tiempo de compilación.
