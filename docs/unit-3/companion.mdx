---
title: Variables y Funciones Estáticas
---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

En programación, una **variable estática** es una variable que ha sido asignada de manera **estática**, lo que significa que su tiempo de vida es todo el tiempo de ejecución del programa. Esto contrasta con las variables automáticas, cuya asignación de almacenamiento ocurre en el **stack** (pila de llamadas) y cuya duración es limitada al alcance de la función o bloque donde fueron declaradas. Las variables estáticas también son diferentes de los objetos, cuyo almacenamiento es asignado y liberado dinámicamente en el **heap** (memoria dinámica).

## Características Clave de las Variables Estáticas

1. **Duración de Vida**: Las variables estáticas persisten durante toda la ejecución del programa. Esto significa que su almacenamiento se asigna en tiempo de compilación y permanece en memoria hasta que el programa finaliza. En cambio, las variables locales automáticas solo existen dentro del bloque de código o función donde son declaradas, y su memoria es liberada cuando se sale de dicho bloque.

2. **Alcance vs. Tiempo de Vida**: Aunque el alcance (scope) se refiere a las áreas del programa donde se puede usar una variable, la **duración de vida** (lifetime) de una variable estática es independiente de su alcance. Las variables globales, por ejemplo, son siempre estáticas en términos de duración, ya que persisten durante toda la ejecución, pero su **alcance** puede ser global o limitado según el lenguaje y cómo se defina.

3. **Asignación de Memoria Estática**: La memoria para las variables estáticas se asigna en **tiempo de compilación**, a diferencia de la asignación dinámica, donde la memoria se asigna durante la ejecución del programa. Este tipo de asignación es eficiente, ya que no requiere llamadas al **heap** ni operaciones costosas durante la ejecución del programa.

## Variables y Funciones Estáticas en Diferentes Lenguajes

La implementación de variables y funciones estáticas varía entre lenguajes de programación, aunque el concepto subyacente sigue siendo el mismo: estas variables y funciones están vinculadas a la clase o al contexto global, no a instancias específicas.

### Kotlin: Companion Objects

En **Kotlin**, las variables y funciones estáticas se manejan a través de **companion objects**. Aunque Kotlin no utiliza el modificador `static` como otros lenguajes, los **companion objects** proporcionan una manera de definir propiedades y métodos que pertenecen a la clase en lugar de a las instancias.

```kotlin
class Number(val value: Int) {
    operator fun plus(other: Number) = Number(value + other.value)

    companion object {
        fun add(a: Int, b: Int) = Number(a + b)
    }
}

fun main() {
    val result = Number.add(5, 10)
    println(result.value)  // Imprime 15
}
  ```

En este ejemplo, el `companion object` de la clase `Number` actúa como un contenedor para la función `add`, que puede ser llamada sin instanciar la clase.

### Java: Métodos y Variables Estáticas

En **Java**, el modificador `static` se utiliza para declarar variables y métodos que pertenecen a la clase, no a las instancias.

```java
public class Number {
    public int value;

    public Number(int value) {
        this.value = value;
    }

    public static Number add(int a, int b) {
        return new Number(a + b);
    }
}

public class Main {
    public static void main(String[] args) {
        Number result = Number.add(5, 10);
        System.out.println(result.value);  // Imprime 15
    }
}
  ```

Aquí, el método `add` se define como `static`, lo que permite acceder a él sin instanciar la clase `Number`.

### Scala: Companion Objects

En **Scala**, las funciones estáticas se implementan a través de **companion objects**, como en Kotlin. El **companion object** actúa como un contenedor de métodos y variables estáticas.

```scala
class Number(val value: Int)

object Number {
    def add(a: Int, b: Int): Number = new Number(a + b)
}

@main def main(): Unit = {
    val result = Number.add(5, 10)
    println(result.value)  // Imprime 15
}
  ```

En **Scala**, el `object Number` actúa como el **companion object** de la clase `Number`, proporcionando un método estático `add`.

### C#: Métodos y Variables Estáticas

En **C#**, el modificador `static` se usa para definir métodos y variables que pertenecen a la clase, no a las instancias.

```csharp
public class Number {
    public int Value { get; set; }

    public Number(int value) {
        Value = value;
    }

    public static Number Add(int a, int b) {
        return new Number(a + b);
    }
}

public class Program {
    public static void Main(string[] args) {
        Number result = Number.Add(5, 10);
        Console.WriteLine(result.Value);  // Imprime 15
    }
}
  ```

Aquí, el método `Add` está marcado como `static`, por lo que se puede acceder a él directamente desde la clase `Number`.

### Python: Métodos de Clase con `@staticmethod`

En **Python**, el decorador `@staticmethod` se utiliza para declarar funciones estáticas en clases.

```python
class Number:
    def __init__(self, value):
        self.value = value

    @staticmethod
    def add(a, b):
        return Number(a + b)

result = Number.add(5, 10)
print(result.value)  # Imprime 15
  ```

Aquí, `add` es un método estático y se puede invocar directamente desde la clase `Number`.

## Conclusión

Las **variables y funciones estáticas** juegan un papel importante en muchos lenguajes de programación, ya que permiten definir miembros que son comunes a todas las instancias de una clase o incluso globales para todo el programa. Ya sea mediante `static` en lenguajes como **Java**, **C#**, y **Python**, o a través de **companion objects** en **Kotlin** y **Scala**, el concepto central es el mismo: estos miembros están vinculados a la clase o al espacio de nombres, no a las instancias específicas. Esto los hace ideales para almacenar funciones o datos que no dependen del estado de una instancia particular.
