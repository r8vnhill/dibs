---
title: Clases Abstractas
---

import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

### Clases abstractas en Kotlin

Una **clase abstracta** es una clase que no está completamente definida y, por lo tanto, no se puede instanciar directamente. Este tipo de clases son ideales para ser utilizadas como base para otras clases, proporcionando una estructura compartida que puede incluir propiedades y métodos comunes, al mismo tiempo que obliga a las clases derivadas a implementar ciertos métodos clave.

### Características de las Clases Abstractas

- **No instanciables:** A diferencia de las clases convencionales, una clase abstracta no se puede instanciar directamente. Su propósito es ser extendida por otras clases.
- **Pueden tener estado:** A diferencia de las interfaces, que no pueden almacenar estado (excepto en sus métodos por defecto desde Kotlin 1.1), las clases abstractas pueden tener propiedades que almacenan datos.
- **No deben usarse como tipos:** Aunque es posible usar una clase abstracta como tipo para parámetros, valores de retorno o variables, es recomendable utilizar interfaces en estos casos para fomentar la composición sobre la herencia.
- **Nomenclatura clara:** Una buena práctica es nombrar las clases abstractas con el prefijo `Abstract`, lo que hace explícito su propósito y evita confusiones.

### Definición de una Clase Abstracta

Aquí tienes un ejemplo de una clase abstracta en Kotlin que implementa la interfaz `ReadWritePlayer` y define un método abstracto que las subclases deben implementar:

```kotlin
abstract class AbstractPlayer(
  override val name: String,
  override var lifePoints: Int
) : ReadWritePlayer {
    abstract fun attack(player: ReadWritePlayer)
}
```

En este ejemplo:
- **Clase `AbstractPlayer`:** Esta clase define las propiedades `name` y `lifePoints` que son obligatorias para cualquier clase que implemente `ReadWritePlayer`. También declara un método abstracto `attack`.
- **Método abstracto:** El método `attack` no tiene implementación en la clase abstracta, lo que obliga a las subclases a proporcionar su propia implementación.

### Métodos Abstractos

- **Declaración explícita:** Los métodos abstractos deben declararse explícitamente usando la palabra clave `abstract`. Estos métodos no tienen una implementación en la clase abstracta y es responsabilidad de las clases derivadas proporcionar dicha implementación.
- **Sin cuerpo:** Al ser abstractos, estos métodos no tienen cuerpo. Esto obliga a las subclases a completarlos de acuerdo con sus necesidades específicas.

### Ejemplo de Implementación

A continuación, se muestra una clase `Warrior` que hereda de `AbstractPlayer` y proporciona una implementación concreta del método `attack`:

```kotlin
class Warrior(name: String, lifePoints: Int) : AbstractPlayer(name, lifePoints) {
    override fun attack(player: ReadWritePlayer) {
        player.lifePoints -= 10  // Simula un ataque que reduce 10 puntos de vida
    }
}
```

En este caso:
- **Clase `Warrior`:** Extiende la clase abstracta `AbstractPlayer` y proporciona una implementación del método `attack`, cumpliendo así con el contrato definido por la clase abstracta.
- **Método `attack`:** En este ejemplo, el método simula un ataque que reduce 10 puntos de vida del jugador objetivo.

Este patrón es muy útil en escenarios donde se desea establecer una estructura común para varias clases, pero permitir que cada subclase implemente ciertos comportamientos de manera específica. Las clases abstractas proporcionan flexibilidad al permitir la reutilización de código mientras obligan a las subclases a implementar los detalles que varían entre ellas.