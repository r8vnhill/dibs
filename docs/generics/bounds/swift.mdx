---
title: Cotas en Swift
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="swift-dibs" />

En esta secci√≥n compararemos c√≥mo Swift maneja las **restricciones en tipos gen√©ricos** con respecto a Kotlin. Si ya le√≠ste la parte de Kotlin, ya est√°s familiarizadx con las **cotas superiores** y c√≥mo Kotlin **no** soporta **cotas inferiores** directamente. Ahora veamos qu√© tanto se puede o no hacer en Swift, y qu√© mecanismos ofrece este lenguaje.

## üß≠ Restricciones en Swift: las ‚Äúconstraints‚Äù

En Swift, las **restricciones en tipos gen√©ricos** se declaran con la palabra clave `where`, aunque tambi√©n se pueden definir directamente en la lista de par√°metros del gen√©rico, igual que en Kotlin.

### üîº Cota superior en Swift

En Swift, podemos restringir el tipo gen√©rico a una clase o protocolo (interfaz) usando dos formas:

#### ‚úÖ Declaraci√≥n directa

```swift
func printId<T: Entity>(_ value: T) {
    print(value.id)
}
```

Esto equivale a `T : Entity` en Kotlin. Aqu√≠ `T` debe conformar al protocolo `Entity`.

#### ‚úÖ Usando `where` para m√∫ltiples restricciones

```swift
func serialize<T>(_ value: T) -> String
where T: Entity, T: Serializable {
    return value.serialize()
}
```

Esto es directamente an√°logo a `where T : Entity, T : Serializable` en Kotlin, y se puede usar tanto en funciones como en tipos.

## üìä Resumen comparativo

| **Aspecto**                                       | **Swift**                                                            | **Kotlin**                                                                |
| ------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Cotas superiores (1 restricci√≥n)**              | `T: Protocol` o `T: Clase` en la lista de gen√©ricos                  | `T : Interface` o `T : Clase` en la lista de gen√©ricos                    |
| **Cotas superiores m√∫ltiples**                    | `where T: A, T: B`                                                   | `where T : A, T : B`                                                      |
| **Cotas inferiores**                              | ‚ùå No soportadas directamente                                         | ‚ùå No soportadas directamente                                              |

## üéØ Conclusiones

Swift proporciona un sistema poderoso y expresivo para trabajar con **restricciones gen√©ricas**, particularmente mediante el uso de protocolos y la cl√°usula `where`.

### üîë Puntos clave

1. **Cotas superiores**  
   - Swift permite imponer restricciones a tipos gen√©ricos utilizando protocolos o clases base.
   - Estas restricciones pueden declararse de forma directa (`T: Protocolo`) o con `where` para m√∫ltiples condiciones.
3. **Comparaci√≥n con Kotlin**  
   - Ambos lenguajes carecen de soporte nativo para cotas inferiores.
   - Kotlin permite declarar varianza, lo que facilita ciertos patrones que en Swift requieren m√°s trabajo manual o indirecto.

### üß∞ ¬øQu√© nos llevamos?

Si est√°s dise√±ando **APIs gen√©ricas en Swift**, puedes lograr gran expresividad utilizando cotas superiores y restricciones condicionales. Sin embargo, cuando necesites reutilizar handlers, consumidores u otras entidades con jerarqu√≠as complejas, deber√°s considerar cuidadosamente si tu dise√±o puede beneficiarse de t√©cnicas como protocolos con `associatedtype` o tipos existenciales. 

En resumen, Swift **ofrece herramientas potentes pero menos directas** para expresar ciertas relaciones de tipo. Aprovechar sus fortalezas implica conocer bien el sistema de protocolos y sus limitaciones.

## üìñ Referencias

### üî• Recomendadas

üåê Generics. (s.¬†f.). Documentation. Recuperado 22 de marzo de 2025, de https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics/
