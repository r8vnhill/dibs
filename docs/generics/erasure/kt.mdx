---
title: Type Erasure
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import LastUpdated from '@site/src/components/LastUpdated'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="generics-kt" />

El uso de gen√©ricos permite que nuestras funciones y estructuras de datos sean m√°s reutilizables, expresivas y seguras. Podemos escribir c√≥digo que funciona para m√∫ltiples tipos sin duplicaci√≥n, y el compilador nos ayuda a prevenir errores.

Sin embargo, cuando usamos **Kotlin**, que se ejecuta sobre la **JVM**, nos enfrentamos a una limitaci√≥n heredada de Java: el **type erasure**. Esta caracter√≠stica implica que, en tiempo de ejecuci√≥n, **una instancia de una clase gen√©rica no conserva informaci√≥n sobre los argumentos de tipo utilizados para crearla**. Como resultado, se pierde la capacidad de inspeccionar o razonar sobre esos tipos en tiempo de ejecuci√≥n, lo que puede derivar en **comportamientos inesperados**, **advertencias del compilador** y **restricciones al utilizar reflexi√≥n o l√≥gica basada en tipos**.

En esta lecci√≥n aprender√°s:

- Por qu√© la JVM borra los tipos gen√©ricos.
- C√≥mo esto afecta al c√≥digo Kotlin.
- Qu√© soluciones ofrece Kotlin, como las funciones `inline` con tipos `reified`, para sortear estas limitaciones.

Al comprender el *type erasure*, estar√°s mejor preparadx para escribir funciones gen√©ricas m√°s seguras y potentes, especialmente al construir bibliotecas que aprovechen las ventajas del sistema de tipos de Kotlin sin caer en sus trampas ocultas.

## üèõÔ∏è Origen del *Type Erasure*

El **type erasure** surge con la incorporaci√≥n de los **gen√©ricos** en Java 5 (2004), cuyo objetivo era permitir un c√≥digo m√°s **seguro y reutilizable**. Antes de su introducci√≥n, las colecciones y otros tipos no especificaban qu√© tipo de elementos conten√≠an, lo que obligaba a realizar *casts* manuales y propensos a errores como el cl√°sico `ClassCastException`.

Para mantener la **compatibilidad hacia atr√°s**, Java implement√≥ los gen√©ricos como una caracter√≠stica del **compilador**, no de la JVM. Esto significa que la informaci√≥n de tipo se utiliza durante la compilaci√≥n para realizar chequeos de tipo y luego se **descarta**: en tiempo de ejecuci√≥n, la JVM no conoce los argumentos de tipo usados. El bytecode generado es pr√°cticamente el mismo que el del c√≥digo sin gen√©ricos.

Como resultado, el **type erasure** qued√≥ incorporado en el dise√±o de la JVM, y todos los lenguajes que se ejecutan sobre ella ‚Äîincluido Kotlin‚Äî heredan esta restricci√≥n.

:::tip[Uso de memoria]

El borrado de tipos tambi√©n tiene un beneficio pr√°ctico: **reduce el uso de memoria**, ya que no se guarda informaci√≥n de tipos gen√©ricos en tiempo de ejecuci√≥n.

::: 

### üí° Ejemplo en Java

Antes de la introducci√≥n de generics, una lista de enteros en Java se escrib√≠a as√≠:

```java showLineNumbers
List numbers = new ArrayList();
numbers.add(1);
// Usamos instanceof para asegurarnos de que el cast sea seguro
if (numbers.get(0) instanceof Integer) {
    Integer num = (Integer) numbers.get(0);
    System.out.println(num);
}
```

El uso de generics en Java 5 mejor√≥ la seguridad del tipo en tiempo de compilaci√≥n:

```java showLineNumbers
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
Integer num = numbers.get(0);  // No requiere cast expl√≠cito
System.out.println(num);
```

A pesar de esta mejora en seguridad, el type erasure implica que, en tiempo de ejecuci√≥n, el tipo `List<Integer>` es borrado y tratado simplemente como `List`, lo que impide conocer el tipo `Integer` durante la ejecuci√≥n. La JVM solo ve una `List` gen√©rica, sin detalles sobre el tipo exacto de sus elementos.

## üß™ Ejemplo de Type Erasure

Considera el siguiente c√≥digo en Kotlin:

```kotlin showLineNumbers
val list: List<String> = listOf("Kotlin", "Java")
```

En tiempo de compilaci√≥n, el compilador sabe que `list` es de tipo `List<String>`. Sin embargo, en tiempo de ejecuci√≥n, la JVM solo sabe que es una `List`, sin informaci√≥n sobre el tipo de sus elementos.

Esto puede causar problemas si intentamos acceder al tipo gen√©rico en tiempo de ejecuci√≥n:

```kotlin showLineNumbers
fun <T> printType(item: T) =
    println(item::class)
```

Si llamamos a `printType("Hello")`, la funci√≥n podr√° imprimir el tipo `String`. Sin embargo, si intentamos obtener el tipo gen√©rico `T` en s√≠, nos encontraremos con limitaciones debido al type erasure.

## ‚ö†Ô∏è Limitaciones debido al Type Erasure

Una consecuencia del type erasure es que no podemos, por ejemplo, comprobar el tipo gen√©rico en tiempo de ejecuci√≥n:

```kotlin showLineNumbers
fun <T> checkType(list: List<T>) {
    if (list is List<String>) {
        println("Es una lista de Strings")
    }
}
```

El c√≥digo anterior dar√° un warning en tiempo de compilaci√≥n: **`"Unchecked cast: List<T> to List<String>"`**. Esto se debe a que en tiempo de ejecuci√≥n, la JVM no puede saber si `list` es una `List<String>` o cualquier otra lista gen√©rica.

<details>
    <summary>‚ÑπÔ∏è ¬øC√≥mo funcionan los chequeos de tipo con gen√©ricos en Kotlin?</summary>

    En Kotlin, no puedes usar un tipo gen√©rico sin especificar sus argumentos. Pero si lo que quieres es comprobar si un valor es una lista (independientemente del tipo de sus elementos), puedes usar la sintaxis especial de **proyecci√≥n estrella**:

    ```kotlin
    if (value is List<*>) { ... }
    ```

    Esto permite verificar si un valor es una instancia de `List`, sin conocer el tipo de sus elementos (equivalente a `List<?>` en Java).

    Ahora bien, **los castings con tipos gen√©ricos a√∫n son posibles**, como en:

    ```kotlin
    val intList = c as? List<Int>
    ```

    Pero debido al *type erasure*, el tipo de los elementos no puede ser verificado en tiempo de ejecuci√≥n, por lo que **el compilador emite una advertencia de "unchecked cast"**. Aun as√≠, el c√≥digo compila y puede ejecutarse sin errores... hasta que ocurre un error en tiempo de ejecuci√≥n.

    #### Ejemplo:

    ```kotlin
    fun printSum(c: Collection<*>) {
        val intList = c as? List<Int>
            ?: throw IllegalArgumentException("List is expected")
        println(intList.sum())
    }

    printSum(listOf(1, 2, 3))       // ‚úÖ Funciona
    printSum(setOf(1, 2, 3))        // ‚ùå Lanza IllegalArgumentException
    printSum(listOf("a", "b", "c")) // üí• Lanza ClassCastException en tiempo de ejecuci√≥n
    ```

    - El primer caso funciona como se espera.
    - El segundo lanza una `IllegalArgumentException` porque el valor no es una `List`.
    - El tercero **pasa el cast**, pero falla al ejecutar `.sum()` porque intenta usar un `String` como `Number`, lo que lanza una `ClassCastException`.
</details>

## üîß Funciones Inline y Reificaci√≥n de Tipos

Kotlin ofrece una forma de superar algunas de las limitaciones del type erasure mediante el uso de **funciones inline** y **reificaci√≥n de tipos** (type reification).

### ‚ö° Funciones Inline

Las funciones `inline` en Kotlin son funciones cuyo cuerpo se inserta (o "se inyecta") en el lugar donde se llama a la funci√≥n durante la compilaci√≥n. Esto puede mejorar el rendimiento al eliminar la sobrecarga de llamadas a funciones, pero tambi√©n tiene otros usos.

### üß¨ Reificaci√≥n de Tipos

La **reificaci√≥n de tipos** permite que los tipos gen√©ricos est√©n disponibles en tiempo de ejecuci√≥n en funciones inline. Para usarla, debemos marcar el par√°metro de tipo con la palabra clave `reified`.

### üìù Sintaxis de una Funci√≥n Inline con Tipo Reificado

```kotlin showLineNumbers
inline fun <reified T> myFunction() {
    // Aqu√≠ podemos acceder al tipo T en tiempo de ejecuci√≥n
}
```

### ‚öôÔ∏è ¬øC√≥mo funciona y qu√© considerar?

Cuando marcas una funci√≥n como `inline` y usas un par√°metro de tipo `reified`, el compilador inserta el c√≥digo de la funci√≥n directamente en cada lugar donde se llama, y reemplaza el tipo gen√©rico `T` por el tipo concreto utilizado. Esto permite acceder al tipo en tiempo de ejecuci√≥n, algo normalmente imposible en la JVM debido al *type erasure*.

Sin embargo, esta t√©cnica tiene un costo: **si la funci√≥n es muy grande**, el hecho de que su c√≥digo se copie en cada llamada puede generar un binario m√°s pesado y afectar el rendimiento. Para evitar esto, es buena pr√°ctica **extraer el c√≥digo que no depende del tipo reificado** a funciones auxiliares que no sean `inline`. As√≠ se mantiene el beneficio del acceso al tipo sin comprometer el tama√±o o eficiencia del programa.

## üß∞ Ejemplo Pr√°ctico: Filtrar una Lista por Tipo

Supongamos que tenemos una lista heterog√©nea y queremos filtrar los elementos de un cierto tipo.

### üö´ Sin Type Reification

Intentemos implementar una funci√≥n que filtre elementos de un cierto tipo:

```kotlin showLineNumbers
fun <T> filterByType(list: List<Any>): List<T> {
    for (it in list) {
        if (it is T) {
            // Error: Cannot check for instance of erased type: T
        }
    }
}
```

Este c√≥digo **no compilar√°**, ya que el type erasure impide que podamos comprobar si `it is T`.

### ‚úÖ Con Type Reification

Utilizando una funci√≥n inline con tipo reificado, podemos lograr nuestro objetivo:

```kotlin showLineNumbers
inline fun <reified T> filterByType(list: List<Any>): List<T> {
    val result = mutableListOf<T>()
    for (it in list) {
        if (it is T) {
            result += it
        }
    }
}
```

Ahora podemos usar la funci√≥n:

```kotlin showLineNumbers
val mixedList: List<Any> = listOf(1, "Kotlin", 2.5, "Java")
val strings: List<String> = filterByType(mixedList)
println(strings)  // Output: [Kotlin, Java]
```

## üß™ Ejemplo Avanzado: Crear Instancias de Tipos Gen√©ricos

Otro uso de la reificaci√≥n de tipos es crear instancias de tipos gen√©ricos:

```kotlin showLineNumbers
inline fun <reified T: Any> createInstance() =
    T::class.java.getDeclaredConstructor().newInstance()
```

Ahora podemos crear instancias de cualquier tipo que tenga un constructor sin argumentos:

```kotlin showLineNumbers
class MyClass {
    init {
        println("MyClass creada")
    }
}

fun main() {
    val instance: MyClass = createInstance()
    // Output: MyClass creada
}
```

## üéØ Conclusiones

El *type erasure* es una consecuencia hist√≥rica del dise√±o de los gen√©ricos en la JVM. Aunque permiti√≥ la compatibilidad hacia atr√°s en Java, tambi√©n introdujo limitaciones reales para quienes desarrollamos con lenguajes que se ejecutan sobre ella, como Kotlin.

En esta lecci√≥n aprendiste que:

- El *type erasure* elimina la informaci√≥n sobre los tipos gen√©ricos en tiempo de ejecuci√≥n, lo que restringe el uso de reflexi√≥n, validaciones de tipo y creaci√≥n din√°mica de instancias gen√©ricas.
- Kotlin hereda estas restricciones de Java, pero ofrece mecanismos que permiten sortearlas en contextos espec√≠ficos.
- Las funciones `inline` con tipos `reified` constituyen una soluci√≥n eficaz que restaura parcialmente la capacidad de acceder a los tipos en tiempo de ejecuci√≥n.

Estas herramientas no solo permiten resolver casos concretos ‚Äîcomo filtrar listas por tipo o crear instancias de clases gen√©ricas‚Äî, sino que abren la puerta a **dise√±ar bibliotecas m√°s expresivas, seguras y componibles**.

### üîë Puntos clave

- **Type erasure** borra los tipos gen√©ricos en tiempo de ejecuci√≥n, lo que impide su inspecci√≥n directa o validaci√≥n din√°mica.
- **No es posible** hacer comprobaciones como `is T` ni crear instancias de `T` sin t√©cnicas adicionales.
- **Las funciones `inline` con tipos `reified`** permiten recuperar informaci√≥n de tipo en tiempo de ejecuci√≥n dentro de funciones gen√©ricas.
- **Kotlin ampl√≠a las capacidades de la JVM**, haciendo el trabajo con gen√©ricos m√°s flexible que en Java.

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° de las limitaciones t√©cnicas, comprender el *type erasure* nos permite escribir c√≥digo gen√©rico m√°s consciente, s√≥lido y predecible. En lugar de frustrarnos por lo que la JVM no nos permite hacer, podemos dise√±ar funciones y APIs que operen con claridad dentro de sus reglas, e incluso las superen cuando el lenguaje lo permite.

La reificaci√≥n de tipos en Kotlin no es solo una herramienta t√©cnica: es una invitaci√≥n a pensar en **c√≥mo usamos los gen√©ricos**, en qu√© contextos necesitamos la informaci√≥n de tipo, y c√≥mo estructurar nuestro c√≥digo para aprovechar lo mejor de ambos mundos ‚Äîla eficiencia del *type erasure* y la expresividad del tipo reificado‚Äî.

En resumen, **entender las limitaciones nos hace mejores dise√±adores de bibliotecas**: nos obliga a pensar, a justificar nuestras elecciones y a buscar soluciones idiom√°ticas que mantengan el equilibrio entre rendimiento, expresividad y robustez.

## üìñ Referencias

### üî• Recomendadas

üìö Generics. (2017). En Dmitry Jemerov & Svetlana Isakova, Kotlin in action (pp. 223‚Äì253). Manning Publications Co.

### üîπ Adicionales

üìö Generics. (2018). En Joshua Bloch, Effective Java (Third edition, pp. 117‚Äì155). Addison-Wesley.
