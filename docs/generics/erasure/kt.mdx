---
title: Type Erasure
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="generics-kt" />

El uso de gen√©ricos permite que nuestras funciones y estructuras de datos sean m√°s reutilizables, expresivas y seguras. Podemos escribir c√≥digo que funciona para m√∫ltiples tipos sin duplicaci√≥n, y el compilador nos ayuda a prevenir errores.

Sin embargo, cuando usamos Kotlin ‚Äîun lenguaje que corre sobre la JVM‚Äî nos enfrentamos a una limitaci√≥n hist√≥rica: el *type erasure*. Esta caracter√≠stica, heredada del sistema de generics de Java, borra la informaci√≥n de tipos gen√©ricos en tiempo de ejecuci√≥n. Esto puede generar comportamientos inesperados, advertencias del compilador y restricciones en lo que podemos hacer con reflexi√≥n o l√≥gica de tipo en tiempo de ejecuci√≥n.

En esta lecci√≥n aprender√°s:

- Por qu√© la JVM borra los tipos gen√©ricos.
- C√≥mo esto afecta al c√≥digo Kotlin.
- Qu√© soluciones ofrece Kotlin, como las funciones `inline` con tipos `reified`, para sortear estas limitaciones.

Al comprender el *type erasure*, estar√°s mejor preparadx para escribir funciones gen√©ricas m√°s seguras y potentes, especialmente al construir bibliotecas que aprovechen las ventajas del sistema de tipos de Kotlin sin caer en sus trampas ocultas.

## üèõÔ∏è Origen del Type Erasure

El **Type Erasure** tiene su origen en la implementaci√≥n de **Generics** en Java. En 2004, con la llegada de **Java 5**, se introdujo el sistema de tipos gen√©ricos para permitir que lxs desarrolladorxs pudieran escribir c√≥digo m√°s seguro y reutilizable. Antes de esta versi√≥n, las colecciones y otros tipos no pod√≠an especificar qu√© tipo de objetos conten√≠an, lo que hac√≠a necesario realizar *casts* expl√≠citos y a menudo inseguros, generando errores en tiempo de ejecuci√≥n como el famoso `ClassCastException`.

Sin embargo, para mantener la compatibilidad con versiones anteriores, los tipos gen√©ricos se implementaron de manera que fueran **borrados** en tiempo de ejecuci√≥n. Esto aseguraba que el c√≥digo antiguo, escrito sin gen√©ricos, seguir√≠a funcionando sin necesidad de modificaciones. El compilador de Java genera el bytecode con las mismas instrucciones para las clases con y sin gen√©ricos, lo que implica que durante la ejecuci√≥n, la JVM no sabe qu√© tipo concreto se us√≥ en tiempo de compilaci√≥n.

Por esta raz√≥n, **Type Erasure** se convirti√≥ en una caracter√≠stica intr√≠nseca de la JVM, y todos los lenguajes que se ejecutan sobre ella, como Kotlin, heredan esta limitaci√≥n.

### üí° Ejemplo en Java

Antes de la introducci√≥n de generics, una lista de enteros en Java se escrib√≠a as√≠:

```java showLineNumbers
List numbers = new ArrayList();
numbers.add(1);
// Usamos instanceof para asegurarnos de que el cast sea seguro
if (numbers.get(0) instanceof Integer) {
    Integer num = (Integer) numbers.get(0);
    System.out.println(num);
}
```

El uso de generics en Java 5 mejor√≥ la seguridad del tipo en tiempo de compilaci√≥n:

```java showLineNumbers
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
Integer num = numbers.get(0);  // No requiere cast expl√≠cito
System.out.println(num);
```

A pesar de esta mejora en seguridad, el type erasure implica que, en tiempo de ejecuci√≥n, el tipo `List<Integer>` es borrado y tratado simplemente como `List`, lo que impide conocer el tipo `Integer` durante la ejecuci√≥n. La JVM solo ve una `List` gen√©rica, sin detalles sobre el tipo exacto de sus elementos.

## üß™ Ejemplo de Type Erasure

Considera el siguiente c√≥digo en Kotlin:

```kotlin showLineNumbers
val list: List<String> = listOf("Kotlin", "Java")
```

En tiempo de compilaci√≥n, el compilador sabe que `list` es de tipo `List<String>`. Sin embargo, en tiempo de ejecuci√≥n, la JVM solo sabe que es una `List`, sin informaci√≥n sobre el tipo de sus elementos.

Esto puede causar problemas si intentamos acceder al tipo gen√©rico en tiempo de ejecuci√≥n:

```kotlin showLineNumbers
fun <T> printType(item: T) =
    println(item::class)
```

Si llamamos a `printType("Hello")`, la funci√≥n podr√° imprimir el tipo `String`. Sin embargo, si intentamos obtener el tipo gen√©rico `T` en s√≠, nos encontraremos con limitaciones debido al type erasure.

## ‚ö†Ô∏è Limitaciones debido al Type Erasure

Una consecuencia del type erasure es que no podemos, por ejemplo, comprobar el tipo gen√©rico en tiempo de ejecuci√≥n:

```kotlin showLineNumbers
fun <T> checkType(list: List<T>) {
    if (list is List<String>) {
        println("Es una lista de Strings")
    }
}
```

El c√≥digo anterior dar√° un warning en tiempo de compilaci√≥n: **`"Unchecked cast: List<T> to List<String>"`**. Esto se debe a que en tiempo de ejecuci√≥n, la JVM no puede saber si `list` es una `List<String>` o cualquier otra lista gen√©rica.

## üîß Funciones Inline y Reificaci√≥n de Tipos

Kotlin ofrece una forma de superar algunas de las limitaciones del type erasure mediante el uso de **funciones inline** y **reificaci√≥n de tipos** (type reification).

### ‚ö° Funciones Inline

Las funciones `inline` en Kotlin son funciones cuyo cuerpo se inserta (o "se inyecta") en el lugar donde se llama a la funci√≥n durante la compilaci√≥n. Esto puede mejorar el rendimiento al eliminar la sobrecarga de llamadas a funciones, pero tambi√©n tiene otros usos.

### üß¨ Reificaci√≥n de Tipos

La **reificaci√≥n de tipos** permite que los tipos gen√©ricos est√©n disponibles en tiempo de ejecuci√≥n en funciones inline. Para usarla, debemos marcar el par√°metro de tipo con la palabra clave `reified`.

### üìù Sintaxis de una Funci√≥n Inline con Tipo Reificado

```kotlin showLineNumbers
inline fun <reified T> myFunction() {
    // Aqu√≠ podemos acceder al tipo T en tiempo de ejecuci√≥n
}
```

### ‚öôÔ∏è ¬øC√≥mo Funciona?

Al marcar la funci√≥n como `inline` y el tipo gen√©rico como `reified`, el compilador insertar√° el c√≥digo de la funci√≥n en cada lugar donde se llame, y reemplazar√° `T` con el tipo concreto en cada llamada. Esto permite que el tipo est√© disponible en tiempo de ejecuci√≥n.

## üß∞ Ejemplo Pr√°ctico: Filtrar una Lista por Tipo

Supongamos que tenemos una lista heterog√©nea y queremos filtrar los elementos de un cierto tipo.

### üö´ Sin Type Reification

Intentemos implementar una funci√≥n que filtre elementos de un cierto tipo:

```kotlin showLineNumbers
fun <T> filterByType(list: List<Any>): List<T> {
    for (it in list) {
        if (it is T) {
            // Error: Cannot check for instance of erased type: T
        }
    }
}
```

Este c√≥digo **no compilar√°**, ya que el type erasure impide que podamos comprobar si `it is T`.

### ‚úÖ Con Type Reification

Utilizando una funci√≥n inline con tipo reificado, podemos lograr nuestro objetivo:

```kotlin showLineNumbers
inline fun <reified T> filterByType(list: List<Any>): List<T> {
    val result = mutableListOf<T>()
    for (it in list) {
        if (it is T) {
            result += it
        }
    }
}
```

Ahora podemos usar la funci√≥n:

```kotlin showLineNumbers
val mixedList: List<Any> = listOf(1, "Kotlin", 2.5, "Java")
val strings: List<String> = filterByType(mixedList)
println(strings)  // Output: [Kotlin, Java]
```

## üß™ Ejemplo Avanzado: Crear Instancias de Tipos Gen√©ricos

Otro uso de la reificaci√≥n de tipos es crear instancias de tipos gen√©ricos:

```kotlin showLineNumbers
inline fun <reified T: Any> createInstance() =
    T::class.java.getDeclaredConstructor().newInstance()
```

Ahora podemos crear instancias de cualquier tipo que tenga un constructor sin argumentos:

```kotlin showLineNumbers
class MyClass {
    init {
        println("MyClass creada")
    }
}

fun main() {
    val instance: MyClass = createInstance()
    // Output: MyClass creada
}
```

## üéØ Conclusiones

El *type erasure* es una de las consecuencias m√°s importantes ‚Äîy a menudo invisibles‚Äî del dise√±o de los gen√©ricos en la JVM. Aunque su implementaci√≥n permiti√≥ compatibilidad hacia atr√°s en Java, hoy representa una limitaci√≥n concreta para quienes escriben c√≥digo gen√©rico sobre la JVM, incluyendo a quienes usamos Kotlin.

En esta lecci√≥n entendimos que:

- El *type erasure* elimina la informaci√≥n de tipo en tiempo de ejecuci√≥n, lo que limita qu√© podemos hacer con gen√©ricos en tiempo de ejecuci√≥n.
- Kotlin, al heredar este comportamiento, sufre las mismas restricciones que Java.
- Afortunadamente, Kotlin ofrece una alternativa poderosa: las funciones `inline` con par√°metros de tipo `reified`, que nos permiten recuperar informaci√≥n de tipo en tiempo de ejecuci√≥n dentro de ciertos contextos.

Esto no solo es √∫til para tareas como filtrado por tipo o instanciaci√≥n de clases gen√©ricas, sino que tambi√©n nos da una herramienta clave para dise√±ar APIs m√°s seguras y expresivas.

### üîë Puntos clave

- **Type Erasure** borra los tipos gen√©ricos en tiempo de ejecuci√≥n, impidiendo su inspecci√≥n directa.
- **No es posible** hacer `instanceof` ni crear instancias de tipos gen√©ricos sin usar reflexi√≥n o trucos del compilador.
- **Funciones `inline` con tipos `reified`** permiten recuperar el tipo en tiempo de ejecuci√≥n y ofrecen soluciones pr√°cticas a estas limitaciones.
- **Kotlin extiende las capacidades de la JVM** con mecanismos que hacen que trabajar con gen√©ricos sea m√°s flexible y expresivo.

### üß∞ ¬øQu√© nos llevamos?

Comprender c√≥mo funciona el *type erasure* y c√≥mo Kotlin nos ayuda a lidiar con sus consecuencias es clave para escribir c√≥digo gen√©rico m√°s robusto. Al desarrollar bibliotecas, este conocimiento marca la diferencia entre una API limitada por la plataforma y una que aprovecha al m√°ximo las herramientas del lenguaje.

Aunque el *type erasure* puede parecer un obst√°culo t√©cnico, tambi√©n representa una oportunidad: al conocer sus restricciones, podemos tomar decisiones m√°s informadas, dise√±ar mejores abstracciones y, cuando sea necesario, escapar de sus l√≠mites con herramientas como `reified`. As√≠, convertimos una desventaja heredada en una motivaci√≥n para escribir c√≥digo m√°s consciente y efectivo.

## üìñ Referencias

### üî• Recomendadas

üìö Generics. (2017). En Dmitry Jemerov & Svetlana Isakova, Kotlin in action (pp. 223‚Äì253). Manning Publications Co.
