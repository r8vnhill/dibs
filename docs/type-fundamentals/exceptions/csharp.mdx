---
title: "Manejo de Excepciones en C#: Lanzamiento, Captura y Recursos"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="csharp-dibs" />

En **C#**, el manejo de excepciones es un mecanismo fundamental para responder de forma segura a errores o condiciones inesperadas durante la ejecuci√≥n de un programa. Al igual que en otros lenguajes modernos como Kotlin o Java, las excepciones se lanzan, capturan y propagan utilizando una sintaxis clara y estructurada.

Una caracter√≠stica clave del sistema de excepciones en C# es que **todas las excepciones derivan de la clase base [`System.Exception`](https://learn.microsoft.com/en-us/dotnet/api/system.exception)**. Esto significa que cualquier tipo de error ‚Äîya sea una divisi√≥n por cero, un acceso a archivo inv√°lido o una excepci√≥n personalizada‚Äî puede ser manejado de manera uniforme y consistente dentro del lenguaje.

El conocimiento profundo de c√≥mo lanzar, capturar y propagar excepciones, as√≠ como de c√≥mo liberar correctamente los recursos, es esencial para escribir software robusto, legible y mantenible.

## üöÄ Lanzar Excepciones

En **C#**, puedes lanzar una excepci√≥n con la palabra clave `throw`, similar a Kotlin:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        if (divisor == 0)
        {
            throw new ArgumentException("Divisor cannot be zero", nameof(divisor));
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers title="Exceptions/Divider.cs"
        namespace Exceptions;

        public static class Divider
        {
            public static int Divide(int dividend, int divisor)
            {
                if (divisor == 0)
                {
                    throw new ArgumentException("Divisor cannot be zero", nameof(divisor));
                }
                return dividend / divisor;
            }
        }
        ```

        ```csharp showLineNumbers title="Exceptions/Program.cs"
        using Exceptions;

        Console.WriteLine(Divider.Divide(10, 2));
        Console.WriteLine(Divider.Divide(10, 0));
        /*
        Output:
        5
        Unhandled exception. System.ArgumentException: Divisor cannot be zero (Parameter 'divisor')
        at Exceptions.Divider.Divide(Int32 dividend, Int32 divisor) in 
        ...
        */
        ```
    </TabItem>
</BoxedTabs>

Aqu√≠ lanzamos una excepci√≥n `ArgumentException` cuando se intenta dividir por cero, muy similar al ejemplo de Kotlin.

## üõë Capturar Excepciones

Al igual que en Kotlin, **C#** utiliza la estructura `try-catch` para capturar excepciones. Puedes manejar diferentes tipos de excepciones de forma espec√≠fica y realizar acciones cuando se producen errores.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        try
        {
            return Divide(dividend, divisor);
        }
        catch (ArgumentException e)
        {
            // Handle exception
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers title="Exceptions/Divider.cs"
        namespace Exceptions;

        public static class Divider
        {
            public static int Divide(int dividend, int divisor)
            {
                if (divisor == 0)
                {
                    throw new ArgumentException("Divisor cannot be zero", nameof(divisor));
                }
                return dividend / divisor;
            }
            
            public static int SafeDivide(int dividend, int divisor)
            {
                try
                {
                    return Divide(dividend, divisor);
                }
                catch (ArgumentException e)
                {
                    Console.WriteLine(e.Message);
                    return 0;
                }
            }
        }
        ```

        ```csharp showLineNumbers title="Exceptions/Program.cs"
        using Exceptions;

        Console.WriteLine(Divider.SafeDivide(10, 2));
        Console.WriteLine(Divider.SafeDivide(10, 0));
        /* Output:
        5
        Divisor cannot be zero (Parameter 'divisor')
        0
        */
        ```
    </TabItem>
</BoxedTabs>

Los **objetos de excepci√≥n** contienen informaci√≥n detallada sobre el error, como el estado de la pila de llamadas (`stack trace`) y una descripci√≥n del error (`Message`). Esta informaci√≥n puede ser muy √∫til para depurar y registrar errores de forma precisa.

:::tip Buena pr√°ctica

No captures una excepci√≥n a menos que realmente puedas manejarla y dejar la aplicaci√≥n en un estado consistente.  
Si capturas una excepci√≥n gen√©rica como `System.Exception`, **vu√©lvela a lanzar** al final del bloque `catch` usando simplemente `throw;`. Esto garantiza que no silencies errores cr√≠ticos que deber√≠an ser tratados m√°s arriba en la pila de llamadas.

:::

## üîÑ Bloque `finally`

En **C#**, el bloque `finally` tambi√©n es opcional y se ejecuta despu√©s del bloque `try` o `catch`, independientemente de si se lanz√≥ una excepci√≥n o no. Es √∫til para liberar recursos, como conexiones a bases de datos o archivos abiertos.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        try
        {
            // Operaci√≥n arriesgada
        }
        catch (Exception e)
        {
            // Manejar excepci√≥n
        }
        finally
        {
            // Liberar recursos
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers
        namespace Exceptions;

        public static class FileReader
        {
            public static void ReadFile(string path)
            {
                StreamReader? reader = null;
                try
                {
                    // Leer archivo
                    reader = new StreamReader(path);
                    var content = reader.ReadToEnd();
                    Console.WriteLine("Contenido del archivo:");
                    Console.WriteLine(content);
                }
                catch (FileNotFoundException e)
                {
                    Console.WriteLine($"Error: Archivo no encontrado. {e.Message}");
                }
                catch (UnauthorizedAccessException e)
                {
                    Console.WriteLine($"Error: Acceso denegado al archivo. {e.Message}");
                }
                finally
                {
                    // Asegurar que el archivo sea cerrado
                    if (reader != null)
                    {
                        reader.Close();
                        Console.WriteLine("El archivo fue cerrado correctamente.");
                    }
                }
            }
        }
        ```
    </TabItem>
</BoxedTabs>

### üìÇ Manejo de Recursos con `using`

En **C#**, el manejo adecuado de archivos, conexiones a bases de datos y otros recursos se puede realizar con el bloque **`using`**, el cual garantiza que los objetos que implementan `IDisposable` sean liberados correctamente.  

<BoxedTabs>
   <TabItem label={"Ejemplo b√°sico"} value={"Ejemplo b√°sico"}>
   ```csharp showLineNumbers title="Exceptions/FileReader.cs"
   using var stream = new FileStream("config.json", FileMode.Open);
   using var reader = new StreamReader(stream);
   var content = reader.ReadToEnd();
   Console.WriteLine(content);
   ```
   </TabItem>
   <TabItem label={"Ejemplo detallado"} value={"Ejemplo detallado"}>
   ```csharp showLineNumbers title="Exceptions/FileReader.cs"
   namespace Exceptions;

   public static class FileReader
   {
       public static void ReadFile(string path)
       {
           try
           {
               using var stream = new FileStream(path, FileMode.Open);
               using var reader = new StreamReader(stream);
               var content = reader.ReadToEnd();
               Console.WriteLine("Contenido del archivo:");
               Console.WriteLine(content);
           }
           catch (FileNotFoundException e)
           {
               Console.WriteLine($"Error: Archivo no encontrado. {e.Message}");
           }
           catch (UnauthorizedAccessException e)
           {
               Console.WriteLine($"Error: Acceso denegado al archivo. {e.Message}");
           }
       }
   }
   ```
   </TabItem>
</BoxedTabs>

## ‚ö†Ô∏è Excepciones Personalizadas

Al igual que en Kotlin, puedes crear tus propias excepciones en **C#** extendiendo la clase `Exception`. Esto permite definir errores espec√≠ficos y personalizados para tu aplicaci√≥n.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        if (age >= 70)
        {
            throw new StopLovingException(
                "And, darling, I will be loving you 'til we're 70");
        }
        ```

        ```csharp showLineNumbers
        public class StopLovingException(string message) : 
            Exception(message);
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers title="Exceptions/EdSheeran.cs"
        namespace Exceptions;

        public static class EdSheeran
        {
            public static void ValidateAge(int age) {
                if (age >= 70) {
                    throw new StopLovingException(
                        "And, darling, I will be loving you 'til we're 70");
                }
            }
        }

        public class StopLovingException(string message) : 
            Exception(message);
        ```
    </TabItem>
</BoxedTabs>

## üì° Propagaci√≥n de Excepciones

En **C#**, si no capturas una excepci√≥n, esta se propagar√° hacia arriba en la pila de llamadas, igual que en Kotlin. No es necesario declarar las excepciones lanzadas por una funci√≥n en la firma del m√©todo, al contrario que en **Java**.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        public static void ReadConfigFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"Configuration file not found: {filePath}");
            }
            try
            {
                Console.WriteLine("Configuration loaded successfully.");
            }
            catch (IOException ex)
            {
                throw new IOException("Error reading the configuration file.", ex);
            }
        }
        ```

        ```csharp showLineNumbers
        try
        {
            FileReader.ReadConfigFile("config.json");
        }
        catch (FileNotFoundException ex)
        {
            Console.WriteLine(ex.Message);
        }
        catch (IOException ex)
        {
            Console.WriteLine(ex.Message);
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers title="Exceptions/FileReader.cs"
        namespace Exceptions;

        public static class FileReader
        {
            public static void ReadFile(string path)
            {
                StreamReader? reader = null;
                try
                {
                    // Leer archivo
                    reader = new StreamReader(path);
                    var content = reader.ReadToEnd();
                    Console.WriteLine("Contenido del archivo:");
                    Console.WriteLine(content);
                }
                catch (FileNotFoundException e)
                {
                    Console.WriteLine($"Error: Archivo no encontrado. {e.Message}");
                }
                catch (UnauthorizedAccessException e)
                {
                    Console.WriteLine($"Error: Acceso denegado al archivo. {e.Message}");
                }
                finally
                {
                    // Asegurar que el archivo sea cerrado
                    if (reader != null)
                    {
                        reader.Close();
                        Console.WriteLine("El archivo fue cerrado correctamente.");
                    }
                }
            }
            
            public static void ReadConfigFile(string filePath)
            {
                if (!File.Exists(filePath))
                {
                    throw new FileNotFoundException($"Configuration file not found: {filePath}");
                }
                try
                {
                    Console.WriteLine("Configuration loaded successfully.");
                }
                catch (IOException ex)
                {
                    throw new IOException("Error reading the configuration file.", ex);
                }
            }
        }
        ```

        ```csharp showLineNumbers title="Exceptions/Program.cs"
        using Exceptions;

        try
        {
            FileReader.ReadConfigFile("config.json");
        }
        catch (FileNotFoundException ex)
        {
            Console.WriteLine(ex.Message);
        }
        catch (IOException ex)
        {
            Console.WriteLine(ex.Message);
        }
        ```
    </TabItem>
</BoxedTabs>

## üìä Resumen Comparativo

| Caracter√≠stica                         | Kotlin                                  | C#                          |
|----------------------------------------|-----------------------------------------|-----------------------------|
| **Lanzar excepciones**                 | `throw ExceptionType()`                 | `throw new ExceptionType()` |
| **Capturar excepciones**               | `try-catch`                             | `try-catch`                 |
| **Bloque `finally`**                   | Ejecuci√≥n opcional tras `try` o `catch` | Igual que en Kotlin         |
| **Excepciones personalizadas**         | Extiende `Exception`                    | Extiende `Exception`        |
| **Declaraci√≥n de excepciones**         | No requiere declaraci√≥n                 | No requiere declaraci√≥n     |
| **Ausencia de excepciones chequeadas** | S√≠                                      | S√≠                          |

<ProCons>
    <Pros>
        - **Manejo robusto**: C# proporciona una forma clara y estructurada de manejar excepciones, con soporte para bloques `try-catch-finally`.
        - **Compatibilidad**: Al igual que Kotlin, **C#** es ampliamente utilizado, lo que facilita la integraci√≥n en entornos corporativos.
        - **Excepciones personalizadas**: Es f√°cil crear excepciones espec√≠ficas, lo que permite un control m√°s preciso sobre el manejo de errores.        
    </Pros>
    <Cons>
        - **Excepciones no chequeadas**: Al igual que en Kotlin, todas las excepciones en C# son no chequeadas, lo que puede llevar a una falta de previsi√≥n sobre las excepciones que una funci√≥n podr√≠a lanzar.
        - **Mayor verbosidad**: Aunque las excepciones en C# son similares a Kotlin, la sintaxis puede ser m√°s extensa, especialmente cuando se manejan errores personalizados.
    </Cons>
</ProCons>

## üìå Conclusiones

En esta lecci√≥n, exploramos el manejo de excepciones en **C#**, abordando su sintaxis y mejores pr√°cticas para lanzar, capturar y gestionar errores de manera eficiente. Aprendimos a usar `throw` para generar excepciones, `try-catch` para manejarlas y `finally` para la liberaci√≥n de recursos. Tambi√©n analizamos el uso del bloque `using` para la gesti√≥n autom√°tica de recursos y la creaci√≥n de excepciones personalizadas.

### üîë Puntos clave:

1. **Estructura clara y robusta:**  
   - C# utiliza `try-catch-finally` para manejar errores de manera estructurada, similar a otros lenguajes como Java y Kotlin.  
2. **Manejo eficiente de recursos:**  
   - El bloque `using` permite liberar autom√°ticamente objetos que implementan `IDisposable`, reduciendo el riesgo de fugas de memoria.  
3. **Excepciones personalizadas:**  
   - Se pueden crear excepciones espec√≠ficas extendiendo la clase `Exception`, lo que facilita la captura y tratamiento de errores seg√∫n las necesidades del programa.  
4. **Propagaci√≥n de excepciones:**  
   - Las excepciones no capturadas se propagan autom√°ticamente en la pila de ejecuci√≥n, sin necesidad de declararlas en la firma del m√©todo.  
5. **Comparaci√≥n con Kotlin:**  
   - Aunque C# y Kotlin tienen similitudes en el manejo de excepciones, C# es m√°s detallado en la gesti√≥n de recursos, mientras que Kotlin enfatiza la concisi√≥n y el uso de expresiones.

### ‚úÖ Reflexi√≥n final

El manejo de excepciones en **C#** es una herramienta poderosa para escribir c√≥digo m√°s robusto y seguro. Utilizar correctamente `try-catch`, `finally`, `using` y excepciones personalizadas permite mejorar la calidad del software y reducir errores inesperados en tiempo de ejecuci√≥n.

Con estas pr√°cticas, puedes escribir c√≥digo m√°s confiable, modular y mantenible en **C#**.

## üìñ Referencias

### üî• Recomendadas

üåê Exceptions and Exception Handling‚ÄîC#. (2023, abril 22). https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/ {/* √öltima revisi√≥n: 2025/03/21 */}

### üîπ Adicionales

üåê Best practices for exceptions‚Äî.NET. (2024, mayo 2). https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions
{/* √öltima revisi√≥n: ??? */}
