---
title: Excepciones
---
import {Cons, ProCons, Pros} from "/src/components/cajitas/ProCons";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import References from "/src/components/ReferencesComponent";
import ReadingTime from "/src/components/ReadingTime";
import { LanguageCard, JavaScriptCard } from "/src/components/cards/LanguageCard";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime />

En cualquier sistema software, los errores son inevitables: archivos que no existen, conexiones interrumpidas, datos malformados. Por eso, contar con un mecanismo robusto para capturar y manejar estos errores no es una opci√≥n, sino una necesidad. Las **excepciones** son una herramienta clave en ese proceso.

Kotlin, al igual que otros lenguajes de la JVM como Java o Scala, ofrece un sistema de manejo de excepciones familiar y poderoso, basado en las construcciones `throw`, `try-catch` y `finally`. Sin embargo, tambi√©n aporta mejoras que promueven un estilo m√°s conciso y expresivo, como su integraci√≥n con funciones como `use` para liberar recursos de forma segura.

En esta lecci√≥n, aprender√°s c√≥mo lanzar, capturar y propagar excepciones en Kotlin, c√≥mo utilizar bloques `finally`, y c√≥mo aprovechar constructos modernos para escribir c√≥digo m√°s limpio y seguro. Tambi√©n analizaremos sus ventajas y desventajas, y c√≥mo este enfoque se compara con alternativas en otros lenguajes.

## üö® Lanzar Excepciones

En Kotlin, puedes **lanzar** una excepci√≥n utilizando la palabra clave `throw`. Este mecanismo permite **interrumpir el flujo normal del programa** cuando se detecta una condici√≥n inv√°lida o inesperada.

Esto es especialmente importante al dise√±ar **bibliotecas de software**: lanzar una excepci√≥n en el momento adecuado permite se√±alar errores de uso, validar contratos y proteger la consistencia interna de las estructuras que expones. Por ejemplo, una biblioteca de gr√°ficos podr√≠a lanzar una excepci√≥n si se intenta construir un tri√°ngulo con lados inv√°lidos, o una de m√©tricas si se intenta registrar un valor negativo donde no se permite.

Adem√°s, es importante destacar que la expresi√≥n `throw` en Kotlin tiene el tipo especial [`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/). Esto significa que **la funci√≥n se interrumpe en el punto donde se lanza la excepci√≥n** y no contin√∫a ejecutando el resto del cuerpo. El uso de `Nothing` tambi√©n permite que el compilador entienda que esa rama nunca retorna, lo cual puede ayudar en la inferencia de tipos o validaciones de flujo.

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
    ```kotlin showLineNumbers
    fun normalizeAngle(degrees: Int): Int {
        if (degrees !in 0..360) {
            throw IllegalArgumentException("Angle must be between 0 and 360")
        }
        return degrees
    }
    ```
  </TabItem>
  <TabItem label={"Ejemplo aplicado"} value={"Ejemplo aplicado"}>
    ```kotlin showLineNumbers
    fun normalizeAngle(degrees: Int): Int {
        if (degrees !in 0..360) {
            throw IllegalArgumentException("Angle must be between 0 and 360")
        }
        return degrees
    }

    fun main() {
        println(normalizeAngle(45))   // 45
        println(normalizeAngle(400))  // ‚ùå Lanza excepci√≥n
    }
    ```
  </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, la funci√≥n `normalizeAngle` podr√≠a formar parte de una biblioteca de utilidades geom√©tricas.  
    Lanzar una excepci√≥n permite evitar resultados incorrectos y ayuda a quien usa la biblioteca a detectar errores de uso r√°pidamente.

    Dado que `throw` tiene tipo `Nothing`, el compilador sabe que no habr√° un valor de retorno v√°lido tras la l√≠nea que lanza la excepci√≥n, y el flujo de ejecuci√≥n de la funci√≥n se interrumpe inmediatamente.
</Explanation>

## üõ°Ô∏è Capturar Excepciones

En Kotlin, puedes capturar y manejar errores en tiempo de ejecuci√≥n utilizando una **expresi√≥n `try-catch`**. A diferencia de muchos lenguajes donde `try-catch` es una *declaraci√≥n*, en Kotlin es una *expresi√≥n*: **produce un valor**, y por lo tanto puede asignarse o devolverse directamente.

Esto es √∫til al construir **bibliotecas de software**, donde puedes encapsular errores dentro de funciones que devuelven un resultado neutral (`null`, un `Result`, etc.) en lugar de lanzar excepciones, permitiendo a quien usa tu biblioteca elegir c√≥mo actuar ante fallos.

:::note Recordatorio

En Kotlin, una *expresi√≥n* es una construcci√≥n que **devuelve un valor**, como una operaci√≥n matem√°tica o una llamada a funci√≥n.  
Una *declaraci√≥n*, en cambio, **realiza una acci√≥n** sin retornar un valor usable (como `val`, `while`, o `fun`).  
Como `try-catch` es una expresi√≥n, puedes usarla directamente en una asignaci√≥n o retorno.

:::

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
    ```kotlin showLineNumbers
    fun calcularTasa(exitos: Int, intentos: Int): Double? = try {
        exitos.toDouble() / intentos
    } catch (e: ArithmeticException) {
        println("Advertencia: divisi√≥n por cero")
        null
    }
    ```
  </TabItem>
  <TabItem label={"Ejemplo aplicado"} value={"Ejemplo aplicado"}>
    ```kotlin showLineNumbers
    fun calcularTasa(exitos: Int, intentos: Int): Double? = try {
        exitos.toDouble() / intentos
    } catch (e: ArithmeticException) {
        println("Advertencia: divisi√≥n por cero")
        null
    }

    fun main() {
        println(calcularTasa(7, 10))  // 0.7
        println(calcularTasa(7, 0))   // null + advertencia
    }
    ```
  </TabItem>
</BoxedTabs>

<Explanation>
    Esta funci√≥n podr√≠a formar parte de una biblioteca de m√©tricas.  
    Usar `try-catch` como expresi√≥n permite devolver un valor directamente (`null` en caso de error), sin necesidad de estructuras adicionales ni m√∫ltiples retornos.  
    As√≠, quien utilice tu biblioteca puede decidir si ignora, transforma o propaga el resultado nulo.
</Explanation>

### üîÅ Bloque `finally` y gesti√≥n de recursos

El bloque `finally` es opcional y se ejecuta **siempre**, sin importar si una excepci√≥n fue lanzada o no. Es √∫til cuando necesitas **liberar recursos** (como archivos, sockets o conexiones) de forma segura, garantizando que el c√≥digo de limpieza se ejecute pase lo que pase.

Esto es especialmente relevante al dise√±ar **bibliotecas de software** que interact√∫an con recursos del sistema. Asegurarte de que los recursos se cierren correctamente evita fugas de memoria, archivos bloqueados y comportamientos inesperados en aplicaciones que usen tu biblioteca.

<BoxedTabs>
  <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
    ```kotlin showLineNumbers
    try {
        // Operaciones que pueden lanzar excepciones
    } catch (e: Exception) {
        // Captura de excepciones
    } finally {
        // C√≥digo que se ejecuta siempre
    }
    ```
  </TabItem>
  <TabItem label="Ejemplo aplicado" value="Ejemplo aplicado">
    <BoxedTabs>
      <TabItem label="Versi√≥n tradicional" value="Versi√≥n tradicional">
        ```kotlin showLineNumbers
        fun readFile(filePath: String) {
            var fileReader: FileReader? = null
            try {
                val file = File(filePath)
                fileReader = FileReader(file)
                val content = fileReader.readText()
                println("Contenido del archivo:\n$content")
            } catch (e: IOException) {
                println("Error al leer el archivo: ${e.message}")
            } finally {
                try {
                    fileReader?.close()
                    println("El archivo ha sido cerrado.")
                } catch (e: IOException) {
                    println("Error al cerrar el archivo: ${e.message}")
                }
            }
        }
        ```

        <Explanation>
            Esta funci√≥n simula una operaci√≥n com√∫n en bibliotecas que trabajan con archivos: abrir, leer y cerrar un recurso. El objetivo es garantizar que el archivo se cierre correctamente, **incluso si ocurre un error durante la lectura**.

            - Se usa un bloque `try-catch` para capturar posibles excepciones al abrir o leer el archivo (por ejemplo, si el archivo no existe o no se puede acceder).
            - El bloque `finally` se asegura de que el archivo se cierre, **independientemente de si hubo un error o no**.
            - El `fileReader?.close()` est√° envuelto en su propio `try-catch` para capturar errores al cerrar el archivo, como si ya se hubiera cerrado o si hubo un error del sistema.

            Esta t√©cnica es com√∫n en bibliotecas que manejan recursos del sistema, ya que permite encapsular el comportamiento seguro de apertura y cierre de archivos, evitando que quien usa la biblioteca tenga que preocuparse por liberar manualmente los recursos.
        </Explanation>
      </TabItem>
      <TabItem label="Versi√≥n idiom√°tica" value="Versi√≥n idiom√°tica">
        ```kotlin showLineNumbers
        fun readFile(filePath: String) = try {
            FileReader(File(filePath)).use { fileReader ->
                val content = fileReader.readText()
                println("Contenido del archivo:\n$content")
            }
        } catch (e: IOException) {
            println("Error al leer el archivo: ${e.message}")
        }
        ```

        :::info Alternativa idiom√°tica con `use`

        En Kotlin, la funci√≥n `use` garantiza que el recurso se cierre autom√°ticamente al finalizar el bloque, incluso si ocurre una excepci√≥n.  
        Es la forma recomendada de manejar recursos que implementan `Closeable`, y reduce la necesidad de `finally`.

        :::
      </TabItem>
    </BoxedTabs>
  </TabItem>
</BoxedTabs>

## üí• Propagaci√≥n de Excepciones

En Kotlin, si una excepci√≥n no se captura, esta se **propaga autom√°ticamente** a la funci√≥n llamante. Este comportamiento es similar al de lenguajes como Java o C#, pero con una diferencia importante: **Kotlin no tiene excepciones chequeadas**.

Esto significa que **no est√°s obligado a declarar las excepciones que una funci√≥n puede lanzar**, aunque puedes hacerlo opcionalmente usando la anotaci√≥n `@Throws`. Esto es especialmente √∫til cuando la funci√≥n ser√° llamada desde c√≥digo Java, donde s√≠ existen excepciones chequeadas.

En el contexto de bibliotecas de software, la propagaci√≥n de excepciones puede ser √∫til para **dejar que la persona que usa la biblioteca decida c√≥mo manejar los errores**, mientras t√∫ te concentras en mantener la l√≥gica clara y segura.

```kotlin showLineNumbers
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException
import kotlin.jvm.Throws

fun main() {
    try {
        readConfigFile("config.json")
    } catch (ex: FileNotFoundException) {
        println(ex.message)
    } catch (ex: IOException) {
        println(ex.message)
    }
}

// Documentaci√≥n opcional de las excepciones lanzadas
@Throws(FileNotFoundException::class, IOException::class)
private fun readConfigFile(filePath: String) {
    if (!File(filePath).exists()) {
        throw FileNotFoundException("Configuration file not found: $filePath")
    }

    try {
        println("Configuration loaded successfully.")
    } catch (ex: IOException) {
        throw IOException("Error reading the configuration file.", ex)
    }
}
```

<Explanation>
    En este ejemplo, `readConfigFile` representa una funci√≥n t√≠pica en una biblioteca que intenta cargar un archivo de configuraci√≥n.

    - Si el archivo no existe, se lanza una excepci√≥n `FileNotFoundException`.
    - Si ocurre un error al leer el archivo, se lanza una `IOException`, posiblemente con la causa original.
    - Gracias al uso de `@Throws`, quienes usen esta funci√≥n desde Java pueden beneficiarse del sistema de chequeo de excepciones.
    
    Este patr√≥n permite mantener la funci√≥n enfocada en su prop√≥sito, dejando a quien la llama el control sobre c√≥mo reaccionar ante los errores.
</Explanation>

## ‚ö†Ô∏è Excepciones Personalizadas

Al desarrollar **bibliotecas de software**, a veces necesitas se√±alar errores que son **espec√≠ficos de tu dominio**: validaciones de entrada, estados inv√°lidos, violaciones de contrato, etc. Para estos casos, puedes definir **excepciones personalizadas** extendiendo `Exception` o `RuntimeException`.

```kotlin showLineNumbers
class InvalidColorException(message: String) : IllegalArgumentException(message)

fun parseHexColor(hex: String): Int {
    if (!hex.matches(Regex("#[0-9A-Fa-f]{6}"))) {
        throw InvalidColorException("Formato inv√°lido para color: $hex")
    }
    return hex.removePrefix("#").toInt(16)
}
```

<Explanation>
    Esta funci√≥n podr√≠a formar parte de una biblioteca de gr√°ficos.  
    En lugar de lanzar una excepci√≥n gen√©rica, definimos `InvalidColorException` para **documentar expl√≠citamente qu√© tipo de error ocurri√≥**, facilitando su manejo desde el c√≥digo cliente.
</Explanation>

Tambi√©n puedes heredar de `RuntimeException` si planeas que tu biblioteca sea utilizada desde **Java** y no deseas que quienes la consumen est√©n obligados a capturar la excepci√≥n.  

> En **Kotlin**, todas las excepciones son *unchecked*, as√≠ que no existe esta obligaci√≥n, sin importar de qu√© clase heredes.

```kotlin
class EdSheeranException(message: String) : RuntimeException(message)

fun validateAge(age: Int) {
    if (age >= 70) {
        throw EdSheeranException("And, darling, I will be loving you 'til we're 70")
    }
}
```

<Explanation>
    Aunque este ejemplo es humor√≠stico, muestra c√≥mo puedes **personalizar el mensaje de error y darle identidad a la excepci√≥n**, algo especialmente √∫til en bibliotecas que apuntan a dominios complejos.

    Si tu biblioteca tambi√©n ser√° utilizada desde **Java**, heredar de `RuntimeException` evita que la excepci√≥n tenga que ser obligatoriamente capturada.
</Explanation>

### ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Manejo centralizado de errores**: Las excepciones permiten capturar y manejar errores desde un √∫nico lugar, lo que mejora la claridad y la organizaci√≥n del c√≥digo. Esto es especialmente valioso en aplicaciones grandes o bibliotecas reutilizables, donde repartir l√≥gica de validaci√≥n por todos lados puede volverse inmanejable.
        - **Separaci√≥n de preocupaciones**: Permiten aislar el flujo principal del manejo de errores, haciendo que el c√≥digo sea m√°s limpio, expresivo y f√°cil de seguir.
        - **Propagaci√≥n autom√°tica**: En Kotlin y otros lenguajes similares, las excepciones no capturadas se propagan autom√°ticamente, lo que permite delegar el manejo de errores a capas superiores del sistema, simplificando funciones intermedias.
        - **Flexibilidad con excepciones personalizadas**: Es posible crear tipos espec√≠ficos de error para representar distintas fallas del dominio de la biblioteca (e.g. `GraphCycleException`, `EmptyConfigurationException`), mejorando la sem√°ntica de la API y facilitando la integraci√≥n con otros sistemas.
        - **Integraci√≥n con gesti√≥n de recursos**: Kotlin ofrece funciones como `use`, que garantizan el cierre de recursos (archivos, conexiones, etc.) incluso ante errores, evitando fugas sin necesidad de escribir bloques `finally`.
    </Pros>

    <Cons>
        - **Mal uso como control de flujo**: Utilizar excepciones para situaciones esperadas (como el fin de una b√∫squeda o una validaci√≥n negativa) es un antipatr√≥n que dificulta la lectura y puede afectar negativamente al rendimiento.
        - **Ausencia de excepciones chequeadas**: A diferencia de Java, Kotlin no requiere declarar ni capturar excepciones. Aunque esto simplifica el c√≥digo, tambi√©n puede ocultar errores si no se documenta correctamente el comportamiento de las funciones.
        - **Coste en rendimiento**: El mecanismo de lanzar y capturar excepciones no est√° optimizado para escenarios frecuentes. En bibliotecas de bajo nivel o con gran volumen de operaciones, puede ser preferible usar enfoques alternativos como `Result`, `Either`, o `Option`.
        - **Dificultades en la trazabilidad**: Si las excepciones se capturan en capas superiores sin un adecuado registro en los niveles intermedios, puede resultar dif√≠cil rastrear su causa original, especialmente en entornos productivos.
        - **Poca componibilidad**: A diferencia de los tipos que representan errores como valores (`Result`, `Option`, etc.), las excepciones son dif√≠ciles de combinar o transformar de forma funcional, lo que puede limitar su expresividad en ciertos estilos de dise√±o.
    </Cons>
</ProCons>

## üéØ Conclusiones

El manejo de excepciones es una herramienta poderosa y necesaria en el desarrollo de bibliotecas de software. Kotlin ofrece un sistema expresivo y seguro que permite capturar errores, liberar recursos de forma confiable y propagar fallas cuando es necesario, sin complicar la l√≥gica principal del programa. Al aprovechar funciones como `use`, excepciones personalizadas y la capacidad de tratar `try-catch` como expresi√≥n, podemos escribir c√≥digo m√°s claro, idiom√°tico y robusto.

### üîë Puntos clave

- Kotlin permite lanzar excepciones con `throw`, una expresi√≥n de tipo `Nothing` que interrumpe el flujo normal del programa.
- El bloque `try-catch` en Kotlin es una expresi√≥n, lo que permite manejar errores de forma m√°s fluida dentro de funciones.
- El bloque `finally` garantiza que los recursos se liberen incluso cuando ocurren errores, y la funci√≥n `use` lo reemplaza idiom√°ticamente.
- Las excepciones en Kotlin no son chequeadas, lo cual simplifica el c√≥digo pero requiere documentar cuidadosamente el comportamiento de las funciones.
- Las excepciones personalizadas permiten expresar con claridad errores espec√≠ficos del dominio de una biblioteca.

### üß∞ ¬øQu√© nos llevamos?

Dise√±ar bibliotecas implica prever errores y ofrecer mecanismos claros para que otras personas los manejen. Usar excepciones de forma controlada, sin abusar de ellas como flujo normal, permite mantener la integridad de la l√≥gica y mejorar la experiencia de quienes integran nuestras bibliotecas. Siempre que sea posible, considera si una excepci√≥n es la mejor herramienta o si un tipo como `Result` o `Option` puede representar mejor un resultado alternativo.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Logo_C_sharp.svg/1200px-Logo_C_sharp.svg.png"
        language="C#"
        link="/docs/intro/exceptions/csharp"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/184143/java.svg"
        language="Java"
        link="/docs/intro/exceptions/java"
    />
    <JavaScriptCard link="/docs/intro/exceptions/js" />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/800px-Python-logo-notext.svg.png"
        language="Python"
        link="/docs/intro/exceptions/python"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="/docs/intro/exceptions/scala"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

- üåê Exceptions | Kotlin. (2025, marzo 7). Kotlin Help. https://kotlinlang.org/docs/exceptions.html
