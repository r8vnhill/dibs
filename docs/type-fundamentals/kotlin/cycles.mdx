---
title: Ciclos y rangos
---
import Exercise from '@site/src/components/exercise/Exercise'
import ReadingTime from '@site/src/components/ReadingTime'
import Solution from '@site/src/components/exercise/Solution'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import Hint from '@site/src/components/exercise/Hint'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Repetir acciones es una necesidad com√∫n en cualquier programa: desde mostrar una lista de elementos hasta validar entradas o aplicar una funci√≥n varias veces.Pero **la forma en que lo hacemos importa**.

En Kotlin, los ciclos est√°n dise√±ados para ser **expresivos y seguros**. En esta lecci√≥n exploraremos las principales formas de iteraci√≥n: bucles `for`, `while` y `do-while`, as√≠ como el uso de rangos y la funci√≥n `repeat`.

Tambi√©n aprenderemos a distinguir entre estructuras que **pueden recorrerse** y aquellas que solo **pueden evaluarse**, y veremos c√≥mo Kotlin prioriza la legibilidad sobre una flexibilidad sin control.

## üîÅ Declaraci√≥n `for`

> En Kotlin, `for` es una **declaraci√≥n**, no una expresi√≥n.
Esto significa que **no devuelve un valor**: se usa **para ejecutar instrucciones**, como imprimir o modificar datos, **no para producir resultados**.

<details>
  <summary>üß† ¬øY en otros lenguajes?</summary>

  A diferencia de Kotlin, donde `for` es solo una declaraci√≥n, en lenguajes como **Scala**, **Haskell** o **Python** existen formas de **recorrer estructuras** que tambi√©n **devuelven un valor**.

  #### üì¶ Scala (`for` como expresi√≥n)

  En Scala, los bucles `for` pueden generar nuevas colecciones mediante `yield`:

  ```scala
  val doubled = for x <- List(1, 2, 3) 
      yield x * 2
  // Resultado: List(2, 4, 6)
  ```

  Esto se conoce como **for-comprehension**, y combina `map`, `flatMap` y `filter` de forma declarativa.

  #### üî¢ Haskell (`forM` mon√°dico)

  Aunque Haskell no tiene un bucle `for` tradicional, puedes recorrer estructuras con efectos usando `forM` del m√≥dulo `Control.Monad`:

  ```haskell
  import Control.Monad (forM)

  forM [1..3] (\x -> return (x * 2))
  -- Resultado (en una m√≥nada pura): [2, 4, 6]
  ```

  `forM` invierte los argumentos de `mapM` para mayor claridad.

  #### üêç Python (comprensiones de listas)

  Las *list comprehensions* permiten construir listas a partir de iteraciones:

  ```python
  [x * 2 for x in range(1, 4)]
  # Resultado: [2, 4, 6]
  ```

  Tambi√©n existen variantes para conjuntos y diccionarios.

  ---

  En todos estos lenguajes, los bucles pueden **devolver un valor** al mismo tiempo que recorren estructuras.  
  En Kotlin, ese papel lo cumplen funciones como `map`, `filter` o `fold`, mientras que `for` est√° pensado para ejecutar acciones con efectos colaterales (como imprimir).
</details>

```kotlin title="Sintaxis b√°sica de un bucle for"
for (variable in rango) {
    // cuerpo del ciclo
}
```

Las llaves `{}` son opcionales si el cuerpo del ciclo tiene una sola l√≠nea, pero se recomienda mantenerlas por legibilidad y para evitar errores al modificar el c√≥digo m√°s adelante.

### Ejemplos:

```kotlin showLineNumbers title="Ejemplos de bucles for (omitimos llaves para simplificar)"
for (i in 1..5) print(i)         // Imprime: 12345 (incluye el 5)
for (i in 5 downTo 1) print(i)   // Imprime: 54321 (cuenta hacia atr√°s)
for (i in 1..5 step 2) print(i)  // Imprime: 135 (salta de 2 en 2)
for (i in 1..<5) print(i)        // Imprime: 1234 (excluye el 5)
for (i in 1 until 5) print(i)    // Equivalente a 1..<5
```

<Explanation>
  - `1..5`: Crea un rango **cerrado**, que incluye el 5.
  - `5 downTo 1`: Cuenta en reversa.
  - `step`: Cambia el tama√±o del paso (por ejemplo, saltar de 2 en 2).
  - `..<` y `until`: Crean un rango **semiabierto** que **excluye** el l√≠mite superior.
</Explanation>

Tambi√©n puedes usar rangos con otros tipos de datos, como caracteres:

```kotlin showLineNumbers title="Iterar sobre caracteres con for"
for (c in 'a'..'e') print(c)         // Imprime: abcde
for (c in 'e' downTo 'a') print(c)   // Imprime: edcba
```

:::tip Rangos m√°s all√° de n√∫meros

En Kotlin, los rangos no se limitan a enteros: puedes usarlos con **cualquier tipo que implemente `Comparable`**, como `Char`, `String`, `Double`, entre otros.

Esto permite escribir expresiones como:

```kotlin title="Rangos con tipos no enteros"
'a'..'z'          // Rango de caracteres
"Foo".."Foz"      // Rango de strings por orden lexicogr√°fico
1.0..5.0          // Rango de n√∫meros en punto flotante
```

Ten en cuenta que no todos los rangos admiten iteraci√≥n. Por ejemplo, `1.0..5.0` crea un rango v√°lido, pero **no puede usarse directamente en un bucle `for`**.

:::

::::warning ¬øSe pueden recorrer con `for`?

No siempre.  
Aunque muchos tipos pueden formar un rango, **no todos los rangos pueden usarse en un ciclo `for`**.

Solo algunos tipos como `Int`, `Long` y `Char` implementan lo necesario para que un rango sea tambi√©n una **secuencia iterable**.  
En cambio, rangos como `1.0..5.0` (`Double`) o `"Foo".."Foz"` (`String`) **no se pueden recorrer directamente con `for`**, porque Kotlin no sabe c√≥mo avanzar de un valor al siguiente.

:::note ¬øQu√© valor sigue?

Pi√©nsalo un momento:

- ¬øQu√© n√∫mero sigue despu√©s de `1.0`?  
  ¬ø`1.1`, `1.01`, `1.000001`, `1 + 1e-100`‚Ä¶?
- ¬øY qu√© `String` viene despu√©s de `"Foo"`?  
  ¬ø`"Fop"`?, ¬ø`"Fooa"`?, ¬ø`"Foofighters"`?

Estas preguntas **no tienen una √∫nica respuesta correcta**, por lo que Kotlin evita asumir una l√≥gica arbitraria.

:::

Por eso es importante distinguir entre **crear un rango** y **recorrer un rango**.  
**No todos los rangos son secuencias.**

:::: 

<details>
    <summary>üí° ¬øY si quiero recorrer algo distinto?</summary>

    Cualquier estructura que implemente [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/) puede recorrerse con un bucle `for`.  
    Esto incluye **listas**, **conjuntos**, **mapas** (usando `entries`), y muchas otras colecciones est√°ndar.

    ```kotlin showLineNumbers
    val sins = listOf("Lust", "Gluttony", "Envy", "Greed", "Wrath", "Sloth", "Pride")
    for (sin in sins) {
        println("Homunculus: $sin")
    }
    ```

    Este fragmento imprime los nombres de los siete **hom√∫nculos** que representan los *pecados capitales* en *Fullmetal Alchemist*.

    Este comportamiento es posible gracias al **patr√≥n de iterador** (`Iterator`), que veremos m√°s adelante en el curso.
</details>

## üìè Verificar si un valor pertenece a un rango

En Kotlin, puedes usar el operador `in` (y su negaci√≥n `!in`) para verificar si un valor est√° **dentro de un rango**.  
Este operador devuelve un valor `Boolean`, por lo que se puede usar directamente en condiciones:

```kotlin showLineNumbers title="Usar in y !in para verificar pertenencia a un rango"
if (x in 1..10) {
    println("$x est√° entre 1 y 10")
}
if (x !in 20..30) {
    println("$x no est√° entre 20 y 30")
}
```

Tambi√©n puedes usarlo dentro de expresiones `when`:

```kotlin showLineNumbers title="Uso de rangos con when"
when (x) {
    in 1..10 -> println("Est√° entre 1 y 10")
    !in 100..200 -> println("Est√° fuera del rango 100 a 200")
    else -> println("Caso no contemplado")
}
```

El operador `in` tambi√©n funciona con otros tipos comparables como caracteres o strings:

```kotlin showLineNumbers title="Verificaci√≥n de pertenencia en rangos no num√©ricos"
if (c in 'a'..'z') {
    println("$c es una letra min√∫scula")
}
if (s in "Foo".."Foz") {
    println("$s est√° entre Foo y Foz")
}
```

<details>
    <summary>üîç ¬øC√≥mo funciona realmente el operador <code>in</code>?</summary>

    Los operadores `in` y `!in` funcionan no solo con rangos, sino tambi√©n con muchas estructuras est√°ndar de Kotlin como listas, conjuntos y mapas.

    ```kotlin
    val songs = listOf("Perfect Day", "Walk on the Wild Side", "Satellite of Love")

    if ("Perfect Day" in songs) {
        println("üéµ Lou Reed is in the playlist.")
    }
    ```

    Esto es posible porque estas colecciones implementan la funci√≥n `contains`.  
    Es decir, `in` es simplemente una forma m√°s legible de escribir `songs.contains("Perfect Day")`.

    :::tip ¬øY si quiero usar `in` con mis propias clases?

    Cualquier clase que defina la funci√≥n `contains` de forma adecuada puede usarse con `in` y `!in`.

    En otras palabras, el operador `in` es una **forma alternativa de escribir una llamada a `contains`**, y puedes habilitarlo en tus propias clases si defines esa funci√≥n.  
    Veremos c√≥mo hacerlo m√°s adelante en el curso, al estudiar **sobrecarga de operadores**.

    :::
</details>

## üîÑ Declaraci√≥n `while`

En Kotlin, la declaraci√≥n `while` permite repetir un bloque de c√≥digo **mientras se cumpla una condici√≥n booleana**.  
Existen dos variantes principales:

```kotlin title="Bucle while"
while (condici√≥n) {
    // cuerpo del ciclo
}
```

- Eval√∫a la condici√≥n **antes** de ejecutar el cuerpo.
- Si la condici√≥n es falsa desde el inicio, el cuerpo **no se ejecuta**.

```kotlin title="Bucle do-while"
do {
    // cuerpo del ciclo
} while (condici√≥n)
```

- Ejecuta el cuerpo **al menos una vez**, y luego eval√∫a la condici√≥n.
- Es √∫til cuando necesitas que la acci√≥n se ejecute **al menos una vez**, como al pedir una entrada de usuario o realizar una verificaci√≥n inicial.

<Explanation>
    Ambos estilos permiten repetir tareas de forma controlada:

    - Usa `while` cuando **la condici√≥n debe cumplirse desde el inicio**.
    - Usa `do-while` cuando **el cuerpo debe ejecutarse al menos una vez** antes de volver a verificar la condici√≥n.
</Explanation>

### üåÄ Ejemplo: Buscando configuraci√≥n disponible

```kotlin showLineNumbers title="Reintento con m√∫ltiples fuentes de configuraci√≥n"
val sources = listOf("user.yaml", "project.yaml", "default.yaml")
var index = 0
var config: Config? = null

do {
    val file = sources[index]
    println("Intentando cargar configuraci√≥n desde $file")
    config = loadConfig(file)
    index++
} while (config == null && index < sources.size)

if (config == null) {
    error("No se pudo cargar ninguna configuraci√≥n v√°lida.")
}
```

<Explanation>
    En este ejemplo, una biblioteca de configuraci√≥n intenta cargar archivos en un orden predefinido.
    Se usa `do-while` porque **necesitamos intentar al menos una vez** antes de saber si debemos continuar. 
</Explanation>

## üîÇ Funci√≥n `repeat`

La funci√≥n `repeat` es una forma concisa de ejecutar un bloque de c√≥digo un n√∫mero espec√≠fico de veces. Su sintaxis es:

```kotlin title="Sintaxis de repeat"
repeat(n) {
    // cuerpo del ciclo
}
```

- `repeat` es una **funci√≥n** (no una declaraci√≥n), lo que la convierte en una **expresi√≥n**.
- Esto significa que puede usarse dentro de otras expresiones o asignarse a una variable.
- Sin embargo, **devuelve `Unit`**, por lo que su valor de retorno raramente se utiliza en la pr√°ctica:

```kotlin showLineNumbers title="We are the knights who say Ni!"
repeat(3) {
    println("Ni!")
}
```

Este ejemplo imprimir√° `"Ni!"` tres veces.

<Explanation>
    - `repeat` es ideal cuando necesitas repetir algo un n√∫mero fijo de veces y no necesitas un √≠ndice.
    - Si **s√≠ necesitas saber en qu√© repetici√≥n est√°s** (como en `for (i in 0 until n)`), puedes usar la versi√≥n con √≠ndice:

    ```kotlin
    repeat(3) { i ->
        println("Iteration $i")
    }
    ```
</Explanation>


## üéØ Conclusiones

Los ciclos son una herramienta fundamental para controlar el flujo en cualquier lenguaje de programaci√≥n, y en Kotlin se presentan de forma concisa, segura y expresiva. En esta lecci√≥n exploramos las distintas formas de repetir acciones, desde ciclos `for` sobre rangos hasta bucles controlados por condiciones y repeticiones fijas.

Tambi√©n aprendimos a distinguir entre lo que se puede **crear** (como un rango) y lo que se puede **recorrer** (como una secuencia iterable), una diferencia clave para evitar errores sutiles al dise√±ar c√≥digo reutilizable.

### üîë Puntos clave

- `for` en Kotlin es una **declaraci√≥n**, no una expresi√≥n: se usa para ejecutar acciones, no para producir valores.
- Puedes recorrer rangos con `for` siempre que estos sean **iterables**, como los de `Int`, `Long` o `Char`.
- Otros tipos como `Double` o `String` pueden formar rangos, pero **no siempre pueden recorrerse**.
- El operador `in` permite verificar si un valor pertenece a un rango o a una colecci√≥n.
- Kotlin incluye dos variantes de ciclo condicional: `while` (eval√∫a antes) y `do-while` (eval√∫a despu√©s).
- La funci√≥n `repeat(n)` es una alternativa concisa para ejecutar un bloque un n√∫mero fijo de veces.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n fue mucho m√°s que un repaso de bucles: exploramos las distintas formas en que Kotlin nos permite **expresar repetici√≥n con claridad y prop√≥sito**.

Aprendimos a usar `for`, `while`, `do-while`, `repeat`, y a distinguir entre **rangos recorribles** y aquellos que no lo son. Pero sobre todo, entendimos que escribir ciclos no se trata de iterar por iterar, sino de **elegir la herramienta que mejor comunica la intenci√≥n del c√≥digo**.

Esta forma de pensar ‚Äîpriorizar expresividad, claridad y dise√±o‚Äî ser√° fundamental al construir bibliotecas.Porque no basta con que algo funcione: debe ser **legible, predecible y reusable**.

Y si lo pensamos bien, **aprender tambi√©n es un ciclo**: volvemos una y otra vez sobre los mismos conceptos, pero con m√°s contexto, m√°s herramientas, m√°s claridad. Al igual que los ciclos en el c√≥digo, lo importante no es solo repetir, sino **repetir con intenci√≥n**.

Y todo eso ‚Äîla expresividad, la intenci√≥n y el dise√±o‚Äî tambi√©n comienza en algo tan b√°sico como los ciclos.

## üìñ Referencias

### üî• Recomendadas

- [üåê *Ranges and progressions*](https://kotlinlang.org/docs/ranges.html) de la **documentaci√≥n oficial de Kotlin**: Explica c√≥mo crear y recorrer rangos con diferentes tipos y pasos personalizados, lo que resulta esencial para comprender el uso de `for`, `in`, `step`, y `downTo` en Kotlin.

### üîπ Adicionales

- [üéû *Ciclos en Kotlin: ¬°Domina while, do-while y for!* (Kotlin Bits #3)](https://youtu.be/QuHGHAo-mpc) de **Developer GB**: Una introducci√≥n pr√°ctica al uso de `while`, `do-while` y `for` en Kotlin con ejemplos sencillos como calcular factoriales o promedios; √∫til para personas que est√°n comenzando a programar y quieren entender c√≥mo y cu√°ndo usar cada tipo de ciclo.
- üìö *"Kotlin basics"* (pp. 17‚Äì43) en *"Kotlin in action"* de **Dmitry Jemerov & Svetlana Isakova**: Presenta las estructuras de control como `if`, `when`, `for` y rangos como `1..5`, destacando c√≥mo Kotlin las hace m√°s expresivas y uniformes que en Java, lo cual es clave para escribir ciclos claros y seguros.
