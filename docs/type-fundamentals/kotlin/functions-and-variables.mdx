---
title: Declaraci√≥n de funciones y variables
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Kotlin es un lenguaje que promueve la claridad, la expresividad y la seguridad. En la lecci√≥n anterior exploramos su filosof√≠a y vimos un primer ejemplo que nos permiti√≥ reconocer su sintaxis y estilo. Ahora es momento de enfocarnos en dos elementos esenciales para cualquier programa, y especialmente importantes para el desarrollo de bibliotecas reutilizables: las **funciones** y las **variables**.

En esta lecci√≥n aprender√°s c√≥mo declarar funciones tanto de forma tradicional como mediante expresiones, aprovechar√°s la **inferencia de tipos** para reducir redundancias y aumentar la legibilidad, y aprender√°s a elegir conscientemente entre **val** y **var**, dependiendo de la necesidad real de mutabilidad en tu c√≥digo. Adem√°s, discutiremos convenciones y buenas pr√°cticas que te ayudar√°n a mantener un estilo claro, coherente y alineado con el dise√±o idiom√°tico de Kotlin.

Comprender estos aspectos fundamentales te permitir√° escribir desde el inicio c√≥digo m√°s limpio, seguro y f√°cil de mantener, sentando las bases necesarias para la creaci√≥n de bibliotecas s√≥lidas y bien dise√±adas.

## üß© Funciones en Kotlin

Una **funci√≥n** en Kotlin es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es:

```kotlin title="Estructura general"
fun functionName(param1: Type1, param2: Type2 = defaultValue, ...): ReturnType {
    // Cuerpo de la funci√≥n
    return result
}
```

:::info Explicaci√≥n de la sintaxis

- **`fun`**: Palabra clave para definir la funci√≥n.
- **`functionName`**: Identificador claro y descriptivo para la funci√≥n.
- **`param1`, `param2`**: Par√°metros que recibe la funci√≥n, cada uno acompa√±ado de su tipo correspondiente.
  - Es posible declarar funciones sin par√°metros.
  - Tambi√©n es posible definir par√°metros opcionales con valores predeterminados.
- **`ReturnType`**: Tipo de dato que devuelve la funci√≥n.
  - Si una funci√≥n no devuelve ning√∫n valor √∫til, se usa el tipo especial `Unit` (el cual es impl√≠cito si se omite).
- **Cuerpo de la funci√≥n**: Bloque de instrucciones que especifican la tarea concreta que realizar√° la funci√≥n.
:::


### ‚ûï Ejemplo: Sumar dos n√∫meros

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

Cuando una funci√≥n tiene una sola expresi√≥n, se puede simplificar con la sintaxis de asignaci√≥n directa:

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int): Int = a + b
```

Y a√∫n m√°s, el tipo de retorno puede deducirse autom√°ticamente:

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int) = a + b
```

Esto hace que el c√≥digo sea m√°s conciso y legible.

:::note Si vienes de Scala...

En Kotlin, **la palabra clave `return` es necesaria** cuando se usa el bloque cl√°sico `{ ... }`. A diferencia de Scala, donde la √∫ltima expresi√≥n de una funci√≥n se devuelve impl√≠citamente, en Kotlin eso solo ocurre cuando usas la sintaxis de una sola expresi√≥n (`= ...`).

:::

::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n en funci√≥n del contexto. En el ejemplo anterior, como la funci√≥n tiene una √∫nica expresi√≥n, el tipo de retorno se infiere autom√°ticamente.

:::warning No abuses de la inferencia

Aunque la inferencia de tipos puede hacer el c√≥digo m√°s limpio, **no siempre es conveniente** omitir los tipos. En funciones p√∫blicas o m√°s complejas, declararlos expl√≠citamente mejora la claridad y la mantenibilidad.

:::
::::

::::tip Estilo de nombres

En Kotlin, **los nombres de funciones y variables siguen la convenci√≥n `camelCase`**. Esto significa que:

- El nombre comienza con min√∫scula.
- Cada palabra posterior se une sin espacios, iniciando con may√∫scula.

Ejemplos correctos:
- `calculateTotal`
- `printMessage`
- `main`

Usar un estilo consistente mejora la legibilidad del c√≥digo y se alinea con las pr√°cticas recomendadas del lenguaje.

:::danger Ejemplos incorrectos

Evita estos estilos comunes en otros lenguajes o por h√°bitos anteriores:

- `CalculateTotal` ‚Üí ‚ùå Estilo PascalCase (usado en clases, no funciones)
- `calculate_total` ‚Üí ‚ùå Snake_case (com√∫n en Python, no en Kotlin)
- `calculate-total` ‚Üí ‚ùå Kebab-case (no permitido como identificador en Kotlin)
- `CALCULATE_TOTAL` ‚Üí ‚ùå Usado para constantes, no para funciones

:::
::::


## üì¶ Declaraci√≥n de variables

En Kotlin puedes declarar variables usando:

- `val` ‚Üí **inmutable** (no puede cambiarse tras inicializarse)
- `var` ‚Üí **mutable** (puede cambiarse despu√©s)

```kotlin title="Sintaxis general"
val/var nombreVariable: Tipo = valor
```

### üîí Inmutable (`val`)

Usa `val` cuando la referencia de la variable no cambiar√° despu√©s de su primera asignaci√≥n. Una vez asignada, no podr√°s reasignarle otro valor.

```kotlin showLineNumbers
val master = "Goomoonryong"
master = "Yi Shi-Woon"  // üî• Error: no se puede reasignar un 'val'

val student: String
student = "Haje Kang"   // ‚úÖ Correcto: se asigna una √∫nica vez
student = "Shi-Ho Lee"  // üî• Error: reasignaci√≥n no permitida
```

<Explanation>
    - **`master`** es una variable declarada con `val` e inicializada inmediatamente. Intentar cambiar su valor genera un error.
    - **`student`** es una variable declarada con `val`, pero asignada m√°s adelante. La primera asignaci√≥n es v√°lida, pero cualquier intento posterior provoca un error, pues su referencia es inmutable.
</Explanation>

### üîì Mutable (`var`)

Usa `var` cuando necesites cambiar la referencia o el valor de una variable despu√©s de declararla:

```kotlin showLineNumbers
var technique = "Black Heaven & Earth"
technique = "Soul-Crushing Strike"     // ‚úÖ Correcto: la variable puede cambiar

var energy = 10
energy = energy + 5                    // ‚úÖ Correcto: incrementa valor
energy += 5                            // ‚úÖ Equivalente m√°s conciso
energy++                               // ‚úÖ Incrementa en 1
```

<Explanation>
    - **`technique`** es una variable mutable declarada con `var` que cambia su referencia a otra t√©cnica diferente.
    - **`energy`** es una variable mutable num√©rica que demuestra distintas formas v√°lidas de modificar su valor: la forma expl√≠cita (`energy = energy + 5`), la abreviada (`energy += 5`) y la incremental (`energy++`).
</Explanation>

:::danger Inmutabilidad ‚â† inmutabilidad profunda

`val` en Kotlin **no garantiza** que el objeto sea inmutable, solo que **la referencia** no puede cambiar. Es decir, puedes modificar el contenido del objeto si este es mutable.

```kotlin showLineNumbers
val lista = mutableListOf(1, 2, 3)
lista.add(4)  // ‚úÖ Esto es v√°lido, aunque 'lista' sea un val
lista = mutableListOf(5, 6, 7) // üî• Error: reasignar est√° prohibido
```

En cambio, en lenguajes como **Rust**, declarar una variable con `let` de forma inmutable **tambi√©n impide modificar su contenido**:

```rust showLineNumbers
let mut lista = vec![1, 2, 3];
lista.push(4); // ‚úÖ si y solo si fue declarada como 'mut'

let lista_fija = vec![1, 2, 3];
lista_fija.push(4); // üî• Error: no se puede modificar
```

:::

:::tip ¬°Prefiere `val`!

Siempre que sea posible, **prefiere `val` en lugar de `var`**. La inmutabilidad hace que el c√≥digo sea m√°s f√°cil de entender, mantener y menos propenso a errores.  
Usa `var` solo cuando realmente necesites cambiar el valor de una variable.

```kotlin
// Mejor con val: no cambia
val basePower = 42
val bonus = 8
val total = basePower + bonus

// Menos claro con var: ¬øcambia por alguna raz√≥n?
var total = 42
total += 8
```

El primer caso expresa claramente que `total` es una **combinaci√≥n fija** de `basePower` y `bonus`, mientras que el segundo **invita a preguntarse si `total` cambiar√° m√°s adelante**.

:::

## üß† Ejercicio: T√©cnicas ninja con valores

<Exercise>
    Imagina que est√°s creando una biblioteca para videojuegos que permita definir y mostrar t√©cnicas especiales de personajes. Como primer paso, necesitas una funci√≥n que construya el nombre completo de una t√©cnica secreta a partir de sus partes.

    Tu tarea consiste en escribir una funci√≥n llamada `buildTechniqueName` que reciba tres par√°metros (`userName`, `techniqueType`, `attackName`) y los combine en una sola cadena. El segundo par√°metro (`techniqueType`) debe tener un valor por defecto de `"Ninjutsu"`.

    ### üß™ Ejemplo de uso

    ```kotlin
    buildTechniqueName("Naruto", attackName = "Kage Bunshin no Jutsu")
    // devuelve: "Naruto's Ninjutsu: Kage Bunshin no Jutsu"

    buildTechniqueName("Sasuke", "Kekkei Genkai", "Amaterasu")
    // devuelve: "Sasuke's Kekkei Genkai: Amaterasu"
    ```

    <Hint hints={[
        <>
            Usa la forma <code>= ...</code> para funciones con una sola expresi√≥n.
        </>,
        <>
            Puedes usar <code>$variable</code> o <code>${'{expresi√≥n}'}</code> para interpolar cadenas.
        </>
    ]} />

    <Solution>
        ```kotlin showLineNumbers title="app/src/main/kotlin/org/example/Technique.kt"
        package org.example

        fun buildTechniqueName(
            userName: String,
            techniqueType: String = "Ninjutsu",
            attackName: String
        ): String = "$userName's $techniqueType: $attackName"
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

En esta lecci√≥n exploramos dos pilares fundamentales de cualquier lenguaje de programaci√≥n: las **funciones** y las **variables**. Aprendimos c√≥mo se declaran en Kotlin, c√≥mo se comportan, y c√≥mo aprovechar sus reglas para escribir c√≥digo m√°s expresivo, seguro y legible.

Kotlin promueve un estilo claro y pragm√°tico, favoreciendo la **inferencia de tipos**, la **sintaxis de una sola expresi√≥n** y una fuerte orientaci√≥n hacia la **inmutabilidad**. Su distinci√≥n entre referencias **mutables** (`var`) e **inmutables** (`val`) no solo es una cuesti√≥n de estilo, sino una herramienta para fomentar una programaci√≥n m√°s **predecible** y **menos propensa a errores**.

### üîë Puntos clave

- Las funciones pueden declararse con bloques `{ ... }` o como **expresiones √∫nicas** `= ...`, permitiendo estilos m√°s concisos y expresivos.
- La **inferencia de tipos** reduce redundancias, pero los tipos expl√≠citos siguen siendo recomendables en interfaces p√∫blicas.
- Kotlin diferencia claramente entre **`val` (inmutable)** y **`var` (mutable)**, y promueve el uso de `val` por defecto.
- La inmutabilidad de `val` se aplica a la **referencia**, no al contenido del objeto.
- Seguir la convenci√≥n `camelCase` mejora la legibilidad y coherencia del c√≥digo.

### üß∞ ¬øQu√© nos llevamos?

Estas herramientas forman la base para escribir funciones reutilizables, expresivas y seguras, con una sintaxis que favorece la claridad desde el principio.  
Entender c√≥mo y cu√°ndo usar `val`, `var`, y c√≥mo estructurar funciones, nos prepara para **construir bibliotecas idiom√°ticas, mantenibles y f√°ciles de usar**.

En las pr√≥ximas lecciones, aplicaremos estos fundamentos al dise√±ar estructuras de datos, operadores personalizados, y APIs que comuniquen su intenci√≥n de forma clara y robusta.  
Ahora que dominas las bases, tu c√≥digo puede comenzar a hablar el lenguaje de Kotlin.

## üìñ Referencias

### üî• Recomendadas

- üåê Basic syntax | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 3 de abril de 2025, de https://kotlinlang.org/docs/basic-syntax.html
