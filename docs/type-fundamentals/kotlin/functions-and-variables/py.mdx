---
title: Declaraci√≥n de funciones y variables en Python
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Definition from '@site/src/components/Definition'
import References from '@site/src/components/ReferencesComponent'

<ReadingTime />

## üß© Funciones en Python

En Python, las funciones se definen usando la palabra clave `def`. A diferencia de Kotlin, **no se declara el tipo de los par√°metros ni del valor de retorno** (aunque puedes usar anotaciones opcionales).

```python
def sum(a: int, b: int):
    return a + b
```

### ‚úçÔ∏è Par√°metros con valores por defecto

Python, al igual que Kotlin, **permite valores por defecto** en los par√°metros, lo que facilita escribir funciones m√°s flexibles sin necesidad de sobrecarga.

```python
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"
```

A diferencia de Kotlin, Python **no permite m√∫ltiples funciones con el mismo nombre**, por lo que el uso de valores por defecto es especialmente √∫til como alternativa a la sobrecarga.

### üîç Tipos opcionales

Python permite usar anotaciones de tipo, pero **no son obligatorias** ni comprobadas en tiempo de compilaci√≥n (aunque pueden ser verificadas con herramientas como `mypy`).

```python
def sum(a: int, b: int) -> int:
    return a + b
```

Esto hace que la verificaci√≥n de tipos sea **opcional y externa**, a diferencia del sistema fuerte y est√°tico de Kotlin.

### üö´ Expresiones √∫nicas

Python **no tiene una sintaxis espec√≠fica para declarar funciones como expresiones** (como `= ...` en Kotlin). En su lugar, se puede usar `lambda`, pero con importantes restricciones:

```python
add = lambda a, b: a + b  # solo permite una expresi√≥n, sin return ni cuerpo m√∫ltiple
```

Esto es menos potente y menos idiom√°tico para definir funciones con l√≥gica compleja, a diferencia de la sintaxis de expresiones de Kotlin.

<ProCons>
<Pros title="Ventajas de Python">
- Sintaxis sencilla y legible para principiantes.
- Permite definir funciones con tipos o sin ellos.
- Los valores por defecto eliminan la necesidad de sobrecarga.
</Pros>
<Cons title="Limitaciones comparadas con Kotlin">
- Las funciones no pueden declararse como expresiones completas con m√∫ltiples l√≠neas.
- No hay inferencia de tipos fuerte en tiempo de compilaci√≥n.
- Las funciones lambda son muy limitadas (solo una expresi√≥n).
</Cons>
</ProCons>

## üì¶ Declaraci√≥n de variables

En Python, las variables se declaran simplemente **asignando un valor**. No necesitas usar palabras clave como `val` o `var`.

```python
technique = "Black Heaven & Earth"
energy = 10
```

Esto implica que **todas las variables son mutables por defecto**. No existe una forma directa de declarar una variable como "inmutable" como lo har√≠as con `val` en Kotlin.

### üîÅ Mutabilidad en Python

Aunque las variables son siempre mutables, **la mutabilidad del contenido depende del tipo del objeto**:

```python
numbers = [1, 2, 3]
numbers.append(4)  # ‚úÖ Esto es v√°lido
```

Y al igual que en Kotlin, si apuntas a un objeto mutable, su contenido puede cambiar incluso si no cambias la referencia.

### üîí ¬øY constantes?

Python **no tiene soporte nativo para constantes**. Por convenci√≥n, se escribe en may√∫sculas:

```python
MAX_SIZE = 100
```

Pero esto **no impide que se modifique** el valor. Es solo una pr√°ctica recomendada, no una garant√≠a del lenguaje.

<Explanation>
    Si necesitas proteger una constante o propiedad, debes usar mecanismos externos como clases, propiedades de solo lectura (`@property`) o herramientas como `typing.Final`.
</Explanation>

## ‚öñÔ∏è Comparaci√≥n directa

| Caracter√≠stica                         | Kotlin                              | Python                                   |
|---------------------------------------|-------------------------------------|------------------------------------------|
| Inferencia de tipos                   | Fuerte, en tiempo de compilaci√≥n    | D√©bil, solo en ejecuci√≥n                 |
| Declaraci√≥n de inmutabilidad (`val`)  | Soportada de forma nativa           | No soportada (solo convenci√≥n)           |
| Tipado                                 | Est√°tico                            | Din√°mico (opcional con anotaciones)      |
| Sintaxis de funciones como expresi√≥n  | S√≠ (`= ...`)                        | Limitada (`lambda`)                      |
| Par√°metros con valores por defecto    | Soportados                          | Soportados                               |
| Verificaci√≥n de tipos                 | En tiempo de compilaci√≥n            | Solo con herramientas externas           |

## üß† Conclusi√≥n

Python es un lenguaje expresivo y flexible, pero su sistema de tipos es mucho m√°s relajado que el de Kotlin. Esto puede ofrecer agilidad en fases tempranas, pero tambi√©n **reduce las garant√≠as de seguridad y mantenibilidad**, especialmente en bibliotecas grandes.

En contraste, Kotlin promueve una sintaxis m√°s expl√≠cita y coherente con su filosof√≠a de seguridad en tiempo de compilaci√≥n: tipos fuertes, inferencia controlada, y un enfoque claro en la inmutabilidad.

Si vienes de Kotlin, programar en Python te parecer√° m√°s permisivo, pero tambi√©n m√°s propenso a errores si no aplicas disciplina.  
Y si vienes de Python, Kotlin puede parecer m√°s restrictivo al principio, pero su sistema de tipos **te ayuda a construir APIs m√°s robustas, autoverificables y f√°ciles de documentar**.

## üìñ Referencias

- [PEP 8 - Gu√≠a de estilo para Python](https://peps.python.org/pep-0008/)
- [PEP 484 - Type Hints](https://peps.python.org/pep-0484/)
- [Documentaci√≥n oficial de Python sobre funciones](https://docs.python.org/3/tutorial/controlflow.html#defining-functions)
