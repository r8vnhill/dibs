---
title: Declaraci√≥n de funciones y variables
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />

Ahora es momento de enfocarnos en dos elementos esenciales para cualquier programa ‚Äîy especialmente importantes al desarrollar bibliotecas reutilizables‚Äî: las funciones y las variables.
En una biblioteca, estos elementos constituyen la interfaz p√∫blica (API), por lo que deben dise√±arse con claridad, coherencia y prop√≥sito.

En esta lecci√≥n aprender√°s a declarar funciones tanto de forma tradicional como mediante expresiones, aprovechar√°s la **inferencia de tipos** para reducir redundancias y aumentar la legibilidad, y entender√°s c√≥mo elegir conscientemente entre **val** y **var**, seg√∫n la necesidad real de mutabilidad en tu c√≥digo. Tambi√©n discutiremos convenciones y buenas pr√°cticas para mantener un estilo claro, coherente y alineado con el dise√±o idiom√°tico de Kotlin.

Comprender estos aspectos fundamentales te permitir√° escribir, desde el inicio, un c√≥digo m√°s limpio, seguro y f√°cil de mantener, sentando las bases necesarias para construir bibliotecas s√≥lidas y bien dise√±adas.

## üß© Funciones en Kotlin

Una **funci√≥n** en Kotlin es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es la siguiente:

```kotlin title="Estructura general"
fun functionName(param1: Type1, param2: Type2 = defaultValue, ...): ReturnType {
    // Cuerpo de la funci√≥n
    return result
}
```

:::info Explicaci√≥n de la sintaxis

- **`fun`**: Palabra clave que se utiliza para declarar una funci√≥n.
- **`functionName`**: Nombre descriptivo que identifica la funci√≥n.
- **`param1`, `param2`**: Par√°metros que recibe la funci√≥n, cada uno con su tipo correspondiente.
  - Puedes declarar funciones sin par√°metros si no los necesitas.
  - Tambi√©n puedes definir par√°metros opcionales, asign√°ndoles valores predeterminados.
- **`ReturnType`**: Tipo del valor que retorna la funci√≥n.
  - Si la funci√≥n no retorna ning√∫n valor √∫til, se utiliza el tipo especial `Unit` (puede omitirse, ya que es impl√≠cito).
- **Cuerpo de la funci√≥n**: Conjunto de instrucciones que definen el comportamiento de la funci√≥n.

:::


### ‚ûï Ejemplo: Sumar dos n√∫meros

```kotlin showLineNumbers title="Versi√≥n con cuerpo de bloque"
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

Si la funci√≥n consiste en una √∫nica expresi√≥n, puedes usar una sintaxis m√°s concisa mediante asignaci√≥n directa:

```kotlin showLineNumbers title="Versi√≥n con asignaci√≥n directa y tipo expl√≠cito"
fun sum(a: Int, b: Int): Int = a + b
```

Y a√∫n m√°s, Kotlin puede inferir autom√°ticamente el tipo de retorno:

```kotlin showLineNumbers title="Versi√≥n con inferencia de tipos"
fun sum(a: Int, b: Int) = a + b
```

Este estilo hace que el c√≥digo sea m√°s conciso, idiom√°tico y f√°cil de leer.

:::note Si vienes de Scala...

En Kotlin, **la palabra clave `return` es obligatoria** cuando usas el bloque cl√°sico `{ ... }`.
Esto contrasta con Scala, donde la **√∫ltima expresi√≥n se devuelve autom√°ticamente** sin necesidad de `return`.

En Kotlin, ese comportamiento impl√≠cito **solo ocurre** cuando usas la sintaxis de una sola expresi√≥n (`= ...`).

:::


::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n seg√∫n el contexto.
En el ejemplo anterior, como la funci√≥n tiene una √∫nica expresi√≥n, **el tipo de retorno se infiere autom√°ticamente**.

:::warning No abuses de la inferencia

Aunque la inferencia puede hacer el c√≥digo m√°s limpio y conciso, **no siempre es recomendable omitir los tipos**.
En funciones **p√∫blicas** o con l√≥gica **m√°s compleja**, declarar el tipo expl√≠citamente mejora la **claridad**, la **documentaci√≥n impl√≠cita** y la **mantenibilidad** del c√≥digo.

:::
::::

:::::tip Estilo de nombres

En Kotlin, **las funciones y variables deben nombrarse usando la convenci√≥n `camelCase`**. Esto significa:

- El nombre comienza con **min√∫scula**.
- Las palabras subsiguientes se escriben **pegadas**, iniciando con **may√∫scula**.

‚úÖ Ejemplos correctos:
- `calculateTotal`
- `printMessage`
- `main`

Un estilo de nombres consistente **mejora la legibilidad** y ayuda a mantener un c√≥digo coherente con las pr√°cticas idiom√°ticas de Kotlin.

::::danger Estilos incorrectos

Evita otros estilos que pueden venir de otros lenguajes o h√°bitos anteriores:

- `CalculateTotal` ‚Üí ‚ùå **PascalCase**, usado para **clases** y **tipos**, no funciones.
- `calculate_total` ‚Üí ‚ùå **snake_case**, t√≠pico de Python, **no se usa** en Kotlin.
- `calculate-total` ‚Üí ‚ùå **kebab-case**, **inv√°lido** como identificador en Kotlin.
- `CALCULATE_TOTAL` ‚Üí ‚ùå Reservado para **constantes**, no para funciones o variables mutables.

:::note ¬øY `val`?

Aunque `val` representa una variable inmutable, eso **no significa que sea una constante**.
En Kotlin, las variables en may√∫sculas como `CALCULATE_TOTAL` est√°n reservadas para **constantes**, es decir, valores que son conocidos y fijos **en tiempo de compilaci√≥n**.

Ampliaremos esta idea m√°s adelante cuando veamos **definiciones est√°ticas** y c√≥mo Kotlin las maneja.

:::
::::
:::::


## üì¶ Declaraci√≥n de variables

En Kotlin puedes declarar variables de dos formas:

- `val` ‚Üí **inmutable**: no puede reasignarse una vez inicializada.
- `var` ‚Üí **mutable**: puede cambiar su valor posteriormente.

```kotlin title="Sintaxis general"
val o var nombreVariable: Tipo = valor
```

:::tip Inferencia de tipos

En ambos casos, el tipo puede omitirse si el compilador puede inferirlo.

:::

### üîí Inmutable (`val`)

Usa `val` cuando **la referencia** de la variable no cambiar√° despu√©s de su asignaci√≥n. Una vez inicializada, no podr√°s reasignarle otro valor.

```kotlin showLineNumbers title="Inmutabilidad con val: asignaci√≥n √∫nica y errores de reasignaci√≥n"
val master = "Goomoonryong"
master = "Yi Shi-Woon"  // üî• Error: no se puede reasignar un 'val'

val student: String
student = "Haje Kang"   // ‚úÖ Correcto: asignaci√≥n tard√≠a (solo una vez)
student = "Shi-Ho Lee"  // üî• Error: la referencia no puede cambiar
```

<Explanation>
    - **`master`** es una variable declarada con `val` e inicializada inmediatamente. Reasignarla genera un error de compilaci√≥n.
    - **`student`** tambi√©n es una `val`, pero se inicializa m√°s adelante. Kotlin permite esta inicializaci√≥n diferida siempre que se haga solo una vez.
</Explanation>

A lo largo del curso nos referiremos a estas variables como **constantes referenciales** o **propiedades de solo lectura**: su referencia no puede cambiar una vez asignada.

Esto **no implica** que el valor al que apuntan sea inmutable. Por ejemplo, una variable `val` puede referirse a una lista mutable, y aunque no puedas reasignar la variable, s√≠ puedes modificar el contenido de la lista.

M√°s adelante hablaremos de las **constantes en tiempo de compilaci√≥n**, que se declaran con `const val` y cuyo valor debe conocerse de antemano.  
Por ahora, basta con distinguir entre variables **mutables** (`var`) y **referencias inmutables** (`val`).

### üîì Mutable (`var`)

Usa `var` cuando necesites **modificar el valor o cambiar la referencia** de una variable despu√©s de declararla:

```kotlin showLineNumbers title="Variables mutables: reasignaci√≥n y actualizaci√≥n de valores"
var technique = "Black Heaven & Earth"
technique = "Soul-Crushing Strike"     // ‚úÖ Correcto: la referencia cambia a otra t√©cnica

var energy = 10
energy = energy + 5                    // ‚úÖ Correcto: suma expl√≠cita
energy += 5                            // ‚úÖ Equivalente m√°s conciso
energy++                               // ‚úÖ Incremento en 1
```

<Explanation>
    - **`technique`** es una variable mutable cuyo contenido puede cambiar libremente: aqu√≠ cambia de una t√©cnica a otra.
    - **`energy`** demuestra distintas formas v√°lidas de modificar valores num√©ricos mutables: suma expl√≠cita, operaci√≥n compuesta (`+=`) e incremento (`++`).
</Explanation>

:::danger Inmutabilidad ‚â† inmutabilidad profunda

En Kotlin, declarar una variable con `val` **no significa** que su contenido sea inmutable, sino que **la referencia no puede cambiar**.  
Es decir, si el objeto apuntado es mutable, **puedes modificarlo**.

```kotlin showLineNumbers title="Kotlin: val no impide modificar el contenido"
val lista = mutableListOf(1, 2, 3)
lista.add(4)  // ‚úÖ Esto es v√°lido: el contenido cambia, no la referencia
lista = mutableListOf(5, 6, 7) // üî• Error: no se puede reasignar un val
```

En cambio, en lenguajes como **Rust**, la inmutabilidad por defecto **s√≠ aplica al contenido**, no solo a la referencia:

```rust showLineNumbers title="Inmutabilidad en Rust: let vs let mut"
let mut lista = vec![1, 2, 3];
lista.push(4); // ‚úÖ Solo si fue declarada con 'mut'

let lista_fija = vec![1, 2, 3];
lista_fija.push(4); // üî• Error: no se puede modificar
```

:::

:::tip ¬°Prefiere `val`!

Siempre que sea posible, **prefiere `val` en lugar de `var`**.
La inmutabilidad no solo mejora la legibilidad y el mantenimiento del c√≥digo, sino que **facilita el razonamiento formal** sobre su comportamiento.
Usa `var` √∫nicamente cuando realmente necesites que el valor de una variable **cambie a lo largo del tiempo**.

```kotlin showLineNumbers title="Expresividad e intenci√≥n: mejor con val que con var"
// ‚úÖ Mejor con val: expresa intenci√≥n, el valor no cambia
val basePower = 42
val bonus = 8
val total = basePower + bonus

// üî∂ Menos claro con var: sugiere que el valor puede cambiar
var total = 42
total += 8
```

En el primer caso, `total` es el resultado de una operaci√≥n fija y conocida.
En el segundo, el uso de `var` podr√≠a hacer pensar que `total` **seguir√° cambiando**, aunque no sea as√≠.

:::

## üß† Ejercicio pr√°ctico: T√©cnicas ninja con valores

<Exercise>
    Est√°s desarrollando una biblioteca para videojuegos que permita definir y mostrar **t√©cnicas especiales de personajes**.  
    Como primer paso, necesitas una funci√≥n que construya el nombre completo de una t√©cnica secreta a partir de sus componentes.

    Tu tarea es escribir una funci√≥n llamada `buildTechniqueName` que reciba tres par√°metros: el nombre del personaje (`userName`), el tipo de t√©cnica (`techniqueType`) y el nombre del ataque (`attackName`).  
    El par√°metro `techniqueType` debe tener un valor por defecto de `"Ninjutsu"`.

    ```kotlin showLineNumbers title="üß™ Ejemplos de uso"
    buildTechniqueName("Naruto", attackName = "Kage Bunshin no Jutsu")
    // devuelve: "Naruto's Ninjutsu: Kage Bunshin no Jutsu"

    buildTechniqueName("Sasuke", "Kekkei Genkai", "Amaterasu")
    // devuelve: "Sasuke's Kekkei Genkai: Amaterasu"
    ```

    <Hint hints={[
        <>Usa <code>=</code> para definir funciones como una √∫nica expresi√≥n.</>,
        <>Puedes usar <code>$variable</code> o <code>${'{expresi√≥n}'}</code> para interpolar valores dentro de cadenas.</>
    ]} />

    <Solution>
        ```kotlin showLineNumbers title="Construyendo el nombre de una t√©cnica secreta"
        fun buildTechniqueName(
            userName: String,
            techniqueType: String = "Ninjutsu",
            attackName: String
        ): String = "$userName's $techniqueType: $attackName"
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

En esta lecci√≥n exploramos dos pilares fundamentales de cualquier lenguaje de programaci√≥n: las **funciones** y las **variables**. Aprendimos c√≥mo se declaran en Kotlin, c√≥mo se comportan y c√≥mo aprovechar sus propiedades y convenciones para escribir c√≥digo m√°s expresivo, seguro y legible.

Kotlin promueve un estilo claro, pragm√°tico y expresivo, favoreciendo la **inferencia de tipos**, la **sintaxis de una sola expresi√≥n** y una fuerte orientaci√≥n hacia la **inmutabilidad**. Su distinci√≥n entre referencias **mutables** (`var`) e **inmutables** (`val`) no es solo una cuesti√≥n de estilo, sino una decisi√≥n de dise√±o que impulsa la escritura de c√≥digo **predecible** y **menos propenso a errores**.

### üîë Puntos clave

- Las funciones pueden declararse con bloques `{ ... }` o como **expresiones √∫nicas** `= ...`, permitiendo estilos m√°s concisos y expresivos.
- La **inferencia de tipos** reduce redundancias, pero los tipos expl√≠citos siguen siendo recomendables en interfaces p√∫blicas.
- Kotlin diferencia claramente entre **`val` (inmutable)** y **`var` (mutable)**, y promueve el uso de `val` por defecto.
- La inmutabilidad de `val` se aplica a la **referencia**, no al contenido del objeto.
- Seguir la convenci√≥n `camelCase` mejora la legibilidad y coherencia del c√≥digo.

### üß∞ ¬øQu√© nos llevamos?

Estas herramientas forman la base para escribir funciones reutilizables, expresivas y seguras, con una sintaxis que promueve la claridad desde la primera l√≠nea.
**En el contexto de bibliotecas de software, funciones y variables no son detalles de implementaci√≥n: forman la interfaz p√∫blica de la biblioteca**, y por tanto, deben ser dise√±adas con especial cuidado.

Entender c√≥mo y cu√°ndo usar `val`, `var`, y c√≥mo estructurar funciones no solo permite escribir buen c√≥digo: **es clave para construir APIs claras, idiom√°ticas y f√°ciles de mantener**.

A medida que avancemos en el curso, aplicaremos estos fundamentos al dise√±ar estructuras de datos, operadores personalizados, y componentes que comuniquen su intenci√≥n de forma precisa y robusta.
Ahora que dominas las bases, tu c√≥digo puede comenzar a hablar de forma idiom√°tica en Kotlin.

<div className="language-card-container">
    <LanguageCards.PythonCard link="/docs/type-fundamentals/kotlin/functions-and-variables/py" />    
</div>

## üìñ Referencias

### üî• Recomendadas

- [üåê Basic syntax](https://kotlinlang.org/docs/basic-syntax.html) de **la documentaci√≥n oficial de Kotlin**: Resume funciones, variables y control de flujo con ejemplos claros. √ötil como repaso general, aunque abarca m√°s temas de los vistos en esta lecci√≥n.

### üîπ Adicionales

- üìö *"Defining and calling functions"* (pp. 44‚Äì66) en *Kotlin in Action* de **Dmitry Jemerov y Svetlana Isakova**: Aborda funciones idiom√°ticas en Kotlin, con argumentos nombrados, valores por defecto y funciones de extensi√≥n. Relevante por mostrar c√≥mo estas herramientas mejoran el dise√±o de funciones en bibliotecas. Las funciones de extensi√≥n se explorar√°n m√°s adelante en el curso.
