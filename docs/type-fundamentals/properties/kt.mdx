---
title: Propiedades/Accessors
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard, AssertJCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

Al desarrollar bibliotecas de software, es fundamental definir estructuras de datos que no solo sean f√°ciles de usar, sino tambi√©n **robustas, seguras y expresivas**. Las propiedades en Kotlin ofrecen un mecanismo poderoso para encapsular estado, controlar acceso y definir reglas de negocio de forma declarativa.

En lugar de exponer campos directamente, Kotlin permite usar *getters* y *setters* personalizados, propiedades calculadas o con *backing fields*, lo que aporta claridad sem√°ntica y control fino sobre c√≥mo se accede y modifica la informaci√≥n.

En esta lecci√≥n, exploraremos c√≥mo aplicar estos mecanismos al dise√±ar bibliotecas reutilizables ‚Äîya sea de m√©tricas, gr√°ficos, geometr√≠a o configuraci√≥n‚Äî para que tus propiedades no solo sirvan como contenedores de datos, sino como contratos expl√≠citos sobre el comportamiento esperado del sistema.

### üß™ Setter personalizado: validaci√≥n de entrada

Sup√≥n que est√°s construyendo una biblioteca de gr√°ficos. Quieres exponer una propiedad `opacity` en un componente visual, pero restringir sus valores entre `0.0` y `1.0`:

```kotlin
class GraphicElement {
    var opacity: Double = 1.0
        set(value) {
            require(value in 0.0..1.0) { "Opacity must be between 0.0 and 1.0" }
            field = value
        }
}
```

<Explanation>
    Este setter personalizado valida que el valor est√© dentro del rango permitido antes de asignarlo.  
    `require` lanza una excepci√≥n si la condici√≥n no se cumple, y `field` hace referencia al valor interno de la propiedad.
</Explanation>


### ‚è± Propiedad calculada: evitar almacenamiento innecesario

En una biblioteca de m√©tricas, puedes querer exponer el tiempo actual cada vez que alguien lo consulte, sin almacenarlo:

```kotlin
class Timer {
    val timestamp: String
        get() = Clock.System.now().toString()
}
```

<Explanation>
    Esta propiedad calculada obtiene el tiempo actual cada vez que se accede, evitando almacenar un valor que quedar√≠a r√°pidamente obsoleto.  
    Es √∫til en bibliotecas donde se requiere informaci√≥n siempre actualizada sin gestionar su estado manualmente.
</Explanation>

## üîí Setter privado: control de modificaciones

En una biblioteca de configuraci√≥n, podr√≠as permitir leer un identificador desde fuera, pero restringir qui√©n puede modificarlo. As√≠ proteges valores importantes del estado interno de tu clase:

```kotlin
class Config {
    var id: String = "default"
        private set

    fun resetId() {
        id = "new-id"
    }
}
```

<Explanation>
    El `setter` privado impide que otras clases modifiquen directamente la propiedad `id`, protegiendo la integridad del estado.  
    Solo los m√©todos definidos dentro de `Config` pueden actualizar su valor, lo que ayuda a mantener un control m√°s estricto sobre su modificaci√≥n.
</Explanation>

:::tip Otros privilegios de acceso

Adem√°s de `private`, tambi√©n podemos definir setters con `protected` o `internal`, seg√∫n el nivel de acceso que queramos otorgar.

:::

## üé≠ Backing field privado: control de representaci√≥n

Supongamos que est√°s construyendo una biblioteca de geometr√≠a, y necesitas que una propiedad calcule internamente su representaci√≥n textual:

```kotlin
class Vector2D(private var _x: Double, private var _y: Double) {
    val description: String
        get() = "Vector(x=$_x, y=$_y)"
}
```

<Explanation>
    Esta propiedad calculada usa un *backing field* privado (`_x` y `_y`) para construir una descripci√≥n p√∫blica del vector.  
    De esta forma, se encapsula el estado interno y se expone una vista controlada sin permitir modificaciones externas directas.
</Explanation>

## üéØ Conclusiones

Las propiedades en Kotlin no son simples campos: son herramientas expresivas para controlar c√≥mo se accede, representa y modifica el estado dentro de una clase. Al desarrollar bibliotecas, esto se vuelve a√∫n m√°s relevante: una propiedad mal dise√±ada puede comprometer invariantes, exponer implementaci√≥n interna o dificultar la evoluci√≥n del API.

A trav√©s de setters personalizados, propiedades calculadas, setters restringidos y backing fields, Kotlin nos permite definir con precisi√≥n c√≥mo debe interactuar un usuario con nuestra API, manteniendo el equilibrio entre **ergonom√≠a, encapsulamiento y robustez**.

### üîë Puntos clave

1. **Un setter puede ser m√°s que asignaci√≥n**: validar entradas desde el inicio evita errores silenciosos en el uso de la API.
2. **Propiedades calculadas permiten evitar estados redundantes o inconsistentes**.
3. **Restricci√≥n de acceso a setters protege la integridad del modelo interno**.
4. **Backing fields privados facilitan separar estado interno de representaci√≥n externa.**

### üß∞ ¬øQu√© nos llevamos?

Al construir bibliotecas, no solo definimos funciones: **definimos contratos**. Las propiedades son parte fundamental de esos contratos. Saber cu√°ndo usar una propiedad calculada, cu√°ndo restringir un setter, o c√≥mo ocultar el estado interno sin perder expresividad, es clave para ofrecer **interfaces claras, seguras y f√°ciles de mantener**.

Las decisiones que tomas al definir propiedades afectan directamente la **calidad y confiabilidad del c√≥digo que otras personas escribir√°n usando tu biblioteca**. Aprovechar las herramientas que Kotlin ofrece para declararlas no solo mejora el dise√±o, tambi√©n eleva la experiencia de quien la utiliza.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Logo_C_sharp.svg/1200px-Logo_C_sharp.svg.png"
        language="C#"
        link="/docs/type-fundamentals/properties/csharp"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/800px-Python-logo-notext.svg.png"
        language="Python"
        link="/docs/type-fundamentals/properties/python"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Ruby_logo.svg/240px-Ruby_logo.svg.png"
        language="Ruby"
        link="/docs/type-fundamentals/properties/ruby"
    />
    <LanguageCard
        logoSrc="https://cdn-icons-png.flaticon.com/512/3984/3984314.png"
        language="Swift"
        link="/docs/type-fundamentals/properties/swift"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/800px-Typescript_logo_2020.svg.png"
        language="TypeScript"
        link="/docs/type-fundamentals/properties/typescript"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

üåê Properties | Kotlin. (2024, septiembre 25). Kotlin Help. https://kotlinlang.org/docs/properties.html
