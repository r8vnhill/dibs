---
title: Declaraci√≥n de funciones y variables en Python
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Definition from '@site/src/components/Definition'
import References from '@site/src/components/ReferencesComponent'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="python-dibs"/>

En esta lecci√≥n exploraremos c√≥mo se **definen funciones y se declaran variables en Python**, enfoc√°ndonos en las diferencias clave con Kotlin. Aunque ambos lenguajes permiten escribir c√≥digo conciso y expresivo, **Python adopta un enfoque mucho m√°s flexible y din√°mico**, lo que trae tanto beneficios como desaf√≠os.

A lo largo del contenido veremos:

- C√≥mo se definen funciones con y sin anotaciones de tipo.
- C√≥mo usar valores por defecto, `*args` y `**kwargs` para construir funciones vers√°tiles.
- Qu√© alternativas existen en Python para simular variables inmutables.
- Qu√© pr√°cticas se recomiendan al desarrollar bibliotecas o APIs reutilizables.

Este an√°lisis no solo busca ense√±ar la sintaxis de Python, sino tambi√©n ayudarte a entender sus **decisiones de dise√±o** y c√≥mo **adaptar buenas pr√°cticas** al trabajar en proyectos que exigen claridad, mantenibilidad y consistencia.

## üß© Funciones en Python

En Python, las funciones se definen con la palabra clave `def`, seguida del nombre, los par√°metros entre par√©ntesis y dos puntos (`:`) para iniciar el bloque. A diferencia de Kotlin, **no es obligatorio declarar los tipos de los par√°metros ni del valor de retorno**, aunque es posible usar **anotaciones de tipo opcionales**.

### ‚úÖ Con anotaciones de tipo (recomendado)

```python showLineNumbers title="Funci√≥n con anotaciones de tipo"
def add(a: int, b: int) -> int:
    return a + b
```

- `a: int` y `b: int` indican que los par√°metros deben ser enteros.
- `-> int` especifica que la funci√≥n deber√≠a devolver un entero.
- Estas anotaciones **no son obligatorias** ni afectan la ejecuci√≥n: Python **no verificar√° en tiempo de ejecuci√≥n** que los valores coincidan con los tipos indicados.

::::warning Esto no convierte a Python en un lenguaje de tipado est√°tico.

El int√©rprete ejecutar√° este c√≥digo incluso si los tipos no coinciden con las anotaciones. Por ejemplo:

```python showLineNumbers title="Python ignorando tipos"
def multiply(a: int, b: int) -> int:
    return a * b


print(multiply("üí•", 3))  # Esto imprime üí•üí•üí• en lugar de lanzar un error
```

Este comportamiento es v√°lido para el int√©rprete, pero puede generar errores sutiles si no se utiliza con cuidado.

::::

### üü° Sin anotaciones de tipo

```python showLineNumbers title="Funci√≥n sin anotaciones"
def sum(a, b):
    return a + b
```

- Esta forma es completamente v√°lida en Python y com√∫n en scripts peque√±os o experimentales.
- Sin embargo, **se pierde claridad** sobre qu√© se espera recibir o retornar, lo cual puede complicar el mantenimiento y dificultar la integraci√≥n con herramientas de an√°lisis.

:::tip Ante la duda, usa anotaciones de tipo

Aunque Python no hace cumplir las anotaciones, **usarlas es una buena pr√°ctica** cuando escribes funciones reutilizables, p√∫blicas o parte de una biblioteca. Te ayuda a detectar errores con herramientas como `mypy`, a mejorar la documentaci√≥n y a facilitar el trabajo en equipo.

:::

:::info ¬øY si no retorno nada?

Si no necesitas retornar nada, puedes usar `None` como tipo de retorno. Esto es similar a `Unit` en Kotlin.

```python showLineNumbers title="Funci√≥n sin retorno"
def do_nothing() -> None:
    pass
```

:::

### ‚úçÔ∏è Par√°metros con valores por defecto

Al igual que en Kotlin, en Python puedes asignar **valores por defecto a los par√°metros** de una funci√≥n. Esto permite definir funciones m√°s flexibles sin necesidad de m√∫ltiples versiones.

```python showLineNumbers title="Funci√≥n con par√°metro opcional"
def summon(character: str, location: str = "Rivendell") -> str:
    return f"{character} has been summoned to {location}."
```

- `summon("Gandalf")` retorna `"Gandalf has been summoned to Rivendell."`
- `summon("Aragorn", "Minas Tirith")` retorna `"Aragorn has been summoned to Minas Tirith."`

A diferencia de Kotlin, **Python no permite sobrecargar funciones** (es decir, definir varias funciones con el mismo nombre pero distinta firma). Por eso, los **valores por defecto son la forma principal de lograr comportamiento flexible** sin duplicar c√≥digo.

### üåü Par√°metros variables con `*args` y `**kwargs`

Python permite definir funciones que aceptan un n√∫mero **variable de argumentos posicionales** o **de palabras clave (keyword arguments)** usando `*args` y `**kwargs`, respectivamente.

Esto ofrece una gran flexibilidad, especialmente para construir APIs gen√©ricas, decoradores o funciones utilitarias.

#### ‚úÖ Usando `*args`

```python showLineNumbers title="Funci√≥n con *args y pattern matching"
def throw_pokeballs(*targets: str | int) -> None:
    for target in targets:
        match target:
            case str():
                print(f"You threw a Pok√©ball at {target}!")
            case int():
                print(f"You threw a Pok√©ball at Pok√©mon #{target}!")
```

<Explanation>
    - `*targets` captura todos los argumentos posicionales como una tupla.
    - La anotaci√≥n `str | int` indica que los elementos pueden ser cadenas (`"Pikachu"`) o enteros (`25`).
    - Se usa **pattern matching** (desde Python 3.10) para distinguir el tipo de cada valor y actuar en consecuencia.
</Explanation>

:::note ¬øPor qu√© `str | int`?

Esta forma de anotar tipos se llama **uni√≥n de tipos** y proviene de la **programaci√≥n funcional**. Indica que un valor puede ser de **uno u otro tipo**, pero no necesariamente ambos a la vez.

Aunque no forma parte del paradigma orientado a objetos tradicional (que se basa en jerarqu√≠as y polimorfismo por herencia), este enfoque es muy expresivo y **permite dise√±ar funciones m√°s concisas y seguras**, especialmente cuando combinamos uniones con `match`.

:::

#### ‚úÖ Usando `**kwargs` (argumentos con nombre)

```python showLineNumbers title="Funci√≥n con **kwargs"
def describe_technique(name: str, **details) -> None:
    print(f"Technique: {name}")
    for key, value in details.items():
        print(f"  {key}: {value}")
```

<Explanation>
    - `**details` captura todos los argumentos con nombre como un diccionario.
    - Esto permite pasar informaci√≥n adicional sin definir todos los par√°metros de antemano.
    - Llamar a `describe_technique("Phantom Mirage", speed="extreme", class_type="offensive")` imprimir√° cada atributo con su valor.
    - Este patr√≥n es muy √∫til para funciones que necesitan aceptar una configuraci√≥n flexible, como sistemas de habilidades o configuraciones din√°micas.
</Explanation>

#### ‚úÖ Usando `*args` y `**kwargs` juntos

```python showLineNumbers title="Funci√≥n con *args y **kwargs"
def cast_spell(caster: str, *companions: str, **spell_details) -> None:
    print(f"{caster} begins casting a spell!")
    if companions:
        print("Assisted by:", ", ".join(companions))
    for key, value in spell_details.items():
        print(f"{key.capitalize()}: {value}")
```

<Explanation>
    - `*companions` captura los nombres de otras brujas o personajes que colaboran en el hechizo.
    - `**spell_details` almacena los atributos del hechizo como un diccionario: elemento, duraci√≥n, poder, etc.
    - Llamar a `cast_spell("Akko", "Lotte", "Sucy", element="light", power="unstable")` imprime tanto los asistentes como los detalles del hechizo.
    - Este patr√≥n es ideal cuando se combinan **par√°metros obligatorios**, **listas variables de argumentos** y **configuraciones flexibles**.
</Explanation>

:::warning Cuidado con el uso excesivo de `*args` y `**kwargs`

`*args` y `**kwargs` son herramientas poderosas para construir funciones extensibles, pero pueden dificultar la comprensi√≥n o validaci√≥n de tipos si se abusa de ellas sin documentaci√≥n clara.

:::

## üì¶ Declaraci√≥n de variables

En Python, las variables se definen simplemente **asign√°ndoles un valor**, sin necesidad de palabras clave como `val` o `var`.

```python showLineNumbers title="Variables en Python"
name = "Emilia"
mana = 80
```

- `name` almacena una cadena (string).
- `mana` almacena un n√∫mero entero (int).

### üîÑ Mutabilidad por defecto

Todas las variables en Python son **mutables por defecto**: puedes reasignar su valor en cualquier momento.

```python
mana = 100  # It can be modified without error
```

Esto contrasta con Kotlin, donde puedes declarar una variable como inmutable usando `val`.

### üö´ Inmutabilidad por convenci√≥n

Python **no tiene una sintaxis nativa para declarar variables inmutables**. Algunas pr√°cticas comunes para simular constantes incluyen:

#### ‚úÖ Usar may√∫sculas por convenci√≥n

```python
MAX_MANA = 100
```

Esta convenci√≥n es informal y **no impide modificaciones**, pero se entiende que no debe cambiarse.

#### ‚úÖ Encapsular en una funci√≥n

Puedes encapsular un valor en una funci√≥n para **simular una constante inmutable**:

```python
def sanctuary_name() -> str:
    return "Elior Forest"
```

Esto evita que el valor sea reasignado directamente, pero sigue siendo **menos directo y m√°s restrictivo** que usar `val` en Kotlin.

### üîí Inmutabilidad con `Final` (Python 3.8+)

Desde Python 3.8, puedes usar [`Final`](https://docs.python.org/3/library/typing.html#typing.Final) del m√≥dulo `typing` para declarar que una variable **no debe ser reasignada**.

```python
from typing import Final

SPIRIT_NAME: Final[str] = "Puck"
```

Esto no cambia el comportamiento en tiempo de ejecuci√≥n, pero herramientas como `mypy` pueden detectar asignaciones incorrectas:

```python
SPIRIT_NAME = "Beatrice"  # ‚ö†Ô∏è mypy: Cannot assign to final variable "SPIRIT_NAME"
```

:::tip Buenas pr√°cticas

Si est√°s desarrollando bibliotecas o trabajando en proyectos colaborativos, usar `Final` es una forma clara de comunicar la intenci√≥n de inmutabilidad y evitar errores accidentales.

:::

## ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - Sintaxis simple y flexible para definir funciones y declarar variables.
        - Soporte opcional de anotaciones de tipo para mejorar documentaci√≥n y an√°lisis est√°tico.
        - Par√°metros con valores por defecto permiten flexibilidad sin necesidad de sobrecarga.
        - `Final` y herramientas externas como `mypy` permiten mejorar la seguridad y mantener la intenci√≥n del c√≥digo.
        - `*args` y `**kwargs` permiten dise√±ar funciones extensibles con interfaces din√°micas.
        - Pattern matching y uniones de tipo (`|`) acercan a Python a estilos m√°s expresivos y funcionales.
        - Ideal para prototipado r√°pido, scripting y desarrollo exploratorio gracias a su baja fricci√≥n.
    </Pros>
    <Cons>
        - El tipado no es obligatorio ni verificado en tiempo de ejecuci√≥n: **errores de tipo pueden pasar desapercibidos**.
        - No existe una forma nativa de declarar variables inmutables como `val` en Kotlin.
        - No se permite la sobrecarga de funciones, lo que puede limitar la expresividad en algunos dise√±os de APIs.
        - La inmutabilidad con `Final` no se aplica en tiempo de ejecuci√≥n y depende de herramientas externas para su utilidad.
        - Las funciones sin tipos expl√≠citos pueden volverse dif√≠ciles de mantener en proyectos grandes o colaborativos.
        - El uso excesivo de `*args` y `**kwargs` puede afectar la claridad, el autocompletado y el an√°lisis est√°tico.
        - El sistema de tipos sigue siendo opcional y poco estricto, lo que dificulta la prevenci√≥n de errores en grandes bases de c√≥digo si no se aplican pr√°cticas disciplinadas.
    </Cons>
</ProCons>

## üéØ Conclusiones

Python ofrece una forma muy flexible y accesible de definir funciones y declarar variables. Aunque permite adoptar un estilo cercano al de lenguajes con tipado est√°tico (como Kotlin) mediante anotaciones y herramientas externas, su naturaleza din√°mica implica que esa seguridad no es obligatoria ni garantizada en tiempo de ejecuci√≥n.

Comprender estas diferencias es clave al portar ideas entre lenguajes o al dise√±ar bibliotecas reutilizables, donde la claridad y la seguridad del c√≥digo son tan importantes como la concisi√≥n.

### üîë Puntos clave

- Las funciones en Python se definen con `def` y pueden usar anotaciones de tipo opcionales (`a: int`) para mayor claridad.
- El tipado no es estricto: Python no verifica que los valores coincidan con los tipos anotados.
- Los par√°metros con valores por defecto reemplazan la necesidad de sobrecarga de funciones.
- `*args` y `**kwargs` permiten construir funciones altamente flexibles y gen√©ricas.
- Las variables en Python son mutables por defecto y no existe un equivalente exacto a `val`, aunque `Final` (desde Python 3.8) permite comunicar intenci√≥n de inmutabilidad.

### üßæ Tabla comparativa: Python vs Kotlin

| Caracter√≠stica                          | Python                                       | Kotlin                               |
|----------------------------------------|----------------------------------------------|---------------------------------------|
| Declaraci√≥n de funciones               | `def` con tipos opcionales                   | `fun` con tipos obligatorios          |
| Tipado                                  | Din√°mico con anotaciones opcionales          | Est√°tico y obligatorio                |
| Verificaci√≥n de tipos en runtime       | ‚ùå No                                          | ‚úÖ S√≠                                 |
| Variables mutables por defecto         | ‚úÖ S√≠ (`=`)                                   | ‚ùå No (`val` es inmutable por defecto)|
| Inmutabilidad expl√≠cita                | `Final` (no forzado en runtime)              | `val` (forzado por el compilador)     |
| Valores por defecto en par√°metros      | ‚úÖ S√≠                                         | ‚úÖ S√≠                                 |
| Sobrecarga de funciones                | ‚ùå No                                         | ‚úÖ S√≠                                 |
| `*args` y `**kwargs`                   | ‚úÖ Soportado con sintaxis especial            | ‚ùå No directamente                    |
| Pensado para                           | Flexibilidad y rapidez                       | Seguridad y expresividad              |

## üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n nos mostr√≥ c√≥mo **Python combina flexibilidad con expresividad**, permitiendo escribir funciones potentes con muy poca sintaxis. Pero tambi√©n nos deja una advertencia: **esa libertad requiere mayor disciplina del equipo desarrollador**, especialmente al escribir bibliotecas o aplicaciones a gran escala.

Entender c√≥mo se declaran funciones y variables ‚Äîy c√≥mo esto difiere del enfoque m√°s estricto de Kotlin‚Äî es fundamental para:

- Escribir c√≥digo m√°s predecible y mantenible,
- Compartir funciones con otras personas sin ambig√ºedad,
- Dise√±ar APIs coherentes que resistan el paso del tiempo.
## üìñ Referencias

### üî• Recomendadas

- [üåê "Gu√≠a de funciones de Python con ejemplos"](https://www.freecodecamp.org/espanol/news/guia-de-funciones-de-python-con-ejemplos/) en *"freeCodeCamp"* por **Sebastian J. Bustamante**: Explicaci√≥n clara y accesible sobre c√≥mo se definen y utilizan funciones en Python, incluyendo sintaxis, par√°metros con valores por defecto, paso de argumentos por posici√≥n o nombre, √°mbito de variables, y comportamiento con objetos mutables. Tambi√©n cubre funciones incorporadas como `max`, `min`, `divmod`, `hex`, `len`, `ord`, `chr` e `input`. Es especialmente relevante para esta lecci√≥n porque refuerza con ejemplos pr√°cticos los fundamentos que tratamos: **sintaxis de funciones, reutilizaci√≥n de c√≥digo, comportamiento din√°mico del lenguaje y diferencias clave con lenguajes de tipado est√°tico como Kotlin**.

{/* ### üîπ Adicionales */}
