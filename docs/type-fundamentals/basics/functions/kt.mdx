---
title: "Declaraci√≥n de funciones"
sidebar_label: "Funciones"
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime';
import Solution from '@site/src/components/exercise/Solution';
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import Box from '@site/src/components/cajitas/Box';

<ReadingTime multiplier={2}/>

Las funciones son una herramienta fundamental para construir software reutilizable, legible y organizado. En Kotlin, declarar funciones es sencillo y expresivo, gracias a su sintaxis concisa y caracter√≠sticas como par√°metros con valores por defecto, funciones de una sola expresi√≥n e inferencia de tipos.

En esta lecci√≥n aprender√°s a declarar funciones en Kotlin, entender c√≥mo funciona `vararg` para aceptar m√∫ltiples argumentos y cu√°ndo conviene especificar tipos de retorno. Ver√°s tambi√©n c√≥mo aplicar funciones est√°ndar como `map` y `fold`, y conocer√°s las diferencias entre colecciones como `Array` y `List`.

No es necesario dominar todos los detalles de inmediato: a medida que avancemos en el curso, retomaremos y profundizaremos los elementos m√°s relevantes.

## üß© Funciones en Kotlin

Una **funci√≥n** en Kotlin es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es la siguiente:

```kotlin title="Estructura general"
fun functionName(param1: Type1, param2: Type2 = defaultValue, ...): ReturnType {
    // Cuerpo de la funci√≥n
    return result
}
```

:::info Explicaci√≥n de la sintaxis

- **`fun`**: Palabra clave utilizada para declarar una funci√≥n.
- **`functionName`**: Nombre descriptivo que identifica la funci√≥n.
- **`param1`, `param2`**: Par√°metros que recibe la funci√≥n, cada uno con su tipo correspondiente.
  - Las funciones pueden no tener par√°metros si no se requieren.
  - Tambi√©n pueden incluir par√°metros con valores predeterminados (opcionales).
- **`ReturnType`**: Tipo del valor que retorna la funci√≥n.
  - Si no retorna ning√∫n valor √∫til, se utiliza el tipo especial `Unit`, que puede omitirse por ser impl√≠cito.
- **Cuerpo de la funci√≥n**: Conjunto de instrucciones que definen su comportamiento.

:::

### ‚ûï Ejemplo: Sumar dos n√∫meros

```kotlin showLineNumbers title="Versi√≥n con cuerpo de bloque (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int): Int {
    return a + b
}
```

Si la funci√≥n contiene solo una expresi√≥n, puedes usar una forma m√°s concisa mediante **asignaci√≥n directa**:

```kotlin showLineNumbers title="Versi√≥n con asignaci√≥n directa y tipo expl√≠cito (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int): Int = a + b
```

Y a√∫n m√°s, Kotlin puede **inferir el tipo de retorno** autom√°ticamente:

```kotlin showLineNumbers title="Versi√≥n con inferencia de tipo (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int) = a + b
```

Este estilo produce c√≥digo m√°s breve, pero deber√≠as usarlo con cuidado.

<details>
    <summary>
        Si vienes de Scala...
    </summary>
    
    En Kotlin, **la palabra clave `return` es obligatoria** cuando usas el bloque cl√°sico `{ ... }`.  
    Esto contrasta con Scala, donde **la √∫ltima expresi√≥n de una funci√≥n se devuelve autom√°ticamente** sin necesidad de `return`.

    En Kotlin, ese comportamiento impl√≠cito **solo se aplica** cuando utilizas la sintaxis de una sola expresi√≥n (`= ...`).    
</details>

::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n a partir del contexto.  
En el ejemplo anterior, como la funci√≥n consiste en una sola expresi√≥n, **el tipo de retorno se infiere autom√°ticamente**.

:::warning No abuses de la inferencia

Aunque la inferencia puede hacer el c√≥digo m√°s limpio y conciso, **no siempre conviene omitir los tipos**.  
En funciones **p√∫blicas** o con l√≥gica **m√°s compleja**, declarar el tipo expl√≠citamente mejora la **claridad**, sirve como **documentaci√≥n impl√≠cita** y facilita la **mantenibilidad** del c√≥digo.

:::

::::

:::::tip Estilo de nombres

En Kotlin, **las funciones y variables deben nombrarse usando la convenci√≥n `camelCase`**. Esto significa:

- El nombre comienza con **min√∫scula**.
- Las palabras siguientes se escriben **pegadas**, iniciando con **may√∫scula**.

‚úÖ Ejemplos correctos:
- `calculateTotal`
- `printMessage`
- `main`

Usar un estilo de nombres consistente **mejora la legibilidad** y facilita mantener un c√≥digo coherente con las pr√°cticas idiom√°ticas de Kotlin.

::::danger Estilos incorrectos

Evita estilos que provienen de otros lenguajes o h√°bitos anteriores:

- `CalculateTotal` ‚Üí ‚ùå **PascalCase**, reservado para **clases** y **tipos**, no para funciones.
- `calculate_total` ‚Üí ‚ùå **snake_case**, com√∫n en Python, **no se utiliza** en Kotlin.
- `calculate-total` ‚Üí ‚ùå **kebab-case**, **inv√°lido** como identificador en Kotlin.
- `CALCULATE_TOTAL` ‚Üí ‚ùå Reservado para **constantes** y **enumeraciones**, no para funciones ni variables mutables.

:::note ¬øY `val`?

Aunque `val` define una variable inmutable, eso **no significa que sea una constante**.  
En Kotlin, los nombres completamente en may√∫sculas como `CALCULATE_TOTAL` est√°n reservados para **constantes reales**, es decir, valores **conocidos y fijos en tiempo de compilaci√≥n**.

Ampliaremos esta idea m√°s adelante, cuando veamos **definiciones est√°ticas** y c√≥mo Kotlin las maneja.

:::

::::

:::::

### üî¢ Funciones vari√°dicas (`vararg`)

En Kotlin puedes definir funciones que aceptan una **cantidad variable de argumentos** usando la palabra clave `vararg`.  
Esto permite invocar la funci√≥n con **cero, uno o m√°s argumentos** del mismo tipo, de manera similar a c√≥mo funciona `*args` en Python o `...args` en JavaScript.

```kotlin showLineNumbers title="Ejemplo: sumar m√∫ltiples n√∫meros"
fun sumAll(vararg nums: Int): Int =
    nums.sum()
```

<details>
    <summary>
        `sum()`
    </summary>

    La funci√≥n [`sum()`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/sum.html) es una extensi√≥n que suma todos los elementos de un arreglo.

    En el caso de `IntArray`, su firma es:

    ```kotlin
    fun IntArray.sum(): Int
    ```

    En nuestro ejemplo, esto se traduce a `nums[0] + nums[1] + ... + nums[n-1]`.

    Tambi√©n se puede usar `sum()` con otros tipos de arreglos primitivos (`DoubleArray`, `FloatArray`, etc.), **arreglos gen√©ricos** de tipos primitivos (`Array<Int>`, `Array<Double>`, etc.) e **iterables** de tipos primitivos como `List<Int>`, `Set<Double>`, etc.

    La versi√≥n generalizada tiene la siguiente forma:

    ```kotlin
    fun Array<out Double>.sum(): Double
    fun Array<out Int>.sum(): Int
    ...
    fun Iterable<Double>.sum(): Double
    fun Iterable<Int>.sum(): Int
    ...
    ```

    donde `out` indica que el arreglo es covariante, siguiendo el principio get-put.[^1]
</details>

[^1]: El principio get-put establece que un tipo covariante puede ser usado como un tipo de retorno (`out`) pero no como un tipo de entrada (`in`). En este caso, `out` indica que el arreglo solo se usa para obtener valores, no para insertarlos.

```kotlin showLineNumbers title="Invocaci√≥n de la funci√≥n"
sumAll(1, 2, 3, 4)  // devuelve 10
sumAll()            // devuelve 0
```

Si tienes un arreglo de elementos del mismo tipo, puedes **desempaquetarlo** usando `*` al invocarlo:

```kotlin title="Desempaquetando un arreglo"
val extras = intArrayOf(5, 6)
sumAll(1, 2, *extras) // devuelve 14
```

:::tip Hack: Uno o m√°s argumentos

Si necesitas que la funci√≥n reciba **al menos un argumento obligatorio**, puedes declararlo como par√°metro separado y luego usar `vararg` para los dem√°s.

Una forma √∫til de entenderlo es pensar en expresiones regulares:  
- El s√≠mbolo `*` indica ‚Äú**cero o m√°s** repeticiones‚Äù,  
- Mientras que `+` indica ‚Äú**una o m√°s** repeticiones‚Äù.

En este contexto, el par√°metro obligatorio representa el `+`, y `vararg` representa el `*`.  
Juntos, expresan la idea de ‚Äú**uno o m√°s argumentos**‚Äù.

```kotlin showLineNumbers title="Al menos un argumento requerido"
fun sumTo(first: Int, vararg rest: Int): Int =
    rest.fold(first) { acc, i -> acc + i }
```

<details>
    <summary>
        `fold()`
    </summary>

    La funci√≥n [`fold()`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/fold.html) es una extensi√≥n que aplica una operaci√≥n acumulativa sobre los elementos de una colecci√≥n o arreglo, comenzando desde un valor inicial.

    En el caso de `IntArray`, su firma es:

    ```kotlin
    fun IntArray.fold(initial: Int, operation: (acc: Int, Int) -> Int): Int
    ```

    En nuestro ejemplo, esto se traduce a una suma progresiva como `first + rest[0] + rest[1] + ...`.

    Es especialmente √∫til para realizar operaciones como **suma**, **producto**, **concatenaci√≥n**, o construir estructuras m√°s complejas, sin necesidad de escribir bucles manuales.

    Tambi√©n se puede usar `fold()` con otros tipos de arreglos primitivos (`DoubleArray`, `FloatArray`, etc.), **arreglos gen√©ricos** (`Array<T>`) e **iterables** como `List<T>` o `Set<T>`.

    La versi√≥n generalizada tiene la siguiente forma:

    ```kotlin
    fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R
    fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R
    ```

    donde `R` es el tipo del acumulador y `T` el tipo de los elementos. `out` indica que el arreglo es covariante, lo que significa que puede contener subtipos de `T`.
</details>

```kotlin showLineNumbers title="Invocaci√≥n de la funci√≥n"
sumTo(1)                                        // devuelve 1
sumTo(1, 2, 3, 4)                               // devuelve 10
sumTo(first = 1, rest = intArrayOf(2, 3, 4))    // devuelve 10
```

Este mismo patr√≥n puede aplicarse a funciones que reciban 2 o m√°s par√°metros obligatorios, seguidos de un n√∫mero variable de argumentos opcionales.

:::

:::info `vararg` vs. `Array`

En Kotlin, `vararg` es una forma conveniente de permitir que una funci√≥n reciba **una cantidad variable de argumentos**. Internamente, el compilador convierte esos argumentos en un arreglo del tipo correspondiente (`Array<T>`, `IntArray`, etc.).

Esto significa que:

- Usar `vararg` es **az√∫car sint√°ctico** sobre una funci√≥n que acepta un arreglo.
- Puedes seguir llamando a la funci√≥n con un arreglo existente usando el operador `*` para desempaquetarlo.

```kotlin showLineNumbers title="Usando vararg vs. pasando un arreglo"
fun sumAll(vararg nums: Int): Int = nums.sum()

val valores = intArrayOf(1, 2, 3)
sumAll(*valores)  // ‚úÖ correcto: desempaquetado con *
```

Kotlin optimiza tipos primitivos como `Int`, `Double`, etc., usando `IntArray`, `DoubleArray`, etc., en lugar de `Array<Int>`, para mejorar el rendimiento y evitar boxing innecesario.

:::

<details>
    <summary>
        `Array<T>` vs. `List<T>`
    </summary>

    Tanto `Array<T>` como `List<T>` representan **colecciones de tama√±o fijo** e **inmutables en cuanto a estructura** (es decir, no puedes agregar ni quitar elementos), pero se usan en contextos distintos:

    - `Array<T>` es una **estructura de bajo nivel**, m√°s cercana al funcionamiento de los arreglos en lenguajes como Java.
    - `List<T>` es parte de la API de colecciones de Kotlin, m√°s expresiva y flexible para la programaci√≥n funcional.

    | Caracter√≠stica         | `Array<T>`                          | `List<T>`                          |
    |------------------------|-------------------------------------|------------------------------------|
    | Mutable                | S√≠ (`array[i] = ...`)               | No (`List<T>` es inmutable)        |
    | Tama√±o fijo            | S√≠                                  | S√≠ (en `List`, no en `MutableList`)|
    | Posiciones accesibles  | Por √≠ndice (`array[i]`)             | Por √≠ndice (`list[i]`)             |
    | M√©todos funcionales    | Limitados                           | Amplia API funcional               |
    | Uso com√∫n              | Eficiencia, interoperabilidad con Java | Estilo idiom√°tico, programaci√≥n funcional |
    | Conversi√≥n             | `array.toList()`                    | `list.toTypedArray()`              |

    :::tip En resumen

    - Usa `List<T>` para la mayor√≠a de los casos, sobre todo si buscas **inmutabilidad l√≥gica** y una API m√°s rica y expresiva para manipulaci√≥n de datos.
    - Usa `Array<T>` si necesitas interoperar con c√≥digo Java, o si el rendimiento al acceder/modificar por √≠ndice es cr√≠tico.

    :::
</details>

<Box>
    ## üß† Ejercicio pr√°ctico: Duplicar niveles de poder

    Vamos a practicar la declaraci√≥n de funciones en Kotlin aplicando una transformaci√≥n sobre una lista.  
    Sup√≥n que tienes una lista de niveles de poder (`Int`) y quieres duplicar cada uno de ellos usando `map`.

    Como recordatorio, `map` aplica una funci√≥n a cada elemento de una colecci√≥n y devuelve una nueva colecci√≥n con los resultados:

    ```kotlin
    fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R>
    fun IntArray.map(transform: (Int) -> R): List<R>
    ```

    Tu tarea es definir una funci√≥n llamada `doublePowers` que reciba una lista de enteros (`List<Int>`) o como una funci√≥n variadica y devuelva una nueva lista con cada valor duplicado.

    ```kotlin showLineNumbers title="üß™ Ejemplo de uso"
    doublePowers(listOf(5, 10, 15)) 
    // devuelve: [10, 20, 30]
    ```

    <Solution>
        <BoxedTabs>
            <TabItem value="Lista" label="Input como lista">
                ```kotlin showLineNumbers title="Soluci√≥n: Input como lista"
                fun doublePowers(powers: List<Int>): List<Int> =
                    powers.map { it * 2 }
                ```
            </TabItem>
            <TabItem value="Vararg" label="Input como vararg">
                ```kotlin showLineNumbers title="Soluci√≥n: Input como vararg"
                fun doublePowers(vararg powers: Int): List<Int> =
                    powers.map { it * 2 }
                ```
            </TabItem>
        </BoxedTabs>
    </Solution>
</Box>

## üéØ Conclusiones

En esta lecci√≥n conocimos la sintaxis b√°sica para declarar funciones en Kotlin, un componente esencial para estructurar c√≥digo reutilizable, expresivo y mantenible. Tambi√©n exploramos algunas variantes idiom√°ticas como la inferencia de tipo, las funciones vari√°dicas y la diferencia entre colecciones como `Array` y `List`.

### üîë Puntos clave

- Las funciones en Kotlin se declaran con la palabra clave `fun`, y pueden tener par√°metros con valores por defecto.
- El tipo de retorno puede inferirse autom√°ticamente si la funci√≥n es de una sola expresi√≥n.
- `vararg` permite definir funciones que aceptan m√∫ltiples argumentos del mismo tipo.
- Es posible requerir al menos un argumento junto a `vararg` combinando ambos en la firma.
- `Array<T>` y `List<T>` son colecciones que pueden parecer similares pero tienen usos y propiedades distintas.
- Kotlin favorece un estilo conciso, pero tambi√©n claro y expl√≠cito cuando la funci√≥n es p√∫blica o compleja.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n es una primera introducci√≥n al sistema de funciones de Kotlin. No es necesario memorizar todos los elementos de inmediato: puedes volver aqu√≠ como referencia r√°pida cuando lo necesites. A lo largo del curso iremos retomando estos conceptos y profundizando en los aspectos m√°s relevantes seg√∫n el contexto de cada unidad.
