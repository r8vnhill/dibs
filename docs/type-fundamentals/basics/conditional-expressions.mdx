---
title: Expresiones condicionales
---
import Exercise from '@site/src/components/exercise/Exercise'
import Explanation from '@site/src/components/admonitions/Explanation'
import Solution from '@site/src/components/exercise/Solution'
import ReadingTime from '@site/src/components/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Las estructuras condicionales son uno de los pilares del control de flujo en cualquier lenguaje de programaci√≥n.  
Sin embargo, **Kotlin ofrece una perspectiva m√°s expresiva y funcional que lenguajes imperativos tradicionales como Java**, al permitir que construcciones como `if` y `when` no sean solo declaraciones, sino tambi√©n **expresiones que devuelven valores**.

Este enfoque habilita un estilo de programaci√≥n m√°s **conciso**, **declarativo** y alineado con la escritura de **funciones puras y reutilizables**. En esta lecci√≥n aprenderemos a **diferenciar entre declaraciones y expresiones condicionales**, y a aprovechar la expresividad de Kotlin para construir funciones m√°s limpias y mantenibles.

Tambi√©n exploraremos el uso idiom√°tico de `when`, una alternativa poderosa a m√∫ltiples `if` anidados, y discutiremos sus diferencias con el *pattern matching* en lenguajes como Scala o Rust.

## üîÄ Expresi√≥n `if`

En Kotlin, `if` puede usarse como una **expresi√≥n** que retorna un valor, no solo como una declaraci√≥n de control, como en muchos lenguajes imperativos.

```kotlin showLineNumbers title="if como expresi√≥n"
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

Esto permite escribir funciones m√°s **concisas** y **expresivas**.

Cuando no necesitas obtener un valor, tambi√©n puedes usar `if` como **declaraci√≥n**, simplemente para ejecutar c√≥digo condicional:

```kotlin showLineNumbers title="if como declaraci√≥n"
if (isLoggedIn) {
    println("Welcome back!")
}
// else es opcional si se usa como declaraci√≥n
```

:::danger Sin `else`, no hay valor

Cuando `if` se utiliza como **expresi√≥n**, el bloque `else` es **obligatorio**.  
Si lo omites, el compilador no sabr√° qu√© valor retornar:

```kotlin title="if sin else en expresi√≥n" showLineNumbers
val result = if (x > 0) "Positive" // ‚ùå Error de compilaci√≥n: falta `else`
```

:::

:::info Llaves en `if`: ¬øcu√°ndo son necesarias?

- Si una rama (`if` o `else`) tiene **m√°s de una l√≠nea**, las llaves `{}` son **obligatorias**.
- Si tiene **una sola l√≠nea**, pueden omitirse, aunque se recomienda mantenerlas para evitar errores al modificar el c√≥digo.
- En expresiones `if`, el valor retornado ser√° el de la **√∫ltima expresi√≥n evaluada** en cada rama.
    ```kotlin showLineNumbers title="if como expresi√≥n simple"
    val result = if (x > 0)
        "positive"
    else
        "negative"
    ```

    En este caso, el valor de `result` ser√° `"positive"` o `"negative"`, seg√∫n la condici√≥n.  
    Con llaves, se aplica la misma l√≥gica:

    ```kotlin showLineNumbers title="if como expresi√≥n con efectos colaterales"
    val result = if (x > 0) {
        println("Evaluating...")
        "positive"
    } else {
        println("Evaluating...")
        "negative"
    }
    ```

    Aqu√≠, cada rama imprime un mensaje y luego retorna una cadena como resultado.

:::

## üéõÔ∏è Expresi√≥n `when`

La expresi√≥n `when` en Kotlin es una alternativa concisa, segura y expresiva a cadenas de `if-else if`. Adem√°s, **devuelve un valor**, lo que la convierte en una herramienta vers√°til para el control de flujo.

```kotlin showLineNumbers title="when con argumento"
when (status) {
    200, 201, 204 -> "Success"
    400 -> "Bad Request"
    404 -> "Not Found"
    500 -> "Internal Server Error"
    "timeout" -> "The request timed out"
    is Int -> "Unhandled status code: $status"
    !is String -> "Unknown type"
    else -> "Unhandled string: $status"
}
```

<Explanation>
    - **`when (status)`** eval√∫a el valor de `status` y lo compara contra m√∫ltiples condiciones.
    - Puedes **agrupar valores** en una rama usando comas: `200, 201, 204 ->`.
    - Permite **verificaciones de tipo**, como `is Int` o `!is String`.
    - El bloque **`else`** es obligatorio si no se cubren todos los posibles casos.
    - Como `when` es una **expresi√≥n**, puede usarse directamente en asignaciones o retornos.
</Explanation>

<details>
    <summary>Diferencias con <code>switch</code> en otros lenguajes</summary>

    A diferencia de estructuras como `switch` en C, Java o JavaScript, **Kotlin no permite ejecuci√≥n por ca√≠da (*fall-through*)** entre ramas.  
    No es necesario usar `break` para evitar que se ejecuten m√∫ltiples bloques.

    Por ejemplo, en Java:

    ```java title="Java: sin break"
    switch (status) {
        case 200:
            System.out.println("Success");
        case 400:
            System.out.println("Bad Request");
    }
    ```

    Si `status` es `200`, imprimir√°:

    ```
    Success
    Bad Request
    ```

    Esto ocurre porque la ejecuci√≥n "cae" al siguiente caso si no hay un `break`.

    Para lograr un comportamiento equivalente al de Kotlin, se necesita agregar `break` expl√≠citamente:

    ```java title="Java: con break"
    switch (status) {
        case 200:
            System.out.println("Success");
            break;
        case 400:
            System.out.println("Bad Request");
            break;
    }
    ```

    Ahora s√≠, si `status` es `200`, solo se imprimir√°:

    ```
    Success
    ```

    En Kotlin, este es el comportamiento por defecto:

    ```kotlin title="Kotlin"
    when (status) {
        200 -> println("Success")
        400 -> println("Bad Request")
    }
    ```

    No existe la posibilidad de *fall-through*. Cada rama es **aislada**, y el flujo de control es **m√°s seguro, claro y f√°cil de mantener**.
</details>

:::tip Tambi√©n puede usarse sin argumento

Puedes omitir el valor entre par√©ntesis para evaluar condiciones arbitrarias, como en un bloque `if-else if`:

```kotlin showLineNumbers title="when sin argumento"
when {
    temperature < 0 -> "Below freezing"
    temperature <= 15 -> "Cold"
    temperature <= 25 -> "Mild"
    temperature <= 35 -> "Warm"
    else -> "Hot"
}
```

:::

:::info Uso de llaves `{}` en `when`

- Las llaves son **obligatorias** si la rama contiene m√°s de una instrucci√≥n.
- Si hay **una sola expresi√≥n**, se pueden omitir (aunque es recomendable incluirlas por claridad).
- En expresiones `when`, el **valor retornado** ser√° el de la **√∫ltima expresi√≥n evaluada** en cada rama.

```kotlin showLineNumbers title="when con llaves"
val message = when (code) {
    404 -> {
        println("Not Found")
        logError(code)
        "Not Found" // ‚Üê Esta l√≠nea se devuelve
    }
    else -> "Unhandled"
}
```

:::

:::warning Diferencias con *pattern matching* real

Aunque `when` tiene una sintaxis similar al *pattern matching* de lenguajes como Scala o Rust, sus capacidades son m√°s limitadas:

- No permite destructuraci√≥n directa (`case (a, b)`).
- No soporta patrones anidados ni coincidencias estructurales complejas.
- Las condiciones tipo `case x if cond` existen, pero son **experimentales** y requieren habilitar `-Xwhen-guards`.
    ```kotlin title="when con guardas (experimental)"
    when (animal) {
        is Dog -> feedDog()
        is Cat if animal.mouseHunter -> feedCat()
        else if animal.eatsPlants -> giveLettuce()
        else -> println("Unknown animal")
    }
    ```
:::

### üîÅ Ejercicio: Reescribir usando `when`

<Exercise>
    Reescribe la funci√≥n `login` utilizando una expresi√≥n `when` en lugar de m√∫ltiples `if`.

    ```kotlin showLineNumbers title="Versi√≥n original usando if"
    fun login(username: String, password: String): Boolean {
        if (loginAttempts >= maxLoginAttempts) {
            return false
        }
        if (isValidPassword(password)) {
            loginAttempts = 0
            return true
        }
        loginAttempts++
        return false
    }
    ```

    <Solution>
        ```kotlin showLineNumbers title="Versi√≥n reescrita con when"
        fun login(username: String, password: String): Boolean = when {
            loginAttempts >= maxLoginAttempts -> false
            isValidPassword(password) -> {
                loginAttempts = 0
                true
            }
            else -> {
                loginAttempts++
                false
            }
        }
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

Kotlin convierte estructuras condicionales cl√°sicas como `if` y `switch` en **expresiones que devuelven valores**, permitiendo un estilo m√°s expresivo, conciso y seguro, especialmente √∫til en funciones puras y dise√±os declarativos.

Tanto `if` como `when` pueden usarse como **expresiones** o **declaraciones**, pero cuando se usan como expresiones, **producen un valor** y su comportamiento es m√°s predecible. Esta distinci√≥n es clave para escribir c√≥digo idiom√°tico en Kotlin.

### üîë Puntos clave

- Kotlin permite que `if` y `when` se usen como expresiones que **devuelven un valor**, no solo como estructuras de control.
- Cuando `if` es una expresi√≥n, el bloque `else` es **obligatorio**.
- En bloques con llaves `{}`, la **√∫ltima l√≠nea evaluada** determina el valor de retorno.
- `when` es una alternativa clara y poderosa a m√∫ltiples `if-else if`, y admite m√∫ltiples valores, comprobaciones de tipo y uso sin argumento.
- Se requieren llaves en `when` si se ejecutan **varias instrucciones** en una rama.
- Aunque `when` se asemeja al *pattern matching*, **no soporta destructuring ni coincidencias estructurales complejas** como Scala o Rust.
- El `when` sin argumento es √∫til para expresar condiciones booleanas complejas de forma m√°s declarativa.

### üß∞ ¬øQu√© nos llevamos?

Estas capacidades son especialmente valiosas al dise√±ar bibliotecas, donde buscamos expresar decisiones sin efectos colaterales ni estructuras verbosas. En este contexto, `if` y `when` no solo controlan el flujo: **tambi√©n producen valores**, lo que facilita escribir funciones m√°s limpias y reutilizables.

Este cambio de enfoque ‚Äîver las condiciones como **expresiones evaluables** y no solo instrucciones‚Äî abre la puerta a un estilo de programaci√≥n m√°s declarativo y funcional, ideal para construir bibliotecas expresivas y mantenibles.

Comprender esta diferencia nos prepara para explorar con mayor claridad temas como lambdas, funciones puras y estructuras de control m√°s complejas. A partir de ahora, podremos elegir con mayor intenci√≥n entre una declaraci√≥n o una expresi√≥n, y escribir c√≥digo que comunique mejor nuestras ideas.

## üìñ Referencias

### üî• Recomendadas

- üìö *"Conditionals"* en *Kotlin Programming: The Big Nerd Ranch Guide* de **Andrew Bailey, David Greenhalgh y Josh Skeen**: Introducci√≥n pr√°ctica al control de flujo con `if`, `else` y `when`, usando ejemplos aplicados al proyecto *bounty-board*.

### üîπ Adicionales

- [üåê *Conditions and loops*](https://kotlinlang.org/docs/control-flow.html) de la **documentaci√≥n oficial de Kotlin**: Gu√≠a completa y actualizada sobre `if`, `when` y bucles. Ideal como referencia r√°pida, aunque incluye temas m√°s avanzados que a√∫n no se abordan en el curso.
- [üéû *C√≥mo escribir CONDICIONALES en Kotlin: if/else, when* [Curso 2024]](https://youtu.be/ZJWh-7JmuEA) de **DevExpert - Programaci√≥n Android y Kotlin**: Video introductorio y did√°ctico sobre `if` y `when` como expresiones y declaraciones, ideal para quienes se inician en programaci√≥n y desean entender c√≥mo tomar decisiones en el flujo del c√≥digo.
- üìö *"If Expressions"* (pp. 39‚Äì43) en *Atomic Kotlin* de **Bruce Eckel y Svetlana Isakova**: Introducci√≥n muy b√°sica al uso de `if` como expresi√≥n en Kotlin, pensada para personas nuevas en programaci√≥n. Destaca su utilidad para escribir funciones concisas y declarativas.
- üìö *"Kotlin basics"* (pp. 17‚Äì43) en *Kotlin in Action* de **Dmitry Jemerov y Svetlana Isakova**: Presenta `if` y `when` como expresiones con valor de retorno, m√°s expresivas y poderosas que sus equivalentes en Java, lo que facilita un estilo de control de flujo m√°s idiom√°tico.
