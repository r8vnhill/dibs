---
title: Declaraci√≥n de variables
sidebar_label: Variables
---
import Box from '@site/src/components/cajitas/Box'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'

import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'

import Explanation from '@site/src/components/admonitions/Explanation'

import * as LanguageCards from '@site/src/components/cards/LanguageCard'

import Hint from '@site/src/components/exercise/Hint'
import Solution from '@site/src/components/exercise/Solution'

import GitHubRepo from '@site/src/components/git/GitHubRepo'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import GitLabRepo from '@site/src/components/git/GitLabRepo'
import RepoLinks from '@site/src/components/git/RepoLinks'

import ReadingTime from '@site/src/components/reading-time/ReadingTime'

import Book from '@site/src/components/references/Book'
import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<ReadingTime />
<RepoLinks children={[
    <GitLabRepo user="r8vnhill" repo="intro-kt" />,
    <GitHubRepo user="r8vnhill" repo="intro-kt" />,
]}  />

Las variables son uno de los conceptos m√°s b√°sicos de un lenguaje de programaci√≥n, pero en Kotlin no se limitan a ser simples contenedores de datos: son **propiedades** que pueden incluir l√≥gica de acceso, validaci√≥n y encapsulamiento.  

Este enfoque convierte incluso a las declaraciones m√°s simples en **herramientas poderosas de dise√±o**, especialmente cuando est√°s creando bibliotecas reutilizables.

En esta lecci√≥n aprender√°s a:

- Declarar variables con `val` y `var`, y entender las diferencias entre **referencias inmutables** y **mutables**.
- Encapsular correctamente el acceso a los datos usando **getters y setters personalizados**.
- Proteger las invariantes internas de tus estructuras, sin perder expresividad hacia quienes usan tu API.

Todo esto con un enfoque pr√°ctico y centrado en **buenas pr√°cticas de dise√±o**, que te ayudar√°n a escribir c√≥digo claro, seguro y mantenible.

## üì¶ Declaraci√≥n de variables

En Kotlin puedes declarar variables de dos formas:

- `val` ‚Üí **de solo lectura**: su valor no puede reasignarse una vez inicializado.  
- `var` ‚Üí **lectura y escritura**: su valor puede cambiar despu√©s de la declaraci√≥n.

```kotlin title="Sintaxis general"
val o var nombreVariable: Tipo = valor
```

:::tip Inferencia de tipos

En variables locales o privadas, puedes omitir el tipo si el compilador puede inferirlo a partir del valor asignado.  
Esto mejora la legibilidad sin perder seguridad de tipos.

Sin embargo, en bibliotecas es recomendable declarar expl√≠citamente el tipo de las propiedades y funciones p√∫blicas,  
ya que esto hace m√°s robusta la API, facilita el mantenimiento y evita cambios accidentales en la firma p√∫blica.

:::

### üîí S√≥lo lectura (`val`)

Usa `val` cuando **la referencia** de la variable no cambiar√° despu√©s de su asignaci√≥n.  
Una vez inicializada, no podr√°s volver a asignarle otro valor.

```kotlin showLineNumbers title="Variables de solo lectura"
val master = "Goomoonryong"
master = "Yi Shi-Woon"  // üî• Error: no se puede reasignar un 'val'

val student: String
student = "Haje Kang"   // ‚úÖ Correcto: asignaci√≥n diferida (una sola vez)
student = "Shi-Ho Lee"  // üî• Error: la referencia no puede cambiar
```

<Explanation>
    - **`master`** se declara con `val` e inicia de inmediato. Reasignarla provoca un error de compilaci√≥n.
    - **`student`** tambi√©n es una `val`, pero se inicializa despu√©s. Kotlin permite esta asignaci√≥n diferida, siempre que sea una √∫nica vez.
</Explanation>

A lo largo del curso nos referiremos a estas variables como **referencias inmutables** o **propiedades de solo lectura**: su referencia no puede cambiar una vez asignada.

Esto **no implica** que el valor al que apuntan sea inmutable.  
Por ejemplo, una variable `val` puede referirse a una lista mutable: aunque no puedas cambiar la referencia, s√≠ puedes modificar el contenido de la lista.

M√°s adelante hablaremos de las **constantes en tiempo de compilaci√≥n**, declaradas con `const val`, cuyo valor debe conocerse en tiempo de compilaci√≥n.  
Por ahora, basta con distinguir entre **referencias mutables** (`var`) y **referencias inmutables** (`val`).

### üîì Lectura y escritura (`var`)

Usa `var` cuando necesites **modificar el valor o cambiar la referencia** de una variable despu√©s de declararla:

```kotlin showLineNumbers title="Variables de lectura y escritura"
var technique = "Black Heaven & Earth"
technique = "Soul-Crushing Strike"     // ‚úÖ Correcto: se cambia la t√©cnica referenciada

var energy = 10
energy = energy + 5                    // ‚úÖ Correcto: suma expl√≠cita
energy += 5                            // ‚úÖ Equivalente m√°s conciso
energy++                               // ‚úÖ Incremento en 1
```

<Explanation>
    - **`technique`** es una variable mutable: su referencia puede actualizarse a distintas t√©cnicas.
    - **`energy`** demuestra varias formas de modificar valores num√©ricos mutables: reasignaci√≥n directa, operaci√≥n compuesta (`+=`) e incremento (`++`).
</Explanation>

:::danger Inmutabilidad referencial ‚â† inmutabilidad profunda

En Kotlin, declarar una variable con `val` **no significa** que su contenido sea inmutable, sino que **la referencia no puede cambiar**.  
Es decir, si el objeto apuntado es mutable, **puedes modificarlo**.

```kotlin showLineNumbers title="Kotlin: 'val' no impide modificar el contenido"
val lista = mutableListOf(1, 2, 3)
lista.add(4)                      // ‚úÖ V√°lido: se modifica el contenido, no la referencia
lista = mutableListOf(5, 6, 7)    // üî• Error: no se puede reasignar un 'val'
```

En cambio, en lenguajes como **Rust**, la inmutabilidad por defecto **s√≠ aplica al contenido**, no solo a la referencia:

```rust showLineNumbers title="Rust: inmutabilidad por defecto"
let mut lista = vec![1, 2, 3];
lista.push(4); // ‚úÖ Solo si fue declarada con `mut`

let lista_fija = vec![1, 2, 3];
lista_fija.push(4); // üî• Error: no se puede modificar un valor inmutable
```

:::

:::tip ¬°Prefiere `val`!

Siempre que sea posible, **prefiere `val` en lugar de `var`**.  
La inmutabilidad no solo mejora la legibilidad y el mantenimiento del c√≥digo, sino que tambi√©n **facilita el razonamiento formal** sobre su comportamiento.  
Usa `var` √∫nicamente cuando realmente necesites que el valor de una variable **cambie a lo largo del tiempo**.

```kotlin showLineNumbers title="Expresividad e intenci√≥n: mejor con val que con var"
// ‚úÖ Mejor con val: expresa intenci√≥n clara, el valor no cambia
val basePower = 42
val bonus = 8
val total = basePower + bonus

// üî∂ Menos claro con var: sugiere que el valor podr√≠a cambiar
var total = 42
total += 8
```

En el primer caso, `total` es el resultado de una operaci√≥n fija y predecible.  
En el segundo, el uso de `var` puede dar la impresi√≥n de que `total` **seguir√° cambiando m√°s adelante**, aunque no sea as√≠.

:::

### üîÑ ¬øCu√°ndo usar `var`?

Aunque **`val` debe ser tu primera opci√≥n**, hay situaciones justificadas donde el uso de `var` es adecuado:

- Cuando una **variable cambia como parte del estado interno** de una clase mutable.
- Si est√°s **acumulando resultados** a lo largo de un bucle o una funci√≥n.
- Al implementar **algoritmos imperativos** donde el cambio de estado es m√°s natural o legible.
- En **tests o scripts** donde la claridad y simplicidad pueden pesar m√°s que la inmutabilidad.

## üß± Propiedades en Kotlin: m√°s que campos

En Kotlin, `val` y `var` no solo declaran campos como en otros lenguajes:  
en realidad definen **propiedades** con acceso controlado a trav√©s de **getters y setters**.

Esto permite encapsular l√≥gica sin perder expresividad:

```kotlin showLineNumbers title="Propiedades en Kotlin"
val soloLectura: Tipo = inicializador
    get() = campoPersonalizado // Getter impl√≠cito o redefinido

var lecturaEscritura: Tipo = inicializador
    get() = campoPersonalizado
    set(value) {
        // l√≥gica adicional antes de asignar
        field = value
    }
```

<Explanation>
    - `val` genera solo un **getter**, lo que impide modificar la propiedad desde fuera.
    - `var` genera tanto **getter como setter**, permitiendo control total sobre la lectura y escritura.
    - Puedes personalizar estos m√©todos si necesitas validaci√≥n, transformaci√≥n u otros efectos colaterales.
</Explanation>

En el contexto de **bibliotecas**, esto permite definir APIs que exponen informaci√≥n de forma segura, mientras internamente conservan flexibilidad para evolucionar o proteger invariantes.

### üß™ Ejemplo pr√°ctico: Exponer listas inmutables con un campo de respaldo

Cuando desarrollas una biblioteca, es com√∫n tener estructuras internas que deben mantenerse mutables, pero que **no deben exponerse directamente** a quienes consumen tu API.  
Kotlin permite resolver esto mediante un **campo de respaldo**:

```kotlin showLineNumbers title="Battle.kt"
private val _party: MutableList<String> = mutableListOf("Balthier", "Vaan")

val party: List<String>
    get() = _party
```

<Explanation>
    - **`_party`** es un campo de respaldo: una propiedad privada que contiene los datos reales y permite modificaciones internas.
    - **`party`** es una propiedad p√∫blica de solo lectura que expone **una vista inmutable** de la lista.
    - Al devolver `List<String>`, evitamos que otrxs puedan modificar el contenido desde fuera de la biblioteca.
</Explanation>

Este patr√≥n es com√∫n en bibliotecas bien dise√±adas: **exponer lo m√≠nimo necesario** mientras se **protegen las invariantes internas**.

:::tip Conversi√≥n impl√≠cita de mutabilidad

En Kotlin, cuando una funci√≥n o propiedad devuelve una `MutableList<T>` pero declara su tipo como `List<T>`, el compilador **permite esta conversi√≥n impl√≠citamente**.  

Esto es √∫til al desarrollar bibliotecas: puedes mantener una estructura mutable internamente (`MutableList<String>`) y exponer solo una **vista inmutable** (`List<String>`) al exterior, sin necesidad de copiar los datos o envolver la lista manualmente.

:::

### üß™ Ejemplo pr√°ctico: Encapsular l√≥gica de asignaci√≥n en el setter

Cuando dise√±amos una biblioteca, puede ser necesario que ciertos valores no se asignen directamente, sino que pasen por validaciones o transformaciones. Esto se logra mediante un `setter` personalizado.

```kotlin showLineNumbers title="Config.kt"
var version: String = "1.0.0"
    set(value) {
        require(Regex("""\d+\.\d+\.\d+""").matches(value)) {
            "Version must be in the format X.Y.Z where X, Y, and Z are integers."
        }
        field = value
    }
```

<Explanation>
    - La propiedad `version` usa un `setter` personalizado para validar el formato antes de asignar el nuevo valor.
    - Esta validaci√≥n protege a la biblioteca de estados inv√°lidos.
    - A quienes consumen la API les parece una propiedad normal, pero internamente se aplican reglas.
</Explanation>

Este patr√≥n permite crear APIs **intuitivas pero seguras**, combinando accesibilidad con control sobre las invariantes internas.

:::note `require`, `check` y `error`

- `require(Boolean) { String }: Unit` valida argumentos de entrada. Lanza `IllegalArgumentException`.
- `check(Boolean) { String }: Unit` valida el estado interno del objeto. Lanza `IllegalStateException`.
- `error(String): Nothing` lanza incondicionalmente un `IllegalStateException`.

Estas funciones permiten capturar errores de forma temprana y expresiva, con mensajes claros que facilitan el diagn√≥stico.

:::

<Box>
    ## üß© Ejercicio de cierre: Controlar el nivel de dificultad desde el motor

    Sup√≥n que est√°s dise√±ando una biblioteca para un motor de juego.  
    Quieres exponer el **nivel de dificultad actual** para que otras personas puedan consultarlo, pero **solo el motor** debe poder modificarlo.

    Declara una propiedad `difficultyLevel` que:

    - Sea de tipo `String`.
    - Permita valores como `"easy"`, `"normal"` o `"hard"`.
    - Pueda leerse p√∫blicamente desde cualquier parte.
    - Solo pueda modificarse **desde dentro del m√≥dulo**, y con validaci√≥n.

    <Hint
        hints={[
            <>Puedes declarar el setter como <code>private set</code> para limitar su acceso de escritura a este archivo.</>,
            <>Puedes usar el operador <code>in</code> para verificar que un valor se encuentre dentro de una lista de la forma <code>x in listOf(...)</code>.</>
        ]}
    />

    <Solution>
        ```kotlin showLineNumbers title="Engine.kt"
        var difficultyLevel: String = "normal"
            private set(value) {
                require(value in listOf("easy", "normal", "hard")) {
                    "Difficulty level must be one of: easy, normal, hard."
                }
                field = value
            }
        ```

        <Explanation>
            - La propiedad `difficultyLevel` es **p√∫blica para lectura**, pero su **setter es privado**, lo que significa que solo puede modificarse desde el mismo archivo.
            - La funci√≥n `require` se asegura de que solo se asignen valores v√°lidos. Si se intenta asignar un valor distinto, se lanza una excepci√≥n.
            - Este patr√≥n es √∫til cuando queremos **proteger las invariantes del estado** de la aplicaci√≥n sin exponer directamente los mecanismos internos de control.
        </Explanation>
    </Solution>
</Box>

## üéØ Conclusiones

A lo largo de esta lecci√≥n aprendiste a declarar variables en Kotlin, diferenciando claramente entre referencias **inmutables** (`val`) y **mutables** (`var`). Exploramos cu√°ndo conviene usar cada una y c√≥mo Kotlin promueve el uso de propiedades en lugar de simples campos, lo que permite definir l√≥gica de acceso segura, validaciones y encapsulamiento.

Tambi√©n descubriste que `val` no significa que el contenido sea inmutable ‚Äîsolo que la **referencia no puede cambiar**‚Äî, y que las propiedades pueden tener **getters y setters personalizados**, lo cual es fundamental al dise√±ar bibliotecas robustas y seguras.

### üîë Puntos clave

- `val` declara **referencias inmutables**, ideales para expresar valores que no cambian.
- `var` permite **referencias mutables**, √∫tiles para modelar cambios de estado.
- Kotlin trata las variables como **propiedades**, no como campos directos, lo que habilita control total mediante getters y setters.
- Es posible encapsular estructuras mutables internas usando **campos de respaldo** (`private val _campo`) y exponer vistas inmutables.
- Los `setters` personalizados permiten **validar y controlar el acceso** de forma declarativa y segura.
- Al dise√±ar bibliotecas, es clave **exponer lo m√≠nimo necesario** y proteger las invariantes internas.

### üß∞ ¬øQu√© nos llevamos?

El dise√±o cuidadoso de variables y propiedades marca la diferencia entre una biblioteca fr√°gil y una robusta. En Kotlin, las herramientas como `val`, `var`, getters y setters personalizados, y campos de respaldo te permiten **controlar el acceso a la informaci√≥n**, **proteger el estado interno** y **hacer que tu API sea segura e intuitiva para otras personas**.

Adoptar la inmutabilidad por defecto con `val` no solo mejora la legibilidad, sino que tambi√©n facilita el mantenimiento y reduce errores sutiles. En cambio, usar `var` debe ser una decisi√≥n deliberada, motivada por una necesidad real de cambio de estado.

En resumen: **escribe tus variables pensando en c√≥mo ser√°n usadas, qu√© deben permitir y qu√© deben evitar**. Esa es la base de un buen dise√±o de bibliotecas.

<div className="language-card-container">
    <LanguageCards.PythonCard link="/docs/type-fundamentals/basics/variables/py" />    
</div>

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage
        title="Properties"
        url="https://kotlinlang.org/docs/properties.html"
        location="la documentaci√≥n oficial de Kotlin"
    >
        Explica c√≥mo declarar y usar propiedades (<code>val</code> y <code>var</code>) en Kotlin, incluyendo su sintaxis completa con inicializadores, getters y setters personalizados. Describe c√≥mo controlar la visibilidad de los accesores (<code>private set</code>), c√≥mo usar campos de respaldo (<code>field</code>) para almacenar valores internamente y c√≥mo crear propiedades computadas sin necesidad de almacenamiento. Tambi√©n aborda propiedades con inicializaci√≥n diferida (<code>lateinit</code>), constantes en tiempo de compilaci√≥n (<code>const val</code>) y patrones avanzados mediante propiedades delegadas. Ideal para entender c√≥mo Kotlin permite encapsular, validar y exponer estado de forma segura y expresiva.
    </WebPage>
]} />
