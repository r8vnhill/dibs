---
title: Declaraci√≥n de variables
sidebar_label: Variables
---
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import ReferenceList from '@site/src/components/references/ReferenceList'
import Book from '@site/src/components/references/Book'
import WebPage from '@site/src/components/references/WebPage'
import RepoLinks from '@site/src/components/git/RepoLinks'
import GitLabRepo from '@site/src/components/git/GitLabRepo'
import GitHubRepo from '@site/src/components/git/GitHubRepo'

<ReadingTime />
<RepoLinks children={[
    <GitLabRepo user="r8vnhill" repo="intro-kt" />,
    <GitHubRepo user="r8vnhill" repo="intro-kt" />,
]}  />

TODO: Introducci√≥n

## üì¶ Declaraci√≥n de variables

En Kotlin puedes declarar variables de dos formas:

- `val` ‚Üí **solo lectura**: su valor no puede reasignarse una vez inicializado.  
- `var` ‚Üí **lectura y escritura**: su valor puede modificarse despu√©s de su declaraci√≥n.

```kotlin title="Sintaxis general"
val o var nombreVariable: Tipo = valor
```

:::tip Inferencia de tipos

En ambos casos puedes omitir el tipo si el compilador puede inferirlo a partir del valor asignado.  
Esto mejora la legibilidad sin perder seguridad de tipos.

:::

### üîí S√≥lo lectura (`val`)

Usa `val` cuando **la referencia** de la variable no cambiar√° despu√©s de su asignaci√≥n.  
Una vez inicializada, no podr√°s asignarle otro valor.

```kotlin showLineNumbers title="Variables de solo lectura"
val master = "Goomoonryong"
master = "Yi Shi-Woon"  // üî• Error: no se puede reasignar un 'val'

val student: String
student = "Haje Kang"   // ‚úÖ Correcto: asignaci√≥n diferida (una sola vez)
student = "Shi-Ho Lee"  // üî• Error: la referencia no puede cambiar
```

<Explanation>
    - **`master`** es una variable declarada con `val` e inicializada de inmediato. Reasignarla produce un error de compilaci√≥n.
    - **`student`** tambi√©n es una `val`, pero se inicializa m√°s adelante. Kotlin permite esta asignaci√≥n diferida siempre que ocurra solo una vez.
</Explanation>

A lo largo del curso nos referiremos a estas variables como **constantes referenciales** o **propiedades de solo lectura**: su referencia no puede cambiar una vez asignada.

Esto **no implica** que el valor al que apuntan sea inmutable.  
Por ejemplo, una variable `val` puede referirse a una lista mutable. Aunque no puedas reasignar la variable, s√≠ puedes modificar el contenido de la lista.

M√°s adelante hablaremos de las **constantes en tiempo de compilaci√≥n**, que se declaran con `const val` y cuyo valor debe conocerse de antemano.  
Por ahora, basta con distinguir entre variables **mutables** (`var`) y **referencias inmutables** (`val`).

### üîì Lectura y escritura (`var`)

Usa `var` cuando necesites **modificar el valor o cambiar la referencia** de una variable despu√©s de declararla:

```kotlin showLineNumbers title="Variables de lectura y escritura"
var technique = "Black Heaven & Earth"
technique = "Soul-Crushing Strike"     // ‚úÖ Correcto: la referencia cambia a otra t√©cnica

var energy = 10
energy = energy + 5                    // ‚úÖ Correcto: suma expl√≠cita
energy += 5                            // ‚úÖ Equivalente m√°s conciso
energy++                               // ‚úÖ Incremento en 1
```

<Explanation>
    - **`technique`** es una variable mutable: aqu√≠ su referencia cambia libremente de una t√©cnica a otra.
    - **`energy`** muestra distintas formas v√°lidas de actualizar un valor num√©rico mutable: suma directa, operaci√≥n compuesta (`+=`) e incremento (`++`).
</Explanation>

:::danger Inmutabilidad referencial ‚â† inmutabilidad profunda

En Kotlin, declarar una variable con `val` **no significa** que su contenido sea inmutable, sino que **la referencia no puede cambiar**.  
Es decir, si el objeto apuntado es mutable, **puedes modificarlo**.

```kotlin showLineNumbers title="Kotlin: 'val' no impide modificar el contenido"
val lista = mutableListOf(1, 2, 3)
lista.add(4)                      // ‚úÖ V√°lido: se modifica el contenido, no la referencia
lista = mutableListOf(5, 6, 7)    // üî• Error: no se puede reasignar un 'val'
```

En cambio, en lenguajes como **Rust**, la inmutabilidad por defecto **s√≠ aplica al contenido**, no solo a la referencia:

```rust showLineNumbers title="Rust: inmutabilidad por defecto"
let mut lista = vec![1, 2, 3];
lista.push(4); // ‚úÖ Solo si fue declarada con `mut`

let lista_fija = vec![1, 2, 3];
lista_fija.push(4); // üî• Error: no se puede modificar un valor inmutable
```

:::

:::tip ¬°Prefiere `val`!

Siempre que sea posible, **prefiere `val` en lugar de `var`**.  
La inmutabilidad no solo mejora la legibilidad y el mantenimiento del c√≥digo, sino que tambi√©n **facilita el razonamiento formal** sobre su comportamiento.  
Usa `var` √∫nicamente cuando realmente necesites que el valor de una variable **cambie a lo largo del tiempo**.

```kotlin showLineNumbers title="Expresividad e intenci√≥n: mejor con val que con var"
// ‚úÖ Mejor con val: expresa intenci√≥n clara, el valor no cambia
val basePower = 42
val bonus = 8
val total = basePower + bonus

// üî∂ Menos claro con var: sugiere que el valor podr√≠a cambiar
var total = 42
total += 8
```

En el primer caso, `total` es el resultado de una operaci√≥n fija y predecible.  
En el segundo, el uso de `var` puede dar la impresi√≥n de que `total` **seguir√° cambiando m√°s adelante**, aunque no sea as√≠.

:::

## üß† Ejercicio pr√°ctico: T√©cnicas ninja con valores

Est√°s desarrollando una biblioteca para videojuegos que permita definir y mostrar **t√©cnicas especiales de personajes**.  
Como primer paso, necesitas una funci√≥n que construya el nombre completo de una t√©cnica secreta a partir de sus componentes.

Tu tarea es escribir una funci√≥n llamada `buildTechniqueName` que reciba tres par√°metros: el nombre del personaje (`userName`), el tipo de t√©cnica (`techniqueType`) y el nombre del ataque (`attackName`).  
El par√°metro `techniqueType` debe tener un valor por defecto de `"Ninjutsu"`.

```kotlin showLineNumbers title="üß™ Ejemplos de uso"
buildTechniqueName("Naruto", attackName = "Kage Bunshin no Jutsu")
// devuelve: "Naruto's Ninjutsu: Kage Bunshin no Jutsu"

buildTechniqueName("Sasuke", "Kekkei Genkai", "Amaterasu")
// devuelve: "Sasuke's Kekkei Genkai: Amaterasu"
```

<Hint hints={[
    <>Usa <code>=</code> para definir funciones como una √∫nica expresi√≥n.</>,
    <>Puedes usar <code>$variable</code> o <code>${'{expresi√≥n}'}</code> para interpolar valores dentro de cadenas.</>
]} />

<Solution>
    ```kotlin showLineNumbers title="Construyendo el nombre de una t√©cnica secreta"
    fun buildTechniqueName(
        userName: String,
        techniqueType: String = "Ninjutsu",
        attackName: String
    ): String = "$userName's $techniqueType: $attackName"
    ```
</Solution>

## üéØ Conclusiones

En esta lecci√≥n exploramos dos pilares fundamentales de cualquier lenguaje de programaci√≥n: las **funciones** y las **variables**.  
Aprendimos c√≥mo se declaran en Kotlin, c√≥mo se comportan, y c√≥mo aprovechar sus propiedades y convenciones para escribir c√≥digo m√°s expresivo, seguro y legible.

Kotlin promueve un estilo claro, pragm√°tico y expresivo, favoreciendo la **inferencia de tipos**, la **sintaxis de una sola expresi√≥n**, y una fuerte orientaci√≥n hacia la **inmutabilidad**.  
Su distinci√≥n entre referencias **mutables** (`var`) e **inmutables** (`val`) no es solo una cuesti√≥n de estilo, sino una decisi√≥n de dise√±o que impulsa la escritura de c√≥digo **predecible** y **menos propenso a errores**.

### üîë Puntos clave

- Las funciones pueden declararse con bloques `{ ... }` o como **expresiones √∫nicas** (`= ...`), lo que permite estilos m√°s concisos y expresivos.
- La **inferencia de tipos** reduce redundancias, aunque se recomienda usar tipos expl√≠citos en funciones p√∫blicas.
- Kotlin diferencia claramente entre **`val` (s√≥lo lectura)** y **`var` (lectura y escritura)**, y promueve el uso de `val` por defecto.
- La inmutabilidad de `val` se refiere a la **referencia**, no al contenido del objeto.
- Seguir la convenci√≥n `camelCase` mejora la legibilidad y coherencia del c√≥digo.

### üß∞ ¬øQu√© nos llevamos?

Estas herramientas forman la base para escribir funciones reutilizables, expresivas y seguras, con una sintaxis que promueve la claridad desde la primera l√≠nea.  
**En el dise√±o de bibliotecas, funciones y variables no son detalles internos: forman parte de la interfaz p√∫blica**, y por tanto, deben ser pensadas con especial cuidado.

Saber cu√°ndo usar `val`, `var`, y c√≥mo estructurar funciones no solo permite escribir buen c√≥digo: **es clave para construir APIs claras, idiom√°ticas y f√°ciles de mantener**.

A medida que avancemos en el curso, aplicaremos estos fundamentos al dise√±o de estructuras de datos, operadores personalizados y componentes que comuniquen su intenci√≥n de forma precisa y robusta.  
Ahora que dominas las bases, tu c√≥digo puede empezar a hablar en un Kotlin claro, idiom√°tico y expresivo.

<div className="language-card-container">
    <LanguageCards.PythonCard link="/docs/type-fundamentals/basics/functions-and-variables/py" />    
</div>

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage
        title="Basic syntax"
        url="https://kotlinlang.org/docs/basic-syntax.html"
        location="la documentaci√≥n oficial de Kotlin"
    >
        Resume funciones, variables y control de flujo con ejemplos claros. √ötil como repaso general, aunque abarca m√°s temas de los vistos en esta lecci√≥n.
    </WebPage>
]} />

<ReferenceList title="üîπ Referencias complementarias" items={[
    <Book
        chapter="Defining and calling functions"
        pages={[44, 66]}
        book="Kotlin in Action"
        author="Dmitry Jemerov y Svetlana Isakova"
    >
        Aborda funciones idiom√°ticas en Kotlin, con argumentos nombrados, valores por defecto y funciones de extensi√≥n. Relevante por mostrar c√≥mo estas herramientas mejoran el dise√±o de funciones en bibliotecas. Las funciones de extensi√≥n se explorar√°n m√°s adelante en el curso.
    </Book>,
    <WebPage
        title="Coding Conventions | Kotlin"
        url="https://kotlinlang.org/docs/coding-conventions.html"
        location="la documentaci√≥n oficial de Kotlin"
    >
        Gu√≠a oficial de estilo para escribir c√≥digo Kotlin claro, idiom√°tico y mantenible. Se recomienda como una <b>referencia r√°pida</b>, no para leerla completa de una vez. A lo largo del curso iremos explorando los elementos m√°s relevantes seg√∫n el contexto.
    </WebPage>
]} />
