---
title: Declaraci√≥n de variables en Python
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Definition from '@site/src/components/Definition'
import References from '@site/src/components/ReferencesComponent'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import RepoLinks from '@site/src/components/git/RepoLinks'
import GitLabRepo from '@site/src/components/git/GitLabRepo'
import GitHubRepo from '@site/src/components/git/GitHubRepo'
import Box from '@site/src/components/cajitas/Box'
import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'
import AuthorList from '@site/src/components/references/AuthorList'

<ReadingTime />
<RepoLinks children={[
    <GitLabRepo user="r8vnhill" repo="python-dibs" />,
    <GitHubRepo user="r8vnhill" repo="python-dibs" />
]}  />

Python permite escribir programas de forma muy libre: puedes declarar variables sin tipos, cambiar sus valores o incluso su tipo en cualquier momento. Esta flexibilidad hace que el lenguaje sea ideal para tareas exploratorias, prototipado y ense√±anza inicial. Sin embargo, cuando el objetivo es construir **bibliotecas reutilizables y mantenibles**, esa misma libertad plantea nuevos desaf√≠os.

En esta lecci√≥n aprender√°s c√≥mo se declaran y manipulan variables en Python, y c√≥mo implementar propiedades con l√≥gica de acceso mediante decoradores. Tambi√©n analizaremos en qu√© se diferencia este modelo del enfoque de Kotlin ‚Äîm√°s estructurado y expresivo‚Äî y qu√© herramientas del ecosistema pueden ayudarte a recuperar parte de esa expresividad en tus dise√±os.

Al finalizar, contar√°s con una base s√≥lida para decidir cu√°ndo y c√≥mo usar las herramientas de Python de forma responsable, entendiendo los beneficios de su flexibilidad y los riesgos de su falta de restricciones.

## üêç Variables en Python

A diferencia de Kotlin, Python **no exige declarar el tipo de una variable ni usar palabras clave como `val` o `var`**.  
Simplemente se asigna un valor a un nombre, y el tipo se deduce autom√°ticamente en tiempo de ejecuci√≥n.

```python showLineNumbers title="Variables en Python"
name = "Emilia"
mana = 80
```

:::info Explicaci√≥n

- Las variables se crean en el momento en que se les asigna un valor.
- El tipo de cada variable se infiere din√°micamente (en este caso, `str` para `name` e `int` para `mana`).
- No existe una distinci√≥n entre referencias mutables e inmutables como `val` y `var` en Kotlin.
- El concepto de inmutabilidad depende del tipo de objeto (por ejemplo, `int` y `str` son inmutables; `list` y `dict` son mutables).

:::

Esta flexibilidad hace que Python sea m√°s sencillo para principiantes, pero tambi√©n **puede esconder errores** que en Kotlin ser√≠an detectados en tiempo de compilaci√≥n.

### üîÑ Reasignaci√≥n libre (mutabilidad de referencia)

En Python, **puedes reasignar una variable en cualquier momento**, sin importar el tipo de dato:

```python showLineNumbers title="Reasignaci√≥n de variables"
mana = 100
mana = 75  # ‚úÖ Reasignaci√≥n v√°lida
```

Esto contrasta con Kotlin, donde puedes declarar una variable como inmutable usando `val`, lo que impide cambiar su referencia.

:::info Tipos inmutables y mutables

Aunque Python permite reasignar cualquier variable, **no todos los objetos son mutables**.  
Tipos como `int`, `float`, `str` o `tuple` son **inmutables**: no se pueden modificar en el lugar, solo reemplazar.  
En cambio, estructuras como `list`, `dict` o `set` **s√≠ son mutables**, y pueden modificarse directamente.

```python showLineNumbers title="Inmutables vs mutables"
numbers = [1, 2, 3]   # lista mutable
numbers.append(4)     # ‚úÖ modificaci√≥n en el lugar

name = "Emilia"
name[0] = "A"         # üî• Error: los strings son inmutables
```

:::

### üö´ Inmutabilidad por convenci√≥n

Python **no ofrece una forma nativa de declarar variables inmutables** como `val` en Kotlin.  
Sin embargo, existen algunas **convenciones** que ayudan a simular constantes:

#### ‚úÖ Usar may√∫sculas por convenci√≥n

```python showLineNumbers title="Convenci√≥n de constantes"
MAX_MANA = 100
```

Esta es una convenci√≥n com√∫n en Python para indicar que un valor **no deber√≠a cambiarse**, aunque **nada impide modificarlo**.

#### üîí Inmutabilidad con `Final` (Python 3.8+)

Desde Python 3.8, puedes usar [`Final`](https://docs.python.org/3/library/typing.html#typing.Final) del m√≥dulo `typing` para declarar que una variable **no debe ser reasignada**.

```python showLineNumbers title="Declarar una variable inmutable con Final"
from typing import Final

SPIRIT_NAME: Final[str] = "Puck"
```

Aunque `Final` **no impide la reasignaci√≥n en tiempo de ejecuci√≥n**, herramientas de an√°lisis est√°tico como `mypy` pueden detectar usos incorrectos:

```python showLineNumbers title="Error detectado por mypy"
SPIRIT_NAME = "Muspel"  # ‚ö†Ô∏è mypy: Cannot assign to final variable "SPIRIT_NAME"
```

:::tip Buenas pr√°cticas

Si est√°s desarrollando bibliotecas o trabajando en proyectos colaborativos, usar `Final` es una forma expl√≠cita de comunicar la intenci√≥n de inmutabilidad.  
Aunque no impide errores en tiempo de ejecuci√≥n, ayuda a prevenirlos **de forma anticipada** gracias a herramientas como `mypy` o Pyright.

:::

## üß± Propiedades con decoradores

A diferencia de Kotlin, donde **todas las variables son propiedades** (ya sea dentro o fuera de una clase), en Python solo puedes declarar **propiedades dentro de clases** y debes definirlas expl√≠citamente con m√©todos especiales.

```python title="Sintaxis de una propiedad en Python (suponiendo que existe el tipo T)"
class Foo:
    __value: T

    @property
    def value(self) -> T: ...
    
    @value.setter
    def value(self, value: T) -> None: ...

    @value.deleter
    def value(self) -> None: ...
```

:::info Explicaci√≥n de la sintaxis

- `@property` convierte el m√©todo `value` en una **propiedad de solo lectura**.
- `@value.setter` permite asignar un nuevo valor con `obj.value = ...`.
- `@value.deleter` permite eliminar la propiedad con `del obj.value`.
- Los tres m√©todos deben tener el **mismo nombre** (`value`) para formar una √∫nica propiedad.

Este enfoque te permite encapsular acceso, validaci√≥n o l√≥gica de eliminaci√≥n, de forma similar a los `get()` y `set()` personalizados en Kotlin.

:::

### üìö Ejemplo pr√°ctico: Exponer una lista como inmutable

Sup√≥n que est√°s desarrollando una clase `Author` y deseas que otras personas puedan **consultar** las obras del autor, pero **sin poder modificarlas directamente**.

```python showLineNumbers title="type-fundamentals/basics/variables/author.py"
class Author:
    __name: str
    __works: list[str]

    def __init__(self, name: str, works: list[str]):
        self.__name = name
        self.__works = works

    @property
    def works(self) -> tuple[str, ...]:
        return tuple(self.__works)
```

<Explanation>
    El atributo interno `__works` almacena una lista mutable de obras.  
    Sin embargo, el m√©todo getter lo expone como una tupla, que es inmutable.

    Esto permite que quien use la clase pueda acceder a las obras (`author.works`), pero **no podr√° modificarlas directamente**, como reemplazar o agregar elementos.

    Es un patr√≥n √∫til cuando quieres mantener la **inmutabilidad en la interfaz p√∫blica**, sin renunciar a la eficiencia de las listas internamente.
</Explanation>

### ‚úèÔ∏è Ejemplo pr√°ctico: Validar y controlar una propiedad editable

Sup√≥n que est√°s creando una clase `User` y quieres permitir la lectura y edici√≥n del nombre, pero validando que **no est√© vac√≠o**. Adem√°s, quieres poder **eliminar el nombre** si es necesario.

```python showLineNumbers title="type-fundamentals/basics/variables/user.py"
class User:
    __name: str

    def __init__(self, name: str):
        self.__name = name

    @property
    def name(self) -> str:
        return self.__name

    @name.setter
    def name(self, value: str) -> None:
        if not value.strip():
            raise ValueError("Name cannot be empty")
        self.__name = value

    @name.deleter
    def name(self) -> None:
        self.__name = "Anonymous"
```

<Explanation>
    - `@property` permite acceder a `user.name` como si fuera un atributo com√∫n.
    - `@name.setter` se invoca cuando haces `user.name = "Nuevo nombre"`, y valida que no est√© vac√≠o.
    - `@name.deleter` se activa con `del user.name`, y en lugar de borrar el atributo, lo restablece a `"Anonymous"`.

    Este patr√≥n te permite usar una **sintaxis limpia y natural**, mientras mantienes control sobre la l√≥gica interna.
</Explanation>

## üÜö Resumen comparativo

| **Aspecto**                                       | **Kotlin**                                                                               | **Python**                                                                                 |
| ------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Declaraci√≥n**                                   | Requiere `val` o `var` y especificar tipo (opcional con inferencia).                     | Asignaci√≥n directa sin palabra clave ni tipo declarado.                                    |
| **Mutabilidad**                                   | `val` (inmutable) y `var` (mutable).                                                     | Todas las variables son mutables por defecto.                                              |
| **Control de mutabilidad**                        | La referencia puede ser inmutable (`val`), pero el contenido puede ser mutable.          | La mutabilidad depende del tipo del objeto (`int` inmutable, `list` mutable).              |
| **Constantes**                                    | `val` para referencias constantes, `const val` para constantes en tiempo de compilaci√≥n. | No hay constantes reales; se usa convenci√≥n (`MAY√öSCULAS`) o `Final` (desde Python 3.8).   |
| **Propiedades (dentro de clases)**                | Toda propiedad puede tener `get`/`set` personalizados con acceso controlado.             | Uso expl√≠cito de decoradores `@property`, `@setter` y `@deleter`.                          |
| **Visibilidad del setter**                        | Puede limitarse (ej. `private set`).                                                     | No hay modificadores de acceso; se controla indirectamente con convenci√≥n o encapsulaci√≥n. |
| **Campos de respaldo / backing fields**           | Usa `field` para acceder al valor real en `get`/`set`.                                   | Se accede directamente a atributos privados (ej. `__name`) dentro de m√©todos.              |
| **Vista inmutable de estructuras mutables**       | Exponer `List<T>` desde `MutableList<T>` (conversi√≥n impl√≠cita).                         | Exponer `tuple` desde `list` para garantizar inmutabilidad.                                |
| **Validaci√≥n en setters**                         | Se usa en `set(value)` con funciones como `require`.                                     | Se usa en `@setter` con `raise ValueError(...)`.                                           |
| **Detecci√≥n de errores en tiempo de compilaci√≥n** | El compilador verifica asignaciones inv√°lidas (`val`, tipo, etc.).                       | Requiere herramientas externas como `mypy` o Pyright.                                      |
| **Orientaci√≥n a inmutabilidad**                   | Fuerte √©nfasis en inmutabilidad por defecto (`val`).                                     | Enfocado en flexibilidad; la inmutabilidad es opcional y por convenci√≥n.                   |

<ProCons>
    <Pros title="Beneficios de Python">
        - Sintaxis simple y directa para declarar variables sin necesidad de palabras clave adicionales.  
        Esto reduce el ruido visual y permite concentrarse en la l√≥gica del programa, lo cual es √∫til en prototipos, scripts o ense√±anza.  
        Aun cuando sacrifica la expresividad expl√≠cita de la intenci√≥n (como distinguir entre `val` y `var`), favorece la fluidez al escribir c√≥digo r√°pidamente.
        - Flexibilidad total para reasignar variables o cambiar tipos en tiempo de ejecuci√≥n.  
        Esta libertad es valiosa en escenarios din√°micos como procesamiento de datos, scripting, pruebas r√°pidas o metaprogramaci√≥n.  
        Aunque puede dificultar el seguimiento del flujo de tipos, permite escribir c√≥digo m√°s adaptable y reutilizable sin rigidez estructural.
        - Sistema de propiedades mediante decoradores permite encapsular l√≥gica con una sintaxis clara.  
        Aunque m√°s expl√≠cita que en Kotlin, ofrece un control fino sobre lectura, escritura y eliminaci√≥n de atributos.
        - Ideal para scripting, prototipado r√°pido y ense√±anza por su bajo nivel de complejidad inicial.  
        Los principiantes pueden centrarse en conceptos esenciales sin verse abrumados por la sintaxis del lenguaje.
        - Compatibilidad con anotaciones opcionales (`Final`, tipos) permite reforzar buenas pr√°cticas con herramientas externas.  
        Esto facilita una adopci√≥n progresiva de pr√°cticas robustas sin imponerlas desde el inicio.
    </Pros>
    <Cons title="Limitaciones de Python">
        - No existe una forma nativa de restringir la reasignaci√≥n o mutabilidad de variables.  
            Esto dificulta expresar la intenci√≥n de inmutabilidad en la interfaz p√∫blica de una biblioteca. Aunque existen convenciones (`MAY√öSCULAS`) y herramientas como `Final`, ninguna impone restricciones reales en tiempo de ejecuci√≥n.
        - Las garant√≠as de tipo o de estado son opcionales y dependen de herramientas externas.  
            Python no valida las anotaciones de tipo ni impide errores como asignar un valor inesperado.  
            Esto puede llevar a fallos en tiempo de ejecuci√≥n que, en lenguajes como Kotlin, se detectan en compilaci√≥n.
        - Las propiedades deben definirse manualmente con decoradores.  
            Aunque poderosas, requieren m√°s c√≥digo expl√≠cito y repetitivo que en Kotlin, donde cada variable es una propiedad con `get/set` impl√≠citos desde el inicio.
        - No hay modificadores de acceso reales (`private`, `protected`).  
            El uso de convenciones como `__atributo` ayuda a ocultar implementaci√≥n, pero no impide el acceso desde fuera. Esto complica la encapsulaci√≥n y puede dificultar la evoluci√≥n segura de bibliotecas.
        - La flexibilidad del lenguaje dificulta razonar formalmente sobre el estado de los objetos.  
            Al permitir reasignaciones y cambios de tipo en cualquier momento, se vuelve m√°s dif√≠cil garantizar invariantes internas o aplicar transformaciones seguras sin pruebas exhaustivas o validaciones adicionales.
        - La falta de inmutabilidad por defecto complica el estilo funcional.  
            En programaci√≥n funcional, la inmutabilidad es clave para componer funciones puras y evitar efectos colaterales.  
            Como Python permite mutar estructuras y reasignar nombres libremente, es m√°s f√°cil introducir errores sutiles y m√°s dif√≠cil aplicar enfoques funcionales de forma segura y expresiva.
    </Cons>
</ProCons>

## üéØ Conclusiones

A lo largo de esta lecci√≥n exploramos c√≥mo se declaran y gestionan las variables en Python, y c√≥mo este modelo difiere profundamente del enfoque expresivo y seguro de Kotlin.

Python privilegia la **simplicidad y flexibilidad**, permitiendo reasignaciones sin restricciones y eliminando la necesidad de palabras clave como `val` o `var`. Esto facilita la escritura de c√≥digo r√°pido y din√°mico, especialmente √∫til en scripts, prototipos y ense√±anza. Sin embargo, tambi√©n **sacrifica garant√≠as** importantes como la inmutabilidad por defecto, la validaci√≥n de tipos en compilaci√≥n o el control expl√≠cito de visibilidad y mutabilidad.

En contraste con Kotlin, donde cada variable es tambi√©n una propiedad capaz de encapsular l√≥gica de forma declarativa, en Python se requiere definir manualmente cada aspecto mediante decoradores. Esto otorga poder, pero tambi√©n impone m√°s esfuerzo y atenci√≥n al detalle para lograr un dise√±o robusto.

Finalmente, vimos c√≥mo algunas herramientas del ecosistema ‚Äîcomo `Final`, `mypy` o `@property`‚Äî permiten recuperar parte de esa expresividad, aunque nunca con la misma fuerza ni inmediatez que en un lenguaje est√°ticamente tipado y orientado a la inmutabilidad por defecto.

### üîë Puntos clave

- En Python, una variable se crea al asignarle un valor: no necesita declaraci√≥n previa ni palabra clave.
- No hay distinci√≥n nativa entre variables mutables e inmutables; toda variable puede ser reasignada.
- La inmutabilidad depende del tipo del objeto (por ejemplo, `int` es inmutable; `list` es mutable).
- No existe soporte real para constantes, pero se pueden simular con convenciones (`MAY√öSCULAS`) o `Final`.
- Las propiedades se implementan con decoradores (`@property`, `@setter`, `@deleter`), lo que permite encapsular validaciones y l√≥gica de acceso.
- Python no impone restricciones, pero s√≠ ofrece herramientas opcionales para lograr mayor seguridad y expresividad.

### üß∞ ¬øQu√© nos llevamos?

Python ofrece un entorno flexible y accesible, ideal para quienes priorizan rapidez de desarrollo, exploraci√≥n interactiva o ense√±anza. Su sistema de variables permite escribir c√≥digo sin fricciones, pero a costa de perder garant√≠as que en otros lenguajes ‚Äîcomo Kotlin‚Äî est√°n integradas desde la base.

Este enfoque **no es malo por s√≠ mismo**, pero **te delega a ti, como quien dise√±a las bibliotecas, la responsabilidad de proteger tus invariantes**. Tendr√°s que aplicar disciplina, convenciones, y herramientas adicionales si buscas ofrecer una API segura y mantenible.

Elegir entre flexibilidad y restricciones no es una cuesti√≥n de preferencia personal, sino de **adecuaci√≥n al problema y al contexto**. En un script simple o una exploraci√≥n de datos, la flexibilidad de Python brilla. En una biblioteca compartida y en evoluci√≥n, podr√≠as echar de menos las garant√≠as de un sistema como el de Kotlin.

La clave es comprender qu√© te ofrece cada lenguaje, y c√≥mo usar sus herramientas ‚Äîy sus l√≠mites‚Äî a tu favor.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage
        title="Python Constants: Improve Your Code‚Äôs Maintainability ‚Äì Real Python"
        url="https://realpython.com/python-constants/"
        location="Real Python"
        author={<AuthorList authors={[
            { 
                firstName: "Leodanis", 
                lastName: "Pozo Ramos", 
                url: "https://realpython.com/team/lpozoramos/" 
            }
        ]}  />}
    >
        Este art√≠culo ofrece una gu√≠a completa sobre el uso de constantes en Python para mejorar la legibilidad, mantenibilidad y seguridad del c√≥digo. Explica qu√© son las constantes, por qu√© usarlas y c√≥mo implementarlas en proyectos reales, a pesar de que Python no tiene una sintaxis nativa para constantes estrictas. Cubre buenas pr√°cticas, uso de constantes predefinidas y estrategias para organizarlas (como m√≥dulos dedicados, archivos de configuraci√≥n o variables de entorno). Adem√°s, presenta t√©cnicas avanzadas para crear constantes verdaderamente inmutables usando clases, <code>@property</code>, <code>namedtuple</code>, <code>@dataclass</code> y m√°s.
    </WebPage>
]}  />
