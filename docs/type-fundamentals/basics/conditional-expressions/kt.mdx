---
title: Expresiones condicionales
---
import Exercise from '@site/src/components/exercise/Exercise'
import Explanation from '@site/src/components/admonitions/Explanation'
import Solution from '@site/src/components/exercise/Solution'
import ReadingTime from '@site/src/components/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import ReferenceList from '@site/src/components/references/ReferenceList'
import Video from '@site/src/components/references/Video'
import Book from '@site/src/components/references/Book'
import WebPage from '@site/src/components/references/WebPage'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Las estructuras condicionales son uno de los pilares del control de flujo en cualquier lenguaje de programaci√≥n.  
Sin embargo, **Kotlin adopta una perspectiva m√°s expresiva y funcional que lenguajes imperativos tradicionales como Java**, al permitir que construcciones como `if` y `when` no sean solo declaraciones, sino tambi√©n **expresiones que devuelven valores**.

Este enfoque promueve un estilo de programaci√≥n m√°s **conciso**, **declarativo** y alineado con la escritura de **funciones puras y reutilizables**. En esta lecci√≥n aprenderemos a **distinguir entre declaraciones y expresiones condicionales**, y a aprovechar la expresividad de Kotlin para escribir funciones m√°s limpias y mantenibles.

Tambi√©n exploraremos el uso idiom√°tico de `when`, una alternativa poderosa a m√∫ltiples `if` anidados, y discutiremos sus diferencias con el *pattern matching* en lenguajes como Scala o Rust.

## üîÄ Expresi√≥n `if`

En Kotlin, `if` no se limita a controlar el flujo del programa: tambi√©n puede usarse como una **expresi√≥n** que retorna un valor.  
Esto lo diferencia de muchos lenguajes imperativos, donde `if` es √∫nicamente una declaraci√≥n.

```kotlin showLineNumbers title="if como expresi√≥n"
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

Este enfoque permite escribir funciones m√°s **concisas** y **expresivas**.

Cuando no necesitas obtener un valor, tambi√©n puedes usar `if` como una **declaraci√≥n**, simplemente para ejecutar c√≥digo condicional:

```kotlin showLineNumbers title="if como declaraci√≥n"
if (isLoggedIn) {
    println("Welcome back!")
}
// El bloque else es opcional cuando se usa como declaraci√≥n
```

:::danger Sin `else`, no hay valor

Cuando usas `if` como una **expresi√≥n** ‚Äîes decir, para producir un valor‚Äî, el bloque `else` es **obligatorio**.  
Si lo omites, el compilador no sabr√° qu√© valor debe retornar cuando la condici√≥n sea falsa, y generar√° un error.

```kotlin title="if sin else en expresi√≥n" showLineNumbers
val result = if (x > 0) "Positive" // ‚ùå Error de compilaci√≥n: falta `else`
```

:::

:::info Llaves en `if`: ¬øcu√°ndo son necesarias?

- Si una rama (`if` o `else`) contiene **m√°s de una instrucci√≥n**, las llaves `{}` son **obligatorias**.
- Si tiene **una sola instrucci√≥n**, pueden omitirse ‚Äîaunque es recomendable mantener las llaves para evitar errores al modificar el c√≥digo en el futuro.
- Cuando se usa `if` como **expresi√≥n**, el valor retornado es el de la **√∫ltima expresi√≥n evaluada** en cada rama.

    ```kotlin showLineNumbers title="if como expresi√≥n simple"
    val result = if (x > 0)
        "positive"
    else
        "negative"
    ```

    En este ejemplo, `result` ser√° `"positive"` o `"negative"` dependiendo de la condici√≥n.  
    Con llaves, se aplica la misma l√≥gica:

    ```kotlin showLineNumbers title="if como expresi√≥n con efectos colaterales"
    val result = if (x > 0) {
        println("Evaluating...")
        "positive"
    } else {
        println("Evaluating...")
        "negative"
    }
    ```

    Aqu√≠, cada rama imprime un mensaje y luego retorna una cadena como resultado.

:::

## üéõÔ∏è Expresi√≥n `when`

La expresi√≥n `when` en Kotlin es una alternativa concisa, segura y expresiva a cadenas de `if-else if`.  
A diferencia de muchas construcciones similares en otros lenguajes, **`when` produce un valor**, por lo que puede utilizarse en asignaciones o retornos.

```kotlin showLineNumbers title="when con argumento"
when (status) {
    200, 201, 204 -> "Success"
    400 -> "Bad Request"
    404 -> "Not Found"
    500 -> "Internal Server Error"
    "timeout" -> "The request timed out"
    is Int -> "Unhandled status code: $status"
    !is String -> "Unknown type"
    else -> "Unhandled string: $status"
}
```

<Explanation>
    - **`when (status)`** compara el valor de `status` contra m√∫ltiples condiciones.
    - Puedes **agrupar valores** en una misma rama usando comas: `200, 201, 204 ->`.
    - Permite realizar **verificaciones de tipo** con `is` y `!is`.
    - El bloque **`else`** es obligatorio si no se cubren todos los posibles casos.
    - Como `when` es una **expresi√≥n**, puede usarse en contextos como asignaciones, retornos o inicializaciones.
</Explanation>

<details>
  <summary>
    Diferencias con <code>switch</code> en otros lenguajes
  </summary>

    A diferencia de estructuras como `switch` en C, Java o JavaScript, **Kotlin no permite ejecuci√≥n por ca√≠da (*fall-through*)** entre ramas.  
    Esto significa que **no necesitas escribir `break` para evitar que se ejecuten m√∫ltiples bloques**.

    Por ejemplo, en Java:

    ```java title="Java: sin break"
    switch (status) {
        case 200:
            System.out.println("Success");
        case 400:
            System.out.println("Bad Request");
    }
    ```

    Si `status` es `200`, se imprimir√°:

    ```
    Success
    Bad Request
    ```

    Esto ocurre porque la ejecuci√≥n "cae" en la siguiente rama al no encontrar un `break`.

    Para evitar este comportamiento en Java, necesitas agregar `break` expl√≠citamente:

    ```java title="Java: con break"
    switch (status) {
        case 200:
            System.out.println("Success");
            break;
        case 400:
            System.out.println("Bad Request");
            break;
    }
    ```

    Ahora s√≠, si `status` es `200`, se imprimir√° solo:

    ```
    Success
    ```

    En Kotlin, este es el comportamiento por defecto:

    ```kotlin title="Kotlin: sin fall-through"
    when (status) {
        200 -> println("Success")
        400 -> println("Bad Request")
    }
    ```

    No existe la posibilidad de *fall-through*. Cada rama es **completamente aislada**, lo que hace que el flujo de control sea **m√°s seguro, claro y f√°cil de mantener**.
</details>

:::tip Tambi√©n puede usarse sin argumento

Puedes omitir el valor entre par√©ntesis en `when` para evaluar **condiciones arbitrarias**, como lo har√≠as con una cadena de `if` / `else if`:

```kotlin showLineNumbers title="when sin argumento"
when {
    temperature < 0     -> "Below freezing"
    temperature <= 15   -> "Cold"
    temperature <= 25   -> "Mild"
    temperature <= 35   -> "Warm"
    else                -> "Hot"
}
```

Este estilo es √∫til cuando necesitas evaluar **expresiones booleanas distintas** que no dependen de un mismo valor.

:::

:::info Uso de llaves `{}` en `when`

- Las llaves son **obligatorias** si una rama contiene **m√°s de una instrucci√≥n**.
- Si hay **una sola expresi√≥n**, pueden omitirse.
- En expresiones `when`, el **valor de retorno** ser√° el de la **√∫ltima expresi√≥n evaluada** en cada rama.

```kotlin showLineNumbers title="when con llaves"
val message = when (code) {
    404 -> {
        println("Not Found")
        logError(code)
        "Not Found" // ‚Üê Este valor se devuelve
    }
    else -> "Unhandled"
}
```

:::

:::warning Diferencias con *pattern matching* real

Aunque `when` tiene una sintaxis similar al *pattern matching* de lenguajes como Scala o Rust, sus capacidades son m√°s limitadas:

- No permite **destructuraci√≥n directa**, como `case (a, b)` en Scala.
- No soporta **patrones anidados** ni **coincidencias estructurales complejas**.
- No permite hacer coincidir **constructores de tipos algebraicos** de forma declarativa.

:::

### üõ° `when` guards

A partir de **Kotlin 2.2.0**, es posible agregar **condiciones adicionales** a una rama de `when` usando un **guard** con la palabra clave `if`. Esto permite combinar **verificaci√≥n de tipo** y **predicados personalizados** en una misma rama, lo que aumenta la expresividad del control de flujo.

```kotlin showLineNumbers title="when con guards"
when (status) {
    is Int if status in 200..299 -> "Success"
    is Int if status in 400..499 -> "Client Error"
    is Int if status >= 500 -> "Server Error"
    else -> "Unknown"
}
```

<Explanation>
  - Primero se verifica si `status` es un `Int`.
  - Luego, se eval√∫a la condici√≥n del `if`.
  - Esta combinaci√≥n act√∫a como un filtro: **el valor debe cumplir ambas condiciones** para que se ejecute la rama.
  - Si ninguna coincide, se eval√∫a la rama `else`.
</Explanation>

---

### üîÅ Ejercicio: Reescribir usando `when`

Reescribe la funci√≥n `login` utilizando una expresi√≥n `when` en lugar de m√∫ltiples `if`.

```kotlin showLineNumbers title="Versi√≥n original usando if"
fun login(username: String, password: String): Boolean {
    if (loginAttempts >= maxLoginAttempts) {
        return false
    }
    if (isValidPassword(password)) {
        loginAttempts = 0
        return true
    }
    loginAttempts++
    return false
}
```

<Solution>
    ```kotlin showLineNumbers title="Versi√≥n reescrita con when"
    fun login(username: String, password: String): Boolean = when {
        loginAttempts >= maxLoginAttempts -> false
        isValidPassword(password) -> {
            loginAttempts = 0
            true
        }
        else -> {
            loginAttempts++
            false
        }
    }
    ```
</Solution>

---

## üéØ Conclusiones

Kotlin transforma estructuras condicionales tradicionales como `if` y `switch` en **expresiones que retornan valores**, promoviendo un estilo m√°s conciso, expresivo y seguro.  
Este enfoque es especialmente √∫til en funciones puras y dise√±os declarativos, donde buscamos reducir efectos colaterales y aumentar la claridad del c√≥digo.

Desde Kotlin **2.2.0**, la expresividad del lenguaje se ve reforzada con los llamados **`when` guards**, que permiten combinar verificaciones de tipo y condiciones personalizadas en una misma rama, acercando a `when` a un verdadero patr√≥n de filtrado.

Tanto `if` como `when` pueden usarse como **expresiones** o **declaraciones**. La distinci√≥n es importante:

- **Como declaraciones**, controlan el flujo.
- **Como expresiones**, producen un valor y pueden usarse en asignaciones o retornos, lo que abre la puerta a un estilo m√°s funcional.

### üîë Puntos clave

- Kotlin permite que `if` y `when` se usen como expresiones que **retornan valores**.
- Cuando `if` es una expresi√≥n, el bloque `else` es **obligatorio**.
- En ramas con llaves `{}`, se retorna la **√∫ltima expresi√≥n evaluada**.
- `when` es una alternativa poderosa a cadenas `if-else if`, con soporte para m√∫ltiples valores, verificaciones de tipo y uso sin argumento.
- Desde Kotlin 2.2.0, `when` admite **guards**, lo que permite escribir condiciones a√∫n m√°s expresivas.
- Aunque `when` recuerda al *pattern matching*, **no soporta coincidencias estructurales complejas** como Scala o Rust.
- El `when` sin argumento permite expresar condiciones booleanas independientes de manera declarativa.

### üß∞ ¬øQu√© nos llevamos?

Estas capacidades son especialmente valiosas al dise√±ar **bibliotecas reutilizables**, donde buscamos expresar decisiones sin estructuras verbosas ni efectos colaterales.  
En este contexto, `if` y `when` no solo controlan el flujo: **tambi√©n producen valores** que pueden integrarse f√°cilmente en funciones puras.

Adoptar este enfoque ‚Äîver las condiciones como **expresiones evaluables**‚Äî permite escribir c√≥digo m√°s claro, mantenible y alineado con un estilo declarativo.  
Comprender esta diferencia nos prepara para abordar con solidez temas como lambdas, funciones puras y estructuras de control avanzadas.

<div className="language-card-container">
    <LanguageCards.ScalaCard link="/docs/type-fundamentals/basics/conditional-expressions/scala" />    
</div>

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias Recomendadas" items={[
    <Video 
        title="C√≥mo escribir CONDICIONALES en Kotlin: if/else, when [Curso 2024]"
        url="https://youtu.be/ZJWh-7JmuEA"
        duration="6m36s"
        location="YouTube"
        author="DevExpert - Programaci√≥n Android y Kotlin"
    >
        Video introductorio y did√°ctico sobre <code>if</code> y <code>when</code> como expresiones y declaraciones. Ideal para quienes inician en programaci√≥n y quieren entender c√≥mo expresar decisiones condicionales en el flujo del c√≥digo.
    </Video>,
    <Book
        chapter="Conditionals"
        book="Kotlin Programming: The Big Nerd Ranch Guide"
        author="Andrew Bailey, David Greenhalgh y Josh Skeen"
    >
        Introducci√≥n pr√°ctica al control de flujo con <code>if</code>, <code>else</code> y <code>when</code>, usando ejemplos aplicados al proyecto <i>bounty-board</i>.
    </Book>
]} />

<ReferenceList title="üîπ Referencias Adicionales" items={[
    <WebPage
        title="Conditions and loops"
        url="https://kotlinlang.org/docs/control-flow.html"
        location="la documentaci√≥n oficial de Kotlin"
    >
        Gu√≠a completa y actualizada sobre <code>if</code>, <code>when</code> y bucles. Ideal como referencia r√°pida, aunque incluye temas m√°s avanzados que a√∫n no se abordan en el curso.
    </WebPage>,
    <Book
        chapter="when Expressions"
        pages={[187, 192]}
        book="Atomic Kotlin"
        author="Bruce Eckel y Svetlana Isakova"
    >
        Este cap√≠tulo ofrece una introducci√≥n clara y progresiva al uso de <code>when</code> como expresi√≥n, destacando su ventaja frente a m√∫ltiples <code>if-else</code> en t√©rminos de legibilidad y expresividad. Explora desde casos simples hasta condiciones con conjuntos y tipos, reforzando su utilidad para retornar valores, agrupar condiciones y escribir c√≥digo m√°s declarativo y mantenible en bibliotecas funcionales.
    </Book>,
    <Book
        chapter="If Expressions"
        pages={[39, 43]}
        book="Atomic Kotlin"
        author="Bruce Eckel y Svetlana Isakova"
    >
        Introducci√≥n muy b√°sica al uso de <code>if</code> como expresi√≥n en Kotlin, pensada para personas nuevas en programaci√≥n. Destaca su utilidad para escribir funciones concisas y declarativas.
    </Book>,
    <Book
        chapter="Kotlin Basics"
        pages={[17, 43]}
        book="Kotlin in Action"
        author="Dmitry Jemerov y Svetlana Isakova"
    >
        Presenta <code>if</code> y <code>when</code> como expresiones con valor de retorno, m√°s expresivas y poderosas que sus equivalentes en Java, lo que facilita un estilo de control de flujo m√°s idiom√°tico.
    </Book>
]} />

