---
title: Expresiones condicionales en Scala
---
import Explanation from '@site/src/components/admonitions/Explanation'

## üîÄ `if` siempre es una expresi√≥n

En Scala, **`if` es siempre una expresi√≥n**: produce un valor y no se limita a controlar el flujo del programa.  
Esto permite escribir funciones concisas y expresivas, sin necesidad de bloques adicionales para calcular y luego retornar un valor.

```scala
def maxOf(a: Int, b: Int): Int = if a > b then a else b
```

<Explanation>
    En este ejemplo, `if` retorna directamente el mayor valor entre `a` y `b`.  
    No se necesita una variable temporal ni m√∫ltiples l√≠neas: la expresi√≥n produce el resultado esperado en una sola instrucci√≥n.
</Explanation>

Cuando se omite la rama `else`, el compilador debe proporcionar un valor para el caso faltante.  
Scala resuelve esto introduciendo el valor `()`, de tipo `Unit`, que representa la ausencia de informaci√≥n √∫til (similar a `void` en otros lenguajes).

```scala
val x: Int | Unit = if 1 > 2 then 1
println(x) // Prints: ()
```

<Explanation>
    - En este ejemplo, como la condici√≥n es falsa y no hay rama `else`, el resultado de la expresi√≥n `if` es `()`.
    - La rama `then` retorna un `Int`, mientras que la rama impl√≠cita retorna `Unit`, por lo que el tipo inferido debe abarcar ambos: `Int | Unit`.
</Explanation>

:::tip Mejores pr√°cticas

Dado que `if` siempre es una expresi√≥n en Scala, es recomendable incluir expl√≠citame
nte la rama `else`.  
Esto hace que el c√≥digo sea m√°s claro, m√°s predecible, y evita tipos compuestos innecesarios como `Int | Unit`.

:::

### üéõÔ∏è `match` como alternativa a `when`

TODO

```scala
status match {
  case 200 | 201 | 204 => "Success"
  case 400             => "Bad Request"
  case 404             => "Not Found"
  case x if x >= 500   => "Server error"
  case _               => "Unhandled status"
}
```

#### üß† Lo que s√≠ puedes hacer en Scala (pero no en Kotlin):

- **Coincidencia estructural**: puedes hacer *pattern matching* con destructuraci√≥n.
  
  ```scala
  val person = ("Jane", 30)

  person match {
    case (name, age) => s"$name is $age years old"
  }
  ```

- **Coincidencias por tipo y extracci√≥n simult√°nea**:

  ```scala
  def describe(x: Any): String = x match {
    case i: Int    => s"Integer: $i"
    case s: String => s"String: $s"
    case _         => "Unknown"
  }
  ```

- **Coincidencias anidadas y m√∫ltiples niveles de patrones**.

#### ‚ùå Esto no es posible en Kotlin:

Kotlin no admite coincidencias destructivas con `when`, ni siquiera con tuplas. Tampoco permite anidamientos complejos directamente dentro de `when`.  
Para obtener capacidades similares a las de `match`, necesitas usar bibliotecas externas o combinar varias expresiones.

---

### üß™ `if`, `match` y tipos

Scala tambi√©n infiere el tipo de las expresiones `if` o `match`:

```scala
val message = if (isValid) "OK" else 404
// message: Any ‚Üí mezcla String e Int
```

Cuando las ramas tienen tipos distintos, el tipo resultante ser√° su **tipo com√∫n m√°s general**, usualmente `Any`. Esto puede ser fuente de errores si no se maneja con cuidado.

---

### üßÆ `match` exhaustivo

Scala exige que el `match` sea **exhaustivo**, especialmente cuando se trabaja con tipos sellados (`sealed`).  
Esto ayuda al compilador a detectar ramas faltantes:

```scala
sealed trait Status
case object Ok extends Status
case object Error extends Status

def message(s: Status): String = s match {
  case Ok    => "All good"
  case Error => "Something went wrong"
  // No se necesita case _ si todos los casos est√°n cubiertos
}
```

En Kotlin, `when` tambi√©n puede ser exhaustivo si se usa con tipos `sealed`, pero no lo exige por defecto salvo en asignaciones.

---

## üßæ Conclusiones comparativas

| Caracter√≠stica                    | Kotlin (`if` / `when`)               | Scala (`if` / `match`)                      |
|----------------------------------|--------------------------------------|---------------------------------------------|
| `if` como expresi√≥n              | ‚úÖ S√≠                                 | ‚úÖ S√≠                                        |
| `if` sin `else`                 | ‚ùå Error de compilaci√≥n               | ‚ö†Ô∏è Permitido, pero puede resultar en `null` |
| `when` / `match` como expresi√≥n  | ‚úÖ S√≠                                 | ‚úÖ S√≠                                        |
| Verificaci√≥n de tipo            | ‚úÖ `is` / `!is`                       | ‚úÖ con `case x: Type =>`                     |
| Coincidencia estructural        | ‚ùå No                                 | ‚úÖ S√≠                                        |
| Destructuraci√≥n de tuplas       | ‚ùå No                                 | ‚úÖ S√≠                                        |
| Anidaci√≥n compleja              | ‚ùå Limitada                           | ‚úÖ Avanzada                                  |
| Pattern matching exhaustivo     | ‚ö†Ô∏è Solo con `sealed` y en asignaciones | ‚úÖ Requiere exhaustividad con `sealed`       |

---

## üß† Reflexi√≥n

Tanto Kotlin como Scala promueven un enfoque expresivo y funcional en el control de flujo.  
Sin embargo, **Scala lleva este enfoque m√°s lejos con su soporte completo para *pattern matching***, lo cual es especialmente √∫til al construir bibliotecas sobre estructuras algebraicas, √°rboles sint√°cticos o representaciones anidadas.

Si vienes de Kotlin, apreciar√°s la consistencia de las expresiones, pero tambi√©n notar√°s que **Scala te da m√°s herramientas para representar y manipular datos de forma estructurada y concisa**, lo que puede resultar muy poderoso en el dise√±o de bibliotecas reutilizables.

