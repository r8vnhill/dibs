---
title: Expresiones condicionales en Scala
---
import Explanation from '@site/src/components/admonitions/Explanation'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="scala-dibs" />

Scala es un lenguaje expresivo y funcional donde incluso las construcciones de control m√°s tradicionales, como `if` y `match`, se comportan como **expresiones**: devuelven un valor y pueden componer l√≥gica declarativa sin efectos secundarios.

En esta lecci√≥n exploraremos c√≥mo Scala trata las decisiones condicionales de forma m√°s rica que otros lenguajes como Java o Kotlin. Aprender√°s a escribir `if` como una verdadera expresi√≥n, a evitar errores comunes como omitir la rama `else`, y a usar `match` para construir flujos de decisi√≥n potentes y seguros, incluyendo t√©cnicas como **guardas** y **coincidencia estructural**.

Estas capacidades son fundamentales para dise√±ar bibliotecas expresivas, seguras y f√°ciles de mantener ‚Äîy te preparar√°n para modelar l√≥gica m√°s avanzada con tipos algebraicos.

## üîÄ `if` siempre es una expresi√≥n

En Scala, **`if` es siempre una expresi√≥n**: produce un valor y no se limita a controlar el flujo del programa.  
Esto permite escribir funciones concisas y expresivas, sin necesidad de bloques adicionales para calcular y luego retornar un valor.

```scala showLineNumbers
def maxOf(a: Int, b: Int): Int = if a > b then a else b
```

<Explanation>
    En este ejemplo, `if` retorna directamente el mayor valor entre `a` y `b`.  
    No se necesita una variable temporal ni m√∫ltiples l√≠neas: la expresi√≥n produce el resultado esperado en una sola instrucci√≥n.
</Explanation>

### ‚ö†Ô∏è Omitir `else` puede generar resultados confusos

Aunque `if` siempre es una expresi√≥n en Scala, **omitir la rama `else` cuando se espera un valor no invalida el programa**, pero s√≠ produce un comportamiento inesperado y un warning del compilador.

```scala showLineNumbers
val x: Unit = if 1 > 2 then 1
val y: Unit = if 2 > 1 then 1
println(x) // Prints: ()
println(y) // Prints: ()
```

<Explanation>
    - En ambos casos, el compilador detecta que est√°s usando `if` como expresi√≥n, pero falta la rama `else`.
    - Como se espera un valor de tipo `Unit`, Scala convierte impl√≠citamente la expresi√≥n `if` en un bloque `{ 1; () }`, descartando el valor `1` y retornando `()`.
    - El compilador muestra una advertencia:  
      **"Discarded non-Unit value of type Int. Add `: Unit` to discard silently."**
    - Aunque el c√≥digo compila y se ejecuta, **el resultado final es siempre `()`**, lo que probablemente no sea lo que se pretend√≠a.
</Explanation>

:::tip Mejores pr√°cticas

Si est√°s usando `if` como expresi√≥n, **nunca omitas la rama `else`** cuando esperas que produzca un valor.  
Esto previene advertencias, evita que valores √∫tiles sean descartados silenciosamente, y hace que la intenci√≥n del c√≥digo sea expl√≠cita.

:::

## üéõÔ∏è `match` como alternativa a `when`

Scala no tiene una construcci√≥n `when` como Kotlin, pero ofrece algo m√°s potente: el **patr√≥n de emparejamiento** (`match`).  
`match` permite comparar un valor contra m√∫ltiples patrones y ejecutar diferentes ramas seg√∫n corresponda. A diferencia de `switch` en otros lenguajes, es **m√°s expresivo y seguro** si se usa correctamente.

```scala showLineNumbers
status match
  case 200 | 201 | 204 => "Success"
  case 400 => "Bad Request"
  case 404 => "Not Found"
  case 500 => "Internal Server Error"
  case "timeout" => "The request timed out"
  case status: Int => s"Unhandled status code: $status"
  case status: String => s"Unhandled string: $status"
  case _ => "Unknown type"
```

<Explanation>
  Este ejemplo muestra c√≥mo `match` puede combinar m√∫ltiples t√©cnicas de emparejamiento:
  
  - `200 | 201 | 204`: uso de **patrones alternativos** con `|` para valores equivalentes.
  - `status: Int`: **extracci√≥n con tipo**, que permite manejar enteros no cubiertos antes.
  - `status: String`: lo mismo pero para cadenas.
  - `_`: **comod√≠n** que act√∫a como caso por defecto.
  
  Esta estructura es mucho m√°s flexible que `switch` o `when`, ya que permite trabajar con estructuras complejas, tipos, guardas y m√°s.
</Explanation>

### üß™ Pattern guards

Scala permite refinar a√∫n m√°s los patrones usando **pattern guards**, una condici√≥n adicional escrita con `if` despu√©s del patr√≥n.  
Esto permite, por ejemplo, distinguir ciertos enteros o validar condiciones m√°s complejas:

```scala showLineNumbers
status match
  case s: Int if s >= 200 && s < 300 => "Success"
  case s: Int if s >= 400 && s < 500 => "Client error"
  case s: Int if s >= 500 => "Server error"
  case _ => "Unknown"
```

<Explanation>
  Aqu√≠ usamos **pattern guards** para clasificar c√≥digos HTTP num√©ricos por rango:
  
  - Cada `case` empareja primero un entero (`s: Int`), y luego aplica una condici√≥n adicional (`if ...`) sobre ese valor.
  - Esta t√©cnica evita tener que enumerar todos los valores individualmente.
  - Tambi√©n puede usarse con cualquier tipo de patr√≥n, no solo enteros.
</Explanation>

### üßÆ `match` no siempre es exhaustivo

A diferencia de Kotlin, Scala **no fuerza la exhaustividad** en todas las situaciones.  
Si no se cubren todos los casos posibles y no se incluye un comod√≠n (`_`), se corre el riesgo de un error en tiempo de ejecuci√≥n llamado `MatchError`.

```scala showLineNumbers
networkStatus(Object())
```

```plaintext
Exception in thread "main" scala.MatchError: java.lang.Object@... (of class java.lang.Object)
  at ...
```

<Explanation>
  En este ejemplo, `networkStatus` no tiene una rama que maneje objetos arbitrarios.  
  Al pasarle un `Object`, ninguna de las cl√°usulas coincide, lo que produce un `MatchError`.  
  Para evitarlo, se recomienda:
  
  - Usar un caso `case _ =>` como rama por defecto.
  - Trabajar con **tipos sellados (`sealed`)** o **enumeraciones**, donde el compilador s√≠ puede forzar exhaustividad.
</Explanation>

:::tip Mejores pr√°cticas

Siempre que uses `match`, aseg√∫rate de cubrir todos los casos posibles, ya sea mediante patrones espec√≠ficos o con un comod√≠n `_`.  
Si trabajas con tus propios tipos, usa `sealed trait` o `enum` para que el compilador pueda ayudarte a detectar casos no cubiertos.

:::

### üß© Pattern matching

Los ejemplos que vimos hasta ahora son casos simples de **pattern matching**: comparar valores literales o tipos b√°sicos.  
Sin embargo, una de las fortalezas m√°s destacadas de Scala es su capacidad para realizar **coincidencia estructural** y **destructuraci√≥n** de objetos y colecciones.

M√°s adelante, cuando veamos **tipos algebraicos** como `case class`, `enum` o jerarqu√≠as con `sealed trait`, aprenderemos c√≥mo `match` puede descomponer estructuras complejas, extraer valores internos, e incluso aplicar condiciones personalizadas.

Esto permite escribir c√≥digo conciso, seguro y expresivo, especialmente √∫til al dise√±ar bibliotecas y trabajar con estructuras de datos ricas.

## üìä Resumen comparativo

| Caracter√≠stica                  | Kotlin                               | Scala                                |
|---------------------------------|--------------------------------------|--------------------------------------|
| Naturaleza de `if`              | Declaraci√≥n o expresi√≥n              | Siempre expresi√≥n                    |
| Rama `else` en expresiones `if` | Obligatoria                          | Opcional (pero recomendada)          |
| Valor de `if` sin `else`        | Error de compilaci√≥n                 | Retorna `Unit` (con advertencia)     |
| Bloques con llaves              | Obligatorio para m√∫ltiples l√≠neas    | Indentaci√≥n obligatoria (Scala 3)    |
| Estructura m√∫ltiple             | `when`                               | `match`                              |
| Retorno de valor en estructuras | `if` y `when` pueden retornar valor  | `if` y `match` retornan valor       |
| Fall-through en estructuras     | No permitido                         | No permitido                        |
| Patr√≥n comod√≠n                  | Rama `else` obligatoria si no exhaustivo | `_` opcional (pero recomendado)  |
| Chequeo de exhaustividad        | Autom√°tico para `when` con enums o sealed types | Autom√°tico solo con tipos sellados o enums |
| Coincidencia estructural avanzada | No soportada (solo b√°sica)           | Soportada (destructuraci√≥n, guardas, coincidencias avanzadas) |
| Guardas en patrones             | Experimental (`-Xwhen-guards`)       | Soportado plenamente (`if`)         |

<ProCons>
  <Pros title="Beneficios de Scala">
    - **`if` siempre es una expresi√≥n**, lo que simplifica la l√≥gica al permitir un estilo m√°s funcional y menos imperativo.
    - **`match` ofrece patrones avanzados** como la coincidencia estructural, destructuraci√≥n y guardas, lo que permite un control de flujo m√°s potente y expresivo.
    - **Uni√≥n de tipos** (`Int | String`) que mejora la flexibilidad al evaluar condiciones con valores de tipos distintos.
    - El **pattern matching estructural** permite trabajar f√°cilmente con estructuras de datos complejas como listas, tuplas y case classes.
    - Uso de **guardas en patrones** (`case ... if`) para evaluar condiciones adicionales, haciendo el c√≥digo m√°s conciso y legible.
  </Pros>
  
  <Cons title="Limitaciones de Scala">
    - **La rama `else` es opcional en expresiones `if`**, lo que puede causar errores inadvertidos al retornar valores inesperados (`Unit`).
    - **No fuerza exhaustividad en todos los casos** del patr√≥n `match`, lo que puede llevar a errores en tiempo de ejecuci√≥n (`MatchError`) si no se usa correctamente.
    - **El patr√≥n comod√≠n (`_`) es opcional**, por lo que queda en manos del desarrollador asegurar que todos los casos est√©n cubiertos, aumentando el riesgo de errores inadvertidos.
    - Aunque flexible, el uso avanzado del pattern matching puede generar c√≥digo dif√≠cil de leer si se abusa de patrones complejos o guardas demasiado intrincadas.
  </Cons>
</ProCons>

## üéØ Conclusiones

Scala promueve un estilo funcional y expresivo donde incluso las construcciones de control tradicionales como `if` y `match` son expresiones que retornan valores. Esto permite componer l√≥gica de forma m√°s declarativa y concisa, pero tambi√©n implica nuevas responsabilidades: el compilador permite m√°s, pero espera que quien escribe el c√≥digo sea m√°s expl√≠cito y cuidadoso.

El sistema de patrones de Scala ‚Äîjunto con sus guardas y coincidencia estructural‚Äî abre la puerta a un estilo poderoso y seguro de programaci√≥n, especialmente √∫til al dise√±ar bibliotecas con estructuras de datos complejas. No obstante, este poder requiere atenci√≥n: omitir un caso en `match` o no usar un `else` puede derivar en errores sutiles.

### üîë Puntos clave

- `if` **siempre es una expresi√≥n** y puede devolver un valor, pero omitir `else` cuando se espera un valor **puede llevar a resultados inesperados**.
- Scala **no tiene `when`**, pero `match` lo supera ampliamente en flexibilidad y expresividad.
- Se pueden usar **tipos alternativos**, destructuraci√≥n y **pattern guards** para expresar condiciones de forma elegante.
- El compilador **solo fuerza exhaustividad con tipos sellados o enumeraciones**, por lo que es buena pr√°ctica incluir un comod√≠n (`_`) para evitar errores en tiempo de ejecuci√≥n.

### üß∞ ¬øQu√© nos llevamos?

Aprendimos que en Scala el control de flujo no es una excepci√≥n al dise√±o expresivo y funcional del lenguaje: tanto `if` como `match` pueden usarse para devolver valores, construir l√≥gica compleja sin efectos secundarios y modelar decisiones con precisi√≥n.

Adem√°s, vimos c√≥mo `match` no se limita a simples comparaciones, sino que permite construir patrones ricos, validar condiciones con guardas y desestructurar estructuras complejas. Estas capacidades son fundamentales para escribir c√≥digo expresivo, seguro y reutilizable en bibliotecas funcionales.

Esta base ser√° esencial para lo que viene: modelar datos con tipos algebraicos y aprovechar a√∫n m√°s el poder de los patrones.
