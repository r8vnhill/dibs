---
title: Punto de entrada
---
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />

Antes de comenzar a construir bibliotecas reutilizables, es importante comprender **c√≥mo se ejecuta un programa en Kotlin**. Aunque este curso se enfoca en el dise√±o de componentes modulares y reutilizables, conocer el punto de entrada del programa ‚Äîla funci√≥n `main`‚Äî resulta clave para realizar pruebas r√°pidas, crear ejemplos ilustrativos y desarrollar utilidades auxiliares.

En esta lecci√≥n, aprenderemos c√≥mo definir y ejecutar un programa Kotlin desde la l√≠nea de comandos. Exploraremos c√≥mo imprimir mensajes en la consola, recibir argumentos desde la terminal y utilizar Gradle para compilar y ejecutar nuestros programas.

Estos conocimientos nos permitir√°n establecer una base s√≥lida para experimentar con el lenguaje y documentar nuestras bibliotecas de forma **interactiva y reproducible**.

## üö™ Funci√≥n `main`

La funci√≥n `main` es el **punto de entrada** de cualquier programa ejecutable en Kotlin. A continuaci√≥n, se muestra un ejemplo simple inspirado en una galaxia muy, muy lejana:

```kotlin showLineNumbers title="Funci√≥n main con mensaje multil√≠nea (app/src/main/kotlin/com/github/username/app.kt)"
package com.github.username

fun main() {
    val message = """
        Hello there.
        General Kenobi!
        You are a bold one.
    """.trimIndent()

    println(message)
}
```

<Explanation>
    Este programa imprime un mensaje multil√≠nea en la consola utilizando `println`.

    - **`message`** se define como un bloque de texto usando triple comillas (`"""`), lo que permite conservar saltos de l√≠nea.
    - El m√©todo `trimIndent()` elimina la indentaci√≥n com√∫n al inicio de cada l√≠nea, dejando el texto m√°s limpio.
    - Finalmente, `println(message)` imprime el contenido en la consola, seguido de un salto de l√≠nea autom√°tico.

    Esta t√©cnica resulta √∫til para representar texto de forma clara y legible, especialmente en ejemplos, banners o mensajes con formato.
</Explanation>

Aunque el enfoque de este curso est√° en el **dise√±o de bibliotecas reutilizables**, comprender el rol de la funci√≥n `main` es fundamental. Nos permitir√° construir ejemplos ilustrativos, ejecutar experimentos r√°pidos y validar comportamientos antes de formalizar una API.

M√°s adelante, adoptaremos las **pruebas automatizadas** como principal herramienta de verificaci√≥n, lo que reducir√° el uso cotidiano de `main`. Sin embargo, seguir√° siendo un recurso valioso para exploraci√≥n interactiva y documentaci√≥n ejecutable.

<details>
  <summary>`println` como expresi√≥n</summary>

  En Kotlin, `println` es una funci√≥n que devuelve un valor de tipo `Unit`, por lo que puede usarse como **una expresi√≥n**, no solo como una instrucci√≥n.

  Gracias a esto, podemos definir la funci√≥n `main` de forma m√°s concisa utilizando la sintaxis de **expresi√≥n √∫nica**:

  ```kotlin showLineNumbers title="Versi√≥n concisa de main como expresi√≥n"
  fun main() = println("Hello, World!")
  ```

  Aunque esta forma es perfectamente v√°lida, **no suele ser la m√°s com√∫n** para declarar `main`, ya que generalmente se prefiere la versi√≥n con bloques `{ ... }` por claridad y flexibilidad.

  Aun as√≠, es √∫til conocer esta alternativa, especialmente para **programas simples, scripts o ejemplos r√°pidos** donde la brevedad es una ventaja.
</details>

:::note `println` y `print`

El nombre `println` proviene de *"print line"*, y su comportamiento refleja exactamente eso: **imprime el texto seguido de un salto de l√≠nea**.  
En cambio, la funci√≥n `print` **imprime el texto tal como est√°**, sin agregar un salto de l√≠nea al final.

Esto las hace √∫tiles en distintos contextos, seg√∫n si deseas continuar la salida en la **misma l√≠nea** o iniciar una **nueva**.

```kotlin showLineNumbers title="Diferencias entre print y println"
for (i in 1..5) {
    print(i)     // Imprime: 12345 (todo en la misma l√≠nea)
}
println()        // Salto de l√≠nea manual
for (i in 1..5) {
    println(i)   // Imprime: 1\n2\n3\n4\n5 (cada n√∫mero en una l√≠nea distinta)
}
```

En resumen, `println("Texto")` es equivalente a `print("Texto\n")`.

:::

## ‚ñ∂Ô∏è Ejecutando el programa

Para ejecutar la aplicaci√≥n desde la terminal usando Gradle, utiliza el siguiente comando:

```bash title="En tu terminal"
./gradlew :app:run
```

Este comando compila el proyecto (si es necesario) y ejecuta la funci√≥n `main` definida en el m√≥dulo `app`.

```plaintext title="Salida esperada"
> Task :app:run
Hello there.
General Kenobi!
You are a bold one.
```

Este enfoque es ideal para **probar tu c√≥digo r√°pidamente**, sin necesidad de generar un archivo `.jar` ni configurar un entorno adicional.

Lo utilizaremos con frecuencia para ejecutar ejemplos y verificar el comportamiento de nuestras bibliotecas a medida que las desarrollamos.

<details>

<summary>¬øY si tengo m√°s de una funci√≥n `main` en el proyecto?</summary>

Veremos este tema en detalle m√°s adelante, pero si necesitas cambiar la funci√≥n `main` que se ejecuta, puedes modificar la siguiente l√≠nea dentro del bloque `application` de tu archivo `build.gradle.kts`:

```kotlin showLineNumbers title="build.gradle.kts"
application {
    // highlight-next-line
    mainClass = "com.github.username.AppKt"
}
```

Sustituye `"com.github.username.AppKt"` por la ruta completa del archivo `.kt` que contiene la nueva funci√≥n `main`, utilizando el formato que genera Kotlin al compilar:  
- Usa el nombre del paquete (por ejemplo, `some.package`)  
- A√±ade el nombre del archivo con la primera letra en may√∫scula  
- Agrega el sufijo `Kt`, que Kotlin genera autom√°ticamente para los archivos fuente

Por ejemplo, si tienes un archivo llamado `otherMain.kt` en `app/src/main/kotlin/some/package/`, deber√≠as escribir:

```kotlin
mainClass = "some.package.OtherMainKt"
```

</details>

## üß≥ Funci√≥n `main` con argumentos de l√≠nea de comandos

La funci√≥n `main` tambi√©n puede recibir **argumentos externos** al momento de ejecutar el programa, lo que permite modificar su comportamiento seg√∫n los valores proporcionados desde la terminal.

Aqu√≠ tienes un ejemplo b√°sico:

```kotlin showLineNumbers title="Funci√≥n main con argumentos (app/src/main/kotlin/com/github/username/app.kt)"
fun main(args: Array<String>) {
    println("Welcome to Fabletown, ${args.joinToString(" ")}!")
}
```

<Explanation>
    Este programa recibe argumentos desde la l√≠nea de comandos y los usa para personalizar un mensaje de bienvenida.

    - **`args: Array<String>`** es el par√°metro que Kotlin pasa autom√°ticamente a la funci√≥n `main`. Contiene todos los valores ingresados despu√©s del nombre del ejecutable.
    - **`joinToString(" ")`** une los elementos del arreglo usando espacios. As√≠ puedes aceptar nombres compuestos u otros argumentos sin preocuparte por la cantidad.
    - La llamada a **`println(...)`** imprime el resultado interpolado directamente en la consola.

    Esta estrategia es m√°s segura y flexible que acceder directamente a `args[0]`, ya que evita errores cuando el usuario no proporciona argumentos o si estos contienen espacios.
</Explanation>

### üöÄ ¬øC√≥mo ejecutar este programa?

Desde la ra√≠z del proyecto, puedes pasar argumentos a la funci√≥n `main` utilizando el plugin `application` de Gradle. Usa la opci√≥n `--args`, seguida de los argumentos entre comillas:

```bash title="En tu terminal"
./gradlew :app:run --args="Snow White"
```

```plaintext title="üì¶ Salida esperada"
> Task :app:run
Welcome to Fabletown, Snow White!
```

<Explanation>
    La opci√≥n `--args="..."` permite enviar argumentos desde la terminal a la funci√≥n `main(args: Array<String>)`.

    - Los argumentos se separan por espacios dentro de las comillas.
    - Gradle se encarga de pasar el texto como un arreglo de cadenas a tu programa.
    - Es √∫til para realizar pruebas con distintos datos sin modificar el c√≥digo fuente.
</Explanation>

<details>

<summary>

¬°¬øEso es todo?!

</summary>

‚Äî¬°Ja! Apenas estoy calentando... ‚Äîjunta las manos y sonr√≠e‚Äî  
**¬°Compatibilidad con Java... activada!**[^1]

Aunque en Kotlin podemos declarar una funci√≥n `main` sin clases, eso **no basta** si queremos:

- Ejecutar el programa desde herramientas que esperan una clase con `public static void main(String[] args)` (como `java -cp` o scripts `.bat/.sh`).
- Empaquetar un `.jar` ejecutable con Gradle y correrlo con `java -jar`.
- Usar la app desde entornos que solo reconocen clases Java tradicionales (como algunas tareas de Maven o lanzadores de sistema operativo).
- Integrar con herramientas como UIs o sistemas de CI que detectan entradas est√°ticas (por ejemplo, "Run Configurations" en IntelliJ para proyectos mixtos).

:::info
Para cubrir estos casos, necesitamos una **funci√≥n est√°tica real de Java**, algo que Kotlin **no genera autom√°ticamente**... a menos que se lo pidamos expl√≠citamente.
:::

Para eso existe `@JvmStatic`:

```kotlin showLineNumbers title="Funci√≥n main con @JvmStatic"
object Launcher {
    @JvmStatic
    fun main(args: Array<String>) {
        println("Modo Java activado.")
    }
}
```

Esta anotaci√≥n le indica al compilador que genere una funci√≥n `static` verdadera dentro de la clase `Launcher`, **compatible con cualquier herramienta que busque el cl√°sico `public static void main`**.

:::tip ¬øCu√°ndo es √∫til?

- Si quieres distribuir tu herramienta como un `.jar` ejecutable.
- Si necesitas que sea invocable desde Java o desde un script de shell.
- Si trabajas en bibliotecas multiplataforma, herramientas CLI, plugins de build o lanzadores de sistema.

:::

</details>

## üéØ Conclusiones

En esta lecci√≥n exploramos el **punto de entrada de los programas en Kotlin**: la funci√≥n `main`. Aprendimos c√≥mo utilizarla para ejecutar peque√±os programas, y c√≥mo recibir **argumentos desde la l√≠nea de comandos** para adaptar din√°micamente el comportamiento del programa.

Tambi√©n repasamos funciones b√°sicas como `print` y `println`, imprimimos mensajes con formato e indentaci√≥n, y aprendimos a ejecutar la aplicaci√≥n con Gradle, tanto con como sin argumentos.

### üîë Puntos clave

- La funci√≥n `main` marca el inicio de cualquier programa ejecutable en Kotlin.
- `println` imprime con salto de l√≠nea; `print`, sin √©l.
- Es posible definir `main` como una **expresi√≥n √∫nica** si solo contiene una l√≠nea.
- `main` puede recibir argumentos (`args: Array<String>`) desde la terminal.
- Usar `joinToString(" ")` sobre `args` permite capturar m√∫ltiples palabras de forma segura.
- Podemos ejecutar la aplicaci√≥n y pasarle argumentos con:  
  `./gradlew :app:run --args="..."`

### üß∞ ¬øQu√© nos llevamos?

Aunque el foco del curso est√° en el desarrollo de bibliotecas, comprender c√≥mo funcionan los **programas ejecutables** nos permite construir ejemplos ilustrativos, scripts de prueba y herramientas auxiliares para el desarrollo.

Esta lecci√≥n nos dio un primer contacto con elementos esenciales del lenguaje y con Gradle como sistema de construcci√≥n.  
A medida que avancemos, la funci√≥n `main` ser√° menos frecuente, pero seguir√° siendo una herramienta valiosa para crear **experimentos interactivos, scripts internos y documentaci√≥n ejecutable**.

<div className="language-card-container">

<LanguageCards.CppCard link="/docs/type-fundamentals/basics/main/cpp"/>
<LanguageCards.HaskellCard link="/docs/type-fundamentals/basics/main/hs"/>
<LanguageCards.PythonCard link="/docs/type-fundamentals/basics/main/py"/>
<LanguageCards.SwiftCard link="/docs/type-fundamentals/basics/main/swift"/>

</div>

<ExcludeFromReadingTime >

## üìñ Referencias

### üî• Recomendadas

- [üåê "Hello world"](https://kotlinlang.org/docs/kotlin-tour-hello-world.html) de **la documentaci√≥n oficial de Kotlin**: Introduce la funci√≥n `main` y el uso de `println` en Kotlin, conceptos clave para comprender el punto de entrada de un programa ejecutable.
- [üé• "How to Run Kotlin Code Anywhere with Kotlin Main Functions"](https://youtu.be/aZgyvmjm4gA) (53s) de **Donn Felker**: Demuestra c√≥mo las funciones `main` pueden colocarse en cualquier archivo para pruebas r√°pidas en IntelliJ, reforzando su utilidad como herramienta exploratoria durante el desarrollo de bibliotecas.

### üîπ Adicionales

- [üåê "Your first program in Kotlin"](https://developer.android.com/codelabs/basic-android-kotlin-compose-first-program) en **la documentaci√≥n oficial de Android**: Introducci√≥n pr√°ctica al punto de entrada en Kotlin desde la documentaci√≥n oficial de Android. Este recurso gu√≠a al lector en la escritura de su primer programa, mostrando c√≥mo definir funciones con `fun`, usar `println` para imprimir texto en consola, y comenzar a resolver errores comunes. Es relevante para esta lecci√≥n porque refuerza la estructura b√°sica de un programa ejecutable en Kotlin y promueve buenas pr√°cticas como el estilo de nombres y la depuraci√≥n inicial.
- [üåê "Basic syntax"](https://kotlinlang.org/docs/basic-syntax.html) de **la documentaci√≥n oficial de Kotlin**: Revisi√≥n amplia de la sintaxis b√°sica de Kotlin ‚Äîincluyendo `main`, impresi√≥n y argumentos‚Äî √∫til como referencia general complementaria a esta lecci√≥n y como base para explorar el lenguaje m√°s all√° del punto de entrada.
- üìö "Hello, World!" (pp. 26‚Äì28) en *"Atomic Kotlin"* de **Bruce Eckel y Svetlana Isakova**: Explicaci√≥n gradual del punto de entrada en Kotlin desde un enfoque did√°ctico, √∫til como complemento narrativo y pedag√≥gico a esta lecci√≥n para quienes est√°n comenzando.

</ExcludeFromReadingTime>

[^1]: Perd√≥n.
