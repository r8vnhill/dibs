---
title: Punto de entrada
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />

Antes de construir bibliotecas reutilizables, necesitamos comprender c√≥mo se ejecuta un programa en Kotlin. Aunque este curso se enfoca en el dise√±o de componentes modulares y reutilizables, entender el funcionamiento del punto de entrada ‚Äîla funci√≥n `main`‚Äî es fundamental para realizar pruebas r√°pidas, crear ejemplos ilustrativos y escribir utilidades auxiliares.

En esta lecci√≥n, exploraremos c√≥mo se define y ejecuta un programa Kotlin desde la l√≠nea de comandos. Veremos c√≥mo imprimir mensajes en la consola, recibir argumentos desde la terminal y utilizar Gradle para compilar y ejecutar nuestros programas.
Todo esto nos permitir√° establecer una base s√≥lida para experimentar con el lenguaje y documentar nuestras bibliotecas de forma interactiva y reproducible.

## üö™ Funci√≥n `main`

La funci√≥n `main` es el **punto de entrada** de cualquier programa ejecutable en Kotlin. A continuaci√≥n, presentamos un ejemplo simple inspirado en una galaxia muy, muy lejana:

```kotlin showLineNumbers title="Funci√≥n main con mensaje multil√≠nea (app/src/main/kotlin/com/github/username/app.kt)"
package com.github.username

fun main() {
    val message = """
        Hello there.
        General Kenobi!
        You are a bold one.
    """.trimIndent()

    println(message)
}
```

<Explanation>
    Este programa imprime un mensaje multil√≠nea en la consola utilizando `println`.  
    - **`message`** se define como un bloque de texto con triple comillas (`"""`), lo que permite conservar saltos de l√≠nea.  
    - El m√©todo `trimIndent()` elimina la indentaci√≥n com√∫n al inicio de cada l√≠nea, haciendo el texto m√°s limpio.  
    - Finalmente, `println(message)` imprime el mensaje completo seguido de un salto de l√≠nea.  

    Esta es una forma clara y expresiva de trabajar con texto multil√≠nea en Kotlin, ideal para ejemplos, banners o di√°logos √©picos.
</Explanation>

Aunque el enfoque de este curso est√° en el **desarrollo de bibliotecas de software**, es importante comprender el rol de la funci√≥n `main`, ya que nos ser√° √∫til para construir ejemplos ilustrativos y ejecutar peque√±os experimentos.
A medida que avancemos y adoptemos **pruebas automatizadas** como principal estrategia de verificaci√≥n, su uso ser√° menos frecuente, pero seguir√° siendo una herramienta valiosa para exploraci√≥n r√°pida y documentaci√≥n interactiva.

<details>
    <summary>`println` como expresi√≥n</summary>

    En Kotlin, `println` es una funci√≥n que devuelve un valor de tipo `Unit`, lo que significa que puede usarse como **una expresi√≥n**, no solo como una instrucci√≥n.

    Gracias a esto, podemos escribir la funci√≥n `main` de forma m√°s concisa utilizando la sintaxis de expresi√≥n √∫nica:

    ```kotlin showLineNumbers title="Versi√≥n concisa de main como expresi√≥n"
    fun main() = println("Hello, World!")
    ```

    Aunque esta forma es perfectamente v√°lida, **no suele ser la m√°s com√∫n** para definir `main`, ya que generalmente se prefiere la versi√≥n con bloques `{ ... }` por claridad y extensibilidad.
    Aun as√≠, es √∫til conocer esta alternativa, especialmente para **programas simples, scripts o ejemplos r√°pidos**.
</details>

:::note `println` y `print`

El nombre `println` proviene de *"print line"*, y su comportamiento refleja justamente eso: **imprime el texto seguido de un salto de l√≠nea**. En cambio, la funci√≥n `print` **imprime el texto tal como est√°**, sin agregar un salto de l√≠nea al final.
Esto las hace √∫tiles en distintos contextos, dependiendo de si deseas continuar la salida en la **misma l√≠nea** o iniciar una **nueva**.

```kotlin showLineNumbers title="Diferencias entre print y println"
for (i in 1..5) {
    print(i)     // Imprime: 12345 (todo en la misma l√≠nea)
}
println()        // Salto de l√≠nea manual
for (i in 1..5) {
    println(i)   // Imprime: 1\n2\n3\n4\n5 (cada n√∫mero en una l√≠nea distinta)
}
```

En resumen, `println("Texto")` es equivalente a `print("Texto\n")`.

:::

## ‚ñ∂Ô∏è Ejecutando el programa

Para ejecutar la aplicaci√≥n desde la terminal usando Gradle, utiliza el siguiente comando:

```bash title="En tu terminal"
./gradlew :app:run
```

Esto compilar√° el proyecto (si es necesario) y ejecutar√° la funci√≥n `main` definida en el m√≥dulo `app`.

```plaintext title="Salida esperada"
> Task :app:run
Hello there.
General Kenobi!
You are a bold one.
```

Este comando es √∫til para **probar r√°pidamente tu c√≥digo** sin tener que generar un archivo `.jar` ni configurar un entorno adicional.
Lo usaremos con frecuencia para ejecutar ejemplos y comprobar el comportamiento de nuestras bibliotecas a medida que las construimos.

<details>
    <summary>¬øY si tengo m√°s de un `main` en el proyecto?</summary>

    Veremos este tema en detalle m√°s adelante, pero si necesitas cambiar la funci√≥n `main` que se ejecuta, puedes modificar la siguiente l√≠nea en el bloque `application` de tu archivo `build.gradle.kts`:

    ```kotlin showLineNumbers title="build.gradle.kts"
    application {
        // highlight-next-line
        mainClass = "com.github.username.AppKt"
    }
    ```

    Sustituye `"com.github.username.AppKt"` por la ruta completa del archivo `.kt` que contiene el nuevo `main`, ajustado al formato que usa Kotlin al compilar:  
    - Usa el nombre del paquete (como `some.package`)  
    - A√±ade el nombre del archivo con la primera letra en may√∫scula  
    - Agrega el sufijo `Kt` que Kotlin genera autom√°ticamente para los archivos fuente

    Por ejemplo, si tienes un archivo llamado `otherMain.kt` en `app/src/main/kotlin/some/package/`, 
    deber√≠as usar:

    ```kotlin
    mainClass = "some.package.OtherMainKt"
    ```
</details>

## üß≥ Funci√≥n `main` con argumentos de l√≠nea de comandos

La funci√≥n `main` tambi√©n puede recibir **argumentos externos** al momento de ejecutar el programa, lo que permite modificar su comportamiento seg√∫n los valores proporcionados desde la terminal.

Aqu√≠ tienes un ejemplo b√°sico:

```kotlin showLineNumbers title="Funci√≥n main con argumentos (app/src/main/kotlin/com/github/username/app.kt)"
fun main(args: Array<String>) {
    println("Welcome to Fabletown, ${args.joinToString(" ")}!")
}
```

<Explanation>
    Este programa recibe argumentos desde la l√≠nea de comandos y los usa para personalizar un mensaje de bienvenida.

    - **`args: Array<String>`** es el par√°metro que Kotlin proporciona autom√°ticamente a la funci√≥n `main`. Contiene todos los valores ingresados tras el nombre del ejecutable.
    - **`joinToString(" ")`** une todos los elementos del arreglo con espacios. As√≠, puedes pasar nombres compuestos u otros argumentos sin preocuparte por la cantidad.
    - La llamada a **`println(...)`** imprime el resultado interpolado directamente en la consola.

    Esta estrategia es m√°s segura y flexible que acceder directamente a `args[0]`, ya que evita errores si el usuario no proporciona argumentos o si estos contienen espacios.
</Explanation>

### üöÄ ¬øC√≥mo ejecutar este programa?

Desde la ra√≠z del proyecto, puedes pasar argumentos a la funci√≥n `main` utilizando el plugin `application` de Gradle. Usa la opci√≥n `--args` seguida de los argumentos entre comillas:

```bash title="En tu terminal"
./gradlew :app:run --args="Snow White"
```

```plaintext title="üì¶ Salida esperada"
> Task :app:run
Welcome to Fabletown, Snow White!
```

<Explanation>
    `--args="..."` permite enviar argumentos a la funci√≥n `main`.
</Explanation>

<details>
    <summary>
        ¬°¬øEso es todo?!
    </summary>

    ‚Äî¬°Ja! Apenas estoy calentando... ‚Äîjunta las manos y sonr√≠e‚Äî.  
    **¬°Compatibilidad con Java... activada!**

    Aunque en Kotlin podemos declarar una funci√≥n `main` sin clases, eso **no basta** si queremos:

    - Ejecutar el programa desde una herramienta que espera una clase con `public static void main(String[] args)` (como `java -cp` o scripts `.bat/.sh`).
    - Empaquetar un `.jar` ejecutable desde Gradle y correrlo con `java -jar`.
    - Usar la app desde lenguajes o entornos que solo entienden clases Java cl√°sicas (como algunas tareas de Maven o lanzadores en sistemas operativos).
    - Integrar con herramientas de l√≠nea de comandos, sistemas de integraci√≥n continua, o UIs que detectan entradas est√°ticas (como IntelliJ al crear "Run Configurations" en proyectos mixtos).

    :::info

    Para cubrir estos casos, necesitamos una clase con una funci√≥n est√°tica, algo que Kotlin **no genera autom√°ticamente**... a menos que se lo pidamos.

    :::

    Por eso existe `@JvmStatic`:

    ```kotlin showLineNumbers title="Funci√≥n main con @JvmStatic"
    object Launcher {
        @JvmStatic
        fun main(args: Array<String>) {
            println("Modo Java activado.")
        }
    }
    ```

    Esta anotaci√≥n le dice al compilador que **genere una funci√≥n `static` real de Java** dentro de la clase `Launcher`, compatible con cualquier herramienta que busque el cl√°sico `public static void main`.

    :::tip Es especialmente √∫til en proyectos donde:
    
    - Quieres distribuir tu herramienta como un `.jar` ejecutable.
    - Quieres que se pueda invocar desde Java o desde un script de shell.
    - Est√°s trabajando en bibliotecas multiplataforma, herramientas CLI, plugins de build, o lanzadores.

    :::
</details>

## üéØ Conclusiones

En esta lecci√≥n exploramos el **punto de entrada de los programas en Kotlin**: la funci√≥n `main`. Aprendimos c√≥mo utilizarla para ejecutar peque√±os programas y c√≥mo recibir **argumentos desde la l√≠nea de comandos** para adaptar el comportamiento del programa din√°micamente.

Tambi√©n repasamos funciones b√°sicas como `print` y `println`, imprimimos mensajes con formato e indentaci√≥n, y vimos c√≥mo ejecutar nuestra aplicaci√≥n con Gradle, tanto con como sin argumentos.

### üîë Puntos clave

- La funci√≥n `main` marca el inicio de cualquier programa ejecutable en Kotlin.
- `println` imprime con salto de l√≠nea; `print`, sin √©l.
- Es posible definir `main` como una **expresi√≥n √∫nica** si contiene solo una l√≠nea.
- `main` puede recibir argumentos (`args: Array<String>`) desde la terminal.
- Usar `joinToString(" ")` sobre `args` permite capturar m√∫ltiples palabras sin errores.
- Podemos ejecutar la aplicaci√≥n y pasarle argumentos con:  
  `./gradlew :app:run --args="..."`.

### üß∞ ¬øQu√© nos llevamos?

Aunque el foco del curso est√° en el desarrollo de bibliotecas, entender c√≥mo funcionan los **programas ejecutables** nos permite crear ejemplos ilustrativos, scripts de prueba y herramientas de apoyo durante el desarrollo.

Esta lecci√≥n nos dio un primer contacto con elementos esenciales del lenguaje y con Gradle como sistema de construcci√≥n.  
A medida que avancemos, la funci√≥n `main` ser√° menos frecuente, pero seguir√° siendo √∫til para crear **experimentos interactivos, scripts internos y documentaci√≥n ejecutable**.

<div className="language-card-container">
    <LanguageCards.PythonCard link="/docs/type-fundamentals/basics/main/py"/>
</div>

## üìñ Referencias

### üî• Recomendadas

- [üåê "Hello world"](https://kotlinlang.org/docs/kotlin-tour-hello-world.html) de **la documentaci√≥n oficial de Kotlin**: Introduce la funci√≥n `main` y el uso de `println` en Kotlin, conceptos clave para comprender el punto de entrada de un programa ejecutable.
- [‚èØÔ∏è "How to Run Kotlin Code Anywhere with Kotlin Main Functions"](https://youtu.be/aZgyvmjm4gA) (53s) de **Donn Felker**: Demuestra c√≥mo las funciones `main` pueden colocarse en cualquier archivo para pruebas r√°pidas en IntelliJ, reforzando su utilidad como herramienta exploratoria durante el desarrollo de bibliotecas.

### üîπ Adicionales

- [üåê  "Your first program in Kotlin"](https://developer.android.com/codelabs/basic-android-kotlin-compose-first-program) en **la documentaci√≥n oficial de Android**: Introducci√≥n pr√°ctica al punto de entrada en Kotlin desde la documentaci√≥n oficial de Android. Este recurso gu√≠a al lector en la escritura de su primer programa, mostrando c√≥mo definir funciones con `fun`, usar `println` para imprimir texto en consola, y comenzar a resolver errores comunes. Es relevante para esta lecci√≥n porque refuerza la estructura b√°sica de un programa ejecutable en Kotlin y promueve buenas pr√°cticas como el estilo de nombres y la depuraci√≥n inicial.
- [üåê "Basic syntax"](https://kotlinlang.org/docs/basic-syntax.html) de **la documentaci√≥n oficial de Kotlin**: Revisi√≥n amplia de la sintaxis b√°sica de Kotlin ‚Äîincluyendo `main`, impresi√≥n y argumentos‚Äî √∫til como referencia general complementaria a esta lecci√≥n y como base para explorar el lenguaje m√°s all√° del punto de entrada.
- üìö "Hello, World!" (pp. 26‚Äì28) en *"Atomic Kotlin"* de **Bruce Eckel y Svetlana Isakova**: Explicaci√≥n gradual del punto de entrada en Kotlin desde un enfoque did√°ctico, √∫til como complemento narrativo y pedag√≥gico a esta lecci√≥n para quienes est√°n comenzando.