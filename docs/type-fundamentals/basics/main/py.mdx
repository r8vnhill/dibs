---
title: "Punto de entrada en Python"
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import ReadingTime from '@site/src/components/ReadingTime'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'

<ReadingTime />
<GitHubRepoLink repo="python-dibs" user="r8vnhill"/>

En cualquier lenguaje de programaci√≥n, definir c√≥mo empieza un programa es clave para poder probar componentes, escribir scripts auxiliares o incluir ejemplos ejecutables. En Kotlin, ya aprendimos que esto se logra a trav√©s de la funci√≥n `main`, claramente marcada como el punto de entrada del sistema.

Python, en cambio, ofrece un enfoque m√°s flexible: **no exige una funci√≥n principal ni un archivo designado como punto de entrada**, lo que permite una experiencia m√°s √°gil en scripts peque√±os o tareas interactivas. Sin embargo, esta flexibilidad puede volverse confusa si no seguimos ciertas convenciones.

En esta lecci√≥n veremos c√≥mo se ejecutan los programas en Python, qu√© significa el patr√≥n `if __name__ == "__main__"` y por qu√© conviene usarlo, especialmente cuando estamos desarrollando m√≥dulos reutilizables. Tambi√©n compararemos esta estrategia con la de Kotlin para entender mejor c√≥mo ambos lenguajes balancean claridad, control y flexibilidad en la estructura de sus programas.

## üß≠ Punto de entrada en Python

A diferencia de Kotlin, donde la funci√≥n `main` cumple un rol expl√≠cito como punto de partida del programa, **Python no requiere definir `main()` para comenzar la ejecuci√≥n**. Cualquier c√≥digo escrito en el **nivel superior** de un archivo ser√° ejecutado autom√°ticamente al correr ese archivo con `python archivo.py`.

Sin embargo, para mantener el orden y favorecer la reutilizaci√≥n, la comunidad de Python suele recomendar el siguiente patr√≥n idiom√°tico:

```python showLineNumbers title="Patr√≥n recomendado en Python"
# Referencia a Kimi no Na wa.
def main() -> None:
    print("Treasure the experience. Dreams fade away after you wake up.")


if __name__ == '__main__':
    main()
```

Este patr√≥n permite distinguir claramente entre **c√≥digo que debe ejecutarse al correr el script directamente** y c√≥digo que se puede **importar desde otros m√≥dulos sin efectos colaterales**.

### üìå ¬øPor qu√© `if __name__ == '__main__'`?

Python define una variable especial llamada `__name__` para cada archivo que ejecuta:

- Si el archivo se ejecuta directamente (por ejemplo: `python archivo.py`), entonces `__name__ == '__main__'`.
- Si el archivo se **importa desde otro m√≥dulo**, entonces `__name__` toma el nombre del archivo como m√≥dulo (por ejemplo: `'utils'`, `'main'`, etc.).

Este patr√≥n es fundamental para:

- **Separar responsabilidades** entre l√≥gica ejecutable y funciones reutilizables.
- **Evitar efectos colaterales inesperados** al importar un archivo que contiene llamadas a funciones, impresiones o acceso a archivos.
- **Simular un punto de entrada claro**, especialmente √∫til en proyectos grandes o cuando se integran herramientas externas.

### üß® ¬øQu√© pasa si no lo usamos?

Supongamos que tienes un archivo `engine.py` con este c√≥digo:

```python title="engine.py"
print("‚öôÔ∏è Starting engine...")

def run():
    print("üöÄ Engine is running.")
```

Y ahora tienes otro archivo `main.py` que lo importa:

```python title="main.py"
from engine import run

print("üîß Preparing to launch...")
run()
```

Cuando ejecutas `main.py`, la salida ser√°:

```plaintext
‚öôÔ∏è Starting engine...
üîß Preparing to launch...
üöÄ Engine is running.
```

¬°Sorpresa! Se ejecut√≥ el `print` de `engine.py` **inmediatamente al hacer la importaci√≥n**, **antes** de que `run()` fuese llamado.

Esto ocurre porque el c√≥digo de nivel superior en `engine.py` **se ejecuta tan pronto como se importa**, a menos que lo encapsules dentro de un bloque protegido con:

```python
if __name__ == '__main__':
    print("‚öôÔ∏è Starting engine...")
```

De esta forma, `engine.py` **solo imprime el mensaje cuando es ejecutado directamente**, y **no cuando se importa como m√≥dulo**.

:::tip En resumen

Usar `if __name__ == '__main__'` es una buena pr√°ctica que:

- Protege tu c√≥digo de ejecuciones accidentales al importarlo.
- Hace que tus m√≥dulos sean **m√°s predecibles y reutilizables**.
- Permite incluir pruebas, ejemplos o scripts dentro del mismo archivo sin interferir con el resto del sistema.

:::

## ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros title="Ventajas de Python">
        - **Simplicidad en la ejecuci√≥n**: Cualquier archivo `.py` puede ser ejecutado directamente sin necesidad de declarar una funci√≥n `main`.
        - **Flexibilidad para scripts y prototipos**: Ideal para escribir peque√±os programas, pruebas r√°pidas o scripts exploratorios sin mucha estructura.
        - **Patr√≥n idiom√°tico claro (`if __name__ == '__main__'`)**: Permite separar la l√≥gica de ejecuci√≥n del resto del c√≥digo reutilizable.
        - **Multiplataforma y sin necesidad de compilaci√≥n**: Se puede ejecutar en distintos entornos sin pasos de construcci√≥n intermedios.
    </Pros>
    <Cons title="Limitaciones de Python">
        - **Ejecuci√≥n impl√≠cita puede ser confusa**: Todo el c√≥digo al nivel superior se ejecuta al importar el archivo si no est√° protegido por `if __name__ == '__main__'`.
        - **No hay un punto de entrada √∫nico y obligatorio**: En proyectos grandes, puede ser dif√≠cil ubicar qu√© archivo es el principal si no se documenta claramente.
        - **Falta de control sobre el entorno de ejecuci√≥n**: No hay una forma est√°ndar de declarar el nombre de la clase principal como en Kotlin o Java (`mainClassName`).
    </Cons>
</ProCons>

## üéØ Conclusiones

A lo largo de esta lecci√≥n, exploramos c√≥mo Python gestiona el punto de entrada de sus programas y c√≥mo se compara con el enfoque m√°s expl√≠cito de Kotlin. Si bien ambos lenguajes permiten definir una funci√≥n `main`, en Python esta no es obligatoria ni especial, lo que otorga flexibilidad, pero tambi√©n requiere disciplina para mantener el c√≥digo organizado y predecible.

Aprendimos por qu√© es importante usar el patr√≥n `if __name__ == '__main__'`, especialmente cuando desarrollamos m√≥dulos reutilizables o deseamos evitar efectos colaterales al importar archivos.

### üîë Puntos clave

- Python **no requiere una funci√≥n `main`** para ejecutar c√≥digo, pero es recomendable definir una para mayor claridad.
- El patr√≥n `if __name__ == '__main__'` permite **proteger el c√≥digo ejecutable** y evitar que se ejecute al importar el archivo.
- Es posible incluir ejemplos, pruebas o scripts dentro del mismo archivo sin interferir con su uso como m√≥dulo.
- A diferencia de Kotlin, **no hay una √∫nica clase o archivo principal por convenci√≥n**, lo cual otorga flexibilidad pero puede dificultar la navegaci√≥n en proyectos grandes.

### üìã Tabla comparativa: Kotlin vs. Python

| Caracter√≠stica                         | Kotlin                            | Python                                       |
|---------------------------------------|-----------------------------------|----------------------------------------------|
| **Punto de entrada obligatorio**       | ‚úÖ S√≠ (`fun main`)                   | ‚ùå No, pero se puede definir `main()`           |
| **Requiere clase o archivo espec√≠fico**| ‚úÖ S√≠ (`mainClass` en Gradle)        | ‚ùå No, cualquier archivo puede ser ejecutado    |
| **M√∫ltiples puntos de entrada**        | Requiere configuraci√≥n expl√≠cita  | S√≠, cualquier archivo ejecutable puede tener uno |
| **Protecci√≥n contra ejecuci√≥n al importar** | No necesaria, no se ejecuta al importar | S√≠, se necesita `if __name__ == '__main__'` |
| **Scripts r√°pidos y exploraci√≥n**      | Menos directo                     | Muy adecuado para scripts y experimentaci√≥n  |
| **Compilaci√≥n previa requerida**       | ‚úÖ S√≠                                | ‚ùå No                                           |

### üß∞ ¬øQu√© nos llevamos?

Aunque en Kotlin estamos acostumbradas a una estructura clara con una funci√≥n `main` bien definida y una clase principal configurable, en Python el punto de entrada es **m√°s libre y flexible**, pero tambi√©n **m√°s propenso a errores si no seguimos buenas pr√°cticas**.

Este contraste nos recuerda que **la claridad no siempre viene impuesta por el lenguaje**, sino que a menudo depende de nuestra disciplina como personas desarrolladoras. Adoptar el patr√≥n `if __name__ == '__main__'` es un peque√±o gesto que mejora la **reusabilidad**, **previsibilidad** y **mantenibilidad** de nuestros m√≥dulos, sin perder la agilidad que ofrece Python para escribir scripts y experimentar con ideas.

Este entendimiento ser√° fundamental a medida que avancemos hacia el dise√±o de bibliotecas en Python, especialmente si queremos combinar ejemplos ejecutables con componentes reutilizables de calidad.

## üìñ Referencias

### üî• Recomendadas

- [üåê "What Does if `__name__ == '__main__'` Do in Python?"](https://realpython.com/if-name-main-python/) en *Real Python* por **Martin Breuss**: Este art√≠culo explica a fondo el patr√≥n `if __name__ == "__main__"` en Python, mostrando c√≥mo permite ejecutar c√≥digo solo cuando un archivo es ejecutado directamente, y no al ser importado como m√≥dulo. Ilustra casos pr√°cticos, buenas y malas pr√°cticas, y alternativas m√°s idiom√°ticas en situaciones donde este patr√≥n no es necesario. Refuerza el objetivo de esta unidad al explicar por qu√© conviene encapsular la l√≥gica ejecutable, evitando efectos colaterales al importar m√≥dulos ‚Äîun punto clave para desarrollar bibliotecas reutilizables en Python.

{/* ### üîπ Adicionales */}

