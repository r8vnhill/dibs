---
title: "Punto de entrada en Haskell"
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="haskell-dibs" />

En esta lecci√≥n aprender√°s c√≥mo se define el punto de entrada en un programa Haskell. A diferencia de otros lenguajes como Kotlin, donde el sistema puede ocultar ciertos detalles, Haskell exige que declares expl√≠citamente los efectos y la estructura de tu aplicaci√≥n. 

Veremos c√≥mo funciona la funci√≥n `main`, c√≥mo se conectan los m√≥dulos con el archivo `.cabal`, y c√≥mo leer argumentos desde la l√≠nea de comandos. A trav√©s de ejemplos simples entender√°s c√≥mo estos conceptos se aplican en la pr√°ctica y qu√© beneficios ofrece el enfoque funcional de Haskell para programas peque√±os y reutilizables.

## üõ†Ô∏è ¬øC√≥mo ejecutar estos ejemplos?

Para poder ejecutar los ejemplos mostrados, es √∫til saber c√≥mo crear un proyecto b√°sico en Haskell y c√≥mo estructurarlo en m√≥dulos reutilizables. Estos recursos te guiar√°n paso a paso:

- üì¶ [Creando un Proyecto B√°sico en Haskell con Cabal](/docs/build-systems/init/cabal/)  
  Aprende a iniciar un proyecto desde cero usando Cabal.
- üß© [Estructurando un proyecto modular en Haskell con Cabal](/docs/build-systems/modular-design/cabal/)  
  Descubre c√≥mo dividir tu c√≥digo en m√≥dulos separados para mejorar la organizaci√≥n, reutilizaci√≥n y mantenibilidad.

## üèÅ Punto de entrada

En Haskell, el punto de entrada de un programa es una funci√≥n llamada `main` que debe devolver una acci√≥n dentro del tipo `IO ()`. Esta funci√≥n es buscada en el **m√≥dulo principal del ejecutable** configurado en tu archivo `.cabal`, normalmente llamado `Main`.

Un programa b√°sico en Haskell puede escribirse as√≠:

```haskell title="Programa b√°sico (type-fundamentals/basics/Main.hs)" showLineNumbers
module Main where

main :: IO ()
main = putStrLn "When dealing with aliens, try to be polite."
```

<Explanation>

Este programa define un m√≥dulo llamado `Main`, que es obligatorio para que el compilador lo reconozca como ejecutable.

- La funci√≥n `main` es el punto de entrada obligatorio para todos los programas ejecutables en Haskell.
- `putStrLn` es una acci√≥n del tipo `IO ()` que imprime una cadena seguida de un salto de l√≠nea.
- Todo el programa se ejecuta como un efecto, lo que refleja el enfoque expl√≠cito de Haskell sobre los efectos secundarios.
- El mensaje es una referencia a *District 9*, una pel√≠cula de ciencia ficci√≥n que plantea temas sociales a trav√©s del contacto con alien√≠genas.

</Explanation>

Ahora puedes ejecutar este programa con Cabal:

```bash title="Desde la terminal"
cabal run type-fundamentals
```

Este comando compilar√° (si es necesario) y luego ejecutar√° el ejecutable llamado `type-fundamentals`, definido en tu archivo `.cabal`.

## üì• Argumentos desde la l√≠nea de comandos

Al igual que en Kotlin, Haskell permite acceder a los argumentos que se pasan cuando se ejecuta el programa desde la terminal. Esto es √∫til para scripts y herramientas interactivas.

```haskell title="Acceso a argumentos (type-fundamentals/basics/Main.hs)" showLineNumbers
module Main where

import System.Environment (getArgs)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [] -> putStrLn "To obtain, something of equal value must be lost."
        _  -> putStrLn $ "Transmuting " ++ unwords args
```

<Explanation>

Este peque√±o programa accede a los argumentos de l√≠nea de comandos usando `getArgs`, que devuelve una lista de cadenas (`[String]`).

- Si no se pasan argumentos, se imprime una cita famosa de *Fullmetal Alchemist* que representa el principio del intercambio equivalente.
- Si se pasan argumentos, se concatenan y se imprime un mensaje que sugiere una "transmutaci√≥n".

La funci√≥n `unwords` convierte la lista de cadenas en una sola cadena con espacios entre las palabras, √∫til para reconstruir frases completas.

</Explanation>

Luego, puedes ejecutar el programa pasando argumentos desde la l√≠nea de comandos:

```bash title="Desde la terminal"
cabal run type-fundamentals -- Philosopher's Stone
```

Esto imprimir√°:

```
Transmuting Philosopher's Stone
```

## üìä Resumen comparativo

| Caracter√≠stica                        | Kotlin                                                                                   | Haskell                                                                                 |
|--------------------------------------|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|
| **Punto de entrada**                 | Funci√≥n `main()` dentro de un archivo `.kt`                                              | Funci√≥n `main :: IO ()` dentro de un m√≥dulo llamado `Main`                              |
| **Estructura del programa**          | Puede estar en cualquier archivo, idealmente acompa√±ado de `package`                     | El ejecutable debe tener un m√≥dulo `Main` y declararlo en el `.cabal`                   |
| **Impresi√≥n en consola**            | `println(...)` o `print(...)`                                                            | `putStrLn` o `print`                                                                    |
| **Manejo de argumentos**            | `args: Array<String>` en la funci√≥n `main`                                               | Uso de `getArgs` del m√≥dulo `System.Environment`                                        |
| **Compilaci√≥n y ejecuci√≥n**         | `./gradlew :app:run` (con o sin `--args`)                                                | `cabal run ejecutable [args]`                                                           |

### ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>

<Pros>

- Los efectos como impresi√≥n o lectura de argumentos est√°n **tipados de forma expl√≠cita** con `IO`, promoviendo mayor claridad.
- La separaci√≥n entre funciones puras y efectos facilita la prueba y reutilizaci√≥n de l√≥gica sin imprimir ni modificar estado.
- El sistema de tipos ayuda a evitar errores comunes al interactuar con argumentos o realizar entradas/salidas.

</Pros>

<Cons>

- Se requiere mayor familiaridad con el sistema de tipos y el concepto de efectos para tareas b√°sicas como imprimir o leer argumentos.
- La necesidad de definir un m√≥dulo `Main` y configurar el `.cabal` puede ser una barrera para comenzar r√°pidamente con scripts simples.
- La gesti√≥n de efectos puede parecer verbosa o poco intuitiva para quienes vienen de lenguajes imperativos.

</Cons>

</ProCons>

## üéØ Conclusiones

En esta lecci√≥n exploramos c√≥mo definir el punto de entrada en Haskell mediante la funci√≥n `main`, contrastando su enfoque expl√≠cito sobre los efectos con el estilo m√°s flexible de Kotlin. Aprendimos a estructurar ejecutables en proyectos Cabal, a imprimir mensajes en consola, y a procesar argumentos desde la l√≠nea de comandos.

Vimos tambi√©n c√≥mo Haskell exige que todo efecto est√© claramente declarado en el tipo de retorno (`IO`), lo que ayuda a separar el c√≥digo puro del que interact√∫a con el entorno, un principio fundamental del dise√±o funcional.

### üîë Puntos clave

- El punto de entrada de un ejecutable en Haskell es siempre una funci√≥n `main :: IO ()` dentro de un m√≥dulo `Main`.
- La impresi√≥n en consola y el acceso a argumentos se realizan como acciones del tipo `IO`, lo que obliga a declarar expl√≠citamente los efectos.
- `getArgs` permite acceder a los argumentos como una lista de cadenas, que puede ser manipulada libremente con funciones como `unwords`.
- La estructura de un ejecutable debe estar declarada en el archivo `.cabal`, incluyendo su m√≥dulo principal y archivo fuente.
- Haskell enfatiza la separaci√≥n entre l√≥gica pura y efectos colaterales, lo cual fortalece la mantenibilidad, aunque a√±ade complejidad inicial.

### üß∞ ¬øQu√© nos llevamos?

Haskell nos recuerda que incluso las tareas m√°s simples ‚Äîcomo imprimir un mensaje o recibir un argumento‚Äî deben ser tratadas con claridad y rigor. Esta disciplina no es una limitaci√≥n, sino una oportunidad para escribir programas m√°s predecibles, reutilizables y f√°ciles de probar. Aunque requiere familiarizarse con nuevos conceptos, comprender c√≥mo funciona el punto de entrada en Haskell es un paso clave para construir herramientas funcionales robustas y bien tipadas.

<ExcludeFromReadingTime>

## üìñ Referencias

### üî• Recomendadas

- üìï "I/O" (pp.165-191) en *Real World Haskell: Code You Can Believe In* de **Bryan O'Sullivan, John Goerzen, y Donald Bruce Stewart**: Este cap√≠tulo explora en profundidad el sistema de entrada y salida en Haskell, destacando su enfoque funcional y su separaci√≥n estricta entre c√≥digo puro y efectos. Comienza con ejemplos sencillos de I/O, como leer argumentos de la l√≠nea de comandos o escribir en consola con `putStrLn`, y luego presenta conceptos m√°s avanzados como acciones I/O, el uso de `Handle`, I/O perezoso (`hGetContents`, `interact`, `readFile`), manejo de archivos temporales, buffering, y el uso de monadas para secuenciar efectos. Se enfatiza c√≥mo Haskell permite escribir programas interactivos sin sacrificar la pureza, facilitando la optimizaci√≥n, la prueba de c√≥digo y el razonamiento formal.

{/* ### üîπ Adicionales */}

{/* - [üìö]() */}

</ExcludeFromReadingTime>
