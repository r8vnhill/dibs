---
title: Ciclos y rangos en comparaci√≥n con Python
---
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import ReadingTime from '@site/src/components/ReadingTime';
import GitHubRepoLink from "@site/src/components/GithubRepoLink";

<ReadingTime/>
<GitHubRepoLink repo="python-dibs" user="r8vnhill"/>

En esta lecci√≥n compararemos c√≥mo **Python** y **Kotlin** abordan uno de los aspectos m√°s fundamentales de cualquier lenguaje de programaci√≥n: **los ciclos y los rangos**.

Aunque ambos lenguajes permiten repetir acciones, recorrer colecciones y construir nuevas estructuras de datos a partir de otras, lo hacen desde enfoques muy distintos:

- Kotlin favorece **la expresividad con tipos est√°ticos y estructuras bien tipadas**, como `1..10`, `repeat`, o funciones como `map` y `filter`.
- Python, en cambio, apuesta por **una sintaxis simple, flexible y directa**, con herramientas como `range`, `for`, y especialmente las *comprehensions*, que permiten generar listas, conjuntos y diccionarios en una sola l√≠nea.

Esta comparaci√≥n te permitir√°:

- Ver en acci√≥n las diferencias entre ciclos `for`, `while`, `do-while` y sus equivalentes en Python.
- Entender qu√© tipo de estructuras se pueden recorrer y c√≥mo se define un rango en cada lenguaje.
- Aprender a usar comprehensions de listas, sets y diccionarios en Python, entendiendo su poder y sus limitaciones.
- Reconocer cu√°ndo Python simplifica la escritura de c√≥digo y cu√°ndo puede perder expresividad o seguridad de tipos frente a Kotlin.

La meta no es decidir cu√°l es ‚Äúmejor‚Äù, sino **entender los matices** de cada herramienta para que puedas tomar mejores decisiones al dise√±ar tus propias bibliotecas o escribir c√≥digo idiom√°tico y claro, sin importar el lenguaje que uses.

## üîÅ Declaraci√≥n `for`

En Python, los ciclos `for` permiten recorrer directamente cualquier objeto **iterable**, como listas, cadenas o rangos.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```python showLineNumbers
        def print_characters(characters: list[str]) -> None:
            for char in characters:
                print(char)
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        Veamos un ejemplo con una lista de personajes del c√≥mic *The Walking Dead*:

        ```python showLineNumbers
        def print_characters(characters: list[str]) -> None:
            for char in characters:
                print(char)


        if __name__ == '__main__':
            print_characters(["Rick", "Michonne", "Carl", "Negan", "Andrea"])
        ```

        ```plaintext title="Salida"
        Rick
        Michonne
        Carl
        Negan
        Andrea
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En cada iteraci√≥n, el ciclo asigna un personaje a la variable `character` y ejecuta el cuerpo del bucle, que en este caso imprime su nombre.
</Explanation>

Este estilo de iteraci√≥n es claro, expresivo y muy utilizado en Python, especialmente en programas donde queremos **procesar elementos sin preocuparnos por √≠ndices o contadores**.

## ‚öôÔ∏è Generadores b√°sicos

Python ofrece una sintaxis muy concisa y expresiva llamada **comprehensions** para generar nuevas colecciones a partir de otras estructuras iterables. Estas construcciones son especialmente √∫tiles cuando queremos **crear, transformar o filtrar datos de forma declarativa**, sin necesidad de escribir ciclos `for` expl√≠citos.

### üîÅ Sintaxis general

La forma b√°sica de una *comprehension* sigue esta estructura:

```python
expresi√≥n for variable in iterable if condici√≥n
```

- **`expresi√≥n`**: lo que se va a agregar a la nueva colecci√≥n. Tiene acceso a `variable`.
- **`variable`**: nombre con el que accedemos a cada elemento del iterable.
- **`iterable`**: cualquier objeto que se pueda recorrer (`list`, `range`, `str`, etc.).
- **`if condici√≥n`** *(opcional)*: filtra los elementos, incluyendo solo aquellos que la cumplan.

### üì¶ List Comprehensions

Devuelven una **lista** con los resultados evaluados para cada elemento del iterable.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```python showLineNumbers title="Ejemplo: duplicar n√∫meros"
        def double_numbers(numbers: list[int]) -> list[int]:
            return [x * 2 for x in numbers]
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```python showLineNumbers title="Ejemplo: duplicar n√∫meros"
        def double_numbers(numbers: list[int]) -> list[int]:
            return [x * 2 for x in numbers]

        if __name__ == '__main__':
            print(double_numbers([1, 2, 3]))
        ```

        ```plaintext title="Salida"
        [2, 4, 6]
        ```
    </TabItem>
</BoxedTabs>

Tambi√©n pueden incluir una condici√≥n:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```python showLineNumbers title="Ejemplo: filtrar pares"
        def filter_pairs(numbers: list[int]) -> list[int]:
            return [x for x in numbers if x % 2 == 0]
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```python showLineNumbers title="Ejemplo: filtrar pares"
        def filter_pairs(numbers: list[int]) -> list[int]:
            return [x for x in numbers if x % 2 == 0]


        if __name__ == '__main__':
            filter_pairs([1, 2, 3, 4, 5])
        ```
            
        ```plaintext title="Salida"
        [2, 4]
        ```
    </TabItem>
</BoxedTabs>

### üßÆ Set Comprehensions

En Python, las *set comprehensions* permiten construir conjuntos de forma concisa a partir de estructuras iterables, aplicando filtros y transformaciones en una sola l√≠nea.

En el siguiente ejemplo, creamos una funci√≥n que extrae los **elementos √∫nicos no nulos** de una colecci√≥n, como una lista de niveles de Digimon.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```python showLineNumbers title="Ejemplo: elementos √∫nicos"
        def unique_elements(elements: Iterable[T]) -> set[T]:
            return {x for x in elements if x is not None}
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```python showLineNumbers title="Ejemplo: elementos √∫nicos"
        from typing import TypeVar, Iterable

        T = TypeVar("T")


        def unique_elements(elements: Iterable[T]) -> set[T]:
            return {x for x in elements if x is not None}


        if __name__ == '__main__':
            digimon_levels = ["Rookie", "Champion", "Rookie", "Ultimate", None, "Mega"]
            print(unique_elements(digimon_levels))
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este fragmento define una funci√≥n `unique_elements` que:

    - Recibe una colecci√≥n de elementos (`Iterable[T]`).
    - Filtra aquellos que son `None`.
    - Devuelve un `set[T]` con los elementos √∫nicos.

    En el ejemplo tem√°tico, usamos una lista de niveles de Digimon (algunos repetidos y uno nulo). El *set comprehension* nos permite obtener directamente los niveles v√°lidos, sin repeticiones ni valores nulos.
</Explanation>

### üó∫Ô∏è Dict Comprehensions

Las *dict comprehensions* permiten crear diccionarios de forma compacta, aplicando transformaciones y filtros sobre una estructura iterable.

En el siguiente ejemplo, construimos un diccionario que **asocia personajes con su clan**, pero solo incluimos aquellos que **tienen clan conocido**:

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```python showLineNumbers title="Ejemplo: personajes de clanes"
        def known_clan_members(data: list[tuple[str, str | None]]) -> dict[str, str]:
            return {
                char_name: char_clan for char_name, char_clan in data
                if char_clan is not None
            }
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
    ```python showLineNumbers title="Ejemplo: personajes de clanes"
    def known_clan_members(data: list[tuple[str, str | None]]) -> dict[str, str]:
        return {
            char_name: char_clan for char_name, char_clan in data
            if char_clan is not None
        }


    if __name__ == '__main__':
        characters = [
            ("Chun-Woo Han", "Black Heaven and Earth"),
            ("Jin-Ie", None),
            ("So-Chun Hyuk", "Muran"),
            ("Sera Kang", "Muran"),
            ("Goomoonryong", None)
        ]

        result = known_clan_members(characters)
        for name, clan in result.items():
            print(f"{name} ‚Üí {clan}")
    ```

    ```plaintext title="Salida"
    Chun-Woo Han ‚Üí Black Heaven and Earth
    So-Chun Hyuk ‚Üí Muran
    Sera Kang ‚Üí Muran
    ```
    </TabItem>
</BoxedTabs>

<Explanation>
  Este fragmento define una funci√≥n que:

  - Recibe una lista de tuplas (`(char_name, char_clan)`).
  - Filtra los personajes sin clan (`None`).
  - Devuelve un diccionario `{char_name: char_clan}` de aquellos que tienen clan.

  En este ejemplo inspirado en *The Breaker*, evitamos mostrar personajes cuya afiliaci√≥n es desconocida o irrelevante en cierto contexto narrativo. Las dict comprehensions son especialmente √∫tiles cuando quieres transformar y filtrar datos al mismo tiempo, sin necesidad de ciclos expl√≠citos.
</Explanation>

## üìè Rangos: expl√≠citos pero limitados

Tanto Kotlin como Python permiten definir rangos, pero lo hacen de formas muy distintas y con distintos grados de flexibilidad.

En Kotlin, existen operadores nativos para definir rangos:

- `1..5` ‚Üí Rango cerrado de 1 a 5  
- `1..<5` ‚Üí Rango abierto de 1 a 5 (excluye el 5)

Python, en cambio, utiliza la funci√≥n incorporada `range()`:

```python showLineNumbers
range(1, 6)        # Equivalente a 1..<6 (el tope es exclusivo)
range(5, 0, -1)    # Equivalente a 5 downTo 1
range(1, 6, 2)     # Equivalente a 1..<6 step 2
```

A diferencia de Kotlin, **Python no cuenta con un operador espec√≠fico para definir rangos**. Siempre se utiliza la funci√≥n `range`, que adem√°s **solo funciona con n√∫meros enteros**.

## üîÇ Ciclos `while` y `do-while`

Tanto **Kotlin** como **Python** permiten repetir acciones mediante ciclos `while`. La idea es evaluar una **condici√≥n booleana** y, mientras se cumpla, seguir ejecutando el bloque de c√≥digo.

### üåÄ Ciclos `while` en Python

Una estructura com√∫n en Python es recorrer una lista de posibles fuentes de configuraci√≥n hasta encontrar una v√°lida. Este patr√≥n es ideal para mostrar c√≥mo se aplica un ciclo `while`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```python showLineNumbers
        def load_first_valid_config(sources: list[str]) -> int | None:
            index = 0
            while index < len(sources):
                config = try_load_config(sources[index])
                index += 1
                if config is not None:
                    return config
            return None
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```python showLineNumbers
        def try_load_config(source: str) -> int | None:
            print(f"üîç Trying to load configuration from '{source}'")
            if source == "default.yaml":
                print("‚úÖ Configuration loaded successfully.")
                return 420
            else:
                print("‚ùå Invalid configuration.")
                return None


        def load_first_valid_config(sources: list[str]) -> int | None:
            index = 0
            while index < len(sources):
                config = try_load_config(sources[index])
                index += 1
                if config is not None:
                    return config
            return None


        if __name__ == '__main__':
            yaml_files = ["user.yaml", "project.yaml", "default.yaml"]

            valid_config = load_first_valid_config(yaml_files)

            if valid_config is None:
                print("üí• No valid configuration found.")
            else:
                print(f"üõ†Ô∏è System initialized with config ID {valid_config}.")
        ```

        ```plaintext title="Salida"
        üîç Trying to load configuration from 'user.yaml'
        ‚ùå Invalid configuration.
        üîç Trying to load configuration from 'project.yaml'
        ‚ùå Invalid configuration.
        üîç Trying to load configuration from 'default.yaml'
        ‚úÖ Configuration loaded successfully.
        üõ†Ô∏è System initialized with config ID 420.
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este ejemplo muestra un caso cl√°sico de uso para `while`: buscar algo en una lista hasta encontrar una respuesta v√°lida.

    - Se usa un √≠ndice para recorrer una lista de archivos.
    - Se intenta cargar la configuraci√≥n de cada archivo en orden.
    - Si una fuente es v√°lida (`config is not None`), se retorna inmediatamente.
    - Si ninguna lo es, la funci√≥n retorna `None`.
</Explanation>

### ‚ùó ¬øY el ciclo `do-while`?

Python **no tiene una construcci√≥n `do-while`**, pero puedes simularlo con un `while True` y una instrucci√≥n `break`:

```python showLineNumbers title="Simulaci√≥n de do-while en Python"
while True:
    attempt = try_load_config(["file.yaml"])
    if attempt is not None:
        break
```

Este patr√≥n garantiza que el bloque se ejecute **al menos una vez**, como har√≠a un `do-while` en otros lenguajes.

## üîÑ Repeticiones fijas

Kotlin incluye la funci√≥n `repeat(n)`, que no existe como tal en Python. En Python, lo m√°s cercano es un ciclo `for` con `range(n)`:

```python showLineNumbers title="Repetici√≥n fija en Python"
for _ in range(3):
    print("Ni!")
```

Pero **Python no ofrece una alternativa tan expresiva como `repeat { }` de Kotlin**, especialmente cuando no se necesita el √≠ndice de iteraci√≥n.

## ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Sintaxis simple y directa**: Los ciclos `for` en Python funcionan directamente con cualquier iterable, sin necesidad de √≠ndices expl√≠citos.
        - **Comprehensions expresivas**: Las list, set y dict comprehensions permiten construir colecciones transformadas o filtradas de forma concisa y declarativa.
        - **Uniformidad en la iteraci√≥n**: Las estructuras como listas, rangos, cadenas o archivos se pueden recorrer con el mismo tipo de ciclo `for`.
        - **Ciclo `while` claro**: El comportamiento de `while` es directo y se adapta bien a patrones comunes como "leer hasta encontrar algo v√°lido".
        - **Flexible con estructuras personalizadas**: Si una clase implementa `__iter__` o `__contains__`, puede integrarse f√°cilmente con `for` o `in`.

    </Pros>
    <Cons>
        - **Sin `do-while` nativo**: Python no tiene un ciclo que garantice la ejecuci√≥n del cuerpo al menos una vez. Se debe simular con `while True` y `break`.
        - **Sin `repeat(n)`**: No hay una funci√≥n est√°ndar que indique expl√≠citamente "repite esta acci√≥n n veces". Se usa `for _ in range(n)`, que es menos sem√°ntico.
        - **`range()` solo con enteros**: No se pueden usar rangos directamente con `float`, `str`, o `char`, lo que limita su expresividad en ciertos contextos.
        - **No hay operadores de rango**: Python no tiene operadores como `..`, `..<`, o `downTo`; todos los rangos deben construirse con `range(start, stop[, step])`.
        - **Comprehensions no tipadas**: Aunque muy expresivas, las comprehensions no llevan anotaciones de tipo ni estructuras de control sofisticadas como en Kotlin con `map`, `filter`, `flatMap`, etc.

</Cons>
</ProCons>

## üéØ Conclusiones

A lo largo de esta lecci√≥n, exploramos c√≥mo Python y Kotlin abordan las estructuras de repetici√≥n y la generaci√≥n de colecciones de forma declarativa.

Kotlin prioriza la expresividad mediante rangos, funciones como `repeat`, y estructuras de control que hacen expl√≠cita la intenci√≥n del c√≥digo. Python, por su parte, opta por una sintaxis simple, directa y poderosa que facilita escribir ciclos y comprehensions de forma natural.

### üîë Puntos clave

- Python permite recorrer listas, cadenas y otros iterables directamente con `for`, sin necesidad de √≠ndices.
- Las *comprehensions* (de listas, conjuntos y diccionarios) son una herramienta poderosa para construir nuevas colecciones con filtros y transformaciones.
- Python usa la funci√≥n `range()` para generar rangos, pero solo admite enteros.
- Los ciclos `while` funcionan igual que en Kotlin, pero Python no incluye `do-while`; se simula con `while True` + `break`.
- No existe en Python una funci√≥n equivalente a `repeat`, pero se puede lograr el mismo efecto con `for _ in range(n)`.

### üìã Tabla comparativa: Kotlin vs. Python

| Caracter√≠stica                        | Kotlin                                  | Python                                      |
|--------------------------------------|-----------------------------------------|---------------------------------------------|
| **Rangos**                           | `1..5`, `5 downTo 1`, `1..10 step 2`    | `range(1, 6)`, `range(5, 0, -1)`             |
| **Tipos en rangos**                  | Admite `Int`, `Char`, `Double`, etc.    | Solo admite `int`                           |
| **Ciclo `for`**                      | Recorre rangos e iterables              | Recorre directamente cualquier iterable     |
| **`for` como expresi√≥n**             | ‚ùå No                                      | ‚ùå No                                           |
| **List comprehension**               | ‚ùå No (usa `map`, `filter`, etc.)          | ‚úÖ S√≠                                           |
| **Set comprehension**               | ‚ùå No (usa `toSet()` + `map`/`filter`)     | ‚úÖ S√≠                                           |
| **Dict comprehension**              | ‚ùå No (usa constructores o `associate`)    | ‚úÖ S√≠                                           |
| **Ciclo `while`**                    | ‚úÖ S√≠                                      | ‚úÖ S√≠                                           |
| **Ciclo `do-while`**                 | ‚úÖ S√≠                                      | No (se simula con `while True` + `break`)   |
| **Repetici√≥n fija (`repeat`)**       | `repeat(n) { ... }`                     | `for _ in range(n):`                         |
| **Verificaci√≥n con `in`**            | `x in 1..10`, `s in "a".."z"`            | `x in range(1, 11)`, `x in lista`            |

### üß∞ ¬øQu√© nos llevamos?

Comparar c√≥mo dos lenguajes distintos modelan operaciones tan universales como los ciclos nos ayuda a entender no solo sus sintaxis, sino tambi√©n sus **filosof√≠as de dise√±o**.

Kotlin busca evitar ambig√ºedades y favorecer el dise√±o expresivo, especialmente en bibliotecas. Python, en cambio, apuesta por una sintaxis concisa que deja m√°s control (y m√°s responsabilidad) a quien programa.

Ambos enfoques tienen sus ventajas, y conocerlos nos permite tomar decisiones informadas al escribir c√≥digo reutilizable, claro y mantenible.

Al final, aprender estas diferencias no se trata solo de saber "c√≥mo se hace en otro lenguaje", sino de **entrenar el ojo para reconocer cu√°ndo un ciclo, una repetici√≥n o una construcci√≥n declarativa est√°n comunicando bien su prop√≥sito**.

Y eso ‚Äîcomunicar bien nuestras intenciones con el c√≥digo‚Äî es una habilidad clave para dise√±ar buenas bibliotecas.

## üìñ Referencias

### üî• Recomendadas

- [üåê "When to Use a List Comprehension in Python"](https://realpython.com/list-comprehension-python/) en *Real Python* por **James Timmins**: Una gu√≠a pr√°ctica y detallada sobre **cu√°ndo conviene usar list comprehensions en Python**, escrita por el equipo de *Real Python*. Explica c√≥mo estas construcciones permiten **transformar, filtrar y construir colecciones** de forma declarativa, compar√°ndolas con ciclos `for`, `map()` y `filter()`. Tambi√©n aborda **casos avanzados**, como el uso de condicionales, comprehensions anidadas, y alternativas como generadores para manejar grandes vol√∫menes de datos. Es especialmente relevante para esta lecci√≥n porque **profundiza en el dise√±o, ventajas y l√≠mites de las comprehensions**, y ense√±a a decidir **cu√°ndo usarlas y cu√°ndo evitarlas** en favor de soluciones m√°s claras o eficientes.

{/* ### üîπ Adicionales */}
