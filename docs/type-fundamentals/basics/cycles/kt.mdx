---
title: Ciclos y rangos
---
import Exercise from '@site/src/components/exercise/Exercise'
import ReadingTime from '@site/src/components/ReadingTime'
import Solution from '@site/src/components/exercise/Solution'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import Hint from '@site/src/components/exercise/Hint'
import Explanation from '@site/src/components/admonitions/Explanation'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'
import Video from '@site/src/components/references/Video'
import Book from '@site/src/components/references/Book'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Repetir acciones es una necesidad com√∫n en cualquier programa, ya sea para mostrar una lista, validar entradas o aplicar una funci√≥n m√∫ltiples veces. Pero **la forma en que lo hacemos s√≠ importa**.

Kotlin ofrece ciclos dise√±ados para ser **expresivos, seguros y legibles**. En esta lecci√≥n exploraremos las principales formas de iteraci√≥n: los bucles `for`, `while` y `do-while`, as√≠ como el uso de rangos y la funci√≥n `repeat`.

Tambi√©n aprenderemos a distinguir entre estructuras que **pueden recorrerse** y aquellas que solo **pueden evaluarse**, y veremos c√≥mo Kotlin privilegia la claridad por sobre una flexibilidad descontrolada.

## üîÅ Declaraci√≥n `for`

:::important Importante

En Kotlin, `for` es una **declaraci√≥n**, no una expresi√≥n.

:::

Esto significa que **no produce un valor**: se utiliza para **ejecutar acciones** (como imprimir o modificar datos), pero **no puede ser parte de una expresi√≥n mayor** ni asignarse a una variable.

<details>
  <summary>
    üß† ¬øY en otros lenguajes?
  </summary>

  A diferencia de Kotlin, donde `for` es solo una **declaraci√≥n**, lenguajes como **Scala**, **Haskell** o **Python** permiten recorrer estructuras **de forma expresiva** y, al mismo tiempo, **producir un valor** como resultado.

  #### üì¶ Scala (`for` como expresi√≥n)

  En Scala, los bucles `for` pueden generar nuevas colecciones mediante `yield`:

  ```scala showLineNumbers title="Bucle for en Scala"
  val doubled = for x <- List(1, 2, 3)
      yield x * 2
  // Resultado: List(2, 4, 6)
  ```

  Esto se conoce como **for-comprehension**, y combina operaciones como `map`, `flatMap` y `filter` de forma declarativa.

  #### üî¢ Haskell (`forM` mon√°dico)

  Aunque Haskell no tiene un bucle `for` tradicional, puedes recorrer estructuras con efectos usando `forM` del m√≥dulo `Control.Monad`:

  ```haskell showLineNumbers title="Bucle forM en Haskell"
  import Control.Monad (forM)

  forM [1..3] (\x -> return (x * 2))
  -- Resultado (en una m√≥nada pura): [2, 4, 6]
  ```

  `forM` es una variante de `mapM` con los argumentos invertidos, lo que mejora la legibilidad en ciertos contextos.

  #### üêç Python (comprensiones de listas)

  Las *list comprehensions* permiten construir listas a partir de iteraciones:

  ```python showLineNumbers title="Comprensi√≥n de listas en Python"
  [x * 2 for x in range(1, 4)]
  # Resultado: [2, 4, 6]
  ```

  Tambi√©n existen variantes para conjuntos y diccionarios.

  ---

  En todos estos lenguajes, el bucle puede **producir un valor** como resultado, lo que permite **encadenar transformaciones sin efectos colaterales**.  
  En Kotlin, ese papel lo cumplen funciones como `map`, `filter` o `fold`, mientras que `for` est√° pensado para ejecutar acciones con efectos secundarios, como imprimir o modificar variables.
</details>

```kotlin title="Sintaxis b√°sica de un bucle for"
for (variable in rango) {
    // cuerpo del ciclo
}
```

Las llaves `{}` son opcionales cuando el cuerpo del ciclo contiene **una sola instrucci√≥n**, pero se recomienda **usarlas siempre** por razones de **legibilidad** y para evitar errores al agregar nuevas l√≠neas m√°s adelante.

### Ejemplos

```kotlin showLineNumbers title="Ejemplos de bucles for (omitimos llaves para simplificar)"
for (i in 1..5) print(i)         // Imprime: 12345 (incluye el 5)
for (i in 5 downTo 1) print(i)   // Imprime: 54321 (cuenta hacia atr√°s)
for (i in 1..5 step 2) print(i)  // Imprime: 135 (salta de 2 en 2)
for (i in 1..<5) print(i)        // Imprime: 1234 (excluye el 5)
for (i in 1 until 5) print(i)    // Equivalente a 1..<5
```

<Explanation>
  - `1..5`: Crea un rango **cerrado**, que incluye el 5.
  - `5 downTo 1`: Cuenta en reversa (rango descendente).
  - `step`: Define el tama√±o del paso (por ejemplo, de 2 en 2).
  - `..<` y `until`: Crean un rango **semiabierto**, que **excluye** el l√≠mite superior.
</Explanation>

Tambi√©n puedes usar rangos con otros tipos, como caracteres:

```kotlin showLineNumbers title="Iterar sobre caracteres con for"
for (c in 'a'..'e') print(c)         // Imprime: abcde
for (c in 'e' downTo 'a') print(c)   // Imprime: edcba
```

:::tip Rangos m√°s all√° de n√∫meros

En Kotlin, los rangos no se limitan a enteros: puedes usarlos con **cualquier tipo que implemente [`Comparable`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-comparable/)**, como `Char`, `String`, `Double`, entre otros.

Esto permite escribir expresiones como:

```kotlin title="Rangos con tipos no enteros"
'a'..'z'          // Rango de caracteres
"Foo".."Foz"      // Rango de strings por orden lexicogr√°fico
1.0..5.0          // Rango de n√∫meros en punto flotante
```

:::

::::warning ¬øSe pueden recorrer con `for`?

No siempre.  
Aunque muchos tipos pueden formar un rango, **no todos los rangos pueden usarse en un ciclo `for`**.

Solo ciertos tipos como `Int`, `Long` y `Char` implementan lo necesario para que un rango sea tambi√©n una **secuencia iterable**.  
En cambio, rangos como `1.0..5.0` (`Double`) o `"Foo".."Foz"` (`String`) **no pueden recorrerse directamente con `for`**, porque Kotlin **no sabe c√≥mo avanzar autom√°ticamente al siguiente valor**.

:::note ¬øQu√© valor sigue?

Pi√©nsalo un momento:

- ¬øQu√© n√∫mero sigue despu√©s de `1.0`?  
  ¬ø`1.1`, `1.01`, `1.000001`, `1 + 1e-100`‚Ä¶?
- ¬øY qu√© `String` viene despu√©s de `"Foo"`?  
  ¬ø`"Fop"`?, ¬ø`"Fooa"`?, ¬ø`"Foofighters"`?

Estas preguntas **no tienen una √∫nica respuesta correcta**, por lo que Kotlin prefiere **no asumir una l√≥gica arbitraria**.

:::

Por eso es importante distinguir entre **crear un rango** y **recorrer un rango**.  
**No todos los rangos son secuencias.**

::::

<details>
    <summary>
        üí° ¬øY si quiero recorrer algo distinto?
    </summary>

    Cualquier estructura que implemente [Iterable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/) puede recorrerse con un bucle `for`.  
    Esto incluye **listas**, **conjuntos**, **mapas** (a trav√©s de `entries`) y muchas otras colecciones est√°ndar de Kotlin.

    ```kotlin showLineNumbers
    val sins = listOf("Lust", "Gluttony", "Envy", "Greed", "Wrath", "Sloth", "Pride")
    for (sin in sins) {
        println("Homunculus: $sin")
    }
    ```

    Este fragmento imprime los nombres de los siete **hom√∫nculos**, que representan los *pecados capitales* en *Fullmetal Alchemist*.

    Este comportamiento es posible gracias al **patr√≥n de iterador** (`Iterator`), que exploraremos m√°s adelante en el curso.
</details>

## üìè Verificar si un valor pertenece a un rango

En Kotlin, puedes usar el operador `in` (y su negaci√≥n `!in`) para verificar si un valor est√° **dentro de un rango**.  
Este operador devuelve un valor `Boolean`, por lo que puede usarse directamente en condiciones:

```kotlin showLineNumbers title="Usar in y !in para verificar pertenencia a un rango"
if (x in 1..10) {
    println("$x est√° entre 1 y 10")
}
if (x !in 20..30) {
    println("$x no est√° entre 20 y 30")
}
```

Tambi√©n puedes usarlo dentro de expresiones `when`:

```kotlin showLineNumbers title="Uso de rangos con when"
when (x) {
    in 1..10 -> println("Est√° entre 1 y 10")
    !in 100..200 -> println("Est√° fuera del rango 100 a 200")
    else -> println("Caso no contemplado")
}
```

El operador `in` tambi√©n funciona con otros tipos comparables, como caracteres o strings:

```kotlin showLineNumbers title="Verificaci√≥n de pertenencia en rangos no num√©ricos"
if (c in 'a'..'z') {
    println("$c es una letra min√∫scula")
}
if (s in "Foo".."Foz") {
    println("$s est√° entre Foo y Foz")
}
```

:::info Comparaciones lexicogr√°ficas

Cuando usas rangos de `String`, Kotlin compara los valores seg√∫n el orden lexicogr√°fico (es decir, alfab√©tico).  
Esto significa que `"Foo"` est√° antes que `"Foz"`, pero `"Fooo"` no necesariamente cae dentro del mismo rango.

:::

<details>
  <summary>üîç ¬øC√≥mo funciona realmente el operador <code>in</code>?</summary>

  Los operadores `in` y `!in` no se limitan a rangos: tambi√©n funcionan con muchas estructuras est√°ndar de Kotlin, como listas, conjuntos y mapas.

  ```kotlin showLineNumbers title="Verificaci√≥n de pertenencia en una colecci√≥n"
  val songs = listOf("Perfect Day", "Walk on the Wild Side", "Satellite of Love")

  if ("Perfect Day" in songs) {
      println("üéµ Lou Reed is in the playlist.")
  }
  ```

  Esto es posible porque estas colecciones implementan la funci√≥n `contains`.  
  Es decir, `in` es simplemente una forma m√°s legible de escribir `songs.contains("Perfect Day")`.

  :::tip ¬øY si quiero usar `in` con mis propias clases?

  Puedes hacerlo si tu clase define una funci√≥n `contains`.  
  En otras palabras, `in` es solo **una forma alternativa de invocar `contains`**.

  M√°s adelante en el curso veremos c√≥mo habilitar esta funcionalidad mediante **sobrecarga de operadores**.

  :::
</details>

## üîÑ Declaraci√≥n `while`

En Kotlin, la declaraci√≥n `while` permite repetir un bloque de c√≥digo **mientras se cumpla una condici√≥n booleana**.  
Existen dos variantes principales:

```kotlin title="Bucle while"
while (condici√≥n) {
    // cuerpo del ciclo
}
```

- Eval√∫a la condici√≥n **antes** de ejecutar el cuerpo.
- Si la condici√≥n es falsa desde el inicio, el cuerpo **no se ejecuta**.

```kotlin title="Bucle do-while"
do {
    // cuerpo del ciclo
} while (condici√≥n)
```

- Ejecuta el cuerpo **al menos una vez**, y luego eval√∫a la condici√≥n.
- Es √∫til cuando necesitas que la acci√≥n se ejecute **una vez antes de verificar la condici√≥n**, como al pedir una entrada de usuario o realizar una verificaci√≥n inicial.

<Explanation>
    Ambos estilos permiten repetir tareas de forma controlada:

    - Usa `while` cuando **la condici√≥n debe cumplirse desde el inicio**.
    - Usa `do-while` cuando **el cuerpo debe ejecutarse al menos una vez** antes de volver a verificar la condici√≥n.
</Explanation>

### üåÄ Ejemplo: Buscando configuraci√≥n disponible

```kotlin showLineNumbers title="Reintento con m√∫ltiples fuentes de configuraci√≥n"
val sources = listOf("user.yaml", "project.yaml", "default.yaml")
var index = 0
var config: Config?

do {
    val file = sources[index]
    println("Intentando cargar configuraci√≥n desde: $file")
    config = loadConfig(file)
    index++
} while (config == null && index < sources.size)

if (config == null) {
    error("No se pudo cargar la configuraci√≥n desde ninguna fuente.")
}
```

<Explanation>
    Este patr√≥n es √∫til cuando intentamos **recuperar un recurso de varias fuentes posibles**, en orden de prioridad.

    Tambi√©n introduce algunos conceptos que veremos m√°s adelante:

    - **Tipos anulables** (`Config?`), que obligan a manejar la ausencia de valores.
    - **Control de errores seguro**, al verificar si `config` sigue siendo `null` tras los intentos.
    - El uso de `do-while` permite **realizar al menos un intento de carga**, incluso si la lista tiene un solo elemento.
</Explanation>

## üîÇ Funci√≥n `repeat`

La funci√≥n `repeat` ofrece una forma concisa de ejecutar un bloque de c√≥digo un n√∫mero fijo de veces. Su sintaxis es:

```kotlin title="Sintaxis de repeat"
repeat(n) {
    // cuerpo del ciclo
}
```

- `repeat` es una **funci√≥n** (no una declaraci√≥n), por lo tanto es una **expresi√≥n**.
- Esto significa que puede usarse como parte de otras expresiones o asignarse a una variable.
- Sin embargo, su valor de retorno es **`Unit`**, por lo que **rara vez se utiliza** el resultado.

```kotlin showLineNumbers title="We are the knights who say Ni!"
repeat(3) {
    println("Ni!")
}
```

Este ejemplo imprimir√° `"Ni!"` tres veces.

<Explanation>
    - `repeat` es ideal cuando necesitas repetir algo un n√∫mero fijo de veces y **no te interesa el √≠ndice**.
    - Si s√≠ necesitas saber en qu√© repetici√≥n est√°s (como en `for (i in 0 until n)`), puedes usar la variante con √≠ndice:

    ```kotlin
    repeat(3) { i ->
        println("Repetici√≥n $i")
    }
    ```

    Aqu√≠, `i` toma los valores `0`, `1` y `2`.
</Explanation>

## üéØ Conclusiones

Los ciclos son una herramienta fundamental para controlar el flujo en cualquier lenguaje de programaci√≥n, y en Kotlin se presentan de forma concisa, segura y expresiva.  
En esta lecci√≥n exploramos diversas formas de repetir acciones: desde ciclos `for` sobre rangos hasta bucles controlados por condiciones y repeticiones fijas.

Tambi√©n aprendimos a distinguir entre lo que se puede **crear** (como un rango) y lo que se puede **recorrer** (como una secuencia iterable), una diferencia clave para evitar errores sutiles al dise√±ar c√≥digo reutilizable.

### üîë Puntos clave

- `for` en Kotlin es una **declaraci√≥n**, no una expresi√≥n: se usa para ejecutar acciones, no para producir valores.
- Puedes recorrer rangos con `for` siempre que estos sean **iterables**, como los de `Int`, `Long` o `Char`.
- Otros tipos como `Double` o `String` pueden formar rangos, pero **no siempre pueden recorrerse**.
- El operador `in` permite verificar si un valor pertenece a un rango o a una colecci√≥n.
- Kotlin incluye dos variantes de ciclo condicional: `while` (eval√∫a antes) y `do-while` (eval√∫a despu√©s).
- La funci√≥n `repeat(n)` es una alternativa concisa para ejecutar un bloque un n√∫mero fijo de veces.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n fue mucho m√°s que un repaso de bucles: exploramos las distintas formas en que Kotlin permite **expresar repetici√≥n con claridad y prop√≥sito**.

Aprendimos a usar `for`, `while`, `do-while`, `repeat`, y a distinguir entre **rangos recorribles** y aquellos que no lo son.  
Pero, sobre todo, entendimos que escribir ciclos no se trata de iterar por iterar, sino de **elegir la herramienta que mejor comunica la intenci√≥n del c√≥digo**.

Esa forma de pensar ‚Äîpriorizar expresividad, claridad y dise√±o‚Äî ser√° fundamental al construir bibliotecas.  
Porque no basta con que algo funcione: debe ser **legible, predecible y reutilizable**.

Y si lo pensamos bien, **aprender tambi√©n es un ciclo**: volvemos una y otra vez sobre los mismos conceptos, pero con m√°s contexto, m√°s herramientas, m√°s claridad.  
Al igual que en el c√≥digo, lo importante no es solo repetir, sino **repetir con intenci√≥n**.

Y todo eso ‚Äîla expresividad, la intenci√≥n y el dise√±o‚Äî tambi√©n empieza por algo tan b√°sico como los ciclos.

<div className="language-card-container">
    <LanguageCards.PythonCard link="/docs/type-fundamentals/basics/cycles/py" />
</div>

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage 
        title="Ranges and progressions" 
        url="https://kotlinlang.org/docs/ranges.html" 
        location="la documentaci√≥n oficial de Kotlin"
    >
        Explica c√≥mo crear y recorrer rangos con diferentes tipos y pasos personalizados, lo que resulta esencial para comprender el uso de <code>for</code>, <code>in</code>, <code>step</code>, y <code>downTo</code> en Kotlin.
    </WebPage>
]}/>

<ReferenceList title="üìö Referencias complementarias" items={[
    <Video
        title="Ciclos en Kotlin: ¬°Domina while, do-while y for! (Kotlin Bits #3)"
        url="https://youtu.be/QuHGHAo-mpc"
        location="YouTube"
        author="Developer GB"
        duration="8m2s"
    >
        Una introducci√≥n pr√°ctica al uso de <code>while</code>, <code>do-while</code> y <code>for</code> en Kotlin con ejemplos sencillos como calcular factoriales o promedios; √∫til para personas que est√°n comenzando a programar y quieren entender c√≥mo y cu√°ndo usar cada tipo de ciclo.
    </Video>,
    <Book
        chapter="Kotlin basics"
        pages={[17, 43]}
        book="Kotlin in action"
        author="Dmitry Jemerov & Svetlana Isakova"
    >
        Una gu√≠a completa sobre las estructuras de control en Kotlin, incluyendo <code>if</code>, <code>when</code>, <code>for</code> y rangos como <code>1..5</code>, destacando c√≥mo Kotlin las hace m√°s expresivas y uniformes que en Java, lo cual es clave para escribir ciclos claros y seguros.
    </Book>,
]}/>
