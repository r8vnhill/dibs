---
title: "Kotlin: Un lenguaje pragm√°tico y moderno"
---
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

<img src="/img/kotlin.jpg" alt="El gato se llama Kotlin" class="object-contain h-10 mx-auto" />

Kotlin es un lenguaje moderno que se destaca por su **pragmatismo**, **claridad** y su fuerte **enfoque en la seguridad**. En los √∫ltimos a√±os ha ganado gran popularidad gracias a su capacidad para combinar de forma efectiva los paradigmas de **programaci√≥n orientada a objetos** y **programaci√≥n funcional**, todo dentro de una sintaxis concisa y expresiva.

En este curso exploraremos Kotlin como una herramienta para el **dise√±o e implementaci√≥n de bibliotecas de software reutilizables**. Su interoperabilidad con Java, el modelo de seguridad frente a valores nulos, el soporte para **funciones de extensi√≥n**, **corrutinas** y otras caracter√≠sticas modernas lo convierten en una excelente opci√≥n para construir componentes **modulares**, **mantenibles** y **multiplataforma**.

Esta primera lecci√≥n ofrece una **introducci√≥n al lenguaje y su filosof√≠a**. Veremos c√≥mo se escribe en Kotlin, en qu√© se diferencia de otros lenguajes, y qu√© ventajas ofrece a quienes buscan escribir c√≥digo **expresivo**, **seguro** y **pragm√°tico** desde el comienzo.

A trav√©s de ejemplos simples y comparaciones pr√°cticas, comenzaremos a establecer las bases sobre las que se apoyar√° el resto del curso.

## üîç ¬øQu√© aprender√°s en este m√≥dulo?

En este m√≥dulo introductorio conocer√°s los fundamentos esenciales de Kotlin y c√≥mo aplicarlos para crear software reutilizable y expresivo. A lo largo de estas lecciones:

- Descubrir√°s qu√© es Kotlin, cu√°l es su filosof√≠a y por qu√© es una excelente opci√≥n para construir bibliotecas modernas.
- Aprender√°s a **declarar funciones y variables**, y distinguir entre valores mutables e inmutables.
- Comprender√°s la diferencia entre **expresiones y declaraciones**, y c√≥mo aprovecharlas para escribir c√≥digo m√°s claro y conciso.
- Explorar√°s las **estructuras de control** como condicionales, ciclos y rangos, y su sintaxis idiom√°tica en Kotlin.
- Ver√°s c√≥mo funciona el **punto de entrada** de un programa Kotlin y c√≥mo ejecutar tu primer proyecto con Gradle.

Este m√≥dulo sienta las bases sobre las que se construir√° el resto del curso, donde nos enfocaremos en t√©cnicas para dise√±ar bibliotecas reutilizables, seguras y f√°ciles de mantener.

## üéØ Objetivos de aprendizaje

Al finalizar este m√≥dulo, ser√°s capaz de:

- Explicar qu√© es Kotlin, cu√°l es su filosof√≠a y c√≥mo facilita el desarrollo de bibliotecas reutilizables y multiplataforma.
- Declarar funciones y variables, comprendiendo las diferencias entre `val`, `var` y los tipos b√°sicos.
- Usar expresiones condicionales para modelar decisiones de forma concisa y expresiva.
- Aplicar ciclos y rangos para recorrer estructuras repetitivas con claridad.
- Identificar la estructura general de un programa en Kotlin y su punto de entrada.
- Emplear interpolaci√≥n de cadenas para construir mensajes din√°micos de manera eficiente.

Estos objetivos sientan una base s√≥lida para abordar conceptos m√°s avanzados, como tipos algebraicos, estructuras de control m√°s expresivas y dise√±o orientado a la composici√≥n.

## üò∫ ¬øQu√© es Kotlin?

**Kotlin** es un lenguaje de programaci√≥n **moderno y multiplataforma** desarrollado por **JetBrains**, que combina caracter√≠sticas de la **programaci√≥n orientada a objetos** y la **programaci√≥n funcional**. Se destaca por su **sintaxis concisa**, su enfoque en la **seguridad** y su capacidad para compilar en m√∫ltiples plataformas:

- **JavaScript (JS)** y **WebAssembly (WASM)** para ejecuci√≥n en navegadores.
- **Java Virtual Machine (JVM)** para aplicaciones de servidor y Android.
- **LLVM** para aplicaciones nativas en escritorio, iOS y sistemas embebidos.

En este curso nos enfocaremos en **Kotlin sobre la JVM**, la plataforma m√°s consolidada y ampliamente utilizada del ecosistema. Aun as√≠, los conceptos y t√©cnicas que aprender√°s son altamente **transferibles** a las dem√°s plataformas soportadas por Kotlin, y aplicables en muchos otros **lenguajes modernos**.

## üöÄ A Taste of Kotlin

A continuaci√≥n, te mostramos un ejemplo sencillo en Kotlin para que te familiarices con su sintaxis y estilo expresivo:

```kotlin showLineNumbers
data class Person(
    val name: String,
    val age: Int? = null
)

fun main() {
    val persons = listOf(
        Person("Harrier Du Bois"),
        Person("Kim Kitsuragi", age = 43)
    )
    val youngest = persons.minByOrNull { it.age ?: Int.MAX_VALUE }
    println("The youngest is: $youngest")
}
// Output: The youngest is: Person(name=Kim Kitsuragi, age=43)
```

<Explanation>
    - **[1‚Äì4]** Se declara una **data class** llamada `Person` con dos propiedades: `name` de tipo `String` y `age` de tipo `Int?` (opcional).
    - **[3]** La propiedad `age` tiene como valor por defecto `null`.
    - **[7‚Äì10]** Se crea una lista inmutable con `listOf`, que contiene dos personas.
    - **[9]** En el segundo objeto se utiliza una **asignaci√≥n nombrada** (`age = 43`).
    - **[11]** Se usa `minByOrNull` con el operador Elvis (`?:`) para ignorar los `null` y encontrar la persona m√°s joven.
    - **[12]** Se imprime el resultado usando interpolaci√≥n de cadenas.
</Explanation>

## üìú Filosof√≠a de Kotlin

Kotlin fue dise√±ado con el objetivo de **hacer la programaci√≥n m√°s sencilla, segura y expresiva**, sin renunciar a la flexibilidad ni a la potencia. En lugar de introducir ideas experimentales o radicales, **adopta pr√°cticas consolidadas de otros lenguajes modernos**, integr√°ndolas de forma coherente y pragm√°tica.

Algunos de sus principios fundamentales son:

- **Pragmatismo**: Est√° orientado a resolver problemas reales de forma efectiva, priorizando la practicidad sobre las restricciones del lenguaje.
- **Concisi√≥n y legibilidad**: Su sintaxis minimiza la verbosidad sin sacrificar claridad.
- **Seguridad**: Previene errores comunes en tiempo de compilaci√≥n, como las referencias nulas, fomentando un c√≥digo m√°s robusto.
- **Claridad intencional**: Promueve un estilo donde la intenci√≥n del c√≥digo es expl√≠cita y f√°cilmente comprensible para otras personas.

## ‚öñÔ∏è Beneficios y limitaciones de Kotlin en el desarrollo de bibliotecas de software

<ProCons>
    <Pros>
        - **Interoperabilidad con Java** ‚Üí Kotlin se integra sin fricciones con Java, lo que permite reutilizar bibliotecas existentes y adoptar Kotlin de forma gradual.  
        - **Sintaxis concisa y expresiva** ‚Üí Reduce la repetici√≥n de c√≥digo, mejora la legibilidad y facilita el mantenimiento de bibliotecas.  
        - **Seguridad frente a nulls** ‚Üí El sistema de tipos de Kotlin previene errores comunes como los `NullPointerException`, fortaleciendo la robustez de las APIs.  
        - **Funciones de extensi√≥n** ‚Üí Permiten ampliar funcionalidades sin modificar las clases originales, lo que resulta √∫til para extender bibliotecas de terceros.  
        - **Compatibilidad multiplataforma** ‚Üí Posibilita crear bibliotecas que funcionan en JVM, JS y Native, fomentando la reutilizaci√≥n de c√≥digo.  
        - **Corrutinas integradas** ‚Üí Facilitan la programaci√≥n as√≠ncrona de manera eficiente y con una sintaxis clara.  
        - **Facilidad para crear DSLs** ‚Üí Kotlin ofrece herramientas para construir APIs m√°s expresivas e idiom√°ticas, mejorando la experiencia de uso.  
    </Pros>
    <Cons>
        - **Falta de algunas abstracciones avanzadas** ‚Üí Kotlin a√∫n no ofrece soporte completo para conceptos como los **Higher-Kinded Types (HKT)** o mecanismos como los **implicits** en Scala.  
        Esta limitaci√≥n es **intencional**: en lugar de incorporar abstracciones complejas o experimentales, Kotlin prioriza aquellas que han demostrado ser √∫tiles y comprensibles en contextos reales.  
        No obstante, ya se est√°n explorando propuestas como los **[context parameters](https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md)**, que podr√≠an habilitar nuevos patrones de dise√±o funcional reutilizable sin sacrificar la claridad del lenguaje.  
        - **Ausencia de pattern matching exhaustivo** ‚Üí Kotlin no cuenta con un sistema de **pattern matching** tan expresivo como el de lenguajes funcionales como Scala, Rust o Haskell.  
        Aunque se pueden utilizar `when` y jerarqu√≠as selladas para lograr cierto control exhaustivo, **no existe una sintaxis declarativa para hacer match de estructuras anidadas ni extraer m√∫ltiples valores simult√°neamente**.
    </Cons>
</ProCons>

A lo largo del curso, aprender√°s a **sacar el m√°ximo provecho de Kotlin** en el dise√±o de bibliotecas, aprovechando sus fortalezas y **encontrando soluciones pragm√°ticas cuando el lenguaje no ofrece una abstracci√≥n directamente**.

## üßÆ Expresiones vs. Declaraciones

Es importante distinguir entre **expresiones** y **declaraciones**, ya que cumplen roles distintos dentro de un programa. En Kotlin, esta diferencia es clara y ayuda a escribir c√≥digo **m√°s seguro y predecible**. Otros lenguajes como Scala o Rust tambi√©n permiten que muchas construcciones sean expresiones, lo que otorga mayor flexibilidad, aunque puede dificultar el seguimiento del flujo de datos si no se usa con cuidado.

<Definition title="Expresiones">
    Las **expresiones** son fragmentos de c√≥digo que **producen un valor** y pueden combinarse con otras expresiones. En Kotlin, una expresi√≥n puede ser tan simple como una constante, o tan compleja como una funci√≥n an√≥nima. Ejemplos comunes son operaciones aritm√©ticas, operadores l√≥gicos y llamadas a funciones.
</Definition>

<Definition title="Declaraciones">
    Las **declaraciones** son instrucciones que **realizan una acci√≥n**, y en general **no se utilizan por su valor**. No pueden combinarse con otras expresiones. Ejemplos incluyen la definici√≥n de variables, la ejecuci√≥n de bucles o la declaraci√≥n de funciones.
</Definition>

Una diferencia clave frente a lenguajes como **Java, C o JavaScript** es que en esos lenguajes **las asignaciones son expresiones**, lo que permite errores como `if (x = 5)` cuando en realidad se quer√≠a comparar (`==`) en lugar de asignar (`=`). En cambio, **en Kotlin las asignaciones son declaraciones**, lo que impide ese tipo de ambig√ºedades y ayuda a detectar errores en tiempo de compilaci√≥n.

A continuaci√≥n, una tabla con ejemplos representativos:

| Ejemplo                      | ¬øExpresi√≥n o declaraci√≥n? | ¬øDevuelve valor?        |
|-----------------------------|---------------------------|-------------------------|
| `val x = 5`                 | Declaraci√≥n               | No                      |
| `5`                         | Expresi√≥n                 | S√≠ (`5`)                |
| `if (a > b) a else b`       | Expresi√≥n                 | S√≠ (valor de `a` o `b`) |
| `fun greet() { println() }` | Declaraci√≥n               | No                      |

:::tip En resumen

- **Las expresiones** devuelven un valor y se pueden usar dentro de otras expresiones.  
- **Las declaraciones** ejecutan acciones y no se pueden componer con otras.

:::

Esta distinci√≥n clara en Kotlin **contribuye a una programaci√≥n m√°s segura, expresiva y menos propensa a errores sutiles**.

## üßµ Interpolaci√≥n de cadenas

La **interpolaci√≥n de cadenas** (tambi√©n conocida como *string templates*) es una caracter√≠stica de Kotlin que permite insertar valores de variables o resultados de expresiones directamente dentro de una cadena (`String`) usando el s√≠mbolo `$`. Para variables simples, basta con escribir `$variable`, mientras que para expresiones m√°s complejas se utilizan llaves: `${expresi√≥n}`.

### ‚öîÔ∏è Ejemplo

En el siguiente ejemplo mostramos el estado de un personaje seg√∫n sus puntos de vida (`hp`):

```kotlin showLineNumbers
val name = "Leif"
val hp = 24

println("Unit: $name | Status: ${if (hp <= 0) "defeated" else "active"}")
```

Esto imprimir√°:

```plaintext
Unit: Leif | Status: active
```

Gracias a la interpolaci√≥n de cadenas, podemos construir mensajes din√°micos **de forma clara, concisa y expresiva**, sin necesidad de concatenar manualmente con operadores como `+`.

Adem√°s, las expresiones interpoladas se eval√∫an **en el momento en que se forma la cadena final**, lo que aporta claridad y eficiencia en tiempo de ejecuci√≥n.

:::tip Sin prefijos especiales

A diferencia de otros lenguajes como **Scala** (`s"Hola, $nombre"`) o **Python** (`f"Hola, {nombre}"`), en Kotlin **no necesitas usar prefijos** como `s` o `f` para habilitar la interpolaci√≥n.

En Kotlin, **todas las cadenas soportan interpolaci√≥n de forma nativa**, sin configuraciones adicionales. Esto simplifica su uso, reduce errores y mejora la legibilidad del c√≥digo.

:::

<details>
    <summary>¬øQu√© es un <code>StringBuilder</code>?</summary>

    Cuando interpolamos cadenas en Kotlin, el compilador genera c√≥digo que utiliza un **`StringBuilder`**, una clase optimizada para construir texto **de forma eficiente y sin crear objetos intermedios innecesarios**.

    Un `StringBuilder` permite **modificar una cadena en memoria** (agregando, insertando o eliminando texto) sin crear un nuevo objeto `String` cada vez. Esto es importante porque en Kotlin (y en Java), las cadenas (`String`) son **inmutables**: cada concatenaci√≥n con `+` crea una nueva instancia.

    Por ejemplo, esta interpolaci√≥n:

    ```kotlin
    val name = "Leif"
    val status = "active"
    val message = "Unit: $name | Status: $status"
    ```

    Se traduce internamente en algo similar a:

    ```kotlin
    val sb = StringBuilder()
    sb.append("Unit: ")
    sb.append(name)
    sb.append(" | Status: ")
    sb.append(status)
    val message = sb.toString()
    ```

    Gracias a esto, la interpolaci√≥n en Kotlin es **m√°s legible que la concatenaci√≥n manual** y **m√°s eficiente que usar `+` repetidamente**.
</details>

## üöÄ Crear tu primer proyecto Kotlin con Gradle

Antes de comenzar a escribir c√≥digo Kotlin, necesitamos configurar un entorno de desarrollo funcional.  
En esta secci√≥n aprender√°s c√≥mo **crear un proyecto Kotlin b√°sico desde la terminal utilizando Gradle**, el sistema de construcci√≥n que usaremos durante el curso.

Te proporcionamos instrucciones espec√≠ficas para Windows, Linux y macOS, adaptadas a los comandos y alias comunes en cada sistema operativo:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title=""
        "intro-kt" | ForEach-Object {
            New-Item -Path $_ -ItemType Directory -Force
            Set-Location $_
        } && gradle init --use-defaults --type kotlin-application
        ```

        <Explanation>
            Este bloque de PowerShell automatiza la creaci√≥n de un proyecto Kotlin utilizando Gradle:

            1. **`"intro-kt" | ForEach-Object { ... }`**: Usa un pipeline para crear y entrar a un directorio llamado `intro-kt`. Aunque aqu√≠ se usa un solo nombre, este patr√≥n permite trabajar con m√∫ltiples nombres si fuera necesario.
            2. **`New-Item -Path $_ -ItemType Directory -Force`**: Crea el directorio. `-Force` evita errores si el directorio ya existe.
            3. **`Set-Location $_`**: Cambia al nuevo directorio.
            4. **`&& gradle init --use-defaults --type kotlin-application`**: Inicializa un proyecto Gradle como aplicaci√≥n Kotlin, con configuraci√≥n por defecto.
        </Explanation>
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash
        dir="intro-kt"
        mkdir -p $dir
        cd $dir
        gradle init --use-defaults --type kotlin-application
        ```

        <Explanation>
            Este comando en Bash automatiza la creaci√≥n de un proyecto Kotlin con Gradle:

            1. **`dir="intro-kt"`**: Define el nombre del nuevo proyecto.
            2. **`mkdir -p $dir`**: Crea el directorio (sin fallar si ya existe).
            3. **`cd $dir`**: Entra al directorio.
            4. **`gradle init --use-defaults --type kotlin-application`**: Inicializa un proyecto de aplicaci√≥n b√°sica con estructura Kotlin.
        </Explanation>
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash
        dir="intro-kt"
        mkdir -p $dir
        cd $dir
        gradle init --use-defaults --type kotlin-application
        ```

        <Explanation>
            Este comando en Bash automatiza la creaci√≥n de un proyecto Kotlin con Gradle:

            1. **`dir="intro-kt"`**: Define el nombre del nuevo proyecto.
            2. **`mkdir -p $dir`**: Crea el directorio (sin fallar si ya existe).
            3. **`cd $dir`**: Entra al directorio.
            4. **`gradle init --use-defaults --type kotlin-application`**: Inicializa un proyecto de aplicaci√≥n b√°sica con estructura Kotlin.
        </Explanation>
    </TabItem>
</BoxedTabs>

Por ahora, crearemos una **aplicaci√≥n de consola** para probar nuestro c√≥digo. M√°s adelante aprenderemos a utilizar Gradle para construir **bibliotecas de software** reutilizables.

Una vez creado el proyecto, puedes abrirlo con **IntelliJ IDEA**, **Fleet** u otro editor. A√∫n no necesitas comprender a fondo la estructura del proyecto, pero es √∫til tener en cuenta sus directorios principales:

- El c√≥digo fuente est√° en `app/src/main/kotlin`.
- Las pruebas se ubican en `app/src/test/kotlin`.

Si est√°s usando IntelliJ IDEA y tienes disponible la herramienta `idea` en tu terminal, puedes abrir el proyecto con el siguiente comando:

```bash
idea .
```

<Explanation>
    Este comando abre el proyecto actual en IntelliJ IDEA, siempre que tengas habilitado el [Command Line Launcher](https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html) (`idea`). Puedes activarlo desde el men√∫ `Tools > Create Command-line Launcher`.
</Explanation>

---

## üß† Ejercicio de cierre: Un "Hello, World" con sentido

Ya creaste tu primer proyecto en Kotlin. Ahora es momento de **darle voz propia**. Tu tarea consiste en **explorar la estructura del proyecto**, encontrar el **punto de entrada del programa**, y modificarlo para que imprima un mensaje **aut√©ntico y significativo para ti**.

No se trata de un simple `"Hello, World"`, sino de una frase que te represente: una letra de canci√≥n que te acompa√±a, una cita de tu c√≥mic favorito, una l√≠nea que solo quienes jugaron *ese* juego entender√°n, o incluso algo que hayas escrito t√∫.

#### üõ†Ô∏è Para ejecutar el programa, usa:

```bash
./gradlew :app:run
```

Si todo est√° bien configurado, tu mensaje aparecer√° en la consola ‚ú®

:::tip Recuerda

    No necesitas crear clases adicionales ni preocuparte por la estructura ideal, ¬°solo divi√©rtete explorando el lenguaje!

:::

<Solution>

    Una soluci√≥n posible ‚Äîcon un toque literario‚Äî podr√≠a ser:

    <BoxedTabs>

        <TabItem label="C√≥digo esencial" value="C√≥digo esencial">

            ```kotlin showLineNumbers title="app/src/main/kotlin/org/example/App.kt"
            val greeting: String
                get() = "Ladies and Gentlemen, I give you Rose Red's killer..."
            ```

        </TabItem>

        <TabItem label="C√≥digo completo" value="C√≥digo completo">

            ```kotlin showLineNumbers title="app/src/main/kotlin/org/example/App.kt"
            package org.example

            class App {
                val greeting: String
                    get() = "Ladies and Gentlemen, I give you Rose Red's killer..."
            }

            fun main() {
                println(App().greeting)
            }
            ```

        </TabItem>

    </BoxedTabs>

</Solution>

---

<ExcludeFromReadingTime>

    ## üìñ Referencias

    ### üî• Recomendadas

    - üåê [Basic types](https://kotlinlang.org/docs/kotlin-tour-basic-types.html) en la **documentaci√≥n oficial de Kotlin**: Introduce los tipos b√°sicos del lenguaje (enteros, flotantes, booleanos, caracteres y cadenas), junto con la inferencia de tipos, inicializaci√≥n de variables y operadores compuestos.
    - üìö *"Kotlin basics"* (pp. 17‚Äì43) en *Kotlin in Action* por **Dmitry Jemerov y Svetlana Isakova**.
    - üìö *"Kotlin: What and why"* (pp. 3‚Äì16) en *Kotlin in Action* por **Dmitry Jemerov y Svetlana Isakova**.

    ### üîπ Adicionales

    - üåê [Introduction‚ÄîKotlin language specification](https://kotlinlang.org/spec/introduction.html) en la **documentaci√≥n oficial de Kotlin**.
    - üåê [Kotlin (programming language)](https://en.wikipedia.org/w/index.php?title=Kotlin_(programming_language)&oldid=1282501713) en **Wikipedia**.
    - üåê [Strings | Kotlin](https://kotlinlang.org/docs/strings.html) en la **documentaci√≥n oficial de Kotlin**.
    - üé• [Kotlin in Action, Second Edition - First Chapter Summary](https://www.youtube.com/watch?v=EaenOVzxUDc) (3m36s) en *YouTube* por **Manning Publications**.

</ExcludeFromReadingTime>
