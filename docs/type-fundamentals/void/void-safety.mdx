---
title: Void-safety
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard, CSharpCard, EiffelCard, RustCard, SwiftCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="" />

Los punteros o referencias nulas ‚Äîdescritos por Tony Hoare como "[el error de mil millones de d√≥lares](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)"‚Äî son una fuente com√∫n de errores en tiempo de ejecuci√≥n. Este problema ocurre cuando una variable que se espera contenga una referencia v√°lida, en realidad contiene un valor nulo. Al intentar acceder a sus m√©todos o propiedades, se producen fallos cr√≠ticos.

En el contexto del desarrollo de **bibliotecas de software**, estos errores pueden ser a√∫n m√°s problem√°ticos: no solo afectan al c√≥digo interno de la biblioteca, sino tambi√©n a quienes la utilizan. Una biblioteca que no gestiona adecuadamente la nulabilidad puede propagar errores dif√≠ciles de diagnosticar y comprometer la estabilidad de m√∫ltiples proyectos.

## üß≠ Motivaci√≥n

El manejo inadecuado de valores nulos es una de las principales causas de errores en tiempo de ejecuci√≥n, dif√≠ciles de detectar y potencialmente devastadores para la estabilidad y seguridad del software. En proyectos grandes, estos fallos son m√°s frecuentes, m√°s costosos de corregir y m√°s dif√≠ciles de rastrear.

Cuando se trata de desarrollar **bibliotecas de software**, el riesgo se amplifica: una mala gesti√≥n de la nulabilidad puede propagarse hacia todas las aplicaciones que dependen de ella. Por eso, gestionar correctamente los valores nulos no es solo una buena pr√°ctica, sino una necesidad para garantizar **la calidad, la previsibilidad y la fiabilidad de las APIs que ofrecemos a otras personas**.

## üåê Enfoques en Diferentes Lenguajes

- **Java**: Las referencias nulas son habituales y no existen garant√≠as de seguridad en el sistema de tipos. Esto obliga a realizar verificaciones manuales frecuentes, lo que genera c√≥digo redundante, propenso a errores y dif√≠cil de mantener. Las excepciones `NullPointerException` son comunes si no se manejan correctamente.
- **Swift**: Introduce el concepto de **opcionales** (`Optional`), que deben declararse expl√≠citamente con `?`. Para acceder de forma segura al valor, se requiere *unwrap* mediante `if let`, `guard let` o el uso de operadores seguros. Esto obliga a un manejo expl√≠cito y consciente de la nulabilidad, promoviendo APIs m√°s seguras.
- **Scala**: Utiliza el tipo `Option`, que representa la presencia (`Some`) o ausencia (`None`) de un valor. Aunque mejora la expresividad y evita muchos errores, no previene completamente el uso de `null`, ya que es posible encapsular valores nulos dentro de `Some(null)` si no se tiene cuidado.
- **Rust**: El lenguaje no incluye el concepto de `null`. En su lugar, todo valor que podr√≠a estar ausente debe representarse expl√≠citamente con el tipo `Option<T>`, que obliga a manejar ambos casos (`Some` y `None`) en tiempo de compilaci√≥n. Al no permitir referencias nulas, Rust garantiza *null safety* a nivel del sistema de tipos, lo que elimina por completo la posibilidad de errores por acceso a valores nulos.

<details>
    <summary>
        Un poco de historia: Self programming language
    </summary>

    **Self**, un lenguaje de programaci√≥n basado en prototipos, fue uno de los primeros en enfrentar el problema de la **void safety** (seguridad frente a valores nulos), aunque con un enfoque muy distinto al de los lenguajes modernos. A diferencia de sistemas m√°s estructurados ‚Äîcomo los tipos anulables de Kotlin o los contratos de Eiffel‚Äî, **Self** abordaba este problema mediante el **env√≠o din√°mico de mensajes** y el comportamiento de los objetos, sin necesidad de comprobaciones expl√≠citas o tipos especiales.

    #### ¬øC√≥mo enfrentaba Self el problema de *void safety*?

    1. **Todo es un objeto**: En **Self**, absolutamente todo ‚Äîincluidos los valores que en otros lenguajes podr√≠an ser nulos‚Äî es un objeto. No existe el concepto de "valor vac√≠o" o "puntero nulo" como tal, lo que elimina de ra√≠z muchos de los problemas asociados a referencias nulas.
    2. **Env√≠o de mensajes a objetos ausentes**: Si un objeto esperado no est√° presente, **Self** no lanza un error ni una excepci√≥n. En su lugar, simplemente **env√≠a un mensaje** al objeto ausente. Gracias a su sistema din√°mico de env√≠o de mensajes, si un objeto no responde a un mensaje, es posible definir un comportamiento predeterminado o redirigir el mensaje a otro objeto.
        - **Delegaci√≥n din√°mica**: Cuando un objeto no implementa un determinado m√©todo, puede delegar ese mensaje a otro objeto que s√≠ lo haga. Esta idea se asemeja a los mecanismos modernos como `Option` o `Result`, donde la l√≥gica se deriva seg√∫n la presencia o ausencia de un valor.
    3. **Un enfoque flexible por dise√±o**: En vez de requerir verificaciones expl√≠citas sobre la nulabilidad, el sistema de mensajes de Self asume la responsabilidad de gestionar ausencias. La falta de un objeto no se considera un error cr√≠tico, sino una situaci√≥n que el lenguaje maneja de forma flexible y din√°mica.

    #### Ejemplo de comparaci√≥n

    - En lenguajes como **Java**, la ausencia de un valor (nulo) suele causar una excepci√≥n `NullPointerException`, a menos que se verifique manualmente antes de cada acceso.
    - En **Self**, la ausencia de un valor no se trata como un error fatal: el sistema simplemente **env√≠a un mensaje** al objeto (aunque est√© ausente) y permite definir un comportamiento din√°mico para manejar estos casos sin comprobaciones expl√≠citas.

    Este enfoque flexible y din√°mico permiti√≥ evitar muchos errores comunes asociados a valores nulos, aunque no con la misma **rigurosidad est√°tica** que ofrecen los sistemas de tipos modernos que garantizan *void safety* mediante verificaci√≥n en tiempo de compilaci√≥n.

    Aqu√≠ tienes un ejemplo de c√≥mo **Self** manejaba el problema de **void safety** mediante el env√≠o de mensajes y la delegaci√≥n din√°mica:

    ```self showLineNumbers
    (|
        "Definimos un objeto llamado 'persona'"
        persona = (|
            nombre = 'Alice'.

            "Este m√©todo imprime el nombre de la persona"
            saludar = (|
                'Hola, ', nombre print.
            |).
        |).

        "Definimos otro objeto llamado 'sinNombre' que no tiene un nombre, pero responde a los mismos mensajes"
        sinNombre = (|
            "Si intentamos acceder al nombre, este objeto responder√° de forma predeterminada"
            nombre = 'Nombre desconocido'.
        |).

        "Definimos un objeto 'handler' que delega los mensajes"
        handler = (|
            personaOMetodo = nil.

            "Este m√©todo env√≠a el mensaje 'saludar' al objeto correcto"
            manejarSaludo = (|
                (personaOMetodo saludar) ifError: [ 'El objeto no respondi√≥ al mensaje.' print ].
            |).
        |).
    |)

    "Configuramos el handler para usar la persona"
    handler personaOMetodo: persona.
    handler manejarSaludo.  "Resultado: 'Hola, Alice'"

    "Ahora configuramos el handler para usar el objeto sin nombre"
    handler personaOMetodo: sinNombre.
    handler manejarSaludo.  "Resultado: 'Hola, Nombre desconocido'"

    "Si no se asigna un objeto, el sistema maneja el error din√°micamente"
    handler personaOMetodo: nil.
    handler manejarSaludo.  "Resultado: 'El objeto no respondi√≥ al mensaje.'"
    ```

    <Explanation>
        Este ejemplo muestra c√≥mo **Self** maneja la ausencia de objetos sin necesidad de estructuras de control expl√≠citas como `if` o `null checks`.

        - **`persona`** define un objeto con una propiedad `nombre` y un m√©todo `saludar`, que imprime un saludo personalizado.
        - **`sinNombre`** es otro objeto que tambi√©n responde al mensaje `nombre`, pero con un valor por defecto.
        - **`handler`** es un objeto que almacena una referencia (`personaOMetodo`) y delega la llamada al m√©todo `saludar`. Si la referencia no responde (por ejemplo, si es `nil`), Self ejecuta el bloque proporcionado a `ifError:` en lugar de lanzar una excepci√≥n.

        Este enfoque din√°mico:
        - Elimina errores por referencias nulas al permitir manejar fallas en tiempo de ejecuci√≥n de forma controlada.
        - Promueve un estilo de programaci√≥n basado en mensajes y delegaci√≥n, en lugar de verificaciones expl√≠citas.
        - Sirve como inspiraci√≥n para estructuras modernas como `Option`, `Result`, o el operador seguro `?.` en Kotlin.

        La clave est√° en que el **sistema de mensajes de Self trata la ausencia como parte del flujo normal del lenguaje**, no como una excepci√≥n.
    </Explanation>
</details>

## üõ°Ô∏è Soluci√≥n en Kotlin: Seguridad de Tipos frente a Nulos

Kotlin implementa un sistema de tipos que distingue entre referencias anulables y no anulables, lo que permite prevenir en tiempo de compilaci√≥n la mayor√≠a de los errores por acceso a valores nulos, como el cl√°sico `NullPointerException`.

Este enfoque no solo mejora la robustez del c√≥digo, sino que tambi√©n es especialmente √∫til al dise√±ar bibliotecas reutilizables, ya que obliga a quienes las usan a manejar expl√≠citamente la nulabilidad esperada de cada valor.

### üß¨ Tipos anulables y no anulables

En Kotlin, las variables son **no anulables por defecto**, lo que significa que no pueden contener `null` a menos que se indique expl√≠citamente con el modificador `?`. Esto introduce garant√≠as de seguridad desde el sistema de tipos:

```kotlin
var a: String = "Not null"
var b: String? = "Maybe null"

a = null    // ‚ùå Error: 'a' is not nullable
b = null    // ‚úÖ Permitido: 'b' es nullable
```

<Explanation>
    En este ejemplo:

    - `a` tiene el tipo `String`, por lo que nunca puede almacenar `null`.
    - `b` tiene el tipo `String?`, lo que indica que puede ser `String` o `null`.

    Estas anotaciones expl√≠citas permiten a Kotlin detectar posibles errores en tiempo de compilaci√≥n y forzar a quien usa la biblioteca a tratar los casos anulables de forma segura.
</Explanation>

### üß† Inferencia de tipos y nulabilidad

La inferencia de tipos en Kotlin tambi√©n respeta la distinci√≥n entre tipos anulables y no anulables, aplicando las mismas reglas que con declaraciones expl√≠citas:

```kotlin
var c = "Hello" // Tipo inferido: String (no nullable)
c = null        // ‚ùå Error: 'c' no puede ser null
```

:::info Explicaci√≥n

Kotlin infiere que `c` es de tipo `String` (no anulable) a partir del valor asignado. Como no se us√≥ `?`, el compilador no permitir√° asignarle `null` m√°s adelante. Esto demuestra c√≥mo la inferencia no compromete la seguridad frente a nulos.

:::

### üõ° Llamadas Seguras en Kotlin

Kotlin gestiona la nulabilidad de manera expl√≠cita, evitando accesos inseguros a m√©todos o propiedades. Si una variable puede ser nula, debes verificar su estado antes de usarla:

```kotlin
val a: String? = TODO()
if (a != null) {
    println(a.length) // ‚úÖ Acceso seguro
} else {
    println("a is null")
}
```

:::note Smart Casts

Kotlin emplea los [Smart Casts](https://kotlinlang.org/docs/typecasts.html#smart-casts) para convertir autom√°ticamente una variable anulable a no anulable despu√©s de una verificaci√≥n de nulabilidad.

En el ejemplo anterior, tras comprobar que `a` no es `null`, el compilador infiere que `a` es de tipo `String` dentro del bloque `if`, permitiendo el acceso seguro a sus propiedades sin necesidad de cast expl√≠cito.

<details>
    <summary>¬øQu√© es el flow typing?</summary>

    Kotlin aplica lo que se conoce como **flow typing** o *tipado por flujo*: el compilador ajusta din√°micamente el tipo de una variable a lo largo del flujo de ejecuci√≥n del programa.

    Por ejemplo, si verificas que una variable no es `null` o que es de cierto tipo (`is String`), el compilador autom√°ticamente refina el tipo dentro de ese bloque:

    ```kotlin
    fun process(x: Any?) {
        if (x is String) {
            // x es tratado como String aqu√≠
            println(x.length)
        }
    }
    ```

    Esto mejora la seguridad y evita la necesidad de casting expl√≠cito o uso excesivo de `as`.
</details>

:::


Para simplificar este patr√≥n, Kotlin ofrece el **operador de llamada segura** (`?.`), que solo accede a la propiedad si la variable no es `null`:

```kotlin
println(a?.length)
```

<Explanation>
    `a?.length` devuelve `null` si `a` es nulo. De esta forma, se evita un posible `NullPointerException` sin necesidad de una verificaci√≥n expl√≠cita.
</Explanation>

#### üîç Funci√≥n `let`

La funci√≥n `let` es √∫til para ejecutar un bloque de c√≥digo **solo cuando una variable no es nula**. Este m√©todo toma el valor no nulo y lo pasa como argumento al bloque:

```kotlin
a?.let { str -> println(str.length) }
```

<Explanation>
    En este caso, si `a` no es nulo, su valor se pasa al bloque como `str`. Dentro del bloque, puedes acceder a `str` de forma segura.  
    Si `a` es nulo, el bloque simplemente no se ejecuta.
</Explanation>

Esto convierte a `let` en una herramienta concisa y segura para trabajar con valores opcionales, evitando verificaciones manuales y mejorando la legibilidad del c√≥digo.

:::note Variable impl√≠cita `it`

Cuando se pasa un solo par√°metro a una lambda en Kotlin, puedes usar la variable impl√≠cita `it` en lugar de nombrarla manualmente.

Por ejemplo:

```kotlin
a?.let { println(it.length) }
```

Esto es equivalente a:

```kotlin
a?.let { str -> println(str.length) }
```

El uso de `it` reduce la verbosidad y hace el c√≥digo m√°s idiom√°tico.

:::

### ü™ô Operador Elvis

El operador **Elvis** (`?:`) proporciona una forma concisa de manejar valores nulos, al permitir **retornar un valor por defecto** cuando una expresi√≥n es `null`:

```kotlin
val a: String? = TODO()
val l = a?.length ?: -1
```

<Explanation>
    En este ejemplo:

    - Si `a` no es nulo, `a?.length` devuelve la longitud de la cadena, y ese valor se asigna a `l`.
    - Si `a` es nulo, la expresi√≥n despu√©s del `?:` se eval√∫a y `l` toma el valor `-1`.

    Este operador es muy √∫til para evitar estructuras condicionales innecesarias, haciendo que el c√≥digo sea m√°s conciso y expresivo.
</Explanation>

## üß™ Ejercicio: Manejo seguro de cadenas opcionales

<Exercise>
    Crea una funci√≥n `procesarCadenas: (List<String?>) -> Unit` que reciba una lista de cadenas opcionales. Para cada elemento:

    - Si la cadena no es nula, imprime su longitud y su valor en may√∫sculas.
    - Si la cadena es nula, imprime el mensaje `"Cadena no disponible"`.
    
    <Hint hints={[
        <>
            Puedes usar la funci√≥n <code>uppercase: String.() -&gt; String</code> para convertir cadenas a may√∫sculas.
        </>,
    ]}/>

    <Solution>
        ```kotlin
        fun procesarCadenas(cadenas: List<String?>) {
            for (cadena in cadenas) {
                cadena?.let {
                    println("Largo de la cadena: ${it.length}")
                    println("Texto en may√∫sculas: ${it.uppercase()}")
                } ?: println("Cadena no disponible")
            }
        }

        fun main() {
            val cadenas = listOf("Hola", null, "Kotlin", null, "Mundo")
            procesarCadenas(cadenas)
        }
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

A lo largo de esta lecci√≥n, exploramos el concepto de **void-safety** y su importancia en el desarrollo de software ‚Äîespecialmente en la creaci√≥n de bibliotecas reutilizables, donde el mal manejo de referencias nulas puede propagarse y afectar a m√∫ltiples aplicaciones.

Vimos c√≥mo distintos lenguajes han abordado este problema, desde enfoques din√°micos como el de **Self**, hasta soluciones modernas y seguras como las de **Rust** y **Kotlin**, que integran el control de nulabilidad en sus sistemas de tipos.

Kotlin, en particular, nos ofrece herramientas expresivas y seguras como tipos anulables, operadores seguros (`?.`, `?:`), y funciones como `let`, que nos permiten dise√±ar APIs robustas y f√°ciles de usar sin comprometer la seguridad.

### üîë Puntos clave

- **Las referencias nulas son una fuente com√∫n de errores en tiempo de ejecuci√≥n**, y evitarlas es una prioridad en el dise√±o de software seguro.
- **Lenguajes como Swift, Scala, Rust y Kotlin han adoptado mecanismos distintos** para manejar la nulabilidad, obligando a que quien desarrolla reconozca y gestione expl√≠citamente los valores opcionales.
- **Kotlin garantiza la seguridad frente a nulos en tiempo de compilaci√≥n**, evitando muchos errores comunes y facilitando el dise√±o de bibliotecas seguras y confiables.

### üß∞ ¬øQu√© nos llevamos?

El manejo expl√≠cito y seguro de valores nulos no es solo un detalle t√©cnico, sino una decisi√≥n de dise√±o fundamental en la construcci√≥n de bibliotecas reutilizables. Herramientas como el sistema de tipos de Kotlin no solo nos ayudan a prevenir errores, sino que tambi√©n **nos obligan a ser m√°s precisos y honestos en nuestras APIs**: si algo puede ser nulo, debe declararse; si no, el sistema lo garantizar√°.

Adoptar este enfoque no solo mejora la calidad de nuestro c√≥digo, sino que **genera confianza** en quienes usan nuestras bibliotecas. Porque escribir c√≥digo sin errores no basta: tambi√©n debemos dise√±arlo para que sea dif√≠cil usarlo mal.

<div className="language-card-container">
    <CSharpCard link="/docs/type-fundamentals/void/csharp"/>
    <EiffelCard link="/docs/type-fundamentals/void/eiffel"/>
    <RustCard link="/docs/type-fundamentals/void/rust"/>
    <SwiftCard link="/docs/type-fundamentals/void/swift"/>
</div>

## üìñ Referencias

### üî• Recomendadas

- üåê Null safety | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 29 de marzo de 2025, de https://kotlinlang.org/docs/null-safety.html
