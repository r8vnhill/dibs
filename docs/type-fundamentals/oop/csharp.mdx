---
title: Introducci√≥n a la programaci√≥n orientada a objetos en C#
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="csharp-dibs" />

Esta secci√≥n complementa lo aprendido en Kotlin al explorar c√≥mo se expresan los mismos conceptos en **C#**, un lenguaje fuertemente orientado a objetos con un sistema de tipos y sintaxis similares en muchos aspectos. Veremos qu√© se puede hacer en uno u otro lenguaje, y en qu√© se diferencian.

## üßç Singleton

En C#, un singleton se implementa con una combinaci√≥n de constructor privado, una propiedad est√°tica, y control de concurrencia (opcionalmente).

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```csharp showLineNumbers
        public class MySingleton
        {
            private MySingleton() { }

            public static MySingleton Instance { get; } = new MySingleton();
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```csharp showLineNumbers title="OOP/MySingleton.cs"
        namespace OOP;

        public class MySingleton
        {
            public string Name { get; set; } = "Singleton";

            private MySingleton() { }

            public static MySingleton Instance { get; } = new MySingleton();

            public string Greet() => $"Hello, {Name}";
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este patr√≥n asegura que solo exista **una √∫nica instancia** de la clase durante la ejecuci√≥n del programa. Se logra declarando una **propiedad est√°tica** (`Instance`) que se inicializa en el momento en que se carga la clase, y un **constructor privado** que impide crear instancias desde fuera.

    La propiedad `Instance` act√∫a como **punto de acceso global** al singleton. Dado que es una propiedad con inicializaci√≥n directa (`get; } = new ...`), la instancia se crea de forma **segura y garantizada por el runtime**, incluso en contextos **multihilo**, sin necesidad de mecanismos adicionales de sincronizaci√≥n.
</Explanation>


### Ejemplo de uso

```csharp
var singleton = MySingleton.Instance;
singleton.Name = "Power";
Console.WriteLine(singleton.Greet()); // Output: Hello, Power

var other = MySingleton.Instance;
other.Name = "Makima";
Console.WriteLine(other.Greet()); // Output: Hello, Makima

Console.WriteLine(singleton.Greet()); // Output: Hello, Makima (same instance)
```

<Explanation>  
    Este ejemplo muestra que `MySingleton.Instance` siempre devuelve la **misma instancia**. Al modificar `Name` desde cualquier variable, el cambio se refleja en todas, porque comparten el mismo objeto. Esto valida que es un verdadero **singleton**.
</Explanation>

### ¬øQu√© pasa en entornos multihilo?

El patr√≥n singleton garantiza una √∫nica instancia, pero **no garantiza seguridad frente a modificaciones simult√°neas**. En el ejemplo anterior, si m√∫ltiples hilos acceden y modifican la propiedad `Name` al mismo tiempo, puede generarse una [condici√≥n de carrera](https://es.wikipedia.org/wiki/Condici%C3%B3n_de_carrera).

Esto ocurre porque `Name` es una propiedad mutable compartida globalmente. En contextos multihilo, esto equivale a tener una **variable global modificable** que puede cambiar de forma impredecible seg√∫n el orden de ejecuci√≥n de los hilos.

Para evitar estos problemas se recomienda:

- Hacer los singletons **inmutables**.
- Usar **sincronizaci√≥n** (`lock`, `Monitor`, etc.) si es necesario modificar estado compartido.
- Utilizar tipos **thread-safe** como `ConcurrentDictionary` o `ImmutableList`.
- O emplear un singleton con **estado encapsulado por actor**, como en arquitecturas basadas en mensajes.

<details>
    <summary>¬øY si quiero inicializaci√≥n tard√≠a + control de concurrencia?</summary>

    Una alternativa segura y flexible es usar `Lazy<T>`:

    ```csharp showLineNumbers
    public class MySingleton
    {
        private static readonly Lazy<MySingleton> lazy =
            new(() => new MySingleton());

        public static MySingleton Instance => lazy.Value;

        private MySingleton() { }
    }
    ```

    Esto garantiza que la instancia se crea **una sola vez**, solo cuando se accede por primera vez, y de forma segura incluso en contextos **multihilo**.
</details>

## üë§ Clases

```csharp
public class Person
{
    public string Name { get; }

    public Person(string name) => Name = name;

    public string Greet() => $"Hello, {Name}";
}
```

<Explanation>
    
</Explanation>

## üéõÔ∏è Interfaces

```csharp
public interface IGreeter
{
    string Greet();
}

public interface IWalker
{
    string Walk();
}

public class Person : IGreeter, IWalker
{
    public string Name { get; }

    public Person(string name) => Name = name;

    public string Greet() => $"Hello, {Name}";
    public string Walk() => "Walking...";
}
```

**Comparaci√≥n**:
- C# permite implementar m√∫ltiples interfaces, igual que Kotlin.
- Desde C# 8.0, tambi√©n se pueden definir implementaciones por defecto en interfaces (como en Kotlin), pero es menos com√∫n en la pr√°ctica.

---

## üß± Clases abstractas

```csharp
public abstract class AbstractAnimal
{
    public abstract string Sound();
    public virtual string Walk() => "Walking...";
}

public class Dog : AbstractAnimal
{
    public override string Sound() => "Woof";
}
```

**Comparaci√≥n**:
- Las clases abstractas en C# son conceptualmente id√©nticas a las de Kotlin.
- Se usan `abstract` y `virtual` para permitir o exigir la implementaci√≥n de m√©todos.

---

## üîê Encapsulaci√≥n y visibilidad

```csharp
public class Person
{
    private int age;
    public string Name { get; }

    public Person(string name, int age)
    {
        if (age < 0)
            throw new ArgumentException("Age must be non-negative");

        this.Name = name;
        this.age = age;
    }
}
```

**Comparaci√≥n**:
- En C#, `private`, `protected`, `internal` y `public` tienen un significado similar.
- A diferencia de Kotlin, C# **s√≠** tiene `internal` y `protected internal` con sem√°ntica m√°s extensa.
- No existe un modificador equivalente a `package-private` de Java (al igual que Kotlin).

---

## üèóÔ∏è Constructores

```csharp
public class Person
{
    public string Name { get; }
    public int Age { get; }

    public Person(string name) : this(name, 0) { }

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

**Comparaci√≥n**:
- C# no tiene constructores primarios.
- Usa **sobrecarga de constructores** en lugar de par√°metros por defecto (aunque C# tambi√©n permite valores por defecto desde C# 4.0).
- Kotlin permite una escritura m√°s compacta usando valores por defecto.

---

## ‚öñÔ∏è ¬øQu√© se puede hacer en uno pero no en el otro?

| Concepto                        | Kotlin                                      | C#                                             |
|--------------------------------|---------------------------------------------|------------------------------------------------|
| `object` como singleton        | ‚úÖ S√≠, con palabra clave `object`           | ‚ùå No directamente. Se necesita patr√≥n manual. |
| Constructores primarios        | ‚úÖ S√≠                                       | ‚ùå No                                           |
| Par√°metros por defecto         | ‚úÖ S√≠, ampliamente usado                    | ‚úÖ Desde C# 4.0, pero menos com√∫n               |
| Interfaces con default methods | ‚úÖ S√≠                                       | ‚úÖ Desde C# 8.0                                 |
| `sealed` por defecto en jerarqu√≠as | ‚úÖ `sealed` controla herencia cerrada   | ‚úÖ `sealed` existe, pero se usa menos          |
| Delegaci√≥n de implementaci√≥n   | ‚úÖ Con `by`                                 | ‚ùå No tiene una construcci√≥n nativa             |
