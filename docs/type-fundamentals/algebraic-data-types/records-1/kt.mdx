---
title: Tipos producto como registros y data class
sidebar_label: Registros y data class
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'

<ReadingTime />

En la lecci√≥n anterior exploramos c√≥mo las **clases comunes en Kotlin** pueden utilizarse para representar **tipos producto**: estructuras que agrupan m√∫ltiples valores en una sola entidad, como `Position(x, y)` o `Person(name, age)`. Aprendimos a nombrar expl√≠citamente cada campo y a encapsular l√≥gica relevante dentro de la clase, superando las limitaciones de estructuras gen√©ricas como `Pair` o `Triple`.

En esta lecci√≥n llevaremos esa idea un paso m√°s all√°, introduciendo el concepto de **registro** (*record*) como una abstracci√≥n com√∫n a muchos lenguajes de programaci√≥n funcional y orientada a datos. Veremos c√≥mo Kotlin ofrece un soporte nativo y expresivo para este patr√≥n mediante las **`data class`**, y qu√© ventajas nos entrega respecto a las clases tradicionales.

Nuestro objetivo ser√° comprender c√≥mo los registros y las `data class` permiten representar tipos producto de forma **m√°s declarativa, segura y reutilizable**, especialmente en el contexto del dise√±o de bibliotecas.

## üìò ¬øQu√© es un registro (record)?

En programaci√≥n, un **registro** (o *record*) es un tipo de dato compuesto que **agrupa m√∫ltiples valores bajo una misma entidad**, donde **cada valor tiene un nombre expl√≠cito**. Es una forma de representar **datos estructurados**, es decir, informaci√≥n que no solo tiene contenido, sino tambi√©n una **intenci√≥n sem√°ntica clara**.

Desde el punto de vista de la teor√≠a de tipos, un registro es un caso particular de un **tipo producto**: un tipo que **contiene simult√°neamente un valor para cada uno de sus campos**.

Por ejemplo, para representar una coordenada en dos dimensiones, podr√≠amos definir un registro con los campos `x` e `y`:

```kotlin title="Registro como coordenada bidimensional"
val point = Coordinate(x = 2, y = 5)
```

A diferencia de una lista o una tupla, un registro **asocia un nombre a cada componente**, lo que mejora la legibilidad, facilita el mantenimiento del c√≥digo y deja m√°s claro el prop√≥sito de cada campo. Esto resulta especialmente √∫til al dise√±ar **tipos reutilizables en bibliotecas**.

### üÜö ¬øEn qu√© se diferencia de una clase u objeto?

Aunque un **registro** puede parecerse a una clase, su prop√≥sito es m√°s espec√≠fico y limitado:

| Caracter√≠stica              | Clases tradicionales                     | Registros (`record`, `data class`, etc.)     |
|----------------------------|------------------------------------------|----------------------------------------------|
| Prop√≥sito                  | Modelar **entidades** con comportamiento | Modelar **datos estructurados**              |
| Comparaci√≥n (`==`)         | Por **referencia** (por defecto)         | Por **contenido** (por campos)               |
| Mutabilidad                | Pueden tener estado mutable              | Usualmente **inmutables** por convenci√≥n     |
| L√≥gica interna             | Contienen m√∫ltiples m√©todos y estados    | Enfocados en **almacenar y exponer datos**   |

:::tip En resumen

Una **clase** modela una entidad con identidad, estado interno y comportamiento.

Un **registro** modela una **colecci√≥n de datos con nombre**, sin l√≥gica compleja, comparable **por valor**, y pensada para representar estructuras "planas" y **transparentes en su prop√≥sito**.

:::

### üåç Registros en otros lenguajes

Distintos lenguajes ofrecen mecanismos propios para definir registros:

- En **Haskell** y **ML**, los *records* son estructuras inmutables con campos nombrados.
- En **Python**, estructuras como `namedtuple`, `dataclass` o `attrs` permiten lograr un comportamiento similar.
- En **Java**, desde la versi√≥n 16, los `record` proporcionan una forma concisa de declarar clases centradas en datos.
- En **Scala**, las `case class` cumplen este rol de manera idiom√°tica.
- En **Kotlin**, el equivalente directo y expresivo son las `data class`.

Todos estos mecanismos comparten una idea com√∫n: representar datos con sem√°ntica clara, m√≠nima l√≥gica y comportamiento generado autom√°ticamente.

## üì¶ ¬øQu√© es una `data class`?

En Kotlin, una `data class` es la forma idiom√°tica de definir registros. Al marcar una clase como `data`, el compilador genera autom√°ticamente:

- `equals()` y `hashCode()` para comparar objetos por contenido (ideal para usar como claves de mapas, sets o caching).
- `toString()` para imprimir representaciones legibles (√∫til en logs, depuraci√≥n o documentaci√≥n).
- `copy()` para clonar objetos inmutables con ligeras modificaciones.
- Funciones `componentN()` para desestructurar valores f√°cilmente en funciones y expresiones.

Estas caracter√≠sticas hacen que las `data class` sean ideales para representar **datos estructurados** con intenci√≥n sem√°ntica clara y un **contrato de igualdad por valor**.

```kotlin showLineNumbers title="Definici√≥n de un mago como data class"
data class Wizard(
    val name: String,
    val magic: String,
    val powerLevel: Int
)
```

Este tipo representa el producto:

$$
\text{String} \times \text{String} \times \text{Int}
$$

Cada instancia combina un nombre, un tipo de magia y un nivel de poder.

### üé≠ Sin `data class`

Este ejemplo muestra c√≥mo ser√≠a implementar manualmente una clase que represente un registro. Aunque es completamente v√°lido, resulta **verboso** y **repetitivo**, especialmente si lo comparamos con una `data class`, que genera todo este c√≥digo autom√°ticamente:

```kotlin showLineNumbers title="Definici√≥n de un mago como clase normal"
class Wizard(
    val name: String,
    val magic: String,
    val powerLevel: Int
) {
    fun copy(
        name: String = this.name,
        magic: String = this.magic,
        powerLevel: Int = this.powerLevel
    ): Wizard {
        return Wizard(name, magic, powerLevel)
    }

    operator fun component1(): String = name
    operator fun component2(): String = magic
    operator fun component3(): Int = powerLevel

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Wizard) return false

        return name == other.name && 
               magic == other.magic && 
               powerLevel == other.powerLevel
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + magic.hashCode()
        result = 31 * result + powerLevel
        return result
    }

    override fun toString(): String {
        return "Wizard(name='$name', magic='$magic', powerLevel=$powerLevel)"
    }
}
```

:::tip ¬øPor qu√© importa?

Este ejemplo es √∫til para entender qu√© genera una `data class` "por debajo".
Usar `data` no solo reduce el c√≥digo, sino que **garantiza un comportamiento uniforme y correcto**, evitando errores humanos en m√©todos como `equals` o `hashCode`.

:::

<details>
    <summary>
        üî§ ¬øQu√© son las *soft keywords*?
    </summary>

    En Kotlin, una **soft keyword** es una palabra reservada que **no est√° prohibida como nombre de identificador**, a menos que se use en un contexto espec√≠fico.

    Esto significa que puedes usar palabras como `data`, `value`, `sealed`, etc., como nombres de variables, clases o funciones **fuera de los contextos donde tienen un significado especial**.

    Por ejemplo, `data` solo act√∫a como palabra clave cuando aparece en la declaraci√≥n de una clase:

    ```kotlin
    data class Wizard(val name: String)
    ```

    Pero es totalmente v√°lido como nombre de una variable en otro contexto:

    ```kotlin
    val data = "Fairy Tail"
    ```

    :::info
    Esta flexibilidad permite que el lenguaje evolucione agregando nuevas construcciones sin romper el c√≥digo existente.
    :::

    Puedes consultar la [lista completa de soft keywords en la documentaci√≥n oficial](https://kotlinlang.org/docs/keyword-reference.html#soft-keywords).
</details>

### ü•ä Comparaci√≥n por contenido vs referencia

Cuando usamos clases para representar datos, es importante entender c√≥mo se comparan las instancias. En Kotlin, las clases comunes comparan por **referencia**, mientras que las `data class` comparan por **contenido**. Veamos un ejemplo inspirado en *Rocky Balboa*:

```kotlin title="Clase com√∫n: comparaci√≥n por referencia"
class Boxer(val name: String, val weight: Int)

val rocky1 = Boxer("Rocky", 91)
val rocky2 = Boxer("Rocky", 91)

println(rocky1 == rocky2) // false
```

```kotlin title="Data class: comparaci√≥n por contenido"
data class Boxer(val name: String, val weight: Int)

val rocky1 = Boxer("Rocky", 91)
val rocky2 = Boxer("Rocky", 91)

println(rocky1 == rocky2) // true
```

<details>
    <summary>ü§î ¬øY si quiero comparar por referencia?</summary>

    En Kotlin:

    - `==` compara **por contenido**, si la clase redefine `equals()` (como en una `data class`).
    - `===` compara **por referencia**, es decir, si ambas variables apuntan al mismo objeto en memoria.

    ```kotlin
    val a = Boxer("Rocky", 91)
    val b = a
    val c = Boxer("Rocky", 91)

    println(a == c)   // true ‚Üí compara contenido
    println(a === c)  // false ‚Üí diferentes instancias
    println(a === b)  // true ‚Üí misma referencia
    ```
</details>

## üéØ Conclusiones

A lo largo de esta lecci√≥n aprendimos que los **registros** son una representaci√≥n de datos estructurados con campos expl√≠citos, y que en Kotlin su forma idiom√°tica son las `data class`. Estos tipos no solo agrupan m√∫ltiples valores bajo una misma entidad, sino que comunican de forma clara la estructura y el prop√≥sito de los datos.

Exploramos c√≥mo las `data class` permiten representar productos con sem√°ntica fuerte, y c√≥mo el compilador se encarga de generar autom√°ticamente comportamientos comunes como `equals`, `toString`, `copy` y `componentN`. Esto reduce el c√≥digo repetitivo y ayuda a mantener nuestras bibliotecas simples, expresivas y robustas.

Tambi√©n vimos que, aunque las `data class` pueden parecer simples, **su dise√±o refleja decisiones profundas sobre igualdad, mutabilidad y legibilidad del c√≥digo**.

### üîë Puntos clave

- Un **registro** representa un tipo producto con campos con nombre.
- En Kotlin, las `data class` son la forma idiom√°tica de declarar registros.
- El compilador genera autom√°ticamente m√©todos como `equals`, `toString`, `copy` y `componentN`.
- A diferencia de las clases comunes, las `data class` comparan por **contenido** y no por referencia.
- Son especialmente √∫tiles para dise√±ar **tipos claros, reutilizables y f√°ciles de testear**.

### üß∞ ¬øQu√© nos llevamos?

Comprender qu√© es un registro y c√≥mo modelarlo como `data class` es fundamental para escribir bibliotecas expresivas y bien dise√±adas. Este enfoque permite **hacer expl√≠cita la estructura de los datos**, reduciendo ambig√ºedades y promoviendo la claridad sem√°ntica en nuestras APIs.

Al usar `data class`, Kotlin nos da herramientas que favorecen la inmutabilidad, la igualdad estructural y la desestructuraci√≥n, todo con una sintaxis concisa y segura.

<div className="language-card-container">
    <LanguageCards.JavaCard link="/docs/type-fundamentals/algebraic-data-types/records-1/java" />
</div>

## üìñ Referencias

### üî• Recomendadas

- üìö "Data Classes" (pp. 198-200) en *"Atomic Kotlin"* de **Bruce Eckel** y **Dmitry Jemerov**: muestra c√≥mo las `data class` eliminan c√≥digo repetitivo al modelar tipos producto: generan autom√°ticamente `equals`, `toString`, `copy` y `hashCode`, lo que facilita la comparaci√≥n por contenido, el uso en estructuras como `HashMap` y `HashSet`, y la creaci√≥n de nuevas instancias con modificaciones. Es relevante para esta lecci√≥n porque muestra claramente c√≥mo las `data class` implementan el concepto de **registro** en Kotlin de forma idiom√°tica y eficiente.

{/* ### üîπ Adicionales */}