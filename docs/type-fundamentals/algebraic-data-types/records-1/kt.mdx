---
title: Tipos producto como registros y data class
sidebar_label: Registros y data class
---

import Explanation from '@site/src/components/admonitions/Explanation'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'

<ReadingTime />

En la lecci√≥n anterior exploramos c√≥mo las **clases comunes en Kotlin** pueden utilizarse para representar **tipos producto**: estructuras que agrupan m√∫ltiples valores en una sola entidad, como `Position(x, y)` o `Person(name, age)`. Aprendimos a nombrar expl√≠citamente cada campo y a encapsular l√≥gica relevante dentro de la clase, superando las limitaciones de tipos gen√©ricos como `Pair` o `Triple`.

En esta lecci√≥n llevaremos esa idea un paso m√°s all√°, introduciendo el concepto de **registro** (*record*), una abstracci√≥n com√∫n en muchos lenguajes orientados a datos y programaci√≥n funcional. Veremos c√≥mo Kotlin proporciona un soporte conciso y expresivo para este patr√≥n mediante las **`data class`**, y qu√© ventajas ofrece frente a las clases tradicionales.

Nuestro objetivo ser√° comprender c√≥mo los registros ‚Äîy en particular las `data class` de Kotlin‚Äî permiten modelar tipos producto de forma **m√°s declarativa, segura y reutilizable**, lo cual resulta especialmente √∫til en el contexto del **dise√±o de bibliotecas**.

## üìò ¬øQu√© es un registro (*record*)?

En programaci√≥n, un **registro** (o *record*) es una estructura de datos que **agrupa m√∫ltiples valores en una sola entidad**, donde **cada valor est√° asociado a un nombre expl√≠cito**. Es una forma de representar **datos estructurados**, es decir, informaci√≥n compuesta que transmite una **intenci√≥n sem√°ntica clara**.

Desde la teor√≠a de tipos, un registro corresponde a un caso particular de **tipo producto**: un tipo que **posee simult√°neamente un valor para cada uno de sus campos**.

Por ejemplo, para representar una coordenada bidimensional, podr√≠amos definir un registro con los campos `x` e `y`:

```kotlin showLineNumbers title="Registro como coordenada bidimensional"
val point = Coordinate(x = 2, y = 5)
```

A diferencia de listas o tuplas, un registro **asigna un nombre a cada componente**, lo que mejora la legibilidad, refuerza la intenci√≥n del dise√±o y facilita el mantenimiento. Esta claridad es especialmente valiosa al dise√±ar **tipos reutilizables dentro de bibliotecas**.

### üÜö ¬øEn qu√© se diferencia de una clase u objeto?

Aunque un **registro** puede parecerse superficialmente a una clase, su prop√≥sito es m√°s limitado y est√° orientado exclusivamente al **modelo de datos**:

| Caracter√≠stica              | Clases tradicionales                          | Registros (`record`, `data class`, etc.)     |
|----------------------------|-----------------------------------------------|----------------------------------------------|
| Prop√≥sito                  | Modelar **entidades con comportamiento**       | Modelar **estructuras de datos simples**     |
| Comparaci√≥n (`==`)         | Por **referencia** (por defecto)               | Por **contenido** (campos)                   |
| Mutabilidad                | Com√∫nmente **mutables**                       | Usualmente **inmutables** por convenci√≥n     |
| L√≥gica interna             | Pueden encapsular l√≥gica compleja             | Limitados a **almacenar y exponer datos**    |

:::tip En resumen

Una **clase** modela una entidad con identidad, estado mutable y comportamiento asociado.

Un **registro** modela una **colecci√≥n inmutable de datos con nombre**, comparable por valor, sin l√≥gica compleja, ideal para representar **tipos producto planos y transparentes**.

:::

### üåç Registros en distintos lenguajes

Muchos lenguajes ofrecen mecanismos espec√≠ficos para definir registros, es decir, estructuras inmutables y comparables por valor:

- En **Haskell** y **ML**, los *records* son estructuras inmutables con campos nombrados y soporte para desestructuraci√≥n.
- En **Python**, herramientas como `namedtuple`, `dataclass` y `attrs` permiten definir contenedores de datos con comparaciones por valor y generaci√≥n autom√°tica de m√©todos.
- En **Java**, a partir de la versi√≥n 16, los `record` permiten declarar tipos centrados en datos de forma concisa y segura.
- En **Scala**, las `case class` ofrecen inmutabilidad, desestructuraci√≥n y comparaci√≥n por valor de manera idiom√°tica.
- En **Kotlin**, las `data class` son el mecanismo principal para representar registros, con soporte directo para `copy`, `toString`, `equals`, `hashCode`, y desestructuraci√≥n.

Aunque var√≠an en sintaxis y detalles, **todos estos mecanismos comparten un objetivo com√∫n**: representar datos con **estructura expl√≠cita, sem√°ntica clara y sin l√≥gica incidental**.

## üì¶ ¬øQu√© es una `data class`?

En Kotlin, una `data class` es la forma idiom√°tica de definir **registros**: estructuras que agrupan varios valores con nombre y se comparan por contenido.

Al marcar una clase como `data`, el compilador genera autom√°ticamente:

- `equals()` y `hashCode()` para comparaci√≥n por **contenido**, no por referencia (ideal para usar como claves en mapas, sets o para deduplicaci√≥n).
- `toString()` para imprimir una representaci√≥n legible (√∫til en logs, debugging y documentaci√≥n).
- `copy()` para clonar objetos inmutables con modificaciones puntuales.
- Funciones `componentN()` para **desestructurar** f√°cilmente los valores en expresiones y funciones.

Estas caracter√≠sticas hacen que las `data class` sean ideales para representar **tipos producto**.

```kotlin showLineNumbers title="Definici√≥n de un mago como data class"
data class Wizard(
    val name: String,
    val magic: String,
    val powerLevel: Int
)
```

Este tipo representa el producto cartesiano:

$$
\text{String} \times \text{String} \times \text{Int}
$$

Cada instancia combina un nombre, un tipo de magia y un nivel de poder. Su prop√≥sito es **expresar datos**, no l√≥gica compleja ni identidad mutable.

### üé≠ Sin `data class`

Este ejemplo muestra c√≥mo ser√≠a implementar manualmente una clase que represente un **registro**. Aunque es completamente v√°lido, resulta **verboso**, **propenso a errores** y **repetitivo**, especialmente si lo comparamos con una `data class`, que genera autom√°ticamente todo este comportamiento:

```kotlin showLineNumbers title="Definici√≥n de un mago como clase normal"
class Wizard(
    val name: String,
    val magic: String,
    val powerLevel: Int
) {
    fun copy(
        name: String = this.name,
        magic: String = this.magic,
        powerLevel: Int = this.powerLevel
    ) = Wizard(name, magic, powerLevel)

    operator fun component1(): String = name
    operator fun component2(): String = magic
    operator fun component3(): Int = powerLevel

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Wizard) return false

        return name == other.name &&
               magic == other.magic &&
               powerLevel == other.powerLevel
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + magic.hashCode()
        result = 31 * result + powerLevel
        return result
    }

    override fun toString() =
        "Wizard(name='$name', magic='$magic', powerLevel=$powerLevel)"
}
```

:::tip ¬øPor qu√© importa?

Este ejemplo ilustra lo que hace el compilador de Kotlin al marcar una clase como `data`.

- **Ahorro de c√≥digo**: una `data class` genera autom√°ticamente `copy`, `componentN`, `equals`, `hashCode` y `toString`.
- **Comportamiento predecible**: evita errores sutiles que pueden surgir al implementar manualmente m√©todos como `equals`.
- **Intenci√≥n clara**: al usar `data`, declaras expl√≠citamente que el prop√≥sito de la clase es **representar datos con sem√°ntica por valor**.

Este patr√≥n es fundamental al dise√±ar bibliotecas que manejan estructuras inmutables, comparables y f√°ciles de serializar o probar.

:::

### ü•ä Comparaci√≥n por contenido vs referencia

Al representar datos, es clave entender c√≥mo se comparan las instancias. En Kotlin:

- Las **clases comunes** comparan por **referencia** (`===`), es decir, eval√∫an si apuntan al mismo objeto en memoria.
- Las **`data class`** comparan por **contenido** (`==`), es decir, eval√∫an si los campos tienen los mismos valores.

Veamos un ejemplo inspirado en *Rocky Balboa*:

```kotlin showLineNumbers title="Clase com√∫n: comparaci√≥n por referencia"
class Boxer(val name: String, val weight: Int)

val rocky1 = Boxer("Rocky", 91)
val rocky2 = Boxer("Rocky", 91)

println(rocky1 == rocky2) // false
```

```kotlin showLineNumbers title="Data class: comparaci√≥n por contenido"
data class Boxer(val name: String, val weight: Int)

val rocky1 = Boxer("Rocky", 91)
val rocky2 = Boxer("Rocky", 91)

println(rocky1 == rocky2) // true
```

<Explanation>
    Este ejemplo muestra una diferencia clave entre clases comunes y `data class`:

    - En la primera versi√≥n, aunque los valores son id√©nticos, los objetos son distintos en memoria ‚Üí `false`.
    - En la segunda, `data class` genera autom√°ticamente `equals`, por lo que se comparan los campos ‚Üí `true`.

    Esta capacidad de comparar por contenido es fundamental para representar **tipos producto**, donde nos interesa **el valor**, no la identidad del objeto.
</Explanation>

<details>
    <summary>ü§î ¬øY si quiero comparar por referencia?</summary>

    En Kotlin, existen dos operadores para comparar objetos:

    - `==` compara **por contenido**: se traduce en una llamada a `equals()`.  
      Las `data class` sobrescriben `equals` autom√°ticamente, por lo que `==` compara sus campos.
    - `===` compara **por referencia**: verifica si **ambas variables apuntan al mismo objeto en memoria**.

    ```kotlin
    val a = Boxer("Rocky", 91)
    val b = a
    val c = Boxer("Rocky", 91)

    println(a == c)   // true ‚Üí mismo contenido
    println(a === c)  // false ‚Üí objetos distintos
    println(a === b)  // true ‚Üí misma instancia
    ```

    :::tip

    Usa `===` solo cuando necesites verificar identidad de objetos.  
    Para la mayor√≠a de los casos con tipos producto, la comparaci√≥n por contenido (`==`) es m√°s adecuada y segura.

    :::
</details>

## üéØ Conclusiones

A lo largo de esta lecci√≥n aprendimos que los **registros** son estructuras dise√±adas para representar **datos con nombre y prop√≥sito expl√≠cito**. En Kotlin, su forma idiom√°tica son las `data class`, que permiten declarar **tipos producto** de forma concisa, expresiva y segura.

Las `data class` agrupan m√∫ltiples valores en una sola entidad y **delegan en el compilador la generaci√≥n de comportamientos comunes** como `equals`, `toString`, `copy` y `componentN`. Esto **reduce la repetici√≥n de c√≥digo**, mejora la legibilidad y evita errores frecuentes al trabajar con datos estructurados.

Tambi√©n discutimos c√≥mo estas decisiones de dise√±o impactan en la **igualdad estructural**, la **inmutabilidad por convenci√≥n**, y la facilidad para crear APIs limpias y coherentes.

### üîë Puntos clave

- Un **registro** es una forma de representar un **tipo producto con campos nombrados**, pensado para modelar datos.
- Las `data class` son la forma idiom√°tica de definir registros en Kotlin.
- El compilador genera autom√°ticamente m√©todos √∫tiles como `equals`, `hashCode`, `toString`, `copy` y `componentN`.
- A diferencia de las clases comunes, las `data class` **comparan por contenido**, no por referencia.
- Son especialmente √∫tiles para dise√±ar tipos **transparentes, inmutables y f√°cilmente testeables**.

### üß∞ ¬øQu√© nos llevamos?

Comprender el rol de los registros y el uso adecuado de `data class` nos permite escribir **c√≥digo m√°s claro, seguro y reutilizable**. Este enfoque mejora no solo la implementaci√≥n de tipos internos, sino tambi√©n la **legibilidad y mantenibilidad** de nuestras bibliotecas.

Al adoptar `data class` como representaci√≥n idiom√°tica de los tipos producto, **aprovechamos lo mejor del dise√±o declarativo** con el respaldo de un compilador que nos asiste en tareas repetitivas y propensas a errores.

<div className="language-card-container">
    <LanguageCards.JavaCard link="/docs/type-fundamentals/algebraic-data-types/records-1/java" />
</div>

<ExcludeFromReadingTime>

## üìñ Referencias

### üî• Recomendadas

- üìö "Data Classes" (pp. 198-200) en *"Atomic Kotlin"* de **Bruce Eckel** y **Dmitry Jemerov**: muestra c√≥mo las `data class` eliminan c√≥digo repetitivo al modelar tipos producto: generan autom√°ticamente `equals`, `toString`, `copy` y `hashCode`, lo que facilita la comparaci√≥n por contenido, el uso en estructuras como `HashMap` y `HashSet`, y la creaci√≥n de nuevas instancias con modificaciones. Es relevante para esta lecci√≥n porque muestra claramente c√≥mo las `data class` implementan el concepto de **registro** en Kotlin de forma idiom√°tica y eficiente.

### üîπ Adicionales

- üìö ‚ÄúObjects and Classes.‚Äù (pp. 107-132) en *Programming Kotlin: Create Elegant, Expressive, and Performant JVM and Android Applications* de **Venkat Subramaniam**: Este cap√≠tulo explora c√≥mo Kotlin permite definir clases y registros de manera concisa y expresiva, eliminando la necesidad de escribir c√≥digo repetitivo. Introduce las `data class` como una forma idiom√°tica de representar tipos producto inmutables y comparables por valor, destacando c√≥mo el compilador genera autom√°ticamente m√©todos como `equals`, `hashCode`, `toString`, `copy` y `componentN()`. Adem√°s, compara este enfoque con las clases tradicionales, analiza los beneficios de la inmutabilidad, y presenta patrones de dise√±o como objetos singleton y constructores personalizados. Es especialmente relevante para esta lecci√≥n porque **explica en profundidad c√≥mo las `data class` implementan el concepto de registro en Kotlin y c√≥mo esto mejora el dise√±o de estructuras de datos claras, reutilizables y seguras**.

</ExcludeFromReadingTime>
