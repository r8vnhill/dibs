---
title: 'Registros en Java'
---

import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import ReadingTime from '@site/src/components/ReadingTime'
import References from '@site/src/components/mdx/type-fundamentals/algebraic-data-types/records-1/java/references.mdx';
import GithubRepoLink from '@site/src/components/git/GithubRepoLink';

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="java-dibs" />

En lecciones anteriores aprendimos a modelar **tipos producto** en Kotlin utilizando `data class`: estructuras concisas que agrupan m√∫ltiples valores bajo una misma entidad, con campos claramente nombrados, igualdad estructural y generaci√≥n autom√°tica de comportamientos √∫tiles como `toString`, `equals` y `copy`.

Java ‚Äîhist√≥ricamente m√°s detallado y ceremonioso‚Äî incorpor√≥ una alternativa moderna para expresar este mismo concepto: los `record`. Introducidos como *preview* en Java 14 y estabilizados en Java 16, los `record` permiten definir **estructuras inmutables** de manera concisa, con comportamiento generado autom√°ticamente por el compilador.

En esta lecci√≥n compararemos ambos enfoques. Veremos c√≥mo un `record` en Java cumple un rol similar al de una `data class` en Kotlin, qu√© caracter√≠sticas comparten, y qu√© diferencias existen en cuanto a expresividad, flexibilidad y casos de uso. Tambi√©n discutiremos sus limitaciones al dise√±ar bibliotecas centradas en datos.

Nos enfocaremos tanto en lo que los une ‚Äîinmutabilidad, igualdad estructural, transparencia sem√°ntica‚Äî como en lo que los distingue: desde la posibilidad de desestructurar o copiar con cambios, hasta el nivel de control y extensi√≥n que permite cada lenguaje.

## üéµ Ejemplo: Registro de canci√≥n con `record`

A continuaci√≥n presentamos un ejemplo completo del uso de `record` en Java para modelar un tipo producto simple: una canci√≥n con t√≠tulo, compositor, a√±o de lanzamiento y si fue un √©xito en Billboard.

<BoxedTabs>
  <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
    ```java showLineNumbers title="Song.java"
    public record Song(
        String title,
        String writer,
        int releaseYear,
        boolean billboardHit
    ) {}
    ```
  </TabItem>
  <TabItem label="C√≥digo completo" value="C√≥digo completo">
    ```java showLineNumbers title="Song.java"
    package cl.ravenhill.music;

    public record Song(
        String title,
        String writer,
        int releaseYear,
        boolean billboardHit
    ) {}
    ```

    ```java showLineNumbers title="Main.java"
    package cl.ravenhill.music;

    public class Main {
        public static void main(String[] args) {
            var song = new Song(
                "Walk On By",
                "Burt Bacharach",
                1964,
                true
            );

            System.out.println(song);

            System.out.println(song.billboardHit()
                ? song.title() + " was a Billboard hit!"
                : song.title() + " didn't chart.");
        }
    }
    ```

    ```plaintext title="Salida esperada"
    Song[title=Walk On By, writer=Burt Bacharach, releaseYear=1964, billboardHit=true]
    Walk On By was a Billboard hit!
    ```
  </TabItem>
</BoxedTabs>

<Explanation>
  Este ejemplo demuestra c√≥mo Java permite modelar **tipos producto inmutables** de forma concisa usando `record`, una caracter√≠stica introducida en Java 14 y estabilizada en Java 16.

  - La clase `Song` act√∫a como una estructura de datos declarativa con **campos nombrados**, similar a una `data class` en Kotlin.
  - El compilador genera autom√°ticamente:
    - Un **constructor compacto** con todos los campos.
    - Los m√©todos `toString`, `equals`, `hashCode`.
    - Y los m√©todos para acceder a cada campo (como `title()` o `writer()`), **sin necesidad de prefijos como `getTitle()` o `getWriter()`**, lo cual hace que el c√≥digo sea m√°s limpio y legible que las clases tradicionales en Java.

  Este estilo reduce el c√≥digo repetitivo y comunica con claridad la intenci√≥n: estamos definiendo una entidad que representa datos, no comportamiento.
</Explanation>

Este enfoque se alinea con el concepto de **registro** como una unidad de datos inmutable, autoexpresiva y f√°cilmente comparable ‚Äî tal como vimos con `data class` en Kotlin.

## üéØ Conclusiones

El soporte moderno de Java para `record` permite expresar tipos producto de forma concisa y segura, acercando su modelo de datos al de lenguajes m√°s declarativos como Kotlin. Aunque los `record` no ofrecen todas las funcionalidades de una `data class` ‚Äîcomo `copy()` o desestructuraci√≥n mediante `componentN()`‚Äî, s√≠ representan un paso importante hacia la simplificaci√≥n del dise√±o orientado a datos en Java.

Esta lecci√≥n muestra c√≥mo Java puede modelar estructuras **inmutables** y **comparables por valor** con una sintaxis clara, evitando la verbosidad de las clases tradicionales cuando el objetivo es simplemente **representar datos**.

### üîë Puntos clave

- Un `record` en Java define un tipo producto inmutable con sem√°ntica por valor.
- El compilador genera autom√°ticamente m√©todos como `equals`, `hashCode` y `toString`.
- Los campos son inmutables y accesibles mediante m√©todos sin prefijo (`title()` en lugar de `getTitle()`).
- Aunque conciso, un `record` no admite herencia ni operaciones como copia o desestructuraci√≥n autom√°tica.
- Es conceptualmente equivalente a una `data class` de Kotlin, pero con un conjunto de capacidades m√°s acotado.

### üìä Comparativa: Kotlin vs Java

| Caracter√≠stica                              | Kotlin (`data class`)                      | Java (`record`)                                |
| ------------------------------------------- | ------------------------------------------ | ---------------------------------------------- |
| Declaraci√≥n                                 | `data class Person(...)`                   | `record Person(...)`                           |
| Comparaci√≥n por valor (`==`)                | ‚úÖ Generada autom√°ticamente (`equals`)      | ‚úÖ Generada autom√°ticamente (`equals`)          |
| Representaci√≥n legible (`toString`)         | ‚úÖ Generada autom√°ticamente                 | ‚úÖ Generada autom√°ticamente                     |
| Hashing (`hashCode`)                        | ‚úÖ Generado autom√°ticamente                 | ‚úÖ Generado autom√°ticamente                     |
| Desestructuraci√≥n (`componentN()`)          | ‚úÖ S√≠ (hasta 255 campos)                    | ‚ùå No                                           |
| Clonaci√≥n (`copy`)                          | ‚úÖ Con `copy(...)`                          | ‚ùå No (debe escribirse manualmente)             |
| Inmutabilidad                               | ‚úÖ Campos `val` (aunque puede usarse `var`) | ‚úÖ Campos inmutables por defecto                |
| Constructor con todos los campos            | ‚úÖ S√≠                                       | ‚úÖ S√≠                                           |
| Herencia                                    | ‚ùå No                                       | ‚ùå No (los `record` son impl√≠citamente `final`) |

### üß∞ ¬øQu√© nos llevamos?

Tanto `record` como `data class` son mecanismos dise√±ados para **reducir la fricci√≥n al modelar datos**. En ambos casos, su objetivo es permitirte declarar tipos producto con sem√°ntica fuerte, evitando la necesidad de generar manualmente c√≥digo repetitivo para comparaciones, impresiones o acceso a campos.

Para quienes vienen de Java, entender `record` es fundamental para adoptar pr√°cticas m√°s modernas y expresivas. Para quienes ya conocen Kotlin, esta comparaci√≥n refuerza que los **conceptos de la teor√≠a de tipos** ‚Äîcomo los productos‚Äî se implementan de forma distinta en cada lenguaje, pero persiguen los mismos principios: **claridad, seguridad y simplicidad**.

Ambos mecanismos promueven la **inmutabilidad, la transparencia sem√°ntica y el dise√±o modular**, cualidades esenciales para construir bibliotecas reutilizables y mantenibles.

## üìñ Referencias

### üî• Recomendadas

- [üé• *"Complete Java Records Tutorial"*](https://www.youtube.com/watch?v=_xIA7vhWkLk) (20m13s) en *YouTube* por **Cameron McKenzie**: Este video ofrece una **introducci√≥n pr√°ctica y detallada a los `record` en Java**, destacando su utilidad para modelar datos inmutables de forma concisa y segura. McKenzie contrasta el enfoque tradicional ‚Äîbasado en clases verbosas con getters, `equals`, `hashCode` y `toString` manuales‚Äî con la simplicidad declarativa de los `record`, mostrando c√≥mo esta caracter√≠stica reduce errores, mejora el rendimiento y facilita el mantenimiento del c√≥digo. Adem√°s, aborda temas avanzados como constructores personalizados, validaciones internas, m√©todos est√°ticos y restricciones de herencia. Es especialmente relevante para esta lecci√≥n porque **refuerza la idea de que los `record` son el equivalente idiom√°tico de las `data class` de Kotlin en el ecosistema Java**, aportando claridad y eficiencia al modelado de tipos producto.

### üîπ Adicionales

- [üåê *"JEP 395: Records"*](https://openjdk.org/jeps/395) en **OpenJDK**: Propuesta oficial que introdujo los `record` en Java 16 como una forma concisa, inmutable y nominalmente tipada de modelar datos. Este documento explica la motivaci√≥n detr√°s de los `record` (reducir el c√≥digo repetitivo al declarar tipos producto), su sem√°ntica, sus limitaciones (como la ausencia de desestructuraci√≥n o clonaci√≥n autom√°tica), y su integraci√≥n con otras caracter√≠sticas modernas del lenguaje como las clases `sealed` y la futura coincidencia de patrones (*pattern matching*). Es relevante para esta lecci√≥n porque establece las bases formales y filos√≥ficas de los `record` como equivalente conceptual a las `data class` de Kotlin: ambos permiten declarar estructuras orientadas a datos con sem√°ntica por valor, constructor can√≥nico y m√©todos derivados autom√°ticamente. Tambi√©n detalla las restricciones de dise√±o (inmutabilidad, final por defecto, sin herencia) que los hacen especialmente √∫tiles en la construcci√≥n de bibliotecas reutilizables.

