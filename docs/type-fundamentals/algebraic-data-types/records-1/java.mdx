---
title: 'Registros en Java'
---

import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import ReadingTime from '@site/src/components/ReadingTime'
import References from '@site/src/components/mdx/type-fundamentals/algebraic-data-types/records-1/java/references.mdx';
import GithubRepoLink from '@site/src/components/GithubRepoLink';

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="java-dibs" />

En lecciones anteriores aprendimos a modelar **tipos producto** en Kotlin usando `data class`: estructuras que agrupan m√∫ltiples valores bajo una misma entidad, con campos claramente nombrados y comparaci√≥n por contenido.

Java, tradicionalmente un lenguaje m√°s detallado y ceremonioso, tambi√©n ha incorporado una alternativa moderna para expresar este mismo concepto: los `record`. Esta caracter√≠stica ‚Äîintroducida como preview en Java 14 y estabilizada en Java 16‚Äî permite definir **registros inmutables** de manera concisa, con comportamiento generado autom√°ticamente por el compilador.

En esta lecci√≥n compararemos ambos enfoques: veremos c√≥mo un `record` en Java cumple el mismo rol que una `data class` en Kotlin, qu√© capacidades ofrece, y qu√© limitaciones debemos considerar al usarlo en el dise√±o de bibliotecas o estructuras centradas en datos.

Nos centraremos en lo que comparten ‚Äîinmutabilidad, igualdad estructural, transparencia sem√°ntica‚Äî pero tambi√©n destacaremos lo que los distingue: desde la desestructuraci√≥n hasta la capacidad de copia, y el rol del lenguaje en generar c√≥digo repetitivo de forma segura y expresiva.

## üéµ Ejemplo: Registro de canci√≥n con `record`

A continuaci√≥n presentamos un ejemplo completo del uso de `record` en Java para modelar un tipo producto simple: una canci√≥n con t√≠tulo, compositor, a√±o de lanzamiento y si fue un √©xito en Billboard.

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```java showLineNumbers title="Song.java"
        public record Song(
            String title,
            String writer,
            int releaseYear,
            boolean billboardHit
        ) {}
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```java showLineNumbers title="Song.java"
        package cl.ravenhill.music;

        public record Song(
            String title,
            String writer,
            int releaseYear,
            boolean billboardHit
        ) {}
        ```

        ```java showLineNumbers title="Main.java"
        package cl.ravenhill.music;

        public class Main {
            public static void main(String[] args) {
                var song = new Song(
                    "Walk On By",
                    "Burt Bacharach",
                    1964,
                    true
                );

                System.out.println(song);

                System.out.println(song.billboardHit()
                    ? song.title() + " was a Billboard hit!"
                    : song.title() + " didn't chart.");
            }
        }
        ```

        ```plaintext title="Salida esperada"
        Song[title=Walk On By, writer=Burt Bacharach, releaseYear=1964, billboardHit=true]
        Walk On By was a Billboard hit!
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este ejemplo muestra c√≥mo Java permite modelar **tipos producto** de forma concisa usando `record`, una caracter√≠stica introducida en Java 14 y estabilizada en Java 16. La clase `Song` representa un **registro inmutable** con campos claramente definidos y comparaci√≥n por contenido.

    El compilador genera autom√°ticamente:
    - El constructor con todos los campos,
    - Los m√©todos `toString`, `equals` y `hashCode`,
    - Y los *accessors* (`title()`, `writer()`, etc.).
</Explanation>

Este estilo se alinea con el concepto de **registro** como una entidad simple, declarativa y orientada a datos, tal como lo exploramos en Kotlin usando `data class`.

## üéØ Conclusiones

El soporte moderno de Java para `record` permite expresar tipos producto de forma concisa y segura, acercando su modelo de datos al de lenguajes m√°s declarativos como Kotlin. Aunque los `record` no ofrecen todas las funcionalidades de una `data class` (como `copy()` o desestructuraci√≥n con `componentN()`), s√≠ representan un paso importante hacia la simplificaci√≥n del dise√±o orientado a datos en Java.

Esta lecci√≥n muestra c√≥mo Java puede modelar estructuras inmutables y comparables por valor con una sintaxis clara, ayudando a evitar la verbosidad de las clases tradicionales cuando el objetivo es simplemente **representar datos**.

### üîë Puntos clave

- Un `record` en Java permite definir un tipo producto inmutable con sem√°ntica por valor.
- El compilador genera autom√°ticamente m√©todos √∫tiles como `equals`, `hashCode` y `toString`.
- Los campos son finales e inmutables por defecto.
- Aunque conciso, el `record` no permite herencia ni sobrecarga directa de l√≥gica compleja.
- Es comparable conceptualmente a una `data class` de Kotlin, pero con menos herramientas integradas para desestructuraci√≥n o clonaci√≥n.

### üìä Comparativa: Kotlin vs Java

| Caracter√≠stica                              | Kotlin (`data class`)                      | Java (`record`)                                |
| ------------------------------------------- | ------------------------------------------ | ---------------------------------------------- |
| Declaraci√≥n                                 | `data class Person(...)`                   | `record Person(...)`                           |
| Comparaci√≥n por valor (`==`)                | ‚úÖ Generada autom√°ticamente (`equals`)      | ‚úÖ Generada autom√°ticamente (`equals`)          |
| Representaci√≥n legible (`toString`)         | ‚úÖ Generada autom√°ticamente                 | ‚úÖ Generada autom√°ticamente                     |
| Hashing (`hashCode`)                        | ‚úÖ Generado autom√°ticamente                 | ‚úÖ Generado autom√°ticamente                     |
| Desestructuraci√≥n (`componentN()`)          | ‚úÖ S√≠ (hasta 255 campos)                    | ‚ùå No                                           |
| Clonaci√≥n (`copy`)                          | ‚úÖ Con `copy(...)`                          | ‚ùå No (debe escribirse manualmente)             |
| Inmutabilidad                               | ‚úÖ Campos `val` (aunque puede usarse `var`) | ‚úÖ Campos inmutables por defecto                |
| Requiere todos los campos en el constructor | ‚úÖ S√≠                                       | ‚úÖ S√≠                                           |
| Herencia                                    | ‚ùå No (igual que las data classes)          | ‚ùå No (los `record` son impl√≠citamente `final`) |

### üß∞ ¬øQu√© nos llevamos?

Tanto `record` como `data class` son herramientas que simplifican la creaci√≥n de estructuras de datos claras y expresivas. En ambos lenguajes, el objetivo es el mismo: **modelar tipos producto que representen datos con sem√°ntica fuerte**, pero sin la necesidad de implementar manualmente comparaciones, impresiones o constructores.

Para quienes vienen de Java, comprender `record` es clave para aprovechar el dise√±o moderno de APIs. Para quienes vienen de Kotlin, esta comparaci√≥n refuerza la idea de que los conceptos de la teor√≠a de tipos ‚Äîcomo los productos‚Äî **se manifiestan de distintas formas seg√∫n el lenguaje**, pero su prop√≥sito com√∫n es mejorar la claridad, seguridad y mantenibilidad del c√≥digo.

Ambos mecanismos favorecen la **inmutabilidad, la transparencia sem√°ntica y la simplicidad**, cualidades esenciales en el dise√±o de bibliotecas reutilizables.

<References />
