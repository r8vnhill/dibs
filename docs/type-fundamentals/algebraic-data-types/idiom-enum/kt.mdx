---
title: Modelado avanzado con enumeraciones
sidebar_label: Enumeraciones avanzadas
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime';
import RepoLinks from '@site/src/components/git/RepoLinks';
import GitHubRepo from '@site/src/components/git/GitHubRepo';
import GitLabRepo from '@site/src/components/git/GitLabRepo';
import Explanation from '@site/src/components/admonitions/Explanation';

import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons';

import BoxedTabs, { TabItem } from '@site/src/components/cajitas/BoxedTabs';
import Box from '@site/src/components/cajitas/Box';

import Hint from '@site/src/components/exercise/Hint';
import Solution from '@site/src/components/exercise/Solution';

import ReferenceList from '@site/src/components/references/ReferenceList';
import WebPage from '@site/src/components/references/WebPage';
import AuthorList from '@site/src/components/references/AuthorList';

<ReadingTime />
<RepoLinks children={[
    <GitLabRepo user="r8vnhill" repo="algebraic-data-types-kt" />,
    <GitHubRepo user="r8vnhill" repo="algebraic-data-types-kt" />
]}  />

En Kotlin, una `enum class` no se limita a representar un conjunto finito de etiquetas simb√≥licas.  
A diferencia de otros lenguajes donde los enums son simples constantes, en Kotlin pueden tener **propiedades, m√©todos e incluso l√≥gica especializada en cada instancia**. Esto permite modelar comportamientos complejos de manera clara, expresiva y con un alto grado de encapsulamiento.

En esta lecci√≥n aprender√°s a usar enumeraciones como:

- **Tipos con estado interno mutable**, √∫tiles para representar componentes que evolucionan (como versiones).
- **Clases abstractas con comportamiento polim√≥rfico**, donde cada valor define su propia l√≥gica.
- **Colecciones exhaustivas de estrategias**, reglas o modos de operaci√≥n, aprovechando su naturaleza cerrada.

Tambi√©n conocer√°s funciones y propiedades est√°ndar que Kotlin ofrece para trabajar con `enum class` de forma segura y eficiente, como `name`, `entries`, `ordinal` y `valueOf`.

Al finalizar, estar√°s en condiciones de aplicar enumeraciones como herramientas de modelado avanzadas, en lugar de verlas solo como simples colecciones de valores fijos.

## üî¢ Enumeraciones con estado y comportamiento

Una enumeraci√≥n en Kotlin no se limita a representar un conjunto fijo de valores.  
Tambi√©n puede tener **valores asociados**, **propiedades mutables** y **m√©todos**, lo que permite modelar comportamientos m√°s ricos y con estado.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/semver/VersionComponent.kt"
        enum class VersionComponent(val identifier: String, var current: Int) {
            MAJOR("major", 0),
            MINOR("minor", 0),
            PATCH("patch", 0);

            fun bump() {
                current++
            }

            fun reset() {
                current = 0
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/semver/VersionComponent.kt"
        enum class VersionComponent(val identifier: String, var current: Int) {
            MAJOR("major", 0),
            MINOR("minor", 0),
            PATCH("patch", 0);

            fun bump() {
                current++
            }

            fun reset() {
                current = 0
            }
        }

        fun main() {
            println("üîç Initial Version State:\n")
            println("${VersionComponent.MAJOR.identifier}: ${VersionComponent.MAJOR.current}")
            println("${VersionComponent.MINOR.identifier}: ${VersionComponent.MINOR.current}")
            println("${VersionComponent.PATCH.identifier}: ${VersionComponent.PATCH.current}")

            println("\nüîß Performing version updates...\n")

            VersionComponent.MAJOR.bump()
            VersionComponent.MINOR.bump()
            VersionComponent.PATCH.bump()
            VersionComponent.PATCH.bump()

            println("Updated Version State:\n")
            println("${VersionComponent.MAJOR.identifier}: ${VersionComponent.MAJOR.current}")
            println("${VersionComponent.MINOR.identifier}: ${VersionComponent.MINOR.current}")
            println("${VersionComponent.PATCH.identifier}: ${VersionComponent.PATCH.current}")

            println("\nüîÑ Resetting all components...\n")
            VersionComponent.MAJOR.reset()
            VersionComponent.MINOR.reset()
            VersionComponent.PATCH.reset()

            println("Version components reset to zero:\n")
            println("${VersionComponent.MAJOR.identifier}: ${VersionComponent.MAJOR.current}")
            println("${VersionComponent.MINOR.identifier}: ${VersionComponent.MINOR.current}")
            println("${VersionComponent.PATCH.identifier}: ${VersionComponent.PATCH.current}")
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Cada l√≠nea como `MAJOR("major", 0)` declara un valor del enum, y a la vez **invoca el constructor del enum** con los par√°metros definidos.  
    As√≠, `MAJOR` tendr√° `identifier = "major"` y `current = 0`, `MINOR` lo mismo pero con `"minor"`, y as√≠ sucesivamente.

    Estas instancias son **singletons** (una sola instancia por valor), pero el campo `current` es mutable, por lo que **si se modifica, el cambio afecta a cualquier lugar donde se use ese valor enum**.

    Esto permite asociar tanto **datos** como **comportamiento** a los valores enumerados, algo que no es posible en lenguajes donde los enums son solo etiquetas constantes.
</Explanation>

Este patr√≥n puede ser √∫til para representar **componentes que evolucionan en el tiempo** y requieren comportamiento espec√≠fico por cada valor enumerado.

:::danger Precauci√≥n

Sin embargo, **debe usarse con precauci√≥n**: como los valores del enum son instancias √∫nicas, cualquier cambio de estado afecta a todos quienes las compartan. Esto puede romper invariantes si no se maneja cuidadosamente, especialmente en entornos concurrentes o bibliotecas reutilizables.

:::

## üß¨ Enums como clases con comportamiento especializado

:::note Recordatorio: Clases abstractas

Una **clase abstracta** define una interfaz parcial ‚Äîpuede incluir implementaci√≥n‚Äî pero **no puede instanciarse directamente**. Otras clases deben extenderla y **completar sus miembros abstractos**.

:::

En Kotlin, `enum class` puede actuar como una **clase abstracta**, permitiendo que cada uno de sus valores sobrescriba m√©todos o defina comportamiento propio.  
Cada valor del enum es una **instancia √∫nica** de una subclase an√≥nima[^1] impl√≠cita que extiende la clase base del enum.

[^1]: Entraremos en detalle sobre las clases an√≥nimas en Kotlin en una futura lecci√≥n.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/semver/ReleaseChannel.kt"
        enum class ReleaseChannel {
            STABLE {
                override val description: String =
                    "Ready for production use, fully tested and stable"
            },
            BETA {
                override val description: String =
                    "Version with new features, may contain bugs but is more stable than alpha"
            },
            ALPHA {
                override val description: String =
                    "Experimental version subject to significant changes"
            };

            abstract val description: String
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/semver/ReleaseChannel.kt"
        enum class ReleaseChannel {
            STABLE {
                override val description: String =
                    "Ready for production use, fully tested and stable"
            },
            BETA {
                override val description: String =
                    "Version with new features, may contain bugs but is more stable than alpha"
            },
            ALPHA {
                override val description: String =
                    "Experimental version subject to significant changes"
            };

            abstract val description: String
        }

        fun main() {
            println("Release Channels:")
            println("${ReleaseChannel.STABLE}: ${ReleaseChannel.STABLE.description}")
            println("${ReleaseChannel.BETA}: ${ReleaseChannel.BETA.description}")
            println("${ReleaseChannel.ALPHA}: ${ReleaseChannel.ALPHA.description}")
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este patr√≥n permite **asociar l√≥gica diferente a cada valor del enum**.  
    En este ejemplo:

    - `description` es una propiedad abstracta que **cada valor del enum debe implementar**.
    - Cada valor (`STABLE`, `BETA`, `ALPHA`) se comporta como una **clase an√≥nima** que sobrescribe esa propiedad.
    - No se necesita una cl√°usula `when`, ya que el comportamiento especializado est√° directamente encapsulado en cada instancia.

    Esto es √∫til cuando los valores de un enum **no solo representan etiquetas, sino entidades con l√≥gica propia**, como estrategias, reglas de negocio o modos de operaci√≥n.
</Explanation>

:::warning `override` y `abstract` expl√≠citos

En Kotlin, la declaraci√≥n de m√©todos abstractos y sobrescritos debe ser **expl√≠cita**:

- Los m√©todos sin implementaci√≥n deben marcarse con `abstract`.
- Las implementaciones que sobrescriben m√©todos deben usar `override`.

Esto contrasta con lenguajes como **Scala**, donde `abstract` es impl√≠cito (cualquier m√©todo sin cuerpo es abstracto) y `override` puede ser opcional en algunos contextos.  
Kotlin prioriza la claridad y evita ambig√ºedades forzando al desarrollador a **declarar expl√≠citamente sus intenciones**.

:::

:::tip Uso con interfaces

Como los `enum class` pueden declarar m√©todos abstractos y sobrescribirlos en cada instancia, **tambi√©n pueden implementar interfaces**, al igual que las clases.  
Aunque no profundizaremos a√∫n en este tema, lo retomaremos m√°s adelante cuando exploremos **c√≥mo funcionan las interfaces y la reutilizaci√≥n de comportamiento** en Kotlin.  
Este deber√≠a ser un concepto familiar si has trabajado con otros lenguajes orientados a objetos como Java, C# o Scala (donde se denominan _traits_).[^2]

:::

[^2]: La implementaci√≥n de interfaces en Kotlin **no es** id√©ntica a los *traits* de Scala ni a las interfaces de Java o C#, aunque comparten la idea general de reutilizar comportamiento.

## üß∞ Utilidades disponibles en todos los `enum class`

En Kotlin, cada `enum class` viene acompa√±ado de un conjunto de funciones y propiedades √∫tiles que permiten trabajar con sus valores de forma segura y expresiva.  
Esto resulta especialmente pr√°ctico al dise√±ar bibliotecas reutilizables o construir sistemas donde los estados, niveles o fases deben modelarse de forma clara.

Supongamos que trabajamos en una biblioteca de compilaci√≥n que define las fases del ciclo de construcci√≥n de un proyecto de forma c√≠clica: Al terminar una fase, se inicia la siguiente, y al llegar al final, se vuelve a la primera.

```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/compiler/OptimizationPass.kt"
enum class OptimizationPass {
    INLINE_FUNCTIONS, REMOVE_DEAD_CODE, FOLD_CONSTANTS
}
```

Veamos algunas de las cosas que podemos hacer con este `enum`:

### üè∑Ô∏è `name: String`

Propiedad que devuelve el **nombre exacto** del valor tal como fue declarado en el `enum`:

```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/compiler/OptimizationPass.kt"
val name: String = OptimizationPass.INLINE_FUNCTIONS.name
println("${OptimizationPass.INLINE_FUNCTIONS} name: $name")
// Output: "INLINE_FUNCTIONS name: INLINE_FUNCTIONS"
```

En este caso, interpolar el valor del enum directamente produce el mismo resultado que acceder a `name`.  
Esto se debe a que, por defecto, el m√©todo `toString()` de un enum en Kotlin devuelve su `name`.

:::warning

Sin embargo, **no debes asumir que esto ser√° siempre cierto**: si el `enum` sobrescribe `toString()`, el resultado puede diferir.  
Si necesitas acceder al nombre declarado de forma segura y consistente, **usa siempre la propiedad `name`**.

:::

### üìã `entries: EnumEntries<EnumClass>`

Desde Kotlin 1.9, todos los `enum class` exponen la propiedad `entries`, una lista especializada[^3] que contiene **todos los valores del enum en el orden en que fueron declarados**.

[^3]: `EnumEntries` es un subtipo optimizado de `List`, dise√±ado espec√≠ficamente para trabajar con enumeraciones.  
Permite realizar ciertas operaciones ‚Äîcomo verificar si un valor pertenece a la lista (`contains`)‚Äî en **tiempo constante**, a diferencia de una lista convencional, donde esa operaci√≥n ser√≠a lineal.

```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/compiler/OptimizationPass.kt"
for (phase in OptimizationPass.entries) {
    println("> ${phase.name}")
}
```

:::tip

Usar `entries` es especialmente √∫til en bibliotecas y sistemas de construcci√≥n donde:

- Necesitas **recorrer todas las fases de un ciclo**, como en un sistema de compilaci√≥n modular (`INIT`, `COMPILE`, `LINK`, `PACKAGE`).
- Quieres generar din√°micamente un **men√∫, selector o documentaci√≥n** con los modos o configuraciones disponibles (`Mode.entries`, `LogLevel.entries`, etc.).
- Implementas un validador o visualizador gen√©rico que debe **operar sobre todos los casos de un tipo cerrado**, sin acoplarse a su n√∫mero o nombres espec√≠ficos.
- Usas enums como **plugins o estrategias registradas** (por ejemplo, en una arquitectura de procesamiento por fases o canalizaciones), y quieres evitar mantener listas manuales.

De este modo, `entries` reemplaza listas redundantes, elimina errores por omisi√≥n y asegura que tu l√≥gica siempre est√© alineada con los valores declarados.

:::

<details>
    <summary>
        <code>entries</code> vs <code>values()</code>
    </summary>

    Antes de Kotlin 1.9, el m√©todo `values()` era la forma est√°ndar de obtener todas las constantes de una enumeraci√≥n.  
    Este m√©todo, heredado de Java, devuelve un **array mutable** con los valores del enum.

    A partir de Kotlin 1.9, se introdujo la propiedad `entries` como **reemplazo preferido**, y `values()` fue **marcado como obsoleto** (`@Deprecated`) para su futura eliminaci√≥n.

    <ProCons>
        <Cons title={<>Problemas con <code>values()</code></>}>
            - Cada llamada a `values()` **crea una nueva copia del array**, lo que puede producir **problemas de rendimiento**, especialmente si se invoca en bucles o m√©todos frecuentemente utilizados.
            - Es **dif√≠cil de detectar** como cuello de botella, ya que el impacto depende del uso en tiempo de ejecuci√≥n, no del tama√±o del enum.
            - El resultado es un `Array`, pero la mayor√≠a de las APIs modernas en Kotlin usan `List`, por lo que requiere una conversi√≥n expl√≠cita.
            - Se considera un **"bug de dise√±o" heredado de Java**, ampliamente documentado en propuestas como [JDK-8073381](https://bugs.openjdk.org/browse/JDK-8073381) y mencionado como causa de fugas de memoria o problemas en bibliotecas como `kotlinx.serialization` o el conector MySQL JDBC.
        </Cons>
        <Pros title={<>Ventajas de <code>entries</code></>}>
            - Es una **colecci√≥n inmutable especializada** (`EnumEntries`), m√°s segura y alineada con la API de Kotlin.
            - **No requiere crear nuevas instancias** innecesarias.
            - Permite usar operaciones de colecci√≥n (`map`, `filter`, etc.) directamente sin conversi√≥n.
            - Mejora la legibilidad e intenci√≥n del c√≥digo.
        </Pros>
    </ProCons>
</details>

### üî¢ `ordinal: Int`

Indica **la posici√≥n del valor en la declaraci√≥n**, empezando desde 0:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/compiler/OptimizationPass.kt"
        enum class OptimizationPass {
            INLINE_FUNCTIONS, REMOVE_DEAD_CODE, FOLD_CONSTANTS;

            fun next(): OptimizationPass =
                entries[(ordinal + 1) % entries.size]
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/compiler/OptimizationPass.kt"
        enum class OptimizationPass {
            INLINE_FUNCTIONS, REMOVE_DEAD_CODE, FOLD_CONSTANTS;

            fun next(): OptimizationPass =
                entries[(ordinal + 1) % entries.size]
        }

        fun main() {
            println("Transitions:")
            OptimizationPass.entries.forEach { phase ->
                println(buildString {
                    append(phase.name)
                    append(" -> ")
                    append(phase.next().name)
                })
            }
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Cada valor en una `enum class` tiene asociado un √≠ndice llamado `ordinal`, que indica su **posici√≥n de declaraci√≥n** empezando desde 0.

    En este ejemplo:

    - `INLINE_FUNCTIONS` tiene `ordinal = 0`,
    - `REMOVE_DEAD_CODE` tiene `ordinal = 1`,
    - `FOLD_CONSTANTS` tiene `ordinal = 2`.

    Usamos `ordinal` para avanzar a la siguiente fase aplicando aritm√©tica modular con `entries.size`, lo que permite que la √∫ltima fase vuelva a la primera y as√≠ formar un **ciclo cerrado** de optimizaciones.

    Este patr√≥n es √∫til para modelar **m√°quinas de estados c√≠clicas**, **etapas repetitivas de compilaci√≥n**, o **modos de operaci√≥n rotativos** donde no queremos codificar manualmente las transiciones.
</Explanation>

:::danger Evita usar `ordinal` como ID persistente

No uses `ordinal` como identificador en bases de datos, archivos o protocolos.  
**Cambiar el orden de los valores en el `enum` modificar√≠a autom√°ticamente su `ordinal`, rompiendo la correspondencia** con los datos almacenados y causando errores dif√≠ciles de detectar.

En su lugar, usa `name` o una propiedad expl√≠cita como `code` o `id` si necesitas un identificador estable.

:::

### üîé `valueOf(value: String): Enum`

Permite obtener una instancia de la enumeraci√≥n a partir de su nombre como cadena:

```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/build/BuildPhase.kt"
val phase = OptimizationPass.valueOf("INLINE_FUNCTIONS")
println("Current build phase: ${phase.name}")
try {
    OptimizationPass.valueOf("INVALID_PHASE")
} catch (e: IllegalArgumentException) {
    println("Caught an exception: ${e.message}")
}
```

::::danger √ötil, pero a qu√© costo...

`valueOf` permite construir un valor desde texto externo (por ejemplo, configuraci√≥n, argumentos, archivos), pero **sacrifica la seguridad de tipos**:  
- Si el valor no coincide exactamente con ninguno de los nombres definidos, lanza una excepci√≥n en tiempo de ejecuci√≥n.
- No hay validaci√≥n del compilador, ya que el argumento es una cadena arbitraria.

Esto debilita uno de los principales beneficios de los tipos suma: **su naturaleza cerrada y verificable en tiempo de compilaci√≥n**.

:::tip Recomendaci√≥n

Evita `valueOf` en c√≥digo interno. Prefiere `when` exhaustivos siempre que sea posible.

:::

::::

<Box>
    ## üß© Ejercicio de cierre: Enums como estrategias de validaci√≥n

    Imagina que est√°s dise√±ando una biblioteca para validar nombres de usuario en distintas plataformas. Cada plataforma tiene **reglas diferentes**:

    * En *Web*: debe tener entre 4 y 12 caracteres, y solo letras o n√∫meros.
    * En *M√≥vil*: debe comenzar con letra y puede contener guiones bajos.
    * En *Consola*: debe tener exactamente 8 caracteres y no contener vocales.

    Con este fin:

    1. Declara un `enum class` llamado `ValidationPlatform` con los valores `WEB`, `MOBILE` y `CONSOLE`.
    2. Asigna a cada valor del enum una funci√≥n `validate(name: String): Boolean` con su l√≥gica correspondiente.
    3. Agrega una propiedad `description` que explique la validaci√≥n que aplica cada plataforma.
    4. Escribe una funci√≥n `printValidationInfo(name: String)` ‚Äîfuera del `enum`‚Äî que imprima si el nombre es v√°lido en cada plataforma, junto a su descripci√≥n.

    <Hint 
        hints={[
            <>Usa <b>clases an√≥nimas</b> para implementar la l√≥gica de validaci√≥n de cada plataforma.</>,
            <>
                Puedes usar <code>CharSequence.all &#123; Char -&gt; Boolean &#125;: Boolean</code> ‚Äîdonde <code>String</code> es un subtipo de <code>CharSequence</code>‚Äî para verificar que todos los caracteres de una cadena cumplen una condici√≥n.
            </>,
            <>
                Como complemento, la funci√≥n <code>CharSequence.none &#123; Char -&gt; Boolean &#125;: Boolean</code> te ayudar√° a verificar que <b>ning√∫n</b> car√°cter cumple una condici√≥n.
            </>,
            <>
                La funci√≥n <code>Char.isLetterOrDigit(): Boolean</code> te ayudar√° a verificar si un car√°cter es una letra o un n√∫mero.
            </>,
            <>
                De la misma forma, <code>Char.isLetter(): Boolean</code> te permitir√° verificar si un car√°cter es una letra.
            </>
        ]}
    />
    
    :::important

    **No uses `when`**: cada valor debe encapsular su propia l√≥gica.

    :::

    <Solution>
        ```kotlin showLineNumbers title="sum/src/main/kotlin/cl/ravenhill/platform/ValidationPlatform.kt"
        enum class ValidationPlatform {
            WEB {
                override val description: String =
                    "Web platform with strict naming rules: 4-12 characters, alphanumeric only"

                override fun validate(name: String): Boolean =
                    name.length in 4..12 && name.all { it.isLetterOrDigit() }
            },
            MOBILE {
                override val description: String =
                    "Mobile platform with flexible naming: first character must be a letter, rest alphanumeric or underscore"

                override fun validate(name: String): Boolean =
                    name.first().isLetter() && name.all { it.isLetterOrDigit() || it == '_' }
            },
            CONSOLE {
                override val description: String =
                    "Console platform with unique naming: 8 characters, no vowels allowed"

                override fun validate(name: String): Boolean {
                    val vowels = "aeiouAEIOU".toSet()
                    return name.length == 8 && name.none { it in vowels }
                }
            };

            abstract val description: String

            abstract fun validate(name: String): Boolean
        }

        fun printValidationInfo(name: String) {
            for (platform in ValidationPlatform.entries) {
                println(buildString {
                    appendLine("Platform: ${platform.name}")
                    appendLine("Description: ${platform.description}")
                    appendLine("Is '$name' valid? ${platform.validate(name)}")
                })
            }
        }
        ```

        <Explanation>
            En este ejemplo, modelamos **plataformas de validaci√≥n de nombres de usuario** usando una `enum class` que act√∫a como una clase abstracta.

            Cada valor del enum (`WEB`, `MOBILE`, `CONSOLE`) define:
            
            - Una **descripci√≥n espec√≠fica** (`description`), sobrescribiendo una propiedad abstracta.
            - Una funci√≥n `validate(name: String)` con **reglas de validaci√≥n diferentes** seg√∫n la plataforma.

            Este patr√≥n permite encapsular reglas de negocio diferenciadas dentro de cada instancia del `enum`, en lugar de usar condicionales o estructuras `when`.  
            Es √∫til cuando los valores del `enum` representan **estrategias, modos o entornos con comportamiento propio**.

            Adem√°s, como `entries` contiene todos los valores, podemos recorrerlos para aplicar la validaci√≥n en cada plataforma sin acoplar nuestro c√≥digo a un valor espec√≠fico.
        </Explanation>
    </Solution>
</Box>

## üéØ Conclusiones

En esta lecci√≥n exploramos c√≥mo las enumeraciones en Kotlin no se limitan a representar conjuntos finitos de valores constantes, sino que pueden actuar como **clases completas**, con propiedades, estado interno y comportamiento espec√≠fico por instancia.  
Esto permite modelar estructuras m√°s expresivas y reutilizables, encapsulando l√≥gica sin depender de condicionales externos.

Tambi√©n revisamos herramientas est√°ndar disponibles para trabajar con `enum class`, como `name`, `entries`, `ordinal` y `valueOf`, junto con sus beneficios y limitaciones. Finalmente, aplicamos estos conceptos para construir una estrategia de validaci√≥n polim√≥rfica basada en enumeraciones.

### üîë Puntos clave

- Un `enum class` puede contener **propiedades mutables, funciones y l√≥gica especializada** por instancia.
- Las enumeraciones pueden actuar como **clases abstractas**, y cada valor puede sobrescribir miembros distintos.
- Es posible implementar **interfaces** y usar enumeraciones como estrategias reutilizables o controladores de flujo.
- La propiedad `entries` (desde Kotlin 1.9) reemplaza a `values()` como la forma preferida y segura de listar valores.
- Aunque pr√°cticas, funciones como `ordinal` o `valueOf` deben usarse con cuidado en contextos persistentes o externos.

### üß∞ ¬øQu√© nos llevamos?

Las enumeraciones avanzadas nos ense√±an que no todo comportamiento debe modelarse con clases completas o jerarqu√≠as complejas.  
Cuando los casos est√°n cerrados y bien definidos, un `enum class` puede ser una forma compacta, segura y elegante de **representar estrategias, reglas de validaci√≥n, fases de un sistema, modos de operaci√≥n o cualquier conjunto fijo de comportamientos diferenciados**.

Este enfoque promueve un dise√±o **m√°s expresivo, menos propenso a errores y con menor acoplamiento**, al centralizar el comportamiento en las propias instancias del enum.  
Es una herramienta valiosa para quienes dise√±an **librer√≠as reutilizables, DSLs o arquitecturas extensibles**, y un excelente ejemplo de c√≥mo Kotlin fusiona ideas orientadas a objetos con principios de programaci√≥n funcional.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList 
    title="üî• Referencias recomendadas"
    items={[
        <WebPage
            title="Working with Enums in Kotlin"
            url="https://www.baeldung.com/kotlin/enum"
            location="Baeldung"
        >
            Este art√≠culo explora en profundidad las caracter√≠sticas avanzadas de las enumeraciones en Kotlin. Parte desde conceptos b√°sicos como la definici√≥n de enums y su inicializaci√≥n, hasta aspectos m√°s complejos como clases an√≥nimas por constante, implementaci√≥n de interfaces, uso de <code>entries</code> en lugar de <code>values</code>, y los riesgos de depender del <code>ordinal</code>. Adem√°s, discute c√≥mo extender el comportamiento de enums a trav√©s de interfaces o clases selladas, y presenta la distinci√≥n entre enums ordinales y no ordinales. Es una referencia pr√°ctica y detallada para modelar datos con enums en Kotlin de forma segura y expresiva.
        </WebPage>
    ]}
/>

<ReferenceList
    title="üîπ Referencias adicionales"
    items={[
        <WebPage
            title="Enum class declaration"
            url="https://kotlinlang.org/docs/enum-classes.html#enum-class-declaration"
            location="Kotlin Language Specification"
        >
            Explica la estructura y comportamiento de las enum classes en Kotlin. Describe sus propiedades principales (valores predefinidos, herencia de Enum, imposibilidad de heredar o parametrizar), as√≠ como sus miembros impl√≠citos como <code>name</code>, <code>ordinal</code>, <code>compareTo</code>, <code>entries</code>, <code>valueOf</code> y <code>values</code>. Tambi√©n se destaca la diferencia entre <code>entries</code> y <code>values</code>, recomendando el uso de <code>entries</code> desde Kotlin 1.9. Incluye ejemplos de enums simples y con l√≥gica espec√≠fica en cada entrada.
        </WebPage>,
        <WebPage
            title={<>Decommission <code>Enum.values()</code> and replace it with <code>Enum.entries</code></>}
            url="https://github.com/Kotlin/KEEP/blob/master/proposals/enum-entries.md"
            location="KEEP - Kotlin Evolution and Enhancement Process"
            author={<AuthorList authors={[{ firstName: "Vsevolod", lastName: "Tolstopytov", url: "https://github.com/qwwdfsad" }]} />}
        >
            Presenta la propuesta oficial para reemplazar <code>Enum.values()</code> por la propiedad <code>Enum.entries</code> en Kotlin, destacando sus ventajas en rendimiento, inmutabilidad y compatibilidad con APIs basadas en colecciones. Se introducen el tipo <code>EnumEntries&lt;E&gt;</code> y una estrategia de transici√≥n asistida por el IDE sin romper compatibilidad. La propuesta fue aceptada e implementada como parte de Kotlin 1.9, con un plan gradual de despriorizaci√≥n de <code>values()</code> y apoyo mediante funciones como <code>enumEntries</code>.
        </WebPage>
    ]}
/>
