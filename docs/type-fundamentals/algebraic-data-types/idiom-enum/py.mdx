---
title: Modelado avanzado con enumeraciones en Python
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime';

import BoxedTabs, { TabItem } from '@site/src/components/cajitas/BoxedTabs';
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons';

import RepoLinks from '@site/src/components/git/RepoLinks';
import GitLabRepo from '@site/src/components/git/GitLabRepo';
import GitHubRepo from '@site/src/components/git/GitHubRepo';

import ReferenceList from '@site/src/components/references/ReferenceList';
import WebPage from '@site/src/components/references/WebPage';

import OfficialDocumentation from '@site/src/components/Tooltip/OfficialDocumentation';

<ReadingTime    />
<RepoLinks children={[
    <GitLabRepo user="r8vnhill" repo="python-dibs" />,
    <GitHubRepo user="r8vnhill" repo="python-dibs" />
]} />

En esta lecci√≥n profundizamos en el uso de enumeraciones (`Enum`) en Python para modelar **tipos suma con comportamiento**, una t√©cnica com√∫n en el dise√±o de bibliotecas reutilizables y sistemas de automatizaci√≥n.

Hasta ahora, ya sabemos declarar enums simples con `auto()` y usarlos en estructuras de control como `match`. Aqu√≠ aprenderemos a:

- Asociar **valores personalizados** a cada caso y acceder a ellos mediante `.name` y `.value`.
- Iterar sobre los valores de un enum y construir listas legibles o din√°micas.
- Implementar **comportamiento especializado por caso** mediante m√©todos que dependen del valor (`self`).
- Recorrer enums en orden o de forma **circular**, √∫til en secuencias como fases de compilaci√≥n o validaci√≥n.
- Usar `Flag` para representar **modos de operaci√≥n combinables**, una t√©cnica muy √∫til en sistemas de construcci√≥n.

Adem√°s, compararemos el modelo de enums de Python con el de Kotlin para comprender sus **l√≠mites y posibilidades**.

Esta lecci√≥n ampl√≠a las capacidades expresivas de los enums m√°s all√° de los casos constantes, permitiendo construir APIs m√°s claras, seguras y f√°ciles de extender.

:::danger Enum con estado interno mutable

En Kotlin vimos que los valores de un enum pueden tener **propiedades mutables** (`var`) que cambian su estado en tiempo de ejecuci√≥n.  
Python **no lo permite de forma segura**: aunque t√©cnicamente es posible modificar atributos, hacerlo viola el principio de inmutabilidad de los enums y puede producir errores sutiles.

:::

## üõ†Ô∏è Iterando y accediendo a valores en un `Enum`

En este ejemplo exploramos varias caracter√≠sticas clave de los `Enum` en Python:

- C√≥mo definir enumeraciones con valores personalizados (en este caso, descripciones).
- C√≥mo iterar sobre sus valores usando `for` o list comprehension.
- C√≥mo acceder al nombre (`name`) y al valor asociado (`value`) de cada constante.

```python showLineNumbers title="Definici√≥n de enum (type-fundamentals/algebraic_types/sum/enum/compiler.py)"
from enum import Enum

class OptimizationPass(Enum):
    INLINE_FUNCTIONS = "Inline functions to reduce call overhead."
    REMOVE_DEAD_CODE = "Remove code that is never executed."
    FOLD_CONSTANTS = "Replace expressions with constant values where possible."
```

```python showLineNumbers title="Iteraci√≥n y acceso (type-fundamentals/algebraic_types/sum/enum/compiler.py)"
for phase in OptimizationPass:
    print(f"Optimization phase: {phase.name} ({phase.value})")

# Tambi√©n se puede generar una lista de strings representativas:
print([f"{p.name} ({p.value})" for p in OptimizationPass])
```

:::explanation

Cada valor del enum `OptimizationPass` tiene:

- Un **nombre** (por ejemplo, `INLINE_FUNCTIONS`), accesible con `.name`.
- Un **valor asociado** (una descripci√≥n), accesible con `.value`.

En este caso, `.value` no es un n√∫mero, sino una cadena personalizada.  
Esto hace que la enumeraci√≥n sea m√°s expresiva y √∫til, especialmente cuando se quiere mostrar informaci√≥n legible o documentar una secuencia de pasos.

El uso de `for` sobre un enum itera sobre todos sus miembros, en el orden en que fueron declarados.  
Esto permite construir interfaces din√°micas, generar documentaci√≥n o aplicar l√≥gica en secuencia.

:::

## üß™ Estrategias de validaci√≥n con enumeraciones

Este ejemplo muestra c√≥mo usar una enumeraci√≥n (`Enum`) para representar un tipo suma que encapsula distintas **estrategias de validaci√≥n de nombres de usuario**.  
Es una t√©cnica com√∫n en el dise√±o de **librer√≠as reutilizables**, donde cada caso del enum implementa un comportamiento espec√≠fico mediante un m√©todo compartido.

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
    ```python showLineNumbers title="type-fundamentals/algebraic_types/sum/enum/validator.py"
    class ValidationStrategy(Enum):
        WEB = auto()
        MOBILE = auto()
        CONSOLE = auto()

        def validate(self, name: str) -> bool:
            match self:
                case ValidationStrategy.WEB:
                    return name.isalnum() and 4 <= len(name) <= 12
                case ValidationStrategy.MOBILE:
                    return name[0].isalpha() and all(c.isalnum() or c == "_" for c in name)
                case ValidationStrategy.CONSOLE:
                    return len(name) == 8 and not any(c in "aeiouAEIOU" for c in name)
                case _:
                    raise ValueError(f"Unknown validation strategy: {self}")
    ```
  </TabItem>
  <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
    ```python showLineNumbers title="type-fundamentals/algebraic_types/sum/enum/validator.py"
    from enum import Enum, auto


    class ValidationStrategy(Enum):
        WEB = auto()
        MOBILE = auto()
        CONSOLE = auto()

        def validate(self, name: str) -> bool:
            match self:
                case ValidationStrategy.WEB:
                    return name.isalnum() and 4 <= len(name) <= 12
                case ValidationStrategy.MOBILE:
                    return name[0].isalpha() and all(c.isalnum() or c == "_" for c in name)
                case ValidationStrategy.CONSOLE:
                    return len(name) == 8 and not any(c in "aeiouAEIOU" for c in name)
                case _:
                    raise ValueError(f"Unknown validation strategy: {self}")


    if __name__ == "__main__":
        user = "Admin_01"

        for strategy in ValidationStrategy:
            print(f"{strategy.name}: {strategy.value}")
            print("‚úì Valid" if strategy.validate(user) else "‚úó Invalid")
            print()
    ```
  </TabItem>
</BoxedTabs>

:::explanation

Cada valor del enum `ValidationStrategy` representa una estrategia diferente para validar un nombre de usuario.

- La estrategia `WEB` permite solo caracteres alfanum√©ricos y longitudes entre 4 y 12 caracteres.
- La estrategia `MOBILE` permite guiones bajos, pero requiere que el primer car√°cter sea una letra.
- La estrategia `CONSOLE` exige exactamente 8 caracteres y proh√≠be vocales.

El m√©todo `validate()` implementa **comportamiento especializado por caso** usando una estructura `match`, que act√∫a como una alternativa clara y segura a los `if` o `dict`.

:::

:::warning L√≠mite del modelo de enums en Python

En Python, **no puedes asociar una subclase an√≥nima a cada valor del enum** como en Kotlin.  
Esto significa que:

- No puedes declarar m√©todos `abstract` en el enum y sobrescribirlos por constante.
- No puedes encapsular l√≥gica espec√≠fica por caso directamente dentro del valor.
- La l√≥gica diferenciada debe implementarse usando `if`, `match`, o diccionarios.

En contraste, Kotlin permite que cada valor de un `enum class` act√∫e como una subclase an√≥nima con su propia implementaci√≥n, lo que favorece un dise√±o m√°s polim√≥rfico y expresivo.

:::

## üîÅ Recorrido c√≠clico de un enum

En este ejemplo mostramos c√≥mo:

- Convertir una enumeraci√≥n en una lista para poder recorrerla secuencialmente.
- Obtener el √≠ndice (similar al *ordinal* en otros lenguajes) de un valor del enum.
- Calcular el **siguiente valor** en la secuencia de manera c√≠clica.

```python showLineNumbers title="type-fundamentals/algebraic_types/sum/enum/compiler.py"
def next_pass(current: OptimizationPass) -> OptimizationPass:
    passes = list(OptimizationPass)
    index = passes.index(current)
    return passes[(index + 1) % len(passes)]
```

:::explanation

La funci√≥n `next_pass` toma un valor del enum `OptimizationPass` y devuelve el siguiente en la secuencia.  
Si el valor actual es el √∫ltimo, se vuelve al primero, generando un recorrido **circular**.

Esto es posible porque:

- `list(OptimizationPass)` convierte el enum en una lista ordenada seg√∫n su declaraci√≥n.
- `passes.index(current)` obtiene el √≠ndice actual.
- `(index + 1) % len(passes)` permite envolver el √≠ndice cuando se alcanza el final.

Este patr√≥n es √∫til cuando las fases de un proceso (como optimizaci√≥n, compilaci√≥n o validaci√≥n) deben recorrerse en orden o aplicarse c√≠clicamente.

:::

## üß± Modos de construcci√≥n combinables con `Flag`

En este ejemplo usamos `Flag` para representar modos de construcci√≥n que pueden combinarse libremente.  
Es √∫til en **build systems** o bibliotecas de automatizaci√≥n donde se desea ejecutar m√∫ltiples tareas en un solo paso (por ejemplo: compilar + testear).

```python showLineNumbers title="type-fundamentals/algebraic_types/sum/enum/build_mode.py"
from enum import Flag, auto


class BuildMode(Flag):
    COMPILE = auto()
    DOCS = auto()
    TEST = auto()


def run_build(mode: BuildMode):
    print(f"Running build mode: {mode}")

    if BuildMode.COMPILE in mode:
        print("- Compiling source files...")
    if BuildMode.DOCS in mode:
        print("- Generating documentation...")
    if BuildMode.TEST in mode:
        print("- Running test suite...")


if __name__ == "__main__":
    full_build = BuildMode.COMPILE | BuildMode.TEST
    run_build(full_build)
```

:::explanation

El enum `BuildMode` est√° definido como un `Flag`, lo que permite:

- **Combinar valores** mediante `|`, por ejemplo: `BuildMode.COMPILE | BuildMode.TEST`.
- **Verificar** si un modo espec√≠fico est√° activado usando `in`, por ejemplo: `if BuildMode.TEST in mode`.
- **Imprimir** m√∫ltiples modos combinados como `BuildMode.COMPILE|TEST`.

Esto es √∫til para crear interfaces flexibles donde se pueden activar varias fases del proceso de construcci√≥n sin necesidad de definir todas las combinaciones como enums separados.

Este patr√≥n se aplica tanto en herramientas de l√≠nea de comandos como en scripts internos de automatizaci√≥n, y representa una forma pr√°ctica de modelar **tipos suma con combinaci√≥n parcial**, similares a las "bit flags" cl√°sicas de sistemas operativos.

:::

## üÜö Resumen comparativo

| **Aspecto**                                   | **Kotlin**                                                                                             | **Python**                                                                                      |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
| **Estado mutable**                            | S√≠, valores singleton con propiedades `var` mutables (aunque no recomendado en APIs p√∫blicas).         | T√©cnicamente posible modificar atributos, pero no seguro ni recomendable (rompe inmutabilidad). |
| **Comportamiento por valor**                  | Cada valor puede ser una subclase an√≥nima con implementaci√≥n espec√≠fica de m√©todos y propiedades.      | No se puede crear subclases an√≥nimas por valor; se usa l√≥gica condicional en m√©todos comunes.   |
| **Iteraci√≥n sobre valores**                   | Propiedad `entries` (reemplaza a `values()` desde Kotlin 1.9), eficiente y segura.                     | Se puede iterar usando `for valor in Enum`.                                                     |
| **Orden y posici√≥n (`ordinal`)**              | Cada valor tiene `ordinal` (√≠ndice de declaraci√≥n), √∫til para ciclos y ordenamientos.                  | No tiene equivalente directo; se usa √≠ndice de lista `list(Enum).index(valor)`.                 |
| **Obtenci√≥n de valor por nombre (`valueOf`)** | Existe, pero lanzar excepci√≥n si el nombre no existe.                                                  | Acceso directo con `Enum['NOMBRE']`, lanzando `KeyError` si no existe.                          |

<ProCons>
  <Pros title="Beneficios de Python">
    - Las enumeraciones pueden tener valores personalizados legibles (por ejemplo, descripciones).
    - Se pueden recorrer e indexar f√°cilmente usando `list(...)`, lo que permite construir recorridos secuenciales o circulares.
    - La clase `Flag` permite modelar combinaciones de valores como modos de construcci√≥n, √∫tiles para scripts o CLI de automatizaci√≥n.
  </Pros>
  <Cons title="Limitaciones de Python">
    - No se pueden declarar subclases an√≥nimas por cada valor como en Kotlin; el comportamiento espec√≠fico debe implementarse manualmente.
    - No se puede forzar que los valores del enum implementen m√©todos abstractos de forma segura.
    - El modelo de mutabilidad es fr√°gil: aunque t√©cnicamente se puede cambiar el estado de un enum, esto rompe su contrato de inmutabilidad.
  </Cons>
</ProCons>

## üéØ Conclusiones

Las enumeraciones en Python son una herramienta poderosa para representar **tipos suma** de forma clara, segura y expresiva. A pesar de las limitaciones del modelo respecto a lenguajes como Kotlin, es posible construir enums que no solo representen casos distintos, sino que tambi√©n encapsulen **comportamiento especializado** por caso, favoreciendo una separaci√≥n limpia de responsabilidades.

Adem√°s, Python ofrece variantes √∫tiles como `Flag`, que permiten modelar combinaciones de valores de forma concisa, y facilita recorridos secuenciales con t√©cnicas expl√≠citas usando `list(...)`. Estas capacidades hacen de las enumeraciones una pieza central en el dise√±o de bibliotecas configurables, flujos de validaci√≥n, y scripts de automatizaci√≥n.

### üîë Puntos clave

- Python permite asociar valores personalizados a un `Enum`, como descripciones o c√≥digos legibles.
- Los enums pueden definir m√©todos que dependen del valor actual (`self`), usando `match`, `if`, o diccionarios para diferenciar comportamientos.
- Aunque no se pueden declarar subclases an√≥nimas por valor, el patr√≥n `match` permite mantener el c√≥digo legible y modular.
- Se pueden implementar patrones como recorridos circulares (`next`) transformando el enum en lista e indexando manualmente.
- La clase `Flag` permite combinar valores como si fueran "bit flags", √∫til para representar modos de operaci√≥n simult√°neos.
- Python distingue distintos tipos de enums: `Enum`, `IntEnum`, `StrEnum`, y `Flag`, cada uno √∫til seg√∫n el dominio del problema.

### üß∞ ¬øQu√© nos llevamos?

Al dise√±ar bibliotecas de software en Python, las enumeraciones nos permiten **declarar de forma expl√≠cita y segura** los distintos casos o modos de operaci√≥n de un sistema, ya sea para validaciones, fases de compilaci√≥n, configuraciones, o combinaciones de tareas. Aunque el modelo de enums en Python es m√°s limitado que el de otros lenguajes, **el dise√±o cuidadoso y el uso de patrones idiom√°ticos** permite expresar comportamientos complejos de forma clara y mantenible.

Comprender estas capacidades no solo mejora el dise√±o interno de nuestras bibliotecas, sino que tambi√©n **facilita su uso por otras personas**, al hacer expl√≠citas las alternativas disponibles y sus efectos. En s√≠ntesis: dominar las enumeraciones en Python es clave para construir software reusable, expresivo y robusto.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList
    title="üî• Referencias recomendadas"
    items={[
        <WebPage
            title="Enum ‚Äî Support for Enumerations"
            url="https://docs.python.org/3/library/enum.html"
            location={<OfficialDocumentation>The Python Standard Library</OfficialDocumentation>}
        >
            Este documento es la referencia oficial del m√≥dulo <code>enum</code> de Python, incorporado desde la versi√≥n 3.4 y expandido en versiones posteriores. Define c√≥mo modelar conjuntos de constantes simb√≥licas mediante enumeraciones que pueden tener valores √∫nicos, ser iteradas, comparadas y extendidas con comportamiento personalizado. Presenta variantes como <code>Enum</code>, <code>IntEnum</code>, <code>StrEnum</code>, <code>Flag</code> e <code>IntFlag</code>, as√≠ como herramientas avanzadas para validaci√≥n (<code>@verify</code>, <code>EnumCheck</code>), combinaci√≥n de flags, asignaci√≥n autom√°tica de valores (<code>auto</code>), y control de alias y valores inv√°lidos. La gu√≠a tambi√©n describe decoradores √∫tiles, la metaclase <code>EnumType</code>, y c√≥mo extender la funcionalidad por medio de m√©todos especiales.
        </WebPage>
    ]}
/>
