
## üéÅ Desestructuraci√≥n

Una de las ventajas de las `data class` es que generan autom√°ticamente funciones `componentN()` que permiten **extraer sus campos de forma clara y concisa**, sin necesidad de acceder a ellos uno por uno.

Por ejemplo, al representar una canci√≥n de *Aerosmith*:

```kotlin showLineNumbers title="Desestructuraci√≥n de una data class"
data class Song(val title: String, val year: Int)

val (title, year) = Song("Dream On", 1973)
println("'$title' se lanz√≥ en $year")
```

Este tipo de desestructuraci√≥n es especialmente √∫til cuando:

- Iteras sobre listas de objetos
- Trabajas con funciones puras que devuelven m√∫ltiples valores
- Usas combinadores como `map`, `filter`, `fold`, etc.

    ```kotlin showLineNumbers title="Uso en una lista"
    val playlist = listOf(
        Song("Dream On", 1973),
        Song("I Don't Want to Miss a Thing", 1998)
    )

    for ((title, year) in playlist) {
        println("$title ($year)")
    }
    ```

## ‚ôªÔ∏è Mutabilidad controlada con `copy`

Las `data class` en Kotlin son **inmutables por convenci√≥n**. Aunque t√©cnicamente puedes declarar propiedades mutables (`var`), lo recomendable en bibliotecas bien dise√±adas es utilizar **solo propiedades inmutables** (`val`), promoviendo un estilo funcional y seguro.

En lugar de modificar un objeto existente, puedes usar el m√©todo `copy()` para **crear una nueva instancia** con los cambios deseados, sin alterar el original.

```kotlin showLineNumbers title="Uso de copy para modificar datos sin mutar el original"
data class Mecha(val name: String, val power: Int)

val gurren = Mecha("Gurren", 3000)
val gurrenLagann = gurren.copy(name = "Gurren Lagann", power = 9000)

println(gurren)        // Mecha(name=Gurren, power=3000)
println(gurrenLagann)  // Mecha(name=Gurren Lagann, power=9000)
```

Este patr√≥n es √∫til para mantener objetos **seguros, predecibles y f√°ciles de testear**, especialmente en bibliotecas reutilizables o sistemas concurrentes.

### üîÑ ¬øCu√°ndo es razonable usar mutabilidad?

Aunque las `data class` promueven la **inmutabilidad por convenci√≥n**, hay situaciones en las que **usar mutabilidad es justificable**:

- Est√°s modelando **estado mutable por naturaleza**, como una sesi√≥n de usuario, un contador, o una conexi√≥n abierta.
- Necesitas **actualizar datos frecuentemente** en contextos donde **crear copias ser√≠a ineficiente**, como en simulaciones, videojuegos, o sistemas de alto rendimiento.
- Est√°s trabajando en estructuras de datos **transitorias o internas**, donde el modelo no forma parte del contrato p√∫blico de la biblioteca.

:::tip Recomendaci√≥n

Si necesitas mutabilidad, considera **separar los datos inmutables del estado mutable**. Una estrategia com√∫n es encapsular un modelo inmutable (`data class`) dentro de una clase mutable que controla su evoluci√≥n:

```kotlin
data class FighterStats(val hp: Int, val stamina: Int)

class CombatSession(initialStats: FighterStats) {
    var current = initialStats

    fun receiveDamage(amount: Int) {
        current = current.copy(hp = (current.hp - amount).coerceAtLeast(0))
    }
}
```

:::

:::danger Rendimiento

En contextos donde se realizan **cientos o miles de copias por segundo**, como en motores f√≠sicos, renderizado o procesamiento en tiempo real, la creaci√≥n reiterada de nuevas instancias puede convertirse en un **cuello de botella**. En estos casos, es v√°lido optar por clases mutables si ello mejora significativamente el rendimiento.

:::

## üß© ¬øCu√°ndo usar `data class`, `class` o tuplas (`Pair`/`Triple`)?

| **Escenario**                                | **`data class`** üü¢                     | **`class`** ‚öôÔ∏è                           | **Tupla (`Pair` / `Triple`)** üîπ             |
|---------------------------------------------|----------------------------------------|------------------------------------------|-----------------------------------------------|
| Modelar datos estructurados con nombre      | ‚úÖ Ideal                                | ‚ö†Ô∏è Posible pero m√°s verboso              | ‚ùå Nombres impl√≠citos dificultan el uso        |
| Comparaci√≥n por contenido (`==`)            | ‚úÖ Autom√°tica                           | ‚ùå Solo por referencia                    | ‚ö†Ô∏è S√≠, pero sin sem√°ntica clara                |
| Requiere m√©todos como `copy`, `toString` | ‚úÖ Generados autom√°ticamente | ‚ùå Manuales | ‚úÖ Generados autom√°ticamente (`Pair`, `Triple`) |
| Encapsular l√≥gica adicional o comportamiento | ‚ö†Ô∏è Es posible, pero no idiom√°tico         | ‚úÖ Ideal para l√≥gica compleja               | ‚ö†Ô∏è Solo mediante `extension functions`, pero **no se recomienda** |
| Datos temporales o ad-hoc                   | ‚ö†Ô∏è Posible, pero puede ser overkill    | ‚ùå Verboso para casos simples             | ‚úÖ Ideal para datos r√°pidos y sin contexto     |
| Rendimiento extremo / estructuras internas  | ‚ö†Ô∏è Evaluar caso a caso                  | ‚úÖ Control total                          | ‚úÖ Muy livianas y directas                     |

:::tip En resumen

- Usa **`data class`** cuando quieras representar **datos estructurados y reutilizables**, con comparaci√≥n por contenido y una API rica generada autom√°ticamente.
- Usa **`class`** cuando necesites **controlar comportamiento interno**, l√≥gica compleja o herencia.
- Usa **tuplas** solo para **datos temporales**, sin sem√°ntica clara, como resultados intermedios o auxiliares dentro de una funci√≥n.

::: 

## üîß Funciones y propiedades en `data class`

Aunque las `data class` est√°n dise√±adas para modelar **datos estructurados**, eso no impide que incluyan **propiedades calculadas** o **funciones auxiliares**.

Esto puede ser √∫til para agregar **l√≥gica derivada**, validaciones simples o representaciones alternativas sin romper la sem√°ntica del tipo.

```kotlin title="Propiedad calculada y funci√≥n auxiliar"
data class Wizard(val name: String, val magic: String, val power: Int) {
    val isArchmage: Boolean
        get() = power > 9000

    fun shout() = println("$name casts $magic at power $power!")
}
```

:::info
En este ejemplo, `isArchmage` es una propiedad calculada que no forma parte de la estructura del tipo, pero entrega **informaci√≥n derivada** a partir de sus campos. `shout()` es una funci√≥n auxiliar que encapsula un comportamiento asociado al tipo.
:::

### ‚ö†Ô∏è ¬°Ojo! No todos los campos se tratan igual

Solo las propiedades **declaradas en el constructor primario** participan en la generaci√≥n autom√°tica de:

- `equals()` / `hashCode()`
- `toString()`
- `copy()`
- `componentN()`

```kotlin title="Campo declarado fuera del constructor"
data class GuildMember(val name: String) {
    var rank: String = "Novice"
}

val a = GuildMember("Lucy")
val b = GuildMember("Lucy").also { it.rank = "Master" }

println(a == b) // true ‚ùó rank no participa en equals
println(a)      // GuildMember(name=Lucy) ‚ùó sin rank
```

:::warning Cuidado
Al declarar propiedades **fuera del constructor**, est√°s creando campos **excluidos del contrato estructural** de la `data class`. Esto puede llevar a resultados inesperados en comparaci√≥n, impresi√≥n o copia.

Si el campo es relevante para la identidad del objeto, **debe declararse en el constructor**.
:::

### üß≠ Recomendaci√≥n

- ‚úÖ Usa funciones y propiedades para l√≥gica derivada y accesos √∫tiles.
- ‚ùå Evita agregar **l√≥gica compleja** o **estado mutable** que rompa la expectativa de que una `data class` es un **contenedor simple y predecible de datos**.

Esto mantiene la intenci√≥n original clara, mejora la mantenibilidad y previene errores sutiles.

## Constructores

TODO
