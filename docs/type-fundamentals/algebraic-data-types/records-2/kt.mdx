---
title: Uso idiom√°tico de data class
---

import ReadingTime from "@site/src/components/ReadingTime"
import Explanation from "@site/src/components/admonitions/Explanation"
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'

<ReadingTime multiplier={2.0} />

En Kotlin, las `data class` son una de las herramientas m√°s poderosas y expresivas para modelar datos. Su dise√±o se alinea con los principios de inmutabilidad, comparaci√≥n estructural y simplicidad declarativa, convirti√©ndolas en una opci√≥n ideal para representar **tipos producto** ‚Äîestructuras que agrupan m√∫ltiples valores con significado sem√°ntico.

En esta lecci√≥n exploraremos el uso idiom√°tico de las `data class`, enfoc√°ndonos en sus ventajas frente a clases tradicionales o tuplas, su comportamiento predeterminado, y su rol en el dise√±o de **bibliotecas reutilizables**. Veremos c√≥mo desestructurar datos, crear nuevas instancias inmutables con `copy`, aprovechar constructores alternativos, y mantener un dise√±o limpio incluso cuando se requiere mutabilidad controlada.

Esta lecci√≥n no solo te ense√±ar√° a usar `data class` con fluidez, sino que te dar√° herramientas para tomar decisiones de dise√±o informadas al modelar estructuras de datos claras, robustas y f√°ciles de mantener.

:::info Glosario r√°pido

- **Tipo producto**: Agrupa m√∫ltiples valores con nombre, como `Point(x, y)`.
- **Registro (record)**: Tipo producto inmutable, comparable por contenido. En Kotlin: `data class`.
- **Inmutabilidad por convenci√≥n**: Usar `val` para evitar modificar objetos.
- **Comparaci√≥n por contenido**: Eval√∫a igualdad de campos (`==`), no de referencias (`===`).
- **Desestructuraci√≥n**: Extraer campos como variables usando `componentN()`.

:::


## üéÅ Desestructuraci√≥n

Una de las ventajas de las `data class` es que generan autom√°ticamente funciones `componentN()` que permiten **extraer sus campos de forma clara y concisa**, sin necesidad de acceder a ellos uno por uno.

Por ejemplo, al representar una canci√≥n de *Aerosmith*:

```kotlin showLineNumbers title="Desestructuraci√≥n de una data class"
data class Song(val title: String, val year: Int)

val (title, year) = Song("Dream On", 1973)
println("'$title' se lanz√≥ en $year")
```

Este tipo de desestructuraci√≥n es especialmente √∫til cuando:

- Iteras sobre listas de objetos
- Trabajas con funciones puras que devuelven m√∫ltiples valores
- Usas combinadores como `map`, `filter`, `fold`, etc.

```kotlin showLineNumbers title="Uso en una lista"
val playlist = listOf(
    Song("Dream On", 1973),
    Song("I Don't Want to Miss a Thing", 1998)
)

for ((title, year) in playlist) {
    println("$title ($year)")
}
```

## ‚ôªÔ∏è Mutabilidad controlada con `copy`

Las `data class` en Kotlin son **inmutables por convenci√≥n**. Aunque t√©cnicamente permiten declarar propiedades mutables (`var`), en bibliotecas bien dise√±adas se recomienda usar **solo propiedades inmutables** (`val`), promoviendo un estilo funcional y seguro.

En lugar de modificar un objeto existente, puedes usar el m√©todo `copy()` para **crear una nueva instancia** con los cambios deseados, sin alterar el original:

```kotlin showLineNumbers title="Uso de copy para modificar datos sin mutar el original"
data class Mecha(val name: String, val power: Int)

val gurren = Mecha("Gurren", 3000)
val gurrenLagann = gurren.copy(name = "Gurren Lagann", power = 9000)

println(gurren)        // Mecha(name=Gurren, power=3000)
println(gurrenLagann)  // Mecha(name=Gurren Lagann, power=9000)
```

Este patr√≥n permite que los objetos sean **seguros, predecibles y f√°ciles de testear**, cualidades fundamentales en el desarrollo de bibliotecas reutilizables o sistemas concurrentes.

### üîÑ ¬øCu√°ndo es razonable usar mutabilidad?

Aunque las `data class` promueven la **inmutabilidad por convenci√≥n**, existen escenarios en los que **la mutabilidad est√° justificada**:

- Est√°s modelando **estado que cambia naturalmente con el tiempo**, como una sesi√≥n de usuario, un contador o una conexi√≥n activa.
- Necesitas **actualizar datos de forma intensiva o frecuente**, donde **crear copias ser√≠a costoso** o innecesariamente complejo (por ejemplo, en simulaciones, videojuegos o sistemas de alto rendimiento).
- Est√°s trabajando con **estructuras internas o transitorias**, que no forman parte del contrato p√∫blico de tu biblioteca y pueden beneficiarse de una representaci√≥n mutable.

:::tip Recomendaci√≥n

Cuando requieras mutabilidad, considera **separar el estado mutable del modelo inmutable**. Un enfoque com√∫n es utilizar una `data class` como **modelo de referencia o configuraci√≥n inicial**, y representar el estado cambiante con una clase mutable dedicada:

```kotlin showLineNumbers title="Separaci√≥n de modelo y estado mutable"
data class FighterStats(val maxHp: Int, val maxStamina: Int)

class CombatSession(stats: FighterStats) {
    var currentHp: Int = stats.maxHp
        private set

    var currentStamina: Int = stats.maxStamina
        private set

    fun receiveDamage(amount: Int) {
        currentHp = (currentHp - amount).coerceAtLeast(0)
    }

    fun consumeStamina(amount: Int) {
        currentStamina = (currentStamina - amount).coerceAtLeast(0)
    }
}
```

En este patr√≥n, `FighterStats` representa un modelo inmutable de referencia (por ejemplo, los valores base del personaje), mientras que `CombatSession` gestiona el estado mutable de la instancia en ejecuci√≥n. As√≠ se evita crear copias constantes y se mantiene clara la separaci√≥n entre **datos persistentes** y **estado transitorio**.

:::

:::danger Rendimiento

En contextos donde se realizan **cientos o miles de copias por segundo** ‚Äîcomo en motores f√≠sicos, sistemas de renderizado o procesamiento en tiempo real‚Äî, la creaci√≥n constante de nuevas instancias puede convertirse en un **cuello de botella**. En estos casos, usar clases mutables puede ser una decisi√≥n v√°lida si **mejora significativamente el rendimiento** sin comprometer la claridad ni la seguridad del dise√±o.

:::

## üß© ¬øCu√°ndo usar `data class`, `class` o tuplas (`Pair` / `Triple`)?

| **Escenario**                               | **`data class`** üü¢                          | **`class`** ‚öôÔ∏è                              | **Tupla (`Pair` / `Triple`)** üîπ                    |
|--------------------------------------------|---------------------------------------------|---------------------------------------------|-----------------------------------------------------|
| Modelar datos estructurados con nombre     | ‚úÖ Ideal                                     | ‚ö†Ô∏è Posible, pero m√°s verboso                | ‚ùå Nombres impl√≠citos dificultan la claridad         |
| Comparaci√≥n por contenido (`==`)           | ‚úÖ Generada autom√°ticamente                 | ‚ùå Solo por referencia                       | ‚ö†Ô∏è Disponible, pero sin sem√°ntica expl√≠cita          |
| M√©todos como `copy`, `toString`            | ‚úÖ Generados autom√°ticamente                 | ‚ùå Manuales                                  | ‚úÖ Limitados a aridad 2 o 3                          |
| L√≥gica adicional o comportamiento          | ‚ö†Ô∏è Posible, pero no idiom√°tico              | ‚úÖ Ideal para encapsular comportamiento      | ‚ö†Ô∏è V√≠a extensiones, pero **no se recomienda**        |
| Datos temporales o resultados intermedios  | ‚ö†Ô∏è Posible, pero puede ser innecesario       | ‚ùå Verboso para estructuras ef√≠meras         | ‚úÖ Excelente para datos r√°pidos y sin contexto       |
| Uso interno o en contextos de rendimiento  | ‚ö†Ô∏è Evaluar seg√∫n el caso                    | ‚úÖ Control total                             | ‚úÖ Muy livianas, ideales para estructuras internas   |

:::tip En resumen

- Usa **`data class`** para representar **datos estructurados con sem√°ntica clara**, donde la comparaci√≥n por contenido, los m√©todos generados y la legibilidad son importantes.
- Usa **`class`** cuando necesites **l√≥gica adicional**, comportamiento mutable, herencia, o un control m√°s fino sobre el ciclo de vida del objeto.
- Usa **tuplas (`Pair` / `Triple`)** solo para **datos temporales o intermedios**, donde los nombres de los campos no son relevantes y la concisi√≥n es prioritaria.

:::

## üîß Funciones y propiedades en `data class`

Aunque las `data class` est√°n dise√±adas para modelar **datos estructurados**, eso no impide que incluyan **propiedades calculadas** o **funciones auxiliares**.

Esto puede ser √∫til para agregar **l√≥gica derivada**, validaciones simples o representaciones alternativas sin romper la sem√°ntica del tipo.

```kotlin title="Propiedad calculada y funci√≥n auxiliar"
data class Wizard(val name: String, val magic: String, val power: Int) {
    val isArchmage: Boolean
        get() = power > 9000

    fun shout() = println("$name casts $magic at power $power!")
}
```

<Explanation>
    En este ejemplo, `isArchmage` es una propiedad calculada que no forma parte del constructor, pero que **proporciona informaci√≥n derivada** a partir de los campos. La funci√≥n `shout()` encapsula un comportamiento asociado al tipo, mejorando su expresividad sin afectar su estructura.
</Explanation>

::::warning No abuses de esto

Aunque es v√°lido incluir funciones y propiedades adicionales en una `data class`, **no deber√≠as cargarla con l√≥gica compleja, efectos secundarios o estado mutable**. Su prop√≥sito principal es representar **datos inmutables, estructurados y comparables por contenido**.

Las `data class` forman parte del contrato p√∫blico de tu biblioteca o API: cualquier campo fuera del constructor primario **no participar√° en `equals`, `hashCode`, `copy` ni `toString`**, lo que puede generar inconsistencias sutiles o errores dif√≠ciles de detectar.

:::tip Recomendaci√≥n

Si una propiedad es esencial para la identidad del objeto, **debe declararse en el constructor**. Si la clase empieza a mezclar demasiada l√≥gica con datos, considera extraer esa l√≥gica a otra clase o usar composici√≥n.

:::

::::

## üèóÔ∏è Constructores

En Kotlin, las `data class` pueden tener **constructores primarios** y **secundarios**, los cuales permiten definir **formas alternativas de crear una instancia** sin repetir la l√≥gica de inicializaci√≥n. Esto es √∫til cuando algunos datos pueden asumir valores por defecto o si quieres ofrecer una API m√°s flexible.

En el siguiente ejemplo, modelamos libros publicados en el siglo XX. El constructor principal exige t√≠tulo, autor y a√±o, pero tambi√©n ofrecemos una alternativa que **asume que el autor es desconocido** si no se especifica:

<BoxedTabs>
  <TabItem label="C√≥digo esencial" value="essential">

  ```kotlin showLineNumbers title="Constructores en data class"
  data class TwentiethCenturyBook(val title: String, val author: String, val year: Int) {
      init {
          require(year in 1900..1999) {
              "Only books published between 1900 and 1999 are allowed. Received: $year"
          }
      }

      constructor(title: String, year: Int) : this(title, "Unknown", year) {
          println("No author provided ‚Äî using 'Unknown'.")
      }
  }
  ```

  </TabItem>
  <TabItem label="C√≥digo completo" value="complete">

  ```kotlin showLineNumbers title="Main.kt"
  data class TwentiethCenturyBook(val title: String, val author: String, val year: Int) {
      init {
          require(year in 1900..1999) {
              "Only books published between 1900 and 1999 are allowed. Received: $year"
          }
      }

      constructor(title: String, year: Int) : this(title, "Unknown", year) {
          println("No author provided ‚Äî using 'Unknown'.")
      }
  }

  fun main() {
      val book1 = TwentiethCenturyBook("The Hobbit", "J. R. R. Tolkien", 1937)
      println("Book 1: $book1")

      val book2 = TwentiethCenturyBook("The Shadow Over Innsmouth", "H. P. Lovecraft", 1936)
      println("Book 2: $book2")

      val book3 = TwentiethCenturyBook("Primary Colors", 1996)
      println("Book 3: $book3")

      val book4 = TwentiethCenturyBook("Fire & Blood", "George R. R. Martin", 2018)
      println("Book 4: $book4")
  }
  ```

  </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo aprendimos a usar un **constructor secundario** para cubrir un caso especial: cuando el autor de un libro no es conocido. Adem√°s, usamos el constructor primario `init` para validar las reglas del dominio (solo libros publicados entre 1900 y 1999), manteniendo el modelo robusto y consistente. Si se entrega un a√±o fuera del rango, el programa lanza una excepci√≥n.
</Explanation>

:::tip ¬øPodr√≠amos haber usado par√°metros por defecto?

S√≠.

:::

## üìù Ejercicio pr√°ctico ‚Äî Gestiona tu cat√°logo de dependencias

<Exercise>
    Imagina que mantienes un repositorio interno con artefactos Maven/Gradle. Cada artefacto se identifica por:

    | Campo        | Tipo    | Reglas de dominio |
    |--------------|---------|-------------------|
    | `group`      | `String`| No vac√≠o, min√∫sculas y puntos (`com.example`) |
    | `name`       | `String`| No vac√≠o, sin espacios |
    | `version`    | `String`| Formato *semver* `MAJOR.MINOR.PATCH`, p.¬†ej. `1.2.3` |

    1. Declara `DependencyMetadata` y valida en `init` que:
        - Ning√∫n campo est√© en blanco.
        - `version` cumpla el patr√≥n semver.

        <Hint hints={[
            <>
                Puedes verificar que un string no est√© vac√≠o con <code>String.isNotBlank(): Boolean</code>.
            </>,
            <>
                Para validar el formato de <code>version</code>, usa <code>Regex.matches(String): Boolean</code>. Por ejemplo, <code>"""\d+\.\d+\.\d+""".toRegex().matches("19.3.7")</code>.
            </>,
            <>
                Puedes ver que un string est√© en min√∫sculas con <code>String.lowercase(): String</code>.
            </>
        ]}/>

    2. Algunos m√≥dulos internos a√∫n no se versionan; permite crearlos sin `version`. Si no se indica, usa `"0.1.0‚ÄëSNAPSHOT"`.
    3. A√±ade una propiedad calculada `isSnapshot` que sea `true` si `version` termina en `"SNAPSHOT"`.
        <Hint hints={[
            <>Para verificar si una cadena termina en un sufijo, usa <code>String.endsWith(String): Boolean</code>.</>,
        ]}/>

    <Solution>
        <BoxedTabs>
            <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
                1.
                ```kotlin showLineNumbers title="Declaraci√≥n y validaci√≥n de artefacto (DependencyMetadata.kt)"
                data class DependencyMetadata(
                    val group: String,
                    val name: String,
                    val version: String
                ) {

                    private val semver = Regex("""\d+\.\d+\.\d+""")

                    init {
                        require(group.isNotBlank()) { "Group must not be blank" }
                        require(name.isNotBlank()) { "Name must not be blank" }
                        require(group == group.lowercase() && '.' in group) {
                            "Group must be lowercase and dot-separated"
                        }
                        require(semver.matches(version)) {
                            "Version must follow semver format. Got: $version"
                        }
                    }
                }
                ```

                2.
                ```kotlin showLineNumbers title="Constructor secundario por defecto (DependencyMetadata.kt)"
                constructor(group: String, name: String) : this(group, name, "0.1.0-SNAPSHOT") {
                    println("No version provided ‚Äî using default snapshot.")
                }
                ```

                3.
                ```kotlin showLineNumbers title="Propiedad calculada isSnapshot (DependencyMetadata.kt)"
                val isSnapshot: Boolean
                    get() = version.endsWith("SNAPSHOT")
                ```
            </TabItem>
            <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
                ```kotlin showLineNumbers title="Ejemplo completo con validaciones y ejecuci√≥n (DependencyMetadata.kt)"
                data class DependencyMetadata(
                    val group: String,
                    val name: String,
                    val version: String
                ) {

                    private val semver = Regex("""\d+\.\d+\.\d+""")

                    init {
                        require(group.isNotBlank()) { "Group must not be blank" }
                        require(name.isNotBlank()) { "Name must not be blank" }
                        require(group == group.lowercase() && '.' in group) {
                            "Group must be lowercase and dot-separated"
                        }
                        require(semver.matches(version)) {
                            "Version must follow semver format. Got: $version"
                        }
                    }

                    constructor(group: String, name: String) : this(group, name, "0.1.0-SNAPSHOT") {
                        println("No version provided ‚Äî using default snapshot.")
                    }

                    val isSnapshot: Boolean
                        get() = version.endsWith("SNAPSHOT")
                }

                fun main() {
                    val dep1 = DependencyMetadata("com.example", "analytics", "1.2.3")
                    println("Dependency: $dep1")
                    println("Is snapshot: ${dep1.isSnapshot}") // false

                    val dep2 = DependencyMetadata("com.example", "logging")
                    println("Dependency: $dep2")
                    println("Is snapshot: ${dep2.isSnapshot}") // true
                }
                ```
            </TabItem>
        </BoxedTabs>
    </Solution>
</Exercise>

## üéØ Conclusiones

En esta lecci√≥n profundizamos en el uso idiom√°tico de las `data class` en Kotlin como mecanismo fundamental para representar tipos producto. Exploramos sus ventajas frente a clases tradicionales y tuplas, incluyendo su comparaci√≥n por contenido, generaci√≥n autom√°tica de m√©todos comunes, y su integraci√≥n natural con herramientas como desestructuraci√≥n, combinadores funcionales y validaci√≥n en el constructor.

Tambi√©n discutimos buenas pr√°cticas sobre mutabilidad, cu√°ndo est√° justificada, y c√≥mo estructurar el c√≥digo para mantener un dise√±o claro y robusto, especialmente en el contexto del desarrollo de bibliotecas reutilizables.

### üîë Puntos clave

- Las `data class` son la forma idiom√°tica en Kotlin de definir registros: tipos que agrupan datos con nombre y estructura clara.
- Permiten comparar objetos por contenido, generar copias de manera segura y desestructurar valores de forma concisa.
- Aunque permiten l√≥gica adicional, su uso debe centrarse en modelar datos y evitar estados mutables o comportamientos complejos.
- Su uso adecuado contribuye a dise√±os m√°s expresivos, seguros y f√°ciles de mantener.

### üß∞ ¬øQu√© nos llevamos?

Dise√±ar estructuras de datos con intenci√≥n sem√°ntica clara no es solo una cuesti√≥n de estilo, sino una herramienta clave para **mejorar la expresividad, la mantenibilidad y la seguridad de nuestras bibliotecas**. Las `data class` permiten comunicar de forma directa el prop√≥sito de un tipo, garantizando al mismo tiempo un comportamiento coherente por parte del compilador.

Al preferir `data class` para representar tipos producto, evitamos repetir c√≥digo, reducimos errores relacionados con comparaciones, y promovemos un dise√±o m√°s funcional y predecible. Comprender sus l√≠mites y posibilidades es esencial para escribir APIs limpias, reutilizables y alineadas con los principios del dise√±o moderno de software.

<div class="exclude-from-reading-time">
## üìñ Referencias

### üî• Recomendadas

- [üåê "Data classes"](https://kotlinlang.org/docs/data-classes.html) en la **documentaci√≥n oficial de Kotlin**: Explica en detalle c√≥mo funcionan las `data class` en Kotlin y qu√© genera autom√°ticamente el compilador (como `equals`, `hashCode`, `toString`, `copy`, y `componentN`). Es relevante para esta lecci√≥n porque **respalda y ampl√≠a los conceptos presentados**, mostrando requisitos t√©cnicos, restricciones y casos de uso idiom√°ticos fundamentales para modelar tipos producto de forma segura y expresiva.

{/* ### üîπ Adicionales */}

{/* - [üìö]() */}
</div>
