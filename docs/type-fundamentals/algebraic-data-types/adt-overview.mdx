---
title: Tipos de Datos Algebraicos
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

Cuando dise√±amos bibliotecas, uno de los desaf√≠os m√°s comunes es representar los datos de forma precisa, segura y expresiva. Necesitamos tipos que comuniquen claramente su prop√≥sito, que impidan estados inv√°lidos, y que puedan evolucionar sin romper el c√≥digo que los utiliza.

Los **tipos de datos algebraicos** (*Algebraic Data Types*, o **ADTs**) son una herramienta fundamental para lograr esto. Permiten construir nuevos tipos combinando otros m√°s simples, siguiendo las reglas del √°lgebra: **producto**, para agrupar informaci√≥n; y **suma**, para representar alternativas.

Estos conceptos no solo son relevantes desde el punto de vista te√≥rico, sino que est√°n presentes en muchas decisiones de dise√±o en bibliotecas modernas: desde la definici√≥n de estructuras de datos hasta la representaci√≥n de flujos de ejecuci√≥n, errores, validaciones, eventos o estados de interfaz.

En este m√≥dulo exploraremos c√≥mo Kotlin ‚Äîal igual que otros lenguajes modernos‚Äî permite expresar estas construcciones mediante `data class`, `enum class` y `sealed class`. Aprender√°s no solo a identificarlas, sino tambi√©n a aplicarlas para crear modelos de datos robustos, mantenibles y alineados con los principios de claridad y seguridad que distinguen a las buenas bibliotecas.

## üîç ¬øQu√© aprender√°s en este m√≥dulo?

En este m√≥dulo tem√°tico profundizaremos en el uso de **tipos de datos algebraicos** en Kotlin, con un enfoque orientado al dise√±o de bibliotecas reutilizables y expresivas. Aprender√°s a:

- Reconocer cu√°ndo usar tipos **producto**, **suma** o **mixtos** para modelar estructuras de datos.
- Aplicar el dise√±o con **data classes**, **enums** y **clases selladas** (`sealed`) para capturar relaciones l√≥gicas y casos posibles de manera segura y expl√≠cita.
- Evitar estructuras d√©biles, como cadenas o enteros sin sem√°ntica clara, reemplaz√°ndolas por tipos precisos y verificables en tiempo de compilaci√≥n.
- Entender las ventajas de los ADTs frente a modelos menos expresivos, especialmente en APIs p√∫blicas o dominios complejos.
- Conectar estas ideas con otros lenguajes funcionales y traducirlas en patrones robustos de dise√±o aplicables a bibliotecas modernas.

Dividiremos este bloque en tres lecciones principales, cada una centrada en un tipo de construcci√≥n:

- **Tipos producto**: estructuras que agrupan m√∫ltiples datos simult√°neamente.
- **Tipos suma**: valores que representan una entre varias alternativas posibles.
- **Tipos mixtos**: combinaciones de producto y suma (la forma m√°s flexible y com√∫n en modelado de datos).

Cada lecci√≥n incluir√° teor√≠a, ejemplos, ejercicios y comparaciones para ayudarte a incorporar estas herramientas en tu repertorio como dise√±adorx de bibliotecas.

## üéØ Objetivos de aprendizaje

Al finalizar este bloque ser√°s capaz de:

- Explicar qu√© son los tipos de datos algebraicos y distinguir entre tipos **producto**, **suma** y **suma de productos**.
- Modelar datos en Kotlin de forma idiom√°tica usando `data class`, `enum class` y `sealed class`.
- Elegir el tipo de construcci√≥n m√°s adecuado seg√∫n el problema a resolver, priorizando claridad, seguridad y expresividad.
- Dise√±ar modelos de datos robustos y mantenibles como parte de bibliotecas reutilizables.

Este conocimiento ser√° clave para crear APIs seguras, evitar errores comunes en estructuras de datos, y mantener una base de c√≥digo m√°s expresiva, predecible y f√°cil de probar.

## üß© ¬øQu√© son los Tipos de Datos Algebraicos?

Los **tipos de datos algebraicos** (*Algebraic Data Types*, o *ADTs*) son una forma de construir nuevos tipos combinando otros m√°s simples, siguiendo los principios del √°lgebra: **producto** (composici√≥n) y **suma** (elecci√≥n). Son una herramienta fundamental para modelar datos de forma clara, segura y expresiva.

:::warning No confundir con *Abstract Data Types (ADTs)*

Los tipos de datos **algebraicos** describen c√≥mo se **estructura** un valor (por ejemplo, `Either`, `Option`, o `Pair`), mientras que los tipos de datos **abstractos** describen c√≥mo se **comporta** una colecci√≥n o entidad (como `Stack`, `Queue`, o `Map`).

:::

### üß† Desde la teor√≠a‚Ä¶

En √°lgebra, podemos construir nuevos conjuntos a partir de otros mediante dos operaciones fundamentales:

- **Producto ($\times$)**: combina elementos de dos conjuntos formando pares ordenados.
  Por ejemplo, si tienes un conjunto de colores $\{\text{Rojo}, \text{Verde}\}$ y uno de tallas $\{\mathbf{S}, \mathbf{M}, \mathbf{L}\}$, su producto contiene todas las combinaciones posibles:
  $\left(\text{Rojo},\, \mathbf{S}\right)$, $\left(\text{Rojo},\, \mathbf{M}\right)$, $\left( \text{Verde},\, \mathbf{L} \right)$, etc.
- **Suma ($+$)**: representa una elecci√≥n entre alternativas exclusivas.
  Si tienes un conjunto de monedas $\{\text{Peso}, \text{Euro}\}$ y uno de criptomonedas $\{\text{Bitcoin}\}$, su suma representa un valor que puede ser una **moneda** o una **cripto**, pero no ambas a la vez.

### üîç ‚Ä¶hacia un ejemplo concreto

Imagina que est√°s desarrollando una biblioteca para manejar √≥rdenes de compra, y necesitas representar el **estado de una orden**.

Una primera aproximaci√≥n podr√≠a ser guardar el estado como una cadena de texto: `"pending"`, `"shipped"`, `"cancelled"`‚Ä¶
Pero este enfoque es propenso a errores: nada impide que alguien escriba `"canceled"` (con una sola "l") o `"shippedd"` por accidente.
El c√≥digo no puede validar f√°cilmente que todos los valores sean correctos.

Una alternativa m√°s segura es definir un tipo que contenga **solo los estados v√°lidos**.
Este tipo ser√≠a un **tipo suma**, ya que una orden puede estar en *uno entre varios estados posibles*, pero **no en m√°s de uno al mismo tiempo**.
Definir estos estados expl√≠citamente evita errores y permite validaciones autom√°ticas en tiempo de compilaci√≥n.

Del mismo modo, podr√≠as querer representar la **direcci√≥n de entrega** como un conjunto de campos: calle, n√∫mero, ciudad y pa√≠s.
Esto es un **tipo producto**, porque todos esos campos se combinan para formar una direcci√≥n completa y coherente.

## üß© ¬øQu√© tipos de ADTs existen?

Los **tipos de datos algebraicos** se construyen combinando dos operaciones fundamentales: **producto** y **suma**. A partir de ellas, podemos definir tres formas b√°sicas de modelar datos:

- **Tipo producto**: representa un valor que **contiene varios campos al mismo tiempo**.  
  üì¶ Ejemplo: `data class Person(val name: String, val age: Int)`
- **Tipo suma**: representa un valor que puede ser **una entre varias alternativas mutuamente excluyentes**.  
  üéØ Ejemplo: `enum class Result { Success, Failure }`
- **Suma de productos**: combina ambas ideas: **cada alternativa** tiene su **propia estructura interna**.  
  üß¨ Ejemplo: `sealed class Shape`, con subtipos como `Circle(val radius: Double)` y `Rectangle(val width: Double, val height: Double)`

La **suma de productos** es la forma m√°s expresiva y poderosa, especialmente √∫til para modelar casos complejos en bibliotecas reutilizables.

### ‚úèÔ∏è Representaci√≥n formal

Podemos expresar las combinaciones fundamentales de tipos algebraicos usando una notaci√≥n inspirada en gram√°ticas formales:

```text
ADT ::= Producto
      | Suma
      | Suma(Productos)
```

- `Producto`: Agrupa **varios valores simult√°neamente**.  
- `Suma`: Representa **una elecci√≥n entre m√∫ltiples alternativas**.  
- `Suma(Productos)`: Une ambas ideas: cada alternativa puede tener **su propia estructura interna**.

```mermaid
graph TD
  ADT["Tipo de Datos Algebraico (ADT)"]
  ADT --> Prod["Producto (data class)"]
  ADT --> Sum["Suma (enum class)"]
  ADT --> Mix["Suma de Productos (sealed class)"]
```

> üß† Esta clasificaci√≥n te ayudar√° a elegir el tipo correcto seg√∫n si necesitas **combinar datos**, **diferenciar casos**, o **ambas cosas**.

## ü§î ¬øHay algo m√°s adem√°s de suma y producto?

Aunque los **tipos de datos algebraicos** se construyen principalmente a partir de **suma** y **producto**, existen otros tipos que, si bien no son ADTs en sentido estricto, desempe√±an un rol fundamental en la teor√≠a de tipos y la pr√°ctica de programaci√≥n funcional.

### 1. Funciones (`A -> B`)

Las funciones **no son ADTs** porque no representan estructuras de datos, sino **transformaciones** entre ellas.
Sin embargo, desde el punto de vista algebraico, se las considera **exponenciales**, ya que el n√∫mero de funciones posibles de `A` a `B` es `B^A`.
Esto las ubica en una posici√≥n clave dentro del √°lgebra de tipos, y son imprescindibles al componer transformaciones, validaciones y control de flujo en combinaci√≥n con tipos algebraicos.

### 2. Tipos especiales: `Unit` y `Nothing`

Estos tipos completan los extremos de la jerarqu√≠a algebraica:

- **`Unit`**: Tiene **un √∫nico valor posible**, `Unit`. Representa un **producto vac√≠o**, es decir, una tupla con cero elementos.
  Se usa como valor de retorno en funciones que "no devuelven nada √∫til", pero igual deben tener un tipo.
- **`Nothing`**: No tiene valores posibles. Representa una **suma vac√≠a**, es decir, un tipo con cero alternativas.
  Se usa para funciones que **nunca terminan**, como aquellas que lanzan excepciones o entran en loops infinitos.

Estos tipos no son solo curiosidades te√≥ricas: su presencia en Kotlin (y otros lenguajes) permite escribir c√≥digo m√°s expresivo, seguro y coherente con los principios de tipado fuerte.

## üìñ Referencias

### üî• Recomendadas

- üìö *"Algebraic data types and Pattern matching"* (pp. 174‚Äì198) en *Functional Programming in C++* de **Ivan ƒåukiƒá**: Este cap√≠tulo muestra c√≥mo los tipos de datos algebraicos permiten modelar estados de forma segura, evitando combinaciones inv√°lidas y mejorando la claridad del c√≥digo. Es pertinente a esta lecci√≥n porque ilustra c√≥mo los **tipos suma** pueden reemplazar estructuras fr√°giles con modelos m√°s expresivos. Aunque tambi√©n se aborda *pattern matching*, esta t√©cnica queda fuera del alcance y foco de este curso.

### üîπ Adicionales

- [üìÑ "Tipos Algebraicos de Datos en Fork √Ålgebras"](https://clei.org/proceedings_data/CLEI1996/CLEI1996%20-%20Tomo%201/Por%20capitulo_OCR/CLEI1996_310-321_OCR.pdf) en *"XXII Conferencia Latinoamericana de Inform√°tica"* de **Pablo E. Mart√≠nez L√≥pez y Gabriel A. Baum**: Presenta una definici√≥n formal de tipos algebraicos en el marco de las fork √°lgebras, con √©nfasis en su utilidad para especificaciones modulares y correctas. Es una **referencia avanzada** y te√≥rica que aporta una base formal √∫til para comprender los fundamentos algebraicos detr√°s de estructuras de datos como las usadas en Kotlin o Haskell.
