---
title: Tipos producto como clases en Scala
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime'

import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'

import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import RepoLinks from '@site/src/components/git/RepoLinks'
import GitLabRepo from '@site/src/components/git/GitLabRepo'
import GitHubRepo from '@site/src/components/git/GitHubRepo'

import Tooltip from '@site/src/components/Tooltip/Tooltip'
import OfficialDocumentation from '@site/src/components/Tooltip/OfficialDocumentation'

<ReadingTime multiplier={1.0}/>
<RepoLinks
  children={[
    <GitLabRepo user="r8vnhill" repo="scala-dibs" />,
    <GitHubRepo user="r8vnhill" repo="scala-dibs" />
  ]}
/>

Los **tipos producto** son una de las construcciones fundamentales en el dise√±o de estructuras de datos: permiten agrupar m√∫ltiples valores heterog√©neos en una √∫nica unidad compuesta. En Scala, aunque la forma m√°s idiom√°tica de representarlos suele ser mediante `case class`, comenzar con clases comunes es √∫til para comprender con mayor claridad c√≥mo se construyen, se inicializan y se comportan estos tipos.

Esta lecci√≥n explora c√≥mo representar tipos producto en Scala usando clases regulares, comparando sus caracter√≠sticas con otras representaciones como tuplas. Se analizan aspectos clave como los constructores primarios y secundarios, la l√≥gica de inicializaci√≥n y el uso de par√°metros por defecto. El objetivo es comprender c√≥mo construir tipos robustos, mantenibles y expresivos, fundamentales para dise√±ar bibliotecas reutilizables en Scala.

## üèóÔ∏è Clases comunes como tipos producto en Scala

Una forma directa de representar tipos producto en Scala es mediante clases comunes. Estas clases permiten **agrupar m√∫ltiples valores con significado sem√°ntico** bajo una √∫nica estructura con nombre.

```scala showLineNumbers title="Posici√≥n como tipo producto en Scala (type-fundamentals/algebraic-data-types/product/src/main/scala/cl/ravenhill/Position.scala)"
class Position(val x: Int, val y: Int):
  def isOrigin: Boolean =
    x == 0 && y == 0
  end isOrigin
end Position

@main def positionExample(): Unit =
  val pos = Position(x = 541, y = 133)
  println(pos.x)        // Prints: 541
  println(pos.y)        // Prints: 133
  println(pos.isOrigin) // Prints: false
end positionExample
```

:::explanation

La clase `Position` es un ejemplo de **tipo producto** modelado mediante una clase com√∫n. A diferencia de `Tuple` o `Pair`, esta estructura proporciona **nombres expl√≠citos** (`x`, `y`) para sus componentes, lo que mejora la legibilidad y expresividad del c√≥digo.

Adem√°s, permite **incluir comportamiento directamente asociado** al dato, como el m√©todo `isOrigin`.

:::

<details>
  <summary>
    `new` opcional
  </summary>

  En Scala 2, instanciar una clase com√∫n requer√≠a usar `new`, a menos que se definiera manualmente un m√©todo `apply` en el objeto acompa√±ante.

  Scala 3 introduce los **[m√©todos `apply` universales](https://docs.scala-lang.org/scala3/reference/other-new-features/creator-applications.html)** (tambi√©n llamados *constructor proxies*), que permiten instanciar cualquier clase concreta sin necesidad de `new`, siempre que el objeto acompa√±ante (si existe) no defina un miembro llamado `apply`.

  Esta mejora unifica la sintaxis de creaci√≥n de instancias entre `case class` y clases comunes, y contribuye a reducir el "ruido" visual del c√≥digo.

  El mismo comportamiento puede lograrse manualmente en Scala 2 (o en Scala 3 si defines tu propio objeto acompa√±ante) escribiendo un m√©todo `apply`:

  ```scala showLineNumbers title="Scala 2: Instanciaci√≥n sin new mediante apply"
  class Position(val x: Int, val y: Int)

  object Position {
    def apply(x: Int, y: Int): Position = new Position(x, y)
  }

  val pos = Position(3, 4) // Llama a Position.apply(...)
  ```

  :::warning Cuidado con los objetos acompa√±antes

  Si defines manualmente un `object` con el mismo nombre de la clase (como `object Position`), incluso si su m√©todo `apply` tiene una firma distinta al constructor principal, Scala **ya no generar√° autom√°ticamente** el m√©todo `apply` universal.  
  En ese caso, deber√°s usar `new` para invocar constructores que no est√©n cubiertos por tu propia definici√≥n de `apply`.

  ```scala showLineNumbers title="El m√©todo apply autom√°tico deja de generarse"
  class Position(val x: Int, val y: Int)

  object Position:
    def apply(): Position = new Position(0, 0)
  end Position

  val pos = Position(x = 541, y = 133)  // Esto ya no compila
  ```

  :::
</details>

## üß± Constructores primarios y secundarios

Al igual que en Kotlin, Scala permite definir **constructores primarios y secundarios**.

### üîπ Constructor primario

En Scala, el **constructor primario** se define como parte de la declaraci√≥n de la clase, de forma similar a c√≥mo se hace en Kotlin. Los par√°metros declarados en la cabecera de la clase se convierten autom√°ticamente en parte del constructor primario.

```scala showLineNumbers title="Constructor primario en Scala (type-fundamentals/algebraic-data-types/product/src/main/scala/cl/ravenhill/people/Person.scala)"
class Person(val name: String, var age: Int)
```

Al igual que en Kotlin:

- `val` crea una propiedad **inmutable** accesible desde fuera de la clase.
- `var` crea una propiedad **mutable**.
- Si se omite `val` o `var`, el par√°metro ser√° **solo un argumento del constructor**,[^1] no una propiedad visible desde el exterior.

[^1]: En Scala, un par√°metro del constructor primario que no se marca con `val` o `var` **no se convierte en una propiedad del objeto**, es decir, **no es accesible desde fuera de la clase**. Sin embargo, **s√≠ est√° disponible dentro del cuerpo de la clase**, incluidos sus m√©todos. Esto se debe a que el cuerpo de la clase en Scala forma parte del constructor, por lo que estos par√°metros pueden usarse como variables locales persistentes.  
Esto difiere de Kotlin, donde los par√°metros sin `val` o `var` **no son accesibles m√°s all√° del constructor mismo**.

#### üî∏ Anotaciones y modificadores

Cuando necesitas aplicar una **anotaci√≥n** o un **modificador de visibilidad** al constructor primario, puedes colocarlo directamente **antes de la lista de par√°metros** o **del constructor entero**:

```scala showLineNumbers title="Anotaciones y modificadores en el constructor primario"
class Person @targetName("createPerson") private (val name: String)
```

:::explanation

- `@targetName("createPerson")` cambia el nombre del constructor en el bytecode, lo que puede facilitar la interoperabilidad con Java o evitar conflictos con sobrecargas.
- `private` restringe el acceso al constructor, lo que permite controlar la creaci√≥n de instancias desde un *companion object* o una funci√≥n de f√°brica.

:::

#### üî∏ L√≥gica de inicializaci√≥n

En lugar de usar bloques `init` como en Kotlin, Scala permite incluir **c√≥digo directamente en el cuerpo de la clase**, que se ejecutar√° como parte del **constructor primario**:

```scala showLineNumbers title="L√≥gica de inicializaci√≥n en el constructor primario (type-fundamentals/algebraic-data-types/product/src/main/scala/cl/ravenhill/people/Person.scala)"
class Person(val name: String):
  require(name.nonEmpty, "Name cannot be empty")
end Person
```

:::explanation

Este c√≥digo se ejecuta **inmediatamente al construir el objeto**, antes de que se retorne la instancia.  
Esto es posible porque el cuerpo de la clase **forma parte del constructor primario**, lo que permite realizar validaciones o inicializaciones adicionales sin estructuras especiales.

:::

### üîπ Constructores secundarios

Scala permite definir **constructores secundarios** utilizando la palabra clave `this`. Estos constructores ofrecen formas alternativas de inicializar una clase, pero **siempre deben invocar el constructor primario como primera instrucci√≥n**.

```scala showLineNumbers title="Constructor secundario en Scala (type-fundamentals/algebraic-data-types/product/src/main/scala/cl/ravenhill/people/Person.scala)"
class Person(val name: String):
  var age: Int = 0

  def this(name: String, age: Int) =
    this(name)
    this.age = age
  end this
end Person
```

:::explanation

En este ejemplo, el constructor secundario permite crear una instancia de `Person` proporcionando tanto `name` como `age`.  
Llama al constructor primario con `this(name)` y luego inicializa la propiedad `age`.

:::

:::warning

Los constructores secundarios **deben invocar al constructor primario como primera instrucci√≥n** (ya sea directamente o a trav√©s de otro constructor secundario). No se permite ejecutar ning√∫n otro c√≥digo antes de esa llamada.

:::

:::tip Alternativa idiom√°tica

En la pr√°ctica, es m√°s com√∫n usar par√°metros por defecto en el constructor primario en lugar de constructores secundarios:

```scala showLineNumbers title="Par√°metros por defecto en el constructor primario"
class Person(val name: String, var age: Int = 0)
```

Esta forma es m√°s concisa, clara y m√°s utilizada en c√≥digo Scala idiom√°tico moderno.

:::

## üéØ Conclusiones

En esta lecci√≥n exploramos c√≥mo representar **tipos producto** en Scala utilizando clases comunes, una herramienta clave para modelar datos estructurados de forma clara y segura. A trav√©s de ejemplos concretos, vimos c√≥mo definir propiedades, incluir l√≥gica de inicializaci√≥n y aprovechar constructores para crear objetos con distintas configuraciones.

Scala 3 facilita este proceso con mejoras notables, como la **eliminaci√≥n opcional de `new`** al instanciar clases y una **sintaxis m√°s concisa** para declarar constructores y par√°metros. Adem√°s, aprendimos a incorporar validaciones directamente en el cuerpo de la clase y a usar **valores por defecto** como alternativa idiom√°tica a los constructores secundarios.

### üîë Puntos clave

- Las **clases comunes** en Scala permiten representar tipos producto de forma expresiva, con nombres significativos y comportamiento asociado.
- Scala 3 ofrece una sintaxis m√°s limpia, permitiendo **instanciaci√≥n sin `new`** gracias a los m√©todos `apply` universales.
- El **constructor primario** se define junto a la declaraci√≥n de la clase, y sus par√°metros pueden convertirse en propiedades mediante `val` o `var`.
- Los **constructores secundarios**, definidos con `this`, permiten formas alternativas de creaci√≥n, pero siempre deben invocar primero al constructor primario.
- Es posible colocar **l√≥gica de inicializaci√≥n** en el cuerpo de la clase, lo que habilita validaciones y configuraci√≥n del estado interno.
- Los **par√°metros por defecto** son una opci√≥n idiom√°tica para simplificar la construcci√≥n de objetos sin necesidad de m√∫ltiples constructores.

### üß∞ ¬øQu√© nos llevamos?

Modelar tipos producto con clases comunes es una pr√°ctica fundamental para dise√±ar **librer√≠as reutilizables y expresivas** en Scala. Dominar los constructores primarios y secundarios, junto con el uso de l√≥gica de inicializaci√≥n y par√°metros por defecto, permite construir tipos robustos que promueven un c√≥digo claro, seguro y f√°cil de evolucionar.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList
  title="üî• Referencias recomendadas"
  items={[
    <WebPage
      title="Classes"
      url="https://docs.scala-lang.org/tour/classes.html"
      location={<OfficialDocumentation>Tour of Scala</OfficialDocumentation>}
    >
      Introducci√≥n a las clases en Scala, incluyendo su definici√≥n, creaci√≥n de instancias, constructores con valores por defecto, uso de argumentos nombrados, encapsulamiento con miembros privados, y sintaxis de getters/setters. Se destacan las diferencias entre <code>val</code>, <code>var</code> y par√°metros sin modificadores en el constructor. Incluye ejemplos en Scala 2 y Scala 3.
    </WebPage>
  ]}
/>
<ReferenceList
  title="üîπ Referencias adicionales"
  items={[
    <WebPage
      title="Universal Apply Methods"
      url="https://docs.scala-lang.org/scala3/reference/other-new-features/creator-applications.html"
      location={<OfficialDocumentation>Scala 3 reference</OfficialDocumentation>}
    >
      Este contenido explica c√≥mo Scala 3 extiende la sintaxis simplificada de creaci√≥n de objetos ‚Äîanteriormente exclusiva de las *case classes*‚Äî a todas las clases concretas, eliminando la necesidad de usar `new`. Se presentan los *constructor proxies*, objetos generados autom√°ticamente que permiten crear instancias mediante llamadas tipo funci√≥n. El texto detalla las reglas para su generaci√≥n, sus limitaciones y el objetivo principal: hacer el c√≥digo m√°s limpio, uniforme y f√°cil de leer para los desarrolladores.
    </WebPage>
  ]}
/>
