---
title: Tipos producto como clases en Scala
sidebar_label: Scala
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import WebPage from '@site/src/components/references/WebPage'

<ReadingTime multiplier={1.0}/>
<GithubRepoLink user="r8vnhill" repo="scala-dibs" />

Los **tipos producto** son una de las construcciones fundamentales en el dise√±o de estructuras de datos: permiten agrupar m√∫ltiples valores heterog√©neos en una √∫nica unidad compuesta. En Scala, una forma idiom√°tica y expresiva de modelarlos es mediante clases comunes, que proporcionan nombres expl√≠citos para los campos y permiten encapsular comportamiento directamente dentro del tipo.

Esta lecci√≥n explora c√≥mo representar tipos producto en Scala usando clases, comparando sus caracter√≠sticas con otras representaciones como tuplas, y analizando c√≥mo se definen constructores primarios, secundarios, l√≥gica de inicializaci√≥n y par√°metros por defecto. El objetivo es comprender c√≥mo construir tipos robustos, mantenibles y expresivos, fundamentales para dise√±ar bibliotecas reutilizables en Scala.

## üèóÔ∏è Clases comunes como tipos producto en Scala

Una forma natural de representar tipos producto en Scala es mediante clases comunes. Estas clases permiten **agrupar m√∫ltiples valores con significado sem√°ntico** bajo una √∫nica estructura.

```scala showLineNumbers title="Posici√≥n como tipo producto en Scala (type-fundamentals/algebraic-data-types/product/src/main/scala/cl/ravenhill/Position.scala)"
class Position(val x: Int, val y: Int):
  def isOrigin: Boolean =
    x == 0 && y == 0
  end isOrigin
end Position

@main def positionExample(): Unit =
  val pos = Position(x = 541, y = 133)
  println(pos.x) // Prints: 541
  println(pos.y) // Prints: 133
  println(pos.isOrigin) // Prints: false
end positionExample
```

<Explanation>
  Esta clase `Position` es un ejemplo de **tipo producto** definido mediante una clase com√∫n. A diferencia de `Tuple` o `Pair`, aqu√≠ los campos tienen **nombres expl√≠citos** (`x`, `y`) y la clase puede incluir **comportamiento asociado**, como el m√©todo `isOrigin`.

  - El uso de `val` en el constructor convierte `x` e `y` en **propiedades accesibles p√∫blicamente**.
  - Scala 3 permite **omitir `new`** al instanciar clases si existe un m√©todo `apply`.
</Explanation>

<details>
  <summary>
    `new` opcional
  </summary>
      
  A diferencia de Scala 2, donde era necesario usar `new` para instanciar clases comunes, Scala 3 introduce **[m√©todos `apply` universales](https://docs.scala-lang.org/scala3/reference/other-new-features/creator-applications.html)**, lo que permite crear instancias sin necesidad de definir manualmente un m√©todo `apply` en el objeto acompa√±ante.

  ```scala showLineNumbers title="Scala 2: Instanciaci√≥n sin new mediante apply"
  class Position(val x: Int, val y: Int)

  object Position {
    def apply(x: Int, y: Int): Position = new Position(x, y)
  }

  val pos = Position(3, 4) // Llama a Position.apply(...)
  ```
</details>

## üß± Constructores primarios y secundarios

Al igual que en Kotlin, Scala permite definir **constructores primarios y secundarios**.

### üîπ Constructor primario

En Scala 3, el constructor primario se define **como parte de la declaraci√≥n de la clase**, similar a Kotlin. Los par√°metros definidos en la cabecera de la clase son autom√°ticamente parte del constructor primario.

```scala showLineNumbers title="Constructor primario en Scala"
class Person(val name: String, var age: Int)
```

Al igual que en Kotlin:

* `val` define una propiedad **inmutable**.
* `var` define una propiedad **mutable**.
* Si se omite `val` o `var`, el par√°metro ser√° **solo un argumento del constructor**, sin convertirse en propiedad.

#### üî∏ Anotaciones y modificadores

Cuando necesitas aplicar una **anotaci√≥n** o usar un **modificador de visibilidad**, puedes colocarlo directamente antes del par√°metro o del constructor entero:

```scala showLineNumbers title="Anotaciones y modificadores en el constructor primario"
import javax.inject.Inject

class Person @Inject private (val name: String)
```

En este ejemplo:

* `@Inject` es una anotaci√≥n com√∫n en frameworks como [MacWire](https://github.com/adamw/macwire) o [Guice](https://github.com/google/guice).
* `private` hace que el constructor solo sea accesible dentro del objeto companion o la clase misma.

#### üî∏ L√≥gica de inicializaci√≥n

En lugar de bloques `init`, Scala permite incluir **c√≥digo directamente en el cuerpo de la clase**, que se ejecutar√° cuando se cree una instancia:

```scala showLineNumbers title="L√≥gica de inicializaci√≥n en el constructor primario"
class Person(val name: String, var age: Int):
  require(age >= 0, "Age must be non-negative")
end Person
```

Este c√≥digo se ejecuta **inmediatamente al construir el objeto**, antes de que se retorne la instancia.

### üîπ Constructores secundarios

Scala tambi√©n permite definir **constructores secundarios** utilizando la palabra clave `this`. Estos constructores pueden ofrecer diferentes formas de inicializar una clase, pero **siempre deben invocar el constructor primario como primera acci√≥n**.

```scala showLineNumbers title="Constructor secundario en Scala"
class Person(val name: String):
  var age: Int = 0

  def this(name: String, age: Int) =
    this(name)
    this.age = age
  end this
end Person
```

<Explanation>
    En este ejemplo, el constructor secundario permite crear una instancia de `Person` proporcionando tanto `name` como `age`. Llama al constructor primario con `this(name)` y luego inicializa la propiedad `age`.
</Explanation>

:::warning

Los constructores secundarios **deben invocar al constructor primario como primera instrucci√≥n** (ya sea directamente o a trav√©s de otro constructor secundario). No se permite ejecutar ning√∫n otro c√≥digo antes de esa llamada.

:::

:::tip Par√°metros por defecto

Al igual que en Kotlin, Scala permite definir **par√°metros por defecto** en el constructor primario, eliminando la necesidad de constructores secundarios para casos comunes:

```scala showLineNumbers title="Par√°metros por defecto en Scala"
class Person(val name: String, var age: Int = 0)
```

:::

## üéØ Conclusiones

En esta lecci√≥n hemos explorado c√≥mo representar **tipos producto** en Scala utilizando clases comunes. Este enfoque nos permite agrupar valores relacionados bajo una sola entidad con nombres expl√≠citos para cada campo, facilitando la claridad y el mantenimiento del c√≥digo.

Scala 3 introduce varias mejoras para trabajar con clases, como la posibilidad de omitir la palabra clave `new` gracias a los m√©todos `apply` universales, y una sintaxis m√°s limpia para definir constructores primarios y secundarios.

Tambi√©n vimos c√≥mo incluir l√≥gica de inicializaci√≥n directamente en el cuerpo de la clase y c√≥mo manejar par√°metros por defecto para simplificar la creaci√≥n de instancias.

### üîë Puntos clave

- Las **clases comunes en Scala** son una forma natural y clara de representar tipos producto, con campos nombrados y comportamiento asociado.
- Scala 3 permite **omitir `new` al instanciar objetos** si existe un m√©todo `apply`.
- El **constructor primario** se define en la cabecera de la clase y puede incluir par√°metros con modificadores `val` o `var` para definir propiedades inmutables o mutables.
- Se pueden usar **constructores secundarios** con la palabra clave `this`, pero deben invocar siempre al constructor primario como primera acci√≥n.
- La l√≥gica de inicializaci√≥n puede colocarse directamente en el cuerpo de la clase y se ejecuta durante la creaci√≥n de la instancia.
- Los **par√°metros por defecto** simplifican la definici√≥n de m√∫ltiples formas de construir un objeto, reduciendo la necesidad de constructores secundarios.

### üß∞ ¬øQu√© nos llevamos?

A partir de esta lecci√≥n, entendemos que dise√±ar tipos producto con clases comunes en Scala es un patr√≥n esencial para modelar datos estructurados de manera expl√≠cita y mantenible. La combinaci√≥n de constructores primarios y secundarios, junto con par√°metros por defecto, ofrece flexibilidad para crear objetos en distintas situaciones, mientras que la ejecuci√≥n de l√≥gica en el cuerpo de la clase permite validar y preparar correctamente el estado interno.

Este conocimiento es fundamental para dise√±ar librer√≠as reutilizables y robustas, donde la claridad en la definici√≥n de tipos y la inicializaci√≥n correcta de instancias aseguran un c√≥digo m√°s seguro y f√°cil de extender o modificar en el futuro.

<ExcludeFromReadingTime>
  ## üìñ ¬øCon ganas de m√°s?

  ### üî• Referencias recomendadas

  - <WebPage title="Classes" url="https://docs.scala-lang.org/tour/classes.html" location="la documentaci√≥n oficial de Scala">
      Introducci√≥n a las clases en Scala, incluyendo su definici√≥n, creaci√≥n de instancias, constructores con valores por defecto, uso de argumentos nombrados, encapsulamiento con miembros privados, y sintaxis de getters/setters. Se destacan las diferencias entre `val`, `var` y par√°metros sin modificadores en el constructor. Incluye ejemplos en Scala 2 y Scala 3.
    </WebPage>

  {/* ### üîπ Referencias adicionales */}
</ExcludeFromReadingTime>
