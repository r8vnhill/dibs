---
title: Tipos suma como enumeraciones en Python
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="python-dibs"/>

Cuando dise√±amos una biblioteca, muchas veces necesitamos representar **una entre varias alternativas posibles**: por ejemplo, el estado de una conexi√≥n, un nivel de log, o un tipo de operaci√≥n. Estas situaciones corresponden a lo que en teor√≠a de tipos se conoce como **tipos suma**.

Python ofrece una forma pr√°ctica de modelar estos casos mediante **enumeraciones**, a trav√©s del m√≥dulo est√°ndar `enum`. Aunque no ofrece garant√≠as de exhaustividad como Kotlin, su sintaxis flexible y su integraci√≥n con `match` (desde Python 3.10) permiten expresar estos conceptos de manera clara y mantenible.

En esta lecci√≥n exploraremos c√≥mo usar `Enum` para representar decisiones finitas, c√≥mo integrarlas con `match`, y qu√© diferencias clave existen respecto a su contraparte en Kotlin.

## üêç Enumeraciones en Python

Python ofrece soporte para enumeraciones a trav√©s del m√≥dulo est√°ndar `enum`. Las enumeraciones (o `Enum`) permiten definir un conjunto **nombrado** de valores constantes que son instancias √∫nicas y comparables entre s√≠.

```python showLineNumbers title="Definir una enumeraci√≥n (type-fundamentals/algebraic_types/sum/enum/log.py)"
from enum import Enum, auto

class LogLevel(Enum):
    INFO = auto()
    WARNING = auto()
    ERROR = auto()
```

<Explanation>
    - `Enum` es una clase base que convierte cada miembro (`INFO`, `WARNING`, etc.) en una instancia √∫nica de la enumeraci√≥n.
    - `auto()` asigna autom√°ticamente un valor entero creciente a cada miembro, comenzando en 1. Puedes usar valores expl√≠citos si lo prefieres, como `INFO = 1`, `WARNING = 2`, etc., pero `auto()` es m√°s limpio y evita errores de asignaci√≥n manual.
</Explanation>

### üìù Ejemplo de uso

Un caso com√∫n para enumeraciones es representar niveles de log.  
Veamos c√≥mo podemos usar `LogLevel` en una funci√≥n para imprimir mensajes con distintos niveles de severidad:

```python showLineNumbers title="Implementaci√≥n de un logger simple (type-fundamentals/algebraic_types/sum/enum/log.py)"
import sys

def log(level: LogLevel, message: str) -> None:
    if level is LogLevel.ERROR:
        print(f"[{level.name}] {message}", file=sys.stderr)
    else:
        print(f"[{level.name}] {message}")
```

<Explanation>
    - La funci√≥n `log` recibe un `LogLevel` y un mensaje, e imprime ese mensaje con el nivel correspondiente.
    - Se usa `level.name` para obtener el nombre del nivel (`INFO`, `WARNING`, `ERROR`), que se incluye entre corchetes.
    - Si el nivel es `ERROR`, el mensaje se env√≠a a la salida de error est√°ndar (`sys.stderr`), lo cual es √∫til para distinguir errores de mensajes normales.
    - En los dem√°s casos, el mensaje se imprime por la salida est√°ndar (`sys.stdout`).
</Explanation>

<details>
    <summary>
        ¬øQu√© es `file`?
    </summary>
    
    
    El argumento `file` de `print` permite redirigir la salida a un flujo espec√≠fico.  
    Aunque el nombre `file` puede sonar confuso, tambi√©n se utiliza para representar flujos como `sys.stdout` y `sys.stderr`.

    Adem√°s de esos flujos predefinidos, puedes pasar cualquier objeto que tenga un m√©todo `.write(string)`, como un archivo abierto en modo texto:

    ```python showLineNumbers title="Redirigir a un archivo"
    with open("log.txt", "w") as f:
        print("Mensaje de log", file=f)
    ```

    Esto permite redirigir mensajes a archivos u otros destinos personalizados.
</details>

Puedes llamar a esta funci√≥n as√≠:

```python showLineNumbers title="Llamada a la funci√≥n log (type-fundamentals/algebraic_types/sum/enum/log.py)"
log(LogLevel.INFO, "Thank you Mario!")
log(LogLevel.ERROR, "But our princess is in another castle!")
```

Y ver√°s:

```plaintext
[INFO] Thank you Mario!
[ERROR] But our princess is in another castle!
```

## üß™ `match` en Python y exhaustividad parcial

Python 3.10 introdujo `match`, una construcci√≥n similar a `switch` o `when`, que permite realizar **pattern matching** sobre objetos. Es √∫til para manejar enumeraciones de forma clara, aunque ‚Äîa diferencia de Kotlin‚Äî **no exige cubrir todos los casos posibles**.

```python showLineNumbers title="Uso de match con Enum (type-fundamentals/algebraic_types/sum/enum/connection.py)"
class ConnectionState(Enum):
    CONNECTED = auto()
    DISCONNECTED = auto()
    IN_PROGRESS = auto()


def handle_connection(state: ConnectionState) -> str:
    match state:
        case ConnectionState.CONNECTED:
            return "Connection established successfully."
        case ConnectionState.DISCONNECTED:
            return "Connection has been lost."
        case ConnectionState.IN_PROGRESS:
            return "Connection is currently being established."
        case _:  # Python does not enforce exhaustiveness checking
            raise ValueError(f"Invalid connection state: {state}")
```

<Explanation>
    - Usamos `match` para evaluar el estado de la conexi√≥n y devolver un mensaje correspondiente.
    - Aunque se cubren expl√≠citamente los tres casos posibles, Python **no obliga** a cubrir todas las variantes de la enumeraci√≥n.
    - Por eso incluimos un caso comod√≠n (`case _:`), que act√∫a como una red de seguridad si se introduce un nuevo estado en el futuro.
    - A diferencia de Kotlin, donde el compilador impone el chequeo exhaustivo con `when`, en Python esta responsabilidad recae en la persona que escribe el c√≥digo.
</Explanation>

## üÜö Resumen comparativo

| **Aspecto**                        | **Kotlin (`enum class`)**                                                               | **Python (`Enum`)**                                                                 |
|-----------------------------------|------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| **Definici√≥n**                    | `enum class LogLevel { ... }`                                                           | `class LogLevel(Enum): ...`                                                         |
| **Comparaci√≥n**                   | `level == LogLevel.INFO`                                                                | `level is LogLevel.INFO`                                                            |
| **Uso en `when` / `match`**       | `when(level)` exige cobertura exhaustiva (con advertencia si falta un caso)             | `match` en Python 3.10+ no exige cobertura completa por defecto                     |
| **Control de exhaustividad**      | ‚úîÔ∏è Soportado en `when`                                                                  | ‚ùå No obligatorio en `match`                                                        |
| **Extensibilidad**                | Limitada: no se pueden heredar nuevas variantes                                          | Limitada, pero se puede usar herencia dentro de `Enum` con cuidado                  |
| **Serializaci√≥n**                | ‚úîÔ∏è Facilita serializaci√≥n en JSON/XML con nombres estables                              | ‚úîÔ∏è Serializable si se usan valores simples                                           |
| **Casos de uso ideales**          | Estados finitos sin datos adicionales                                                    | Estados finitos con o sin datos adicionales                                         |

<ProCons>
    <Pros title="Ventajas de Python">
        - Sintaxis m√°s flexible.
        - Se puede extender con clases base adicionales si es necesario.
        - Posibilidad de usar `match` para inspecci√≥n estructural.
    </Pros>
    <Cons title="Limitaciones de Python">
        - Sin control exhaustivo autom√°tico; puedes olvidar casos sin advertencias.
        - Menor integraci√≥n con herramientas de an√°lisis est√°tico sin ayudas externas.
    </Cons>
</ProCons>

## üéØ Conclusiones

Las enumeraciones en Python permiten representar de forma expl√≠cita y segura un conjunto finito de valores posibles, lo que las convierte en una herramienta √∫til para modelar **tipos suma simples**. Su integraci√≥n con `match` a partir de Python 3.10 mejora la legibilidad del c√≥digo, aunque la falta de verificaci√≥n de exhaustividad exige disciplina por parte de quien escribe.

Si bien Kotlin ofrece mayor seguridad a trav√©s de controles est√°ticos, Python compensa con flexibilidad y expresividad, manteni√©ndose fiel a su enfoque din√°mico y pragm√°tico.

### üîë Puntos clave

- `Enum` en Python permite definir variantes nombradas de forma simple y legible.
- `auto()` facilita la asignaci√≥n autom√°tica de valores √∫nicos.
- `print(..., file=...)` puede redirigir la salida a `stderr`, `stdout` o cualquier flujo que implemente `.write()`.
- `match` permite estructurar l√≥gica de control de forma clara, pero no exige cubrir todos los casos.
- Es buena pr√°ctica incluir un `case _` para capturar estados no previstos, especialmente si el `Enum` puede crecer.

### üß∞ ¬øQu√© nos llevamos?

Aprender a usar enumeraciones en Python nos ayuda a escribir c√≥digo m√°s claro, mantenible y seguro. Aunque el lenguaje no impone restricciones estrictas como Kotlin, podemos adoptar **buenas pr√°cticas** que nos ayuden a anticipar errores y a comunicar mejor nuestras intenciones.  
En el contexto del dise√±o de bibliotecas, utilizar `Enum` permite exponer APIs m√°s robustas, con tipos controlados y documentaci√≥n impl√≠cita sobre los valores v√°lidos que se esperan.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage
        title="Enum HOWTO"
        url="https://docs.python.org/3/howto/enum.html"
        location="la documentaci√≥n oficial de Python"
    >
        Este documento explica el uso de la clase <code>Enum</code> en Python, dise√±ada para representar conjuntos de constantes simb√≥licas con valores √∫nicos. Enum permite una representaci√≥n m√°s clara y segura en el c√≥digo, comparado con variables globales. Se detallan diferentes tipos de enumeraciones (<code>Enum</code>, <code>IntEnum</code>, <code>StrEnum</code>, <code>Flag</code>, <code>IntFlag</code>), su creaci√≥n, manipulaci√≥n, personalizaci√≥n y casos de uso, como combinaci√≥n de valores con operadores bit a bit, acceso program√°tico, m√©todos personalizados, soporte para <code>auto()</code>, alias, unicidad, serializaci√≥n (<code>pickle</code>), y su interacci√≥n con clases como <code>dataclass</code>. Tambi√©n se incluyen ejemplos pr√°cticos y recetas avanzadas para extender o adaptar el comportamiento de enumeraciones.
    </WebPage>
]} />
