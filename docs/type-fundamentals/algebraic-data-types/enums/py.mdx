---
title: Tipos suma como enumeraciones en Python
---
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="python-dibs"/>

## üêç Comparaci√≥n: Enumeraciones en Python

En Python, tambi√©n podemos representar tipos suma usando enumeraciones mediante el m√≥dulo est√°ndar [`enum`](https://docs.python.org/3/library/enum.html). Esta t√©cnica se usa para representar conjuntos fijos de alternativas, de forma similar a `enum class` en Kotlin.

### ‚úÖ Alternativas cerradas

```python
from enum import Enum

class ConnectionState(Enum):
    CONNECTED = 1
    DISCONNECTED = 2
    IN_PROGRESS = 3
```

Aqu√≠ definimos un conjunto cerrado de alternativas. Cada miembro de `ConnectionState` es una instancia √∫nica del enumerado, similar a lo que ocurre en Kotlin.

### üö¶ Control de flujo exhaustivo (¬°no disponible!)

Python **no tiene verificaci√≥n exhaustiva** como la que ofrece el compilador de Kotlin. Si escribimos una funci√≥n que opera sobre `ConnectionState`, podemos olvidarnos f√°cilmente de manejar un caso sin que el int√©rprete nos lo advierta:

```python
def describe_state(state: ConnectionState) -> str:
    if state == ConnectionState.CONNECTED:
        return "Connected!"
    elif state == ConnectionState.DISCONNECTED:
        return "Disconnected!"
    # ¬øY si olvidamos IN_PROGRESS?
```

> ‚ö†Ô∏è En Kotlin, esto causar√≠a un *error o advertencia de compilaci√≥n* al usar `when`. En Python, el error s√≥lo aparecer√≠a en tiempo de ejecuci√≥n si ese caso se presenta.

### üß† Comparaci√≥n de caracter√≠sticas

{/* <ProCons>

<Pros title="Ventajas de Python">
- Definici√≥n sencilla usando la biblioteca est√°ndar.
- F√°cil de serializar o extender din√°micamente en algunos casos.

<Cons title="Desventajas respecto a Kotlin">
- No hay verificaci√≥n exhaustiva: puedes olvidar un caso y el error pasar√° desapercibido hasta el tiempo de ejecuci√≥n.
- No hay soporte nativo para desestructuraci√≥n ni integraci√≥n con expresiones similares a `when`.
- No se puede restringir el conjunto de alternativas fuera de la definici√≥n tan estrictamente como en Kotlin (por ejemplo, con `sealed`).

</ProCons> */}

### üîç ¬øQu√© puede hacer Kotlin que Python no?

* **Verificaci√≥n exhaustiva en tiempo de compilaci√≥n** usando `when`: garantiza que todos los casos de una enumeraci√≥n est√©n cubiertos.
* **Compatibilidad con `sealed class`** para evolucionar hacia tipos suma con datos asociados.
* **Context-sensitive resolution** para escribir menos sin perder seguridad.

---

Esta comparaci√≥n refuerza por qu√© `enum class` es una herramienta poderosa en Kotlin al dise√±ar bibliotecas seguras y expresivas. Aunque Python permite representar tipos suma con `Enum`, su enfoque din√°mico lo vuelve m√°s propenso a errores silenciosos y omisiones en tiempo de ejecuci√≥n.
