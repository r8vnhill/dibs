---
title: Tipos suma como enumeraciones
sidebar_label: Enumeraciones
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="algebraic-data-types-kt"/>

Cuando dise√±amos bibliotecas, muchas veces necesitamos representar **una entre varias alternativas posibles**: por ejemplo, el estado de una conexi√≥n, un nivel de log, o un resultado predecible como `OK` o `ERROR`. Estas situaciones corresponden a lo que en teor√≠a de tipos se conoce como un **tipo suma**: una estructura que encapsula **una √∫nica alternativa v√°lida** entre varias opciones posibles.

Kotlin nos ofrece una herramienta directa para modelar estos tipos: las **enumeraciones** (`enum class`). A diferencia de soluciones m√°s fr√°giles como usar `String`, las enumeraciones permiten que el compilador garantice que:

- solo se usen valores v√°lidos,
- todos los casos est√©n cubiertos en estructuras como `when`,
- y que el c√≥digo sea m√°s claro, expresivo y mantenible.

En esta lecci√≥n aprenderemos c√≥mo las enumeraciones pueden ayudarnos a representar tipos suma de forma segura e idiom√°tica, explorando sus usos m√°s comunes, ventajas pr√°cticas, y el soporte que ofrece el compilador de Kotlin para mejorar la confiabilidad de nuestras bibliotecas.

## üéØ Motivaci√≥n

Supongamos que est√°s dise√±ando una biblioteca para representar el **estado de una conexi√≥n de red**. Algunos posibles estados son `Connected`, `Disconnected` o `InProgress`. ¬øC√≥mo podr√≠as modelarlos de forma **segura y expresiva**?

Una soluci√≥n fr√°gil ser√≠a usar una `String`:

```kotlin showLineNumbers
val state = "Connected"
```

Pero esto permite errores sutiles, como:

```kotlin showLineNumbers
val state = "Connnected" // error silencioso: compila, pero est√° mal escrito
```

## üî¢ Enumeraciones

Las **enumeraciones** son una forma de representar un **tipo suma** en Kotlin. Permiten definir un conjunto cerrado de valores posibles, lo que mejora la seguridad y la legibilidad del c√≥digo.
Adem√°s, el compilador puede verificar que solo se usen valores v√°lidos, evitando errores comunes como cadenas mal escritas o valores no v√°lidos.

Conceptualmente, si un tipo suma $S$ tiene $N$ alternativas $S = A_1 + A_2 + ... + A_N$, podemos representarlo como una enumeraci√≥n `enum class` en Kotlin:

```kotlin showLineNumbers title="Tipo suma como enumeraci√≥n"
enum class TipoSuma {
    ALTERNATIVA_1,
    ALTERNATIVA_2,
    // ...
    ALTERNATIVA_N
}
```

<Explanation>
    Hemos definido un **tipo suma** usando `enum class`, que nos permite modelar un conjunto de **alternativas fijas y conocidas**.  
    Cada valor dentro del `enum` representa **una opci√≥n v√°lida**, y el compilador se asegura de que **solo una alternativa est√© presente a la vez**.  
    Este enfoque mejora la seguridad del modelo y evita errores como comparar cadenas mal escritas o usar valores no v√°lidos.
</Explanation>

Cada instancia del `enum` es exactamente **una** de las alternativas posibles. Este enfoque es ideal cuando:

- Las alternativas son fijas y conocidas de antemano.
- No necesitas asociar datos adicionales a cada caso.

:::tip `UPPER_CASE`

Por convenci√≥n, los nombres de los casos de un `enum class` se escriben en may√∫sculas (`UPPER_CASE`).

:::

<details>
    <summary>
        Notaci√≥n alternativa: <code>|</code> vs <code>+</code>
    </summary>

    En muchos lenguajes de programaci√≥n ‚Äîcomo TypeScript, Haskell o ML‚Äî el tipo suma se representa usando el s√≠mbolo `|`. Por ejemplo:

    ```haskell
    data State = Connected | Disconnected | InProgress
    ```

    Esta notaci√≥n indica que un valor de tipo `State` **puede ser una entre varias alternativas**, pero nunca m√°s de una al mismo tiempo.

    Sin embargo, en este curso usamos la notaci√≥n `+` para denotar tipos suma, siguiendo la tradici√≥n de la **teor√≠a de tipos** y el **√°lgebra de tipos**, donde:

    - `+` representa la **suma disjunta**: un valor es de un tipo *o* de otro, pero no ambos.
    - `√ó` representa el **producto cartesiano**: un valor contiene un elemento de cada tipo.

    As√≠, un tipo suma con `N` alternativas puede representarse como:

    ```
    S = A‚ÇÅ + A‚ÇÇ + ... + A‚Çô
    ```

    Esta notaci√≥n destaca sus propiedades algebraicas, lo cual es √∫til para analizar el n√∫mero total de valores posibles, razonar sobre equivalencias entre tipos, o construir transformaciones seguras entre estructuras de datos.

    Adem√°s, el s√≠mbolo `|` puede ser **m√°s ambiguo** en algunos lenguajes como **Scala 3** o **Python**, donde tambi√©n se usa para representar **tipos uni√≥n** entre clases o interfaces, no necesariamente disjuntos:

    ```scala
    def parse(input: String): Int | String = ???
    ```

    En estos contextos, `|` denota simplemente que el valor puede ser de **uno u otro tipo**, sin requerir que las alternativas est√©n en un conjunto cerrado como en un tipo suma cl√°sico.
</details>

## üì¶ Uso habitual en bibliotecas

Los `enum class` son especialmente √∫tiles para representar:

- **Estados finitos** (como el estado de una conexi√≥n, sesi√≥n o flujo de trabajo).
- **Modos de operaci√≥n** (por ejemplo, modo oscuro/claro, lectura/escritura).
- **Resultados controlados** (como `OK`, `ERROR`, `TIMEOUT`, etc.).

Veamos un ejemplo t√≠pico:

```kotlin showLineNumbers title="Ejemplo de uso de enum class (sum/src/main/kotlin/com/github/username/log/LogLevel.kt)"
enum class LogLevel {
    INFO,
    WARNING,
    ERROR
}

fun log(message: String, level: LogLevel) {
    if (level == LogLevel.ERROR) {
        System.err.println("$level: $message")
    } else {
        println("$level: $message")
    }
}

fun main() {
    log("I am a genius", LogLevel.INFO)
    log("Oh no!", LogLevel.ERROR)
}
```

<Explanation>
    Hemos definido un conjunto cerrado de niveles de log (`LogLevel`) usando `enum class`.  
    Luego, lo usamos como par√°metro en una funci√≥n `log` que act√∫a de forma distinta seg√∫n el valor recibido.  
    Esto garantiza que **solo valores v√°lidos y conocidos** pueden ser usados, evitando errores como cadenas mal escritas y habilitando el chequeo en tiempo de compilaci√≥n.
</Explanation>

## üß™ `when` exhaustivo

Una de las ventajas de usar `enum class` es que nos permite aprovechar el chequeo exhaustivo del compilador al usar `when`. Esto significa que el compilador verificar√° que manejamos **todas las alternativas posibles**, y nos advertir√° si olvidamos alguna.

Esto es posible porque las enumeraciones definen un **conjunto cerrado** de valores. Veamos un ejemplo:

```kotlin showLineNumbers title="Uso exhaustivo de when (sum/src/main/kotlin/com/github/username/conn/ConnectionState.kt)"
enum class ConnectionState {
    CONNECTED,
    DISCONNECTED,
    IN_PROGRESS
}

fun messageForState(state: ConnectionState): String = when (state) {
    ConnectionState.CONNECTED -> "Connection established successfully."
    ConnectionState.DISCONNECTED -> "Connection has been lost."
    ConnectionState.IN_PROGRESS -> "Connection is currently being established."
}
```

<Explanation>
    El uso de `when` con `enum class` nos permite escribir c√≥digo **m√°s seguro y expl√≠cito**, porque el compilador sabe exactamente cu√°ntos casos hay que cubrir.  
    Si omitimos alguna alternativa, el compilador mostrar√° un **error o advertencia**, oblig√°ndonos a completar todos los casos definidos en la enumeraci√≥n.  

    Esto es posible porque las `enum class` definen un **conjunto cerrado** de valores: no es posible que existan m√°s casos fuera de los que ya est√°n listados en la definici√≥n.  
    Gracias a esta propiedad, evitamos errores sutiles como olvidarse de manejar un caso nuevo al extender una enumeraci√≥n.  

    Adem√°s, este enfoque mejora la **legibilidad**, porque cualquier persona que lea el c√≥digo puede ver de forma expl√≠cita qu√© ocurre en cada situaci√≥n posible, sin ambig√ºedades ni valores "m√°gicos".
</Explanation>

<details>
    <summary>Context-sensitive resolution en Kotlin 2.2+</summary>

    Desde Kotlin 2.2.0, el compilador incluye una funcionalidad experimental llamada **context-sensitive resolution**, que permite omitir el prefijo del nombre de una enumeraci√≥n (`ConnectionState.`) en contextos donde el tipo es claro.

    ```kotlin showLineNumbers title="Uso de context-sensitive resolution (sum/src/main/kotlin/com/github/username/conn/ConnectionState.kt)"
    fun messageForState(state: ConnectionState): String = when (state) {
        CONNECTED -> "Connection established successfully."
        DISCONNECTED -> "Connection has been lost."
        IN_PROGRESS -> "Connection is currently being established."
    }
    ```

    Esto mejora la legibilidad y reduce el ruido visual cuando el tipo ya es conocido.

    Sin embargo, es importante tener en cuenta que esta caracter√≠stica es **experimental** y puede cambiar en futuras versiones de Kotlin.
    Para m√°s informaci√≥n, puedes consultar la [documentaci√≥n oficial](https://kotlinlang.org/docs/whatsnew22.html#preview-of-context-sensitive-resolution).
</details>

## üéØ Conclusiones

Las enumeraciones (`enum class`) son una herramienta fundamental para representar tipos suma en Kotlin. Al modelar conjuntos finitos de alternativas conocidas, nos permiten escribir c√≥digo **m√°s seguro, expresivo y f√°cil de mantener**. Esta estructura es especialmente √∫til en bibliotecas que requieren representar **estados, modos o categor√≠as cerradas**, donde cada valor tiene un significado claro y exclusivo.

El soporte del compilador para el **chequeo exhaustivo** en expresiones `when` sobre enumeraciones refuerza la correcci√≥n del c√≥digo al alertar sobre casos no manejados. Y con la incorporaci√≥n de **context-sensitive resolution** en versiones recientes de Kotlin, se mejora a√∫n m√°s la legibilidad del c√≥digo al reducir el ruido sint√°ctico.

### üîë Puntos clave

* Las enumeraciones modelan **tipos suma** con un conjunto cerrado de alternativas.
* Ofrecen mayor **seguridad en tiempo de compilaci√≥n**, evitando errores como valores mal escritos o no v√°lidos.
* Permiten aprovechar el **chequeo exhaustivo** del compilador con expresiones `when`.
* Son ideales cuando las alternativas son fijas y **no requieren datos asociados**.
* Desde Kotlin 2.2+, se pueden usar sin prefijo en contextos con tipo conocido gracias a **context-sensitive resolution**.

### üß∞ ¬øQu√© nos llevamos?

A partir de esta lecci√≥n, comprendemos c√≥mo y cu√°ndo utilizar `enum class` para modelar alternativas cerradas en nuestras bibliotecas. Vimos que esta herramienta no solo mejora la seguridad del c√≥digo, sino que tambi√©n comunica de forma clara la intenci√≥n del modelo. Elegir enumeraciones en lugar de tipos primitivos como `String` o `Int` nos permite construir **interfaces m√°s robustas**, donde los errores se detectan antes y la intenci√≥n se expresa mejor. En el dise√±o de bibliotecas reutilizables, este tipo de decisiones marcan una diferencia significativa.

<ExcludeFromReadingTime>
    <div className="language-card-container">
        <LanguageCards.PythonCard link="/docs/type-fundamentals/algebraic-data-types/enums/py" />
    </div>

    ## üìñ ¬øCon ganas de m√°s?

    ### üî• Referencias recomendadas

    - üìï "Item 41: Use Enum to Represent a List of Values." (pp. 249-255) en *Effective Kotlin: Best Practices, 2nd ed.* por **Marcin Moska≈Ça**: Explica c√≥mo usar `enum class` para representar conjuntos fijos de valores, destacando sus ventajas en t√©rminos de serializaci√≥n, iteraci√≥n, ordenaci√≥n y extensi√≥n con propiedades o funciones espec√≠ficas por √≠tem. Tambi√©n compara `enum` con `sealed class`, se√±alando que las primeras son preferibles para representar valores constantes simples, mientras que las segundas son m√°s adecuadas cuando se prev√© agregar datos o l√≥gica m√°s compleja a cada caso.

    {/* ### üîπ Referencias adicionales */}
</ExcludeFromReadingTime>
