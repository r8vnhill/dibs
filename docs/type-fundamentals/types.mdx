---
title: Tipos de funciones
---
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

A lo largo de este curso, será importante poder **referirnos a las funciones por su tipo** y contar con una **notación estándar** que nos permita expresar de forma precisa qué datos reciben y qué valores devuelven. Esto no solo facilita la lectura y comprensión de ejemplos, sino que también nos permite **formalizar ideas** y **comparar distintas funciones** de manera clara y consistente.

En esta lección veremos cómo expresar el **tipo de una función**, incluyendo funciones normales, funciones miembro y funciones de extensión. Además, entenderemos por qué en Kotlin —y en muchos lenguajes modernos— las funciones son **ciudadanas de primera clase**, lo que nos permite tratarlas como cualquier otro valor dentro del lenguaje. Esta capacidad será fundamental para explorar temas como funciones de orden superior, composición y abstracción funcional más adelante en el curso.

## 📐 Notación para Funciones

:::warning Nota pedagógica

La notación que usamos para describir tipos de funciones, como `(A, B) -> C` o `W.(X, Y) -> Z`, **no pretende ser una notación formal ni universal**. Es una convención adoptada para este curso por su **claridad visual y compatibilidad con Kotlin**, y nos servirá para **razonar con precisión** sobre el comportamiento de las funciones.  
 
Más adelante, veremos que distintos lenguajes pueden expresar tipos funcionales de formas distintas, pero el concepto que subyace es el mismo: describir **cómo se transforman datos a través de funciones**.

:::

En el contexto de este curso, necesitaremos **referirnos frecuentemente a funciones por su tipo**, ya que eso nos permite razonar con precisión sobre su comportamiento, combinarlas y documentarlas de forma más clara y estandarizada.

El **tipo de una función** se define en función de los tipos de sus parámetros y su tipo de retorno. En Kotlin, podemos expresar esto así:

```kotlin
f: (A, B) -> C
```

Aquí, `A` y `B` representan los tipos de los parámetros que la función acepta, y `C` es el tipo del valor que devuelve como resultado. Esta notación es especialmente útil para analizar cómo las funciones transforman datos.

Cuando se trata de una **función miembro** o una **función de extensión**, también incluimos el tipo del receptor —es decir, el objeto sobre el que opera la función—:

```kotlin
f: W.(X, Y) -> Z
```

En este caso, `W` es el tipo del objeto que "posee" la función; `X` y `Y` son los parámetros, y `Z` es el tipo de retorno.

<details>
  <summary>📘 Comparación con otros lenguajes</summary>

  #### TypeScript

  En TypeScript, una función `(A, B) -> C` se expresa como:

  ```ts
  const f: (a: A, b: B) => C
  ```

  Y una función con receptor (por ejemplo, un método dentro de una clase `W`) se ve como:

  ```ts
  class W {
    f(x: X, y: Y): Z { ... }
  }
  ```

  #### Haskell

  En Haskell, el tipo `(A, B) -> C` se expresa utilizando currying:

  ```haskell
  f :: A -> B -> C
  ```

  Y funciones que operan sobre estructuras (como `W`) se suelen representar como:

  ```haskell
  f :: W -> X -> Y -> Z
  ```

  donde `W` sería un argumento explícito en lugar de receptor implícito.
</details>

Tu sección está clara y bien estructurada, pero aquí van algunas sugerencias para mejorarla ligeramente:

## 🫂 Ciudadanos de Primera Clase

En programación, una entidad se considera un **"ciudadano de primera clase"** si puede ser manipulada como cualquier otro valor del lenguaje. Específicamente, debe poder:

- Crearse dinámicamente durante la ejecución del programa.
- Asignarse a variables.
- Pasarse como argumento a otras funciones.
- Retornarse desde funciones.
- Almacenarse en estructuras de datos como listas o mapas.

En Kotlin, **las funciones son ciudadanos de primera clase**, lo que significa que puedes usarlas como valores: asignarlas a variables, almacenarlas, combinarlas, o pasarlas entre funciones. Esto habilita un estilo de programación más expresivo, reutilizable y modular.

### 🧪 Ejemplo

```kotlin
fun add(a: Int, b: Int): Int = a + b

val add2: (Int, Int) -> Int = ::add
```

Aquí, `add2` es una referencia a la función `add`, lo que demuestra cómo una función puede almacenarse en una variable del tipo `(Int, Int) -> Int`.

:::info Operador de Referencia de Función

El operador `::` en Kotlin se llama **operador de referencia de función** y se utiliza para obtener una referencia a una función existente. En el ejemplo, `::add` toma la función `add` y la convierte en un valor que puede ser asignado, pasado o retornado.

:::

Esta propiedad también está presente en otros lenguajes modernos como Python, TypeScript, Haskell, Scala y Ruby, donde tratar funciones como valores permite construir abstracciones poderosas, como funciones de orden superior o APIs declarativas.

## 🎯 Conclusiones

En esta lección sentamos una base clave para el resto del curso: aprendimos a expresar funciones mediante una notación precisa y a reconocerlas como **valores de primera clase**. Esta perspectiva será esencial para los enfoques funcionales y declarativos que exploraremos más adelante.

Al definir funciones reutilizables, componer comportamientos o construir DSLs, pensar en funciones como valores nos permitirá diseñar bibliotecas más expresivas, robustas y elegantes.

### 🔑 Puntos clave

- Los tipos de funciones describen qué datos reciben y qué valores devuelven, usando notación como `(A, B) -> C` o `W.(X, Y) -> Z`.
- Esta notación será central para razonar, abstraer y comunicar ideas a lo largo del curso.
- Las funciones en Kotlin son **ciudadanas de primera clase**: pueden asignarse a variables, pasarse como argumentos y devolverse como resultados.

### 🧰 ¿Qué nos llevamos?

Tener una notación clara para describir funciones —y entender que pueden manipularse como cualquier otro valor— nos brinda una herramienta poderosa para construir abstracciones. Esta capacidad será fundamental para abordar conceptos como funciones de orden superior, composición, validaciones declarativas y diseño de APIs expresivas.
