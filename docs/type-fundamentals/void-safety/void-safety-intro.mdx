---
title: Introducci√≥n a Void Safety
sidebar_label: Void Safety
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />

## üö´ ¬øQu√© es "Void Safety"?

Una de las causas m√°s frecuentes de errores en aplicaciones es el uso incorrecto de valores *ausentes* o *nulos*. Este problema ocurre cuando una variable que se espera que contenga una referencia v√°lida en realidad contiene `null`. Al intentar acceder a sus m√©todos o propiedades, se generan fallos cr√≠ticos en tiempo de ejecuci√≥n, como el temido **NullPointerException**.

Este tipo de error es tan com√∫n que Tony Hoare, creador del `null` moderno, lo llam√≥ ‚Äú[el error de mil millones de d√≥lares](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)‚Äù.

:::info ¬øPor qu√© es importante la seguridad contra vac√≠os?

**Void safety** ‚Äîo *seguridad contra vac√≠os*‚Äî es una propiedad que ofrecen algunos lenguajes para prevenir que referencias nulas o vac√≠as causen fallas en tiempo de ejecuci√≥n. Esto se logra a trav√©s del sistema de tipos, forzando a que quien desarrolla maneje expl√≠citamente los casos en los que un valor puede estar ausente.

:::

En el desarrollo de **bibliotecas de software**, estos errores pueden ser a√∫n m√°s cr√≠ticos: no solo afectan al c√≥digo interno, sino que tambi√©n se propagan hacia quienes consumen la biblioteca. Una API que no gestiona adecuadamente la nulabilidad puede comprometer la estabilidad de m√∫ltiples proyectos y generar errores dif√≠ciles de diagnosticar.

## üí° Motivaci√≥n

El manejo inadecuado de valores *nulos* (o *vac√≠os*) es una de las causas m√°s frecuentes de errores en tiempo de ejecuci√≥n. Estos errores son dif√≠ciles de detectar, costosos de corregir y pueden comprometer la estabilidad de un sistema completo.

Un ejemplo cl√°sico en Scala:

```scala showLineNumbers
val name: String = null
println(name.length) // üî• NullPointerException
```

Puedes probar este c√≥digo en un compilador en l√≠nea, como [Scastie](https://scastie.scala-lang.org).

Aqu√≠, el programa compila sin advertencias, pero falla en tiempo de ejecuci√≥n. No hay ninguna protecci√≥n est√°tica que impida acceder a `length` cuando `name` es `null`.

Este riesgo se agrava en sistemas grandes. Y cuando se trata de **bibliotecas de software**, el impacto se multiplica: si una API permite valores nulos sin restricciones, los errores pueden propagarse a todas las aplicaciones que la utilizan.

Por eso, gestionar correctamente la presencia (o ausencia) de valores no es solo una buena pr√°ctica: es una necesidad para garantizar **la calidad, previsibilidad y fiabilidad** del software que ofrecemos a otras personas.

El objetivo de *void safety* es justamente ese: **prevenir accesos inv√°lidos a valores vac√≠os antes de que el programa se ejecute**, ya sea usando el sistema de tipos, verificaciones expl√≠citas o alternativas m√°s seguras a `null`.

<details>
    <summary>
        üß† La teor√≠a de `null` ‚Äî objetos iniciales y terminales
    </summary>

    Desde la teor√≠a de categor√≠as, se distinguen dos tipos especiales de objetos:

    - Un **objeto inicial** es uno que puede sustituir a cualquier otro tipo, pero no puede ser inspeccionado ni utilizado directamente.
    - Un **objeto terminal** es uno que puede ser el resultado de cualquier operaci√≥n, pero no se le puede aplicar ninguna otra operaci√≥n √∫til sin fallar.

    En lenguajes como Scala o Java, `null` **act√∫a simult√°neamente como objeto inicial y terminal**, y eso es precisamente lo que lo vuelve problem√°tico.

    #### üîÅ Como objeto inicial

    `null` puede ser asignado a cualquier tipo por referencia:

    ```scala
    val name: String = null
    val items: List[String] = null
    ```

    Esto lo convierte en un valor "universal", que puede aparecer en cualquier parte del sistema, incluso donde no tiene sentido sem√°ntico.

    #### üß® Como objeto terminal

    `null` tambi√©n puede ser el resultado de cualquier funci√≥n, especialmente en casos de error o ausencia de datos:

    ```scala
    def findUsername(): String = null

    val user = findUsername()
    println(user.toUpperCase()) // üî• NullPointerException
    ```

    El problema es que, a diferencia de otros tipos como `Any`, **`null` no es operativo**: cualquier intento de invocarlo provoca errores en tiempo de ejecuci√≥n.

    #### ‚ö†Ô∏è ¬øPor qu√© es tan peligroso?

    Este doble rol convierte a `null` en una especie de **‚Äúvalor polimorfo ileg√≠timo‚Äù**: puede infiltrarse en cualquier tipo, pasar inadvertido en el c√≥digo, y fallar solo cuando ya es demasiado tarde.

    A diferencia de `Any`, que permite llamadas como `.toString` o `.hashCode`, **`null` no ofrece garant√≠as de uso seguro**. Y a diferencia de `Nothing`, que representa una falla expl√≠cita (como lanzar una excepci√≥n), **`null` es una falla silenciosa en potencia**.

    #### üß† En el dise√±o de bibliotecas

    Permitir que `null` forme parte de nuestras APIs obliga a quienes las usan a escribir **c√≥digo defensivo** constantemente. Esto aumenta la complejidad y reduce la confiabilidad del software, especialmente cuando m√∫ltiples capas dependen de datos que podr√≠an estar ausentes.

    En lugar de confiar en valores como `null`, es preferible ofrecer **alternativas expl√≠citas y seguras** para representar la ausencia de datos. De este modo, el c√≥digo se vuelve m√°s predecible y menos propenso a fallos silenciosos.

    Por ello, lenguajes como Scala (mediante `Option`), Kotlin, Swift y Rust han incorporado mecanismos que restringen o eliminan el uso libre de `null`, promoviendo dise√±os que hacen **expl√≠cita** la posibilidad de ausencia y que facilitan su manejo seguro.
</details>

<details>
    <summary>üîç ¬øEn qu√© se diferencia `null` de `Unit`, `Nothing` o incluso `Any`?</summary>

    Aunque `null` suele interpretarse como "no hay valor", su uso es ambiguo. En lenguajes con sistemas de tipos expresivos, como Scala o Kotlin, existen **tipos especializados** para representar distintos aspectos de la ausencia, el fallo o la generalidad. Comprender estas diferencias permite dise√±ar APIs m√°s claras y seguras.

    | Tipo       | Prop√≥sito principal                                      | Caracter√≠sticas clave                                                 |
    |------------|----------------------------------------------------------|-----------------------------------------------------------------------|
    | `null`     | Ausencia de valor o referencia                           | Puede usarse en cualquier lugar, pero no se puede operar con √©l       |
    | `Unit`     | Indica que no hay valor significativo, pero no es error  | Tiene un √∫nico valor `()` y representa efectos sin resultado √∫til     |
    | `Nothing`  | Representa una operaci√≥n que nunca retorna               | Tipo sin instancias; √∫til para modelar fallos                         |
    | `Any`      | S√∫per tipo de todos los valores                          | Seguro de usar; permite llamadas como `.toString`, `.hashCode`, etc.  |

    #### üìö Interpretaci√≥n desde la teor√≠a de tipos

    - `Any` es un **tipo terminal**: todo valor puede convertirse en `Any`. Es completamente operativo.
    - `Nothing` es un **tipo inicial**: puede insertarse donde se espera cualquier tipo, pero no tiene valores. Representa c√≥digo que nunca contin√∫a.
    - `null`, en cambio, es un caso an√≥malo: **act√∫a a la vez como tipo inicial y tipo terminal**, pero sin las garant√≠as de ninguno.

    Esto lo convierte en un ‚Äúcomod√≠n inseguro‚Äù: puede estar en cualquier parte, pero su uso siempre es riesgoso.

    #### ‚úÖ `Unit`: ausencia de valor relevante, sin error

    ```scala
    def logInfo(msg: String): Unit =
        println(s"[INFO] $msg")

    val result = logInfo("Listo") // retorna (), sin fallar
    ```

    #### üí• `Nothing`: indica una operaci√≥n que no finaliza normalmente

    ```scala
    def fail(): Nothing =
        throw new RuntimeException("Error fatal")

    val x = fail() // nunca retorna un valor
    ```

    ---

    Separar claramente estos conceptos permite expresar **la intenci√≥n sem√°ntica del c√≥digo**: cu√°ndo algo fall√≥, cu√°ndo no hay nada que devolver, o cu√°ndo simplemente no se espera un valor. En contraste, `null` **no comunica intenci√≥n alguna** y deja la responsabilidad en quien llama, lo que lo vuelve un riesgo sist√©mico.
</details>

## üîç ¬øQu√© aprender√°s en este bloque?

Este bloque se compone de dos lecciones fundamentales para escribir c√≥digo m√°s seguro y expresivo:

1. **Void safety en Kotlin**  
   Ver√°s c√≥mo Kotlin gestiona la nulabilidad usando su sistema de tipos y operadores como `?.`, `?:`, `!!` y `let`, y c√≥mo el compilador ayuda a prevenir errores comunes como el `NullPointerException`.

2. **Alternativas seguras a `null`: Option y Result**  
   Aprender√°s a modelar la ausencia de valores o fallos mediante estructuras como `Option` y `Result`, que ofrecen formas m√°s expl√≠citas y seguras de representar situaciones en las que algo puede fallar o no existir.

:::tip Dise√±a APIs seguras
Si est√°s creando una biblioteca, **no deber√≠as obligar a quienes la usan a adivinar si un valor puede ser nulo**. Hazlo evidente desde la API: usa tipos que expresen claramente cu√°ndo algo puede fallar o estar ausente.

:::

## üéØ Objetivos de aprendizaje

Al finalizar esta subunidad, deber√≠as ser capaz de:

- Identificar y evitar errores causados por referencias nulas.
- Comprender c√≥mo Kotlin implementa void safety a trav√©s de su sistema de tipos.
- Elegir entre usar `null`, `Option`, `Result` u otras alternativas seg√∫n el caso.
- Dise√±ar APIs m√°s seguras y expresivas, minimizando la posibilidad de errores en tiempo de ejecuci√≥n.

üëâ Vamos a comenzar con la primera lecci√≥n: **Null / Void safety en Kotlin**.
