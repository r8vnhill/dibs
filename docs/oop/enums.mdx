---
title: Enumeraciones
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime/>

El concepto de **enumeración** o **enum** se utiliza en muchos lenguajes de programación para definir un conjunto finito de valores constantes. Estos valores están relacionados de manera lógica y proporcionan una forma más segura y legible de manejar múltiples estados o condiciones.

En el contexto de un sistema para una tienda en línea, podríamos querer representar los estados de un pedido, como:

- Pendiente
- Pagado
- Enviado
- Entregado
- Cancelado

## Primer Enfoque: Strings

Podríamos comenzar usando strings para representar estos estados en **Kotlin**, pero rápidamente notaríamos problemas como la posibilidad de errores en tiempo de ejecución debido a valores mal escritos o incorrectos:

```kotlin
fun handleOrderState(state: String) = when (state) {
    "Pending" -> println("Order is pending")
    "Paid" -> println("Order is paid")
    "Shipped" -> println("Order is shipped")
    "Delivered" -> println("Order is delivered")
    "Cancelled" -> println("Order is cancelled")
    else -> println("Unknown state")
}
```

Este enfoque no garantiza que el estado sea uno de los valores válidos, lo que puede llevar a problemas difíciles de detectar. Para evitar estos errores, podemos utilizar **enumeraciones**.

## Uso de Enumeraciones en Kotlin

En **Kotlin**, las enumeraciones se definen usando la palabra clave `enum class`. Esto mejora la seguridad de tipos y asegura que solo se puedan asignar valores válidos a una variable:

```kotlin
enum class DeliveryState {
    PENDING, PAID, SHIPPED, DELIVERED, CANCELLED
}
```

El uso de **enumeraciones** evita que se asignen estados inválidos o mal escritos, garantizando que el sistema siempre trabaje con estados predefinidos y correctos.

### Uso en un `when` exhaustivo

En Kotlin, un `when` es exhaustivo cuando cubre todos los posibles valores de una enumeración. Esto significa que no necesitas un bloque `else` si has manejado todos los estados:

```kotlin
fun handleOrderState(state: DeliveryState) = when (state) {
    DeliveryState.PENDING -> println("Order is pending")
    DeliveryState.PAID -> println("Order is paid")
    DeliveryState.SHIPPED -> println("Order is shipped")
    DeliveryState.DELIVERED -> println("Order is delivered")
    DeliveryState.CANCELLED -> println("Order is cancelled")
}
```

Aquí tienes un ejemplo de cómo usar la función:

```kotlin
fun main() {
    handleOrderState(DeliveryState.PENDING)
    handleOrderState(DeliveryState.PAID)
}
```

## Ventajas de las Enumeraciones

1. **Seguridad de Tipos**: Las enumeraciones aseguran que solo se puedan asignar valores válidos a las variables, eliminando el riesgo de errores en tiempo de ejecución debido a entradas inválidas.
2. **Legibilidad del Código**: Proporcionan nombres significativos para un conjunto fijo de valores, lo que mejora la claridad del código.
3. **Mantenibilidad**: Facilitan el mantenimiento y la actualización del código, ya que los estados válidos están centralizados.

## Comparaciones con Otros Lenguajes

**Kotlin** ofrece una forma poderosa de manejar estados mediante enumeraciones, pero muchos otros lenguajes también ofrecen características similares. A continuación se muestran ejemplos de cómo se utilizan las enumeraciones en otros lenguajes:

- **C y C++**: Las enumeraciones en **C** y **C++** son simples y permiten asignar nombres a un conjunto de valores enteros constantes.

```c
// C
enum DeliveryState { PENDING, PAID, SHIPPED, DELIVERED, CANCELLED };

void handleOrderState(enum DeliveryState state) {
    switch (state) {
        case PENDING: printf("Order is pending\n"); break;
        case PAID: printf("Order is paid\n"); break;
        case SHIPPED: printf("Order is shipped\n"); break;
        case DELIVERED: printf("Order is delivered\n"); break;
        case CANCELLED: printf("Order is cancelled\n"); break;
    }
}
```

En **C++**, las enumeraciones pueden tener un alcance mejorado mediante `enum class`:

```cpp
// C++
enum class DeliveryState { PENDING, PAID, SHIPPED, DELIVERED, CANCELLED };

void handleOrderState(DeliveryState state) {
    switch (state) {
        case DeliveryState::PENDING: std::cout << "Order is pending\n"; break;
        case DeliveryState::PAID: std::cout << "Order is paid\n"; break;
        case DeliveryState::SHIPPED: std::cout << "Order is shipped\n"; break;
        case DeliveryState::DELIVERED: std::cout << "Order is delivered\n"; break;
        case DeliveryState::CANCELLED: std::cout << "Order is cancelled\n"; break;
    }
}
```

- **Java**: Las enumeraciones en Java son similares a las de Kotlin:

```java
public enum DeliveryState {
    PENDING, PAID, SHIPPED, DELIVERED, CANCELLED
}
```

- **Scala 3**: Scala 3 introduce una sintaxis simplificada para las enumeraciones:

```scala
enum DeliveryState {
  case Pending, Paid, Shipped, Delivered, Cancelled
}
```

- **C#**: En **C#**, las enumeraciones también son similares, aunque no permiten métodos abstractos dentro del `enum`.

```csharp
public enum DeliveryState {
    Pending, Paid, Shipped, Delivered, Cancelled
}
```

## Métodos en Enumeraciones

En **Kotlin**, las enumeraciones pueden incluir tanto métodos abstractos como concretos. Esto permite que cada valor de la enumeración tenga su propia implementación de un método, además de compartir comportamientos comunes.

```kotlin
enum class DeliveryState {
    PENDING {
        override fun signal() = "Order is pending"
    },
    PAID {
        override fun signal() = "Order is paid"
    },
    SHIPPED {
        override fun signal() = "Order is shipped"
    },
    DELIVERED {
        override fun signal() = "Order is delivered"
    },
    CANCELLED {
        override fun signal() = "Order is cancelled"
    };

    abstract fun signal(): String

    // Método concreto común a todos los valores
    fun isFinalState() = this == DELIVERED || this == CANCELLED
}
```

En este ejemplo:
- Cada valor de la enumeración sobrescribe el método `signal`.
- El método `isFinalState` está disponible para todos los valores de la enumeración y determina si el estado es final (es decir, `DELIVERED` o `CANCELLED`).

```kotlin
fun handleOrderState(state: DeliveryState) {
    if (state.isFinalState()) {
        println("Final state: ${state.signal()}")
    } else {
        println("Non-final state: ${state.signal()}")
    }
}
```

## Funciones Útiles en Enumeraciones

1. **entries**: Puedes acceder a todas las entradas de la enumeración con `entries`:

```kotlin
fun listOrderStates() = DeliveryState.entries.forEach { println(it) }
```

2. **valueOf**: Puedes buscar un valor de la enumeración por su nombre con `valueOf`, aunque debes manejar posibles excepciones si el valor no existe:

```kotlin
fun getOrderState(name: String) = DeliveryState.valueOf(name)
```

## Limitaciones de las Enumeraciones

1. **Datos Asociados**: Las enumeraciones tienen capacidades limitadas para manejar información dinámica. Si necesitas almacenar datos específicos para cada valor, deberás definirlos de manera estática o recurrir a otras estructuras.
2. **Complejidad del Manejo del Estado**: Si el manejo del estado es muy complejo, usar enumeraciones puede hacer que el diseño sea más difícil de mantener. En tales casos, es recomendable considerar otras estructuras, como **clases selladas**.

:::tip Ejercicio: Interfaz y Enumeración de Acciones del Juego

<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Implementa una interfaz `GameAction`, una clase `Player` y una enumeración `GameEvent` que representen las
        acciones de un juego.

        - **Interfaz `GameAction`**:
        - Define una interfaz `GameAction` que incluya un método `execute(player: Player)`.
        - El método `execute` debe afectar al estado de un jugador de acuerdo con el tipo de evento.

        - **Clase `Player`**:
        - Crea una clase `Player` que contenga dos propiedades: `healthPoints` y `manaPoints`.
        - La clase debe incluir métodos para aumentar y disminuir los puntos de salud (`healthPoints`) y los puntos de
        maná (`manaPoints`) en una cantidad dada.

    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        class Player(health: Int, mana: Int) {
            var health = health
                private set
            var mana = mana
                private set

            fun increaseHealth(amount: Int) {
                health += amount
            }

            fun decreaseHealth(amount: Int) {
                health -= amount
            }

            fun increaseMana(amount: Int) {
                mana += amount
            }

            fun decreaseMana(amount: Int) {
                mana -= amount
            }
        }
        ```


        ```kotlin
        enum class GameEvent : GameAction {
            HEALTH_BOOST {
                override fun execute(player: Player) {
                    player.increaseHealth(20)
                }
            },
            MANA_DRAIN {
                override fun execute(player: Player) {
                    player.decreaseMana(15)
                }
            },
            POISON {
                override fun execute(player: Player) {
                    player.decreaseHealth(10)
                }
            },
            ENERGY_SURGE {
                override fun execute(player: Player) {
                    player.increaseMana(20)
                }
            };
        }
        ```
    </TabItem>
</Tabs>
:::