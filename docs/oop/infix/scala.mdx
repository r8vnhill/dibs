---
title: Expresiones infijas en Scala
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard, ScalaCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="scala-dibs" />

Las **expresiones infijas** permiten escribir funciones de manera m√°s legible y fluida, eliminando la necesidad de par√©ntesis o puntos. En Scala, este concepto ha evolucionado entre **Scala 2** y **Scala 3**, con cambios en la forma en que se manejan los m√©todos infijos y los operadores personalizados.

### ‚úÖ Sintaxis de Expresiones Infijas

<BoxedTabs>
    <TabItem value="Scala 3" label="Scala 3">
    </TabItem>
    <TabItem value="Scala 2" label="Scala 2">
    </TabItem>
</BoxedTabs>

En **Scala 2**, cualquier m√©todo con un √∫nico par√°metro puede ser utilizado como infijo.

```scala
class Persona(val nombre: String) {
  def saluda(a: Persona): String = s"Hola, ${a.nombre}, soy $nombre"
}

val juan = new Persona("Juan")
val ana = new Persona("Ana")

println(juan saluda ana)  // "Hola, Ana, soy Juan"
```

En este caso, `saluda` se invoca sin par√©ntesis ni punto, permitiendo un c√≥digo m√°s expresivo.

### üöÄ Expresiones Infijas en Scala 3

En **Scala 3**, el uso de expresiones infijas est√° **restringido a m√©todos marcados expl√≠citamente como `infix`**.

```scala
class Persona(val nombre: String) {
  infix def saluda(a: Persona): String = s"Hola, ${a.nombre}, soy $nombre"
}

val juan = new Persona("Juan")
val ana = new Persona("Ana")

println(juan saluda ana)  // "Hola, Ana, soy Juan"
```

El modificador `infix` **no es obligatorio**, pero su uso es recomendado para hacer expl√≠cito que el m√©todo debe ser usado de manera infija.

---

## üîç Diferencias Clave entre Scala 2 y Scala 3

| Caracter√≠stica               | Scala 2                          | Scala 3                              |
|-----------------------------|--------------------------------|--------------------------------|
| **M√©todos infijos**         | Cualquier m√©todo con 1 par√°metro | Requiere la anotaci√≥n `infix` (opcional pero recomendado) |
| **Uso en clases**           | Impl√≠cito en cualquier m√©todo de una clase | Se recomienda marcar con `infix` |
| **Expresiones ambiguas**    | Permitidas sin restricciones | Pueden generar advertencias si no est√°n marcadas con `infix` |
| **Precedencia**             | Similar a operadores est√°ndar | No ha cambiado en Scala 3 |

---

## üìå **Expresiones Infijas con Operadores Personalizados**

En **Scala 2**, cualquier m√©todo puede ser infijo, incluyendo aquellos que usan caracteres especiales como `+`, `*`, etc.

```scala
class Vector2D(val x: Int, val y: Int) {
  def +(other: Vector2D): Vector2D = new Vector2D(this.x + other.x, this.y + other.y)
}

val v1 = new Vector2D(1, 2)
val v2 = new Vector2D(3, 4)

val v3 = v1 + v2  // Vector(4, 6)
```

En **Scala 3**, esto sigue siendo v√°lido, pero se recomienda marcar los operadores con `infix`.

```scala
class Vector2D(val x: Int, val y: Int) {
  infix def +(other: Vector2D): Vector2D = new Vector2D(this.x + other.x, this.y + other.y)
}

val v1 = new Vector2D(1, 2)
val v2 = new Vector2D(3, 4)

val v3 = v1 + v2  // Vector(4, 6)
```

El beneficio de usar `infix` en Scala 3 es que el compilador emite advertencias si el m√©todo se usa de una manera no esperada.

---

## ‚ö†Ô∏è Ambig√ºedades y Precedencia  

En ambos casos, las expresiones infijas pueden generar ambig√ºedades cuando se combinan con operadores est√°ndar.

```scala
class Number(val value: Int) {
  infix def doubleAdd(other: Number): Number = new Number(this.value + other.value * 2)
}

val a = new Number(2)
val b = new Number(3)

val result = a doubleAdd b + b  // Ambiguo: ¬ø(a doubleAdd b) + b o a doubleAdd (b + b)?
```

Para evitar confusi√≥n, **Scala recomienda usar par√©ntesis expl√≠citos**.

```scala
val result1 = (a doubleAdd b) + b
val result2 = a doubleAdd (b + b)
```

---

## üèÜ **Caso de estudio: Expresiones Infijas en Librer√≠as de Pruebas**

Un uso com√∫n de las expresiones infijas en Scala es en **frameworks de pruebas**, como **ScalaTest** y **MUnit**, donde ayudan a escribir **assertions** m√°s legibles y expresivas.

```scala
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers

class ExampleSpec extends AnyFlatSpec with Matchers {
  "Una lista" should "contener elementos esperados" in {
    List(1, 2, 3) should contain(2)
  }
}
```

El uso de `should contain` como una expresi√≥n infija mejora la claridad y legibilidad del test.

En **Scala 3**, `should` y otros operadores personalizados pueden beneficiarse de la anotaci√≥n `infix`:

```scala
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers

class ExampleSpec extends AnyFlatSpec with Matchers {
  infix def esMayorQue(x: Int, y: Int): Boolean = x > y

  "Comparaciones" should "ser m√°s legibles" in {
    (10 esMayorQue 5) shouldBe true
  }
}
```

---

## üìä **Beneficios y Limitaciones**

<ProCons>
    <Pros>
        - **Mayor legibilidad**: Las expresiones infijas hacen que el c√≥digo sea m√°s intuitivo y f√°cil de leer, especialmente en DSLs y librer√≠as de pruebas.
        - **Compatibilidad con librer√≠as de pruebas**: Frameworks como **ScalaTest** aprovechan las expresiones infijas para hacer los tests m√°s expresivos.
        - **Ideal para operadores personalizados**: Facilitan la creaci√≥n de operadores que se comportan como los operadores est√°ndar.
    </Pros>
    <Cons>
        - **Ambig√ºedades en precedencia**: Sin par√©ntesis, algunas expresiones pueden ser dif√≠ciles de interpretar.
        - **Restricciones en Scala 3**: La necesidad de usar `infix` puede hacer que algunas migraciones desde Scala 2 requieran cambios.
    </Cons>
</ProCons>

---

## üìå **Conclusiones**  

Las **expresiones infijas** en Scala han evolucionado con **Scala 3**, introduciendo el modificador `infix` para mejorar la claridad y evitar ambig√ºedades. Aunque su uso sigue siendo opcional, se recomienda para garantizar una sintaxis m√°s predecible y evitar advertencias del compilador.

### üîë **Puntos clave**  

1. **Expresividad y legibilidad mejorada**  
   - En ambos casos, las expresiones infijas permiten escribir c√≥digo m√°s natural y menos cargado de par√©ntesis.
   - Scala 3 introduce `infix` para indicar expl√≠citamente qu√© m√©todos pueden usarse de manera infija.
2. **Uso en librer√≠as de pruebas**  
   - Frameworks como **ScalaTest** y **MUnit** utilizan expresiones infijas para hacer los tests m√°s declarativos.
3. **Precedencia y ambig√ºedad**  
   - Se recomienda **usar par√©ntesis** en expresiones complejas para evitar confusi√≥n.

### ‚úÖ **Reflexi√≥n final**  

Las expresiones infijas son una herramienta poderosa para mejorar la claridad del c√≥digo en Scala, pero deben usarse con criterio. Scala 3 introduce restricciones que hacen el c√≥digo m√°s predecible, asegurando que el uso de infijos sea m√°s controlado y claro para quien desarrolla.
