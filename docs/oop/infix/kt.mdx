---
title: Expresiones infijas
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard, ScalaCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="object-oriented-programming-kt" />
<ModuleSetup module='infix' task='setupInfixModule'>
    
</ModuleSetup>

En Kotlin, las **expresiones infijas** permiten escribir funciones de manera m√°s legible y fluida, eliminando la necesidad de par√©ntesis o puntos. Estas expresiones pueden mejorar la claridad del c√≥digo en casos donde las operaciones se asemejan a un lenguaje natural, como en **pruebas unitarias**, **DSLs** y **operaciones sobre colecciones**.

## üéØ ¬øQu√© es una Expresi√≥n Infija?

Una expresi√≥n infija es una funci√≥n que se puede llamar sin el uso de par√©ntesis ni puntos, de manera similar a los operadores matem√°ticos. Para declarar una funci√≥n como infija, se utiliza la palabra clave `infix`. Estas funciones infijas solo pueden ser miembros de una clase o extensiones de una clase.

### üí° Sintaxis de las Expresiones Infijas

Para definir una funci√≥n infija en Kotlin, se utiliza la siguiente estructura:

<BoxedTabs>
    <TabItem value="Como miembro de una clase" label="Como miembro de una clase">
        ```kotlin
        class ClassName {
            infix fun functionName(parameter: ParameterType): ReturnType {
                // Cuerpo de la funci√≥n
            }
        }
        ```
    </TabItem>
    <TabItem value="Como extensi√≥n de una clase" label="Como extensi√≥n de una clase">
        ```kotlin
        infix fun ClassName.functionName(parameter: ParameterType): ReturnType {
            // Cuerpo de la funci√≥n
        }
        ```
    </TabItem>
</BoxedTabs>

### üìù Reglas para Crear Funciones Infijas

Para que una funci√≥n pueda ser utilizada como infija, debe cumplir las siguientes reglas:

1. **Debe ser una funci√≥n miembro o una extensi√≥n**.
2. **Debe aceptar solo un par√°metro**.
3. **No debe aceptar par√°metros con valores predeterminados**.

```kotlin
// ‚úÖ Correcto: funci√≥n de extensi√≥n con un solo par√°metro
infix fun String.concatenate(other: String) = this + other

// ‚ùå Incorrecto: funci√≥n con m√°s de un par√°metro
infix fun String.concatenate(other: String, separator: String) = this + separator + other

// ‚ùå Incorrecto: funci√≥n con un par√°metro opcional
infix fun String.concatenate(other: String = "default") = this + other
```

### ‚ö†Ô∏è Precedencia y Ambig√ºedad en Expresiones Infijas

Las funciones infijas en Kotlin pueden hacer que el c√≥digo sea **m√°s legible**, pero **tambi√©n pueden introducir ambig√ºedades** en expresiones donde se combinan con **operadores matem√°ticos u otras funciones infijas**.

#### üîç Ejemplo de Ambig√ºedad

```kotlin
infix fun Int.multiplyBy(value: Int): Int = this * value

// ‚ùå Potencialmente ambiguo: ¬ø(3 + 5) * 2 o 3 + (5 * 2)?
val result = 3 + 5 multiplyBy 2  

println(result) // ¬ø16 o 13?
```

:::danger

En este caso, es dif√≠cil saber si **multiplyBy** tiene mayor precedencia que el `+`, lo que puede llevar a **resultados inesperados**.

:::

#### ‚úÖ Soluci√≥n: Usar Par√©ntesis

Para evitar confusi√≥n, **siempre es recomendable usar par√©ntesis** cuando se mezclan **operadores est√°ndar** con **funciones infijas**:

```kotlin
// üöÄ Opci√≥n clara y sin ambig√ºedad
val result1 = (3 + 5) multiplyBy 2  // (3 + 5) * 2 = 16
val result2 = 3 + (5 multiplyBy 2)  // 3 + (5 * 2) = 13
```

## üèÜ Caso de estudio: Expresiones infijas en Kotest

Un uso com√∫n de expresiones infijas en Kotlin es en **frameworks de pruebas**, como **Kotest**, donde ayudan a escribir **assertions** m√°s legibles y expresivas.  

Por ejemplo, en una prueba unitaria, podemos verificar la longitud m√≠nima de un nombre de usuario usando Kotest y una expresi√≥n infija.  

### üîÑ Comparaci√≥n: Expresi√≥n Infija vs. Funci√≥n Normal

Veamos c√≥mo se ver√≠a una prueba usando una **funci√≥n est√°ndar** frente a una **expresi√≥n infija**:

```kotlin
// ‚ùå Sin expresi√≥n infija (funci√≥n est√°ndar)
username.shouldHaveMinimumLength(5)

// ‚úÖ Con expresi√≥n infija
username shouldHaveMinimumLength 5
```

#### üéØ ¬øPor qu√© la versi√≥n infija es mejor?
1. **Legibilidad mejorada** ‚Üí La sintaxis infija imita una oraci√≥n natural, lo que hace que las pruebas sean m√°s f√°ciles de leer y entender.  
2. **Menos ruido visual** ‚Üí Se eliminan los par√©ntesis innecesarios, haciendo que la intenci√≥n del test sea m√°s clara.  
3. **Mayor expresividad** ‚Üí Se asemeja a un lenguaje natural, lo que es especialmente √∫til en **DSLs de testing**.  

### ‚úç Implementaci√≥n en Kotest

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>

        ```kotlin showLineNumbers
        infix fun Username.shouldHaveMinimumLength(length: Int): Username {
            this should haveMinimumLength(length)
            return this
        }
        ```

    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>

        ```kotlin showLineNumbers title="infix/src/test/kotlin/cl/ravenhill/matchers/haveMinimumLength.kt"
        package com.github.username.matchers

        import com.github.username.users.Username
        import io.kotest.matchers.Matcher
        import io.kotest.matchers.MatcherResult
        import io.kotest.matchers.should
        import io.kotest.matchers.shouldNot

        fun haveMinimumLength(length: Int) = Matcher<Username> { username ->
            MatcherResult(
                username.value.length >= length,
                { "Username should have a minimum length of $length" },
                { "Username should not have a minimum length of $length" }
            )
        }

        infix fun Username.shouldHaveMinimumLength(length: Int): Username {
            this should haveMinimumLength(length)
            return this
        }
        ```

    </TabItem>
</BoxedTabs>

<Explanation>
    - **Uso de expresiones infijas** ‚Üí La funci√≥n `shouldHaveMinimumLength` se define como infija para hacer que la prueba sea m√°s legible y expresiva.  
    - **Compatibilidad con Kotest** ‚Üí Se integra con `should`, manteniendo la coherencia con el estilo del framework.  
    - **Retorno fluido** ‚Üí Se devuelve la propia instancia (`this`) para permitir encadenamiento de validaciones si es necesario.  
</Explanation>

### üß™ Uso de la Funci√≥n en Pruebas Unitarias

El uso de `shouldHaveMinimumLength` en pruebas unitarias facilita la generaci√≥n de valores aleatorios para verificar esta condici√≥n:

<BoxedTabs>
<TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
```kotlin showLineNumbers
checkAll(
    Arb.int(0..10).flatMap { length ->
        Arb.usernames()
            .filter { it.value.length >= length }
            .map { length to Username(it.value) }
    }
) { (length, username) ->
    username shouldHaveMinimumLength length
}
```

```kotlin showLineNumbers
checkAll(
    Arb.usernames().flatMap { username ->
        Arb.int(username.value.length + 1..100)
            .map { it to Username(username.value) }
    }
) { (length, username) ->
    shouldThrow<AssertionError> {
        username shouldHaveMinimumLength length
    }
}
```
</TabItem>
<TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
```kotlin showLineNumbers title="infix/src/test/kotlin/cl/ravenhill/validation/HaveMinimumLengthTest.kt"
package cl.ravenhill.validation

import cl.ravenhill.matchers.shouldHaveMinimumLength
import cl.ravenhill.users.Username
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.style.FreeSpec
import io.kotest.property.Arb
import io.kotest.property.arbitrary.filter
import io.kotest.property.arbitrary.flatMap
import io.kotest.property.arbitrary.int
import io.kotest.property.arbitrary.map
import io.kotest.property.arbs.usernames
import io.kotest.property.checkAll

class HaveMinimumLengthTest : FreeSpec({
    "Given a username" - {
        "when testing if it has a minimum length" - {
            "should pass if the username has the minimum length" {
                checkAll(
                    Arb.int(0..10).flatMap { length ->
                        Arb.usernames()
                            .filter { it.value.length >= length }
                            .map { it.value }
                            .map { length to Username(it) }
                    }
                ) { (length, username) ->
                    username shouldHaveMinimumLength length
                }
            }

            "should fail if the username does not have the minimum length" {
                checkAll(
                    Arb.usernames().flatMap { username ->
                        Arb.int(username.value.length + 1..100)
                            .map { it to Username(username.value) }
                    }
                ) { (length, username) ->
                    shouldThrow<AssertionError> {
                        username shouldHaveMinimumLength length
                    }
                }
            }
        }
    }
})
```
</TabItem>
</BoxedTabs>

<Explanation>
    - **Generaci√≥n de valores aleatorios**: Creamos nombres de usuario aleatorios con diferentes longitudes para validar el matcher.
    - **Uso de `shouldHaveMinimumLength`**: La funci√≥n infija se emplea para verificar f√°cilmente si un nombre de usuario cumple con la longitud m√≠nima.
    - **Manejo de excepciones**: Cuando un nombre de usuario no cumple con la longitud m√≠nima, el test lanza una excepci√≥n como se espera.
</Explanation>

### üìä Beneficios y Limitaciones de las Expresiones Infijas

<ProCons>
    <Pros>
        - **Mayor legibilidad**: Las expresiones infijas hacen que el c√≥digo sea m√°s intuitivo y f√°cil de leer, especialmente en casos como pruebas o DSLs, donde se busca un lenguaje natural y expresivo.
        - **Ideal para operadores personalizados**: Facilitan la creaci√≥n de operadores personalizados que se comporten de manera similar a los operadores incorporados, sin necesidad de sobrecargar operadores preexistentes.
        - **Compatibilidad con librer√≠as de pruebas**: En bibliotecas de pruebas como Kotest, las expresiones infijas mejoran la claridad y comprensi√≥n de los casos de prueba al representar directamente el comportamiento esperado.
        - **Simplicidad en la implementaci√≥n**: Implementar una funci√≥n infija solo requiere cumplir algunas reglas simples, permitiendo a quien desarrolla a personalizar operaciones sin complicaciones adicionales.
        - **Facilita la escritura de DSLs en Kotlin**, donde se busca una sintaxis cercana al lenguaje natural.
        - **Reduce la necesidad de sobrecargar operadores**, permitiendo definir funciones con una sintaxis m√°s expresiva.
    </Pros>
    <Cons>
        - **Limitaciones en par√°metros**: Las funciones infijas solo aceptan un par√°metro, lo que limita su aplicabilidad a casos espec√≠ficos y podr√≠a no ser suficiente en operaciones que requieren varios argumentos.
        - **Ambig√ºedad potencial**: En situaciones complejas, las expresiones infijas pueden introducir ambig√ºedad en la precedencia de operaciones, especialmente cuando se combinan m√∫ltiples expresiones infijas en una sola l√≠nea.
        - **Menor reusabilidad en ciertos contextos**: Dado que est√°n pensadas para operaciones simplificadas y expresivas, las funciones infijas pueden no ser ideales para l√≥gica compleja o de m√∫ltiples pasos.
        - **Puede hacer el c√≥digo menos predecible** si se abusa de ellas sin una convenci√≥n clara.
        - **Menor compatibilidad con Java**, ya que las funciones infijas no son idiom√°ticas en otros lenguajes de la JVM.
    </Cons>
</ProCons>

## üìå **Conclusiones**  

Las **expresiones infijas** en Kotlin son una herramienta poderosa que permite escribir c√≥digo m√°s expresivo y legible, eliminando la necesidad de par√©ntesis y puntos en ciertas operaciones. A lo largo de esta lecci√≥n, exploramos sus **beneficios**, **limitaciones** y **casos de uso**, con √©nfasis en su aplicaci√≥n en **DSLs y frameworks de pruebas** como **Kotest**.

### üîë **Puntos clave**  

1. **Expresividad y legibilidad mejorada**  
   - Las expresiones infijas permiten escribir c√≥digo m√°s cercano al lenguaje natural, lo que mejora su comprensi√≥n y mantenimiento.  
   - Son especialmente √∫tiles en **DSLs**, **frameworks de pruebas** y **APIs declarativas**.  
2. **Uso en Kotest y DSLs**  
   - En **pruebas unitarias**, las expresiones infijas ayudan a escribir assertions m√°s claras, como:  
     ```kotlin
     username shouldHaveMinimumLength 5
     ```
   - Esto mejora la **legibilidad** y hace que las pruebas sean m√°s autoexplicativas en comparaci√≥n con llamadas de funci√≥n tradicionales.  
3. **Reglas y limitaciones**  
   - Una funci√≥n infija **debe ser miembro o extensi√≥n de una clase**, aceptar **un solo par√°metro** y **no tener valores predeterminados**.  
   - **No se recomienda su uso excesivo**, ya que pueden hacer el c√≥digo menos predecible si no se utilizan con claridad.  
4. **Precedencia y ambig√ºedad**  
   - **Las expresiones infijas pueden generar ambig√ºedad** cuando se combinan con operadores matem√°ticos u otras funciones infijas.  
   - Se recomienda **usar par√©ntesis** para evitar confusi√≥n en expresiones compuestas:
     ```kotlin
     val result = (3 + 5) multiplyBy 2  // Sin ambig√ºedad
     ```
5. **Comparaci√≥n con funciones tradicionales**  
   - Aunque mejoran la fluidez del c√≥digo, **no siempre son la mejor opci√≥n**.  
   - Para casos en los que **se necesiten m√∫ltiples par√°metros**, es preferible una funci√≥n est√°ndar.  

### ‚úÖ **Reflexi√≥n final**  

Las expresiones infijas ofrecen una **sintaxis elegante** que hace el c√≥digo m√°s legible en contextos adecuados, como **DSLs** y **frameworks de pruebas**. Sin embargo, **deben usarse con criterio**, evitando ambig√ºedades y asegurando que realmente aporten claridad al c√≥digo.  

En proyectos donde la expresividad es clave, como **bibliotecas de pruebas o APIs de alto nivel**, las funciones infijas pueden hacer una diferencia significativa en la calidad del c√≥digo.

Understanding Kotlin Infix Functions: A Detailed Guide. (s.¬†f.). Recuperado 18 de marzo de 2025, de https://www.dhiwise.com/post/understanding-kotlin-infix-functions-a-beginners-guide

<References references={[
     
]} additionalReferences={[
    {
        title: "Understanding Kotlin Infix Functions: A Detailed Guide",
        url: "https://www.dhiwise.com/post/understanding-kotlin-infix-functions-a-beginners-guide",
        type: "article",
        author: "Pratik Chothani",
        publishedDate: "25 de septiembre de 2024"
    },
]}/>

<div className="language-card-container">
    <ScalaCard link="/docs/oop/infix/scala" />
</div>
