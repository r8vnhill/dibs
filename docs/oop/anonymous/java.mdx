---
title: Tipos anónimos en Java
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="java-dibs" />

En Java, una **clase anónima** se utiliza para crear una instancia de una clase sin definir una subclase formal. A diferencia de Kotlin, donde los **object expressions** permiten definir propiedades y métodos en un solo paso, en Java es común que las clases anónimas implementen interfaces o extiendan clases abstractas y se usen principalmente para implementar un solo método o realizar pequeñas modificaciones de comportamiento.

## Ejemplo en Java

Para ilustrar el uso de clases anónimas en Java, pensemos en un escenario similar al ejemplo en Kotlin, en el que implementamos un validador de correos electrónicos y contraseñas. En Java, necesitaríamos escribir la implementación anónima de la interfaz para cada validador:

```java
Validator<String> emailValidator = new Validator<String>() {
    @Override
    public boolean validate(String value) {
        return value.contains("@") && value.contains(".");
    }
};

Validator<String> passwordValidator = new Validator<String>() {
    @Override
    public boolean validate(String value) {
        return value.length() >= 8;
    }
};
```

<Explanation>
    En este caso, Java crea una instancia anónima para cada validador. Aunque el uso es similar, es menos flexible que los **object expressions** de Kotlin, ya que no permite definir propiedades directamente en la clase anónima.
</Explanation>

## Diferencias clave entre Kotlin y Java

| **Característica** | **Kotlin (Object Expressions)** | **Java (Clases Anónimas)** |
|--------------------|---------------------------------|----------------------------|
| **Definición directa de propiedades** | Permite agregar propiedades y métodos directamente dentro del objeto anónimo. | No permite definir nuevas propiedades dentro de la clase anónima; únicamente métodos. |
| **Extensión múltiple de interfaces** | Puede implementar múltiples interfaces. | Sólo permite extender una clase o implementar una interfaz. |
| **Uso en funciones** | Fácil de usar en funciones y lambdas, ofreciendo más flexibilidad en programación funcional. | Las clases anónimas de Java son menos adecuadas para funciones de orden superior debido a su estructura. |

## Beneficios y limitaciones de los tipos anónimos en Java

**Beneficios:**
- **Encapsulación rápida**: Las clases anónimas permiten encapsular comportamientos específicos sin necesidad de definir nuevas clases.
- **Compatibilidad con interfaces y clases abstractas**: Facilitan la implementación de interfaces o la extensión de clases abstractas en casos específicos.

**Limitaciones:**
- **Rigidez**: Las clases anónimas en Java no pueden definir propiedades adicionales y están limitadas a una sola clase o interfaz, lo que las hace menos flexibles que los **object expressions** de Kotlin.
- **Dificultad de lectura**: El uso excesivo de clases anónimas puede hacer que el código sea más difícil de leer y mantener.

## Conclusión

Si bien tanto Kotlin como Java permiten definir tipos anónimos, la flexibilidad de los **object expressions** en Kotlin permite una mayor modularidad y reutilización de código, especialmente en escenarios de pruebas o validaciones. En cambio, Java, al no permitir la definición directa de propiedades en clases anónimas, es menos adecuado para escenarios donde se necesita una mayor personalización de los objetos temporales.