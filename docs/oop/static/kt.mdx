---
title: Variables y funciones estáticas
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

<details>
    <summary>
        Comencemos por crear un módulo para la lección...
    </summary>

    ```kotlin showLineNumbers title=""
    ```

    Preocupate de que el plugin `static` esté aplicado en el archivo `build.gradle.kts` del módulo principal.

    ```bash
    ./gradlew
    ```

    Recuerda agregar el nuevo módulo al archivo `settings.gradle.kts`.
</details>

En el desarrollo de **bibliotecas de software**, es común utilizar variables y funciones que no dependen de instancias específicas de una clase. Estas variables y funciones son conocidas como **estáticas**. En esta lección, exploraremos cómo manejar variables y funciones estáticas en Kotlin.

<Definition title='Funciones estáticas'>
    Una **función estática** es una función que:

    - **Pertenece a la clase**, no a una instancia de la clase.
    - **Puede ser invocada sin crear una instancia** de la clase.
    - **No tiene acceso** a los miembros de instancia (no puede acceder a `this`).
    - **Comparte el mismo espacio de memoria** para todas las instancias de la clase.
</Definition>

Este concepto es común en muchos lenguajes de programación y es especialmente útil en bibliotecas de software donde se necesitan funciones utilitarias o constantes que deben ser accesibles globalmente.

Aquí te dejo un ejemplo más sencillo y fácil de testear utilizando funciones de nivel superior, que puedes aplicar en una biblioteca de software.

## Funciones de Nivel Superior en Kotlin

En Kotlin, podemos declarar **funciones y variables de nivel superior** fuera de cualquier clase o interfaz. En el contexto de una biblioteca de software, esto permite definir utilidades que están disponibles sin necesidad de una clase contenedora. 

Veamos un ejemplo de una función simple para calcular el área de un rectángulo.

Aquí tienes una versión mejorada, con una explicación sobre cómo calcular el área de un rectángulo mediante la multiplicación es conceptualmente equivalente a contar unidades dentro de ese rectángulo:

### Especificación BDD

Calcular el área de un rectángulo multiplicando su ancho por su altura es conceptualmente equivalente a contar las unidades (como cuadrados o píxeles) que caben dentro de ese rectángulo. 

Imagina que el rectángulo está dividido en una cuadrícula, donde cada celda representa una unidad de área. Multiplicar el ancho por la altura te da el número total de estas unidades, porque:

- **El ancho** representa cuántas unidades caben en una fila.
- **La altura** representa cuántas filas de estas unidades hay.

Por lo tanto, multiplicar el ancho por la altura te da el número total de unidades que llenan el rectángulo, lo cual es el área.

Dado esto, podemos escribir una especificación BDD para la función `calculateRectangleArea`:

```kotlin showLineNumbers
"Given a rectangle" - {
    "when calculating its area" - {
        "should return the same result as counting the units" {}
    }
}
```

### Implementación de las pruebas

Ahora vamos a implementar las pruebas para nuestra especificación BDD. Utilizaremos **Property-Based Testing** para generar diferentes valores de `width` y `height` de forma aleatoria y asegurar que la función `calculateRectangleArea` devuelve los resultados correctos al compararlos con una implementación alternativa.

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        checkAll(
            Arb.positiveInt(100),
            Arb.positiveInt(100)
        ) { width, height ->
            calculateRectangleArea(width, height) shouldBe
                    countAreaOnGrid(width, height)
        }
        ```

        <Tabs>
            <TabItem label={"Implementación iterativa"} value={"Implementación iterativa"}>
                ```kotlin showLineNumbers
                private fun countAreaOnGrid(width: Int, height: Int): String {
                    var count = 0
                    for (i in 1..width) {
                        for (j in 1..height) {
                            count++
                        }
                    }
                    return "$count cm²"
                }
                ```
            </TabItem>
            <TabItem label={"Implementación funcional"} value={"Implementación funcional"}>
                ```kotlin showLineNumbers
                private fun countAreaOnGrid(width: Int, height: Int) = (1..width)
                    .sumOf { _ ->
                        (1..height).count()
                    }.let { "$it cm²" }
                ```
            </TabItem>
        </Tabs>
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="src/test/kotlin/com/github/username/staticfn/rectangle/RectangleAreaTest.kt"
        package com.github.username.staticfn.rectangle

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.positiveInt
        import io.kotest.property.checkAll

        class RectangleAreaTest : FreeSpec({
            "Given a rectangle" - {
                "when calculating its area" - {
                    "it should return the correct result based on counting units" {
                        checkAll(
                            Arb.positiveInt(100),
                            Arb.positiveInt(100)
                        ) { width, height ->
                            calculateRectangleArea(width, height) shouldBe
                                    countAreaOnGrid(width, height)
                        }
                    }
                }
            }
        })

        private fun countAreaOnGrid(width: Int, height: Int) = (1..width)
            .sumOf { _ ->
                (1..height).count()
            }.let { "$it cm²" }
        ```
    </TabItem>
</Tabs>

### Implementación de la función

Finalmente, implementamos la función `calculateRectangleArea` que calcula el área de un rectángulo multiplicando su `width` por su `height` y agregando la unidad de medida:

```kotlin showLineNumbers title="src/main/kotlin/com/github/username/staticfn/rectangle/RectangleUtils.kt"
package cl.ravenhill.staticfn.rectangle

const val DEFAULT_UNIT = "cm²"

fun calculateRectangleArea(width: Int, height: Int) = 
    "${width * height} $DEFAULT_UNIT"
```

Aunque en Kotlin las funciones de nivel superior no están asociadas a una clase en el código fuente, el compilador genera una **clase contenedora estática** para cada archivo que contiene funciones de este tipo. Esto significa que, a nivel de bytecode de la JVM, las funciones de nivel superior se convierten efectivamente en **métodos estáticos**. Esto les permite ser accesibles sin necesidad de instanciar una clase, de manera similar a los métodos estáticos en lenguajes como Java.

<details>
    <summary>
        Invocar la función `calculateRectangleArea` desde Java
    </summary>
    
    Si necesitas invocar la función `calculateRectangleArea` desde Java, puedes hacerlo de la siguiente manera:

    ```java
    import com.github.username.staticfn.rectangle.RectangleUtils;

    public class Main {
        public static void main(String[] args) {
            var width = 10;
            var height = 5;
            String area = RectangleUtilsKt.calculateRectangleArea(width, height);
            System.out.println("Area: " + area);
        }
    }
    ```
</details>

## Objects en Kotlin

Kotlin introduce el concepto de `object`, que permite crear **singletons** de manera sencilla. Un `object` es una declaración que combina la definición de una clase y su instancia en una sola expresión.

En el contexto de una biblioteca, un `object` puede ser útil para agrupar funciones y variables relacionadas. Vamos a ver un ejemplo sencillo usando una lista de tareas (**to-do list**):

### Especificación BDD

Vamos a definir una especificación BDD para un `TaskManager` que gestiona una lista de tareas. La especificación describe cómo agregar tareas, obtener todas las tareas y limpiar la lista de tareas.

```kotlin showLineNumbers
"A task manager" - {
    "when adding tasks" - {
        "should be able to get all tasks" {}
    }

    "when clearing tasks" - {
        "should have an empty task list" {}
    }
}
```

### Implementación de las pruebas

Vamos a implementar las pruebas para nuestra especificación BDD. Utilizaremos **Property-Based Testing** para generar diferentes tareas de forma aleatoria y asegurar que el `TaskManager` devuelve los resultados correctos al agregar tareas y limpiar la lista.

Es importante siempre tratar de utilizar casos realistas en tus pruebas, ya que esto te permitirá validar el comportamiento de tu código en situaciones reales. Por esto, utilizaremos como ejemplo una lista de compras, para esto podemos utilizar el generador `products: Arb.() -> Arb<Product>`.

<Tabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        checkAll(Arb.list(arbTask())) { tasks ->
            tasks.forEach { TaskManager += it }
            TaskManager.tasks shouldBe tasks
        }
        ```

        ```kotlin showLineNumbers
        checkAll(Arb.list(arbTask())) { tasks ->
            tasks.forEach { TaskManager += it }
            TaskManager.clear()
            TaskManager.tasks shouldBe emptyList()
        }
        ```

        ```kotlin showLineNumbers
        private fun arbTask(): Arb<Task<Product>> = Arb.products()
            .map { product -> Task(product) }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="static/src/test/kotlin/com/github/usernamestaticfn/tasks/TaskManagerTest.kt"
        package com.github.username.staticfn.tasks

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.list
        import io.kotest.property.arbitrary.map
        import io.kotest.property.arbs.products.Product
        import io.kotest.property.arbs.products.products
        import io.kotest.property.checkAll

        class TaskManagerTest : FreeSpec({
            "A task manager" - {
                "when adding tasks" - {
                    "should be able to get all tasks" {
                        checkAll(Arb.list(arbTask())) { tasks ->
                            tasks.forEach { TaskManager += it }
                            TaskManager.tasks shouldBe tasks
                        }
                    }
                }

                "when clearing tasks" - {
                    "should have an empty task list" {
                        checkAll(Arb.list(arbTask())) { tasks ->
                            tasks.forEach { TaskManager += it }
                            TaskManager.clear()
                            TaskManager.tasks shouldBe emptyList()
                        }
                    }
                }
            }
        })

        private fun arbTask(): Arb<Task<Product>> = Arb.products()
            .map { product -> Task(product) }

        ```
    </TabItem>
</Tabs>


### Implementación de `TaskManager`

Ahora vamos a implementar el `TaskManager` que gestiona una lista de tareas. Aquí tienes una implementación básica de `TaskManager`:

```kotlin showLineNumbers title="static/src/main/kotlin/com/github/username/staticfn/tasks/Task.kt"
package com.github.username.staticfn.tasks

class Task<out T>(val value: T)
```

```kotlin showLineNumbers title="static/src/main/kotlin/com/github/username/staticfn/tasks/TaskManager.kt"
package com.github.username.staticfn.tasks

object TaskManager {
    private val _tasks = mutableListOf<Task<*>>()

    val tasks: List<Task<*>>
        get() = _tasks.toList()

    operator fun plusAssign(task: Task<*>) {
        _tasks += task
    }

    fun clear() {
        _tasks.clear()
    }
}
```

<Explanation>
    - En esta implementación, `TaskManager` es un `object` que contiene una lista mutable de tareas `_tasks`.
    - La función `plusAssign` (`+=`) permite agregar tareas a la lista.
    - La función `clear` elimina todas las tareas de la lista.
    - La propiedad `tasks` devuelve una copia inmutable de la lista de tareas.
</Explanation>

Implementar un **singleton** en Kotlin utilizando un `companion object` es innecesario, ya que Kotlin proporciona una forma más sencilla y directa para este patrón a través de los **`object`**. En lugar de hacer esto, exploremos un caso donde los **companion objects** realmente brillan: **creación de instancias con lógica adicional o funciones de fábrica**.

## Companion Objects

En Kotlin, un **companion object** es un bloque dentro de una clase que permite definir miembros asociados a la clase en sí, en lugar de a instancias de la clase. Esto es útil cuando necesitas lógica adicional para crear objetos o tener funciones relacionadas con la clase pero que no dependan de una instancia específica.

Supongamos que estamos construyendo una clase `User` y queremos controlar la creación de instancias mediante una función de fábrica que verifica si los datos son válidos.

### Especificación BDD

Comencemos definiendo una especificación BDD para la clase `User`. La especificación describe cómo crear un usuario con un nombre y una edad válidos.

```kotlin showLineNumbers
"Given a user" - {
    "when creating it with a valid age" - {
        "should be created" {}
    }
    "when creating it with an invalid age" - {
        "should throw an exception" {}
    }
}
```
```kotlin showLineNumbers
// En el archivo User.kt
package com.example.user

class User private constructor(val name: String, val age: Int) {
    companion object {
        fun create(name: String, age: Int): User? {
            return if (age >= 18) {
                User(name, age)
            } else {
                null // No se permite crear un usuario menor de edad
            }
        }
    }
}
```

Aquí, el **companion object** define una función `create`, que es una **función de fábrica**. Verifica la edad del usuario antes de crear una instancia de `User`. 

Puedes acceder a esta función de fábrica directamente a través del nombre de la clase, sin instanciar `User`:

```kotlin showLineNumbers
import com.example.user.User

fun main() {
    val user = User.create("Alice", 20)
    println(user?.name) // Imprime: Alice

    val underageUser = User.create("Bob", 16)
    println(underageUser) // Imprime: null, ya que no se permite la creación
}
```

### ¿Por qué usar `companion object`?

En este caso, **companion object** permite asociar la función `create` con la clase `User`, ofreciendo una forma limpia y controlada de crear instancias de `User` con validaciones. 

**Ventajas**:
- **Funciones de fábrica**: Permite controlar cómo se crean los objetos.
- **Acceso a miembros estáticos**: Puedes agrupar funciones o constantes relacionadas con la clase sin depender de instancias.

Este enfoque es más común que implementar un singleton manualmente, ya que se ajusta mejor a los casos en los que se necesita lógica adicional para instanciar clases.

## Comparación entre Funciones de Nivel Superior, `object` y `companion object`

| **Característica**               | **Funciones de Nivel Superior**                                              | **Object**                                          | **Companion Object**                                    |
|----------------------------------|-------------------------------------------------------------------------------|-----------------------------------------------------|---------------------------------------------------------|
| **Asociación**                   | No asociadas a ninguna clase                                                 | Singleton global                                     | Asociadas a una clase específica                         |
| **Acceso**                       | Se acceden directamente mediante importaciones                               | Se acceden usando el nombre del `object`             | Se acceden usando el nombre de la clase                  |
| **Uso Común**                    | Funciones y variables utilitarias generales                                  | Agrupar funciones y variables relacionadas globalmente | Funciones y variables estáticas relacionadas con la clase |
| **Necesidad de Instanciación**   | No requieren instanciación                                                   | No requieren instanciación                           | No requieren instanciación                               |
| **Visibilidad de Clase Interna** | No pueden acceder a miembros privados de una clase                           | Pueden acceder a sus propios miembros privados       | Pueden acceder a miembros privados de la clase           |

## Beneficios y Limitaciones

<ProCons>
    <Pros>
        - **Organización del Código**: Permiten estructurar y organizar funciones y variables de manera lógica, mejorando la legibilidad y mantenibilidad del código.
        - **Simplicidad de Acceso**: No es necesario instanciar objetos para acceder a las funciones o variables, lo que facilita su uso en diferentes partes del programa.
        - **Encapsulación**: Con `companion object`, puedes encapsular lógica estática dentro de una clase específica, manteniendo una relación clara entre la clase y sus funciones estáticas.
        - **Singletones Sencillos**: Los `object` facilitan la creación de singletones sin necesidad de patrones adicionales o código complejo.
    </Pros>
    <Cons>
        - **Carga Inicial**: Las variables estáticas pueden aumentar el tiempo de carga inicial de la aplicación si se inicializan muchas al inicio.
        - **Limitaciones en Herencia**: Los `object` no pueden heredar de clases que no sean abstractas o interfaces, lo que puede limitar su flexibilidad en ciertos diseños.
        - **Posibles Confusiones**: Para desarrolladores acostumbrados a otros lenguajes, el uso de `object` y `companion object` puede ser confuso inicialmente, requiriendo una adaptación en la comprensión de estos conceptos.
        - **Escalabilidad**: El uso excesivo de funciones de nivel superior puede llevar a archivos muy grandes y menos estructurados si no se organizan adecuadamente.
    </Cons>
</ProCons>

## ¿Qué Aprendimos?

En esta lección, exploramos cómo manejar variables y funciones estáticas en Kotlin, especialmente en el contexto de **bibliotecas de software**. Vimos que:

- Las **funciones de nivel superior** permiten definir utilidades generales que pueden ser usadas en cualquier parte del código sin necesidad de una clase contenedora. Aunque no se declaran dentro de una clase, el compilador las trata como estáticas, generando una clase contenedora para ellas.
- Los **objects** son útiles para agrupar funciones y variables en un singleton, facilitando el acceso global y la organización del código.
- Los **companion objects** permiten asociar funciones y variables estáticas a una clase específica, manteniendo una relación estrecha y permitiendo acceder a miembros privados de la clase.
- En todos los casos, Kotlin proporciona formas flexibles y eficientes de manejar funciones y variables estáticas, adaptándose a diferentes necesidades de diseño y facilitando el desarrollo de bibliotecas reutilizables y mantenibles.

Este conocimiento es esencial para diseñar bibliotecas de software efectivas en Kotlin, aprovechando sus características para organizar y acceder a funciones y variables de manera óptima, y entendiendo cómo el lenguaje maneja estos conceptos a nivel de compilación y ejecución.
