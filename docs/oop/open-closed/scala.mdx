---
title: Clases abiertas y cerradas en Scala
---

import ReadingTime from "@site/src/components/ReadingTime";
import { ProCons, Pros, Cons } from "@site/src/components/cajitas/ProCons";
import References from "@site/src/components/ReferencesComponent";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Exercise from "@site/src/components/exercise/Exercise";
import Solution from "@site/src/components/exercise/Solution";
import Hint from "@site/src/components/exercise/Hint";
import Definition from "@site/src/components/Definition";
import Corollary from "@site/src/components/Corollary";
import GithubRepoLink from "@site/src/components/git/GithubRepoLink";
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="scala-dibs" />

En **Scala**, las clases pueden ser abiertas o cerradas, y su control de herencia presenta diferencias clave respecto a **Kotlin**. Mientras que en **Scala** las clases son abiertas por defecto, en **Kotlin** deben marcarse expl√≠citamente como `open`. A lo largo de esta lecci√≥n, exploraremos c√≥mo Scala maneja la herencia y el uso de `final` para restringir modificaciones.
 
## üìå Clases Finales üîí

En **Scala**, todas las clases son abiertas por defecto, lo que significa que pueden ser heredadas a menos que se marquen expl√≠citamente como **`final`**.  
Esto es diferente de **Kotlin**, donde las clases son cerradas de manera predeterminada y se deben marcar como `open` para permitir la herencia.

```scala showLineNumbers
final class DatabaseConnection private (
    val url: String, 
    val user: String, 
    val password: String
)
```
En este ejemplo, `DatabaseConnection` est√° marcada como `final`, lo que impide su herencia. Esto garantiza que su implementaci√≥n permanezca inmutable y protegida contra modificaciones accidentales.

## üèóÔ∏è Clases Abstractas

Las **clases abstractas** en Scala, al igual que en Kotlin, son siempre abiertas. Esto significa que pueden ser heredadas sin necesidad de marcar expl√≠citamente la clase como abierta. Esto es consistente en ambos lenguajes, ya que las clases abstractas est√°n dise√±adas para ser extendidas.

## üöß Restricci√≥n de sobrescritura con `final`

En **Scala**, los m√©todos son sobrescribibles por defecto, pero se pueden marcar con `final` para evitar que sean modificados en subclases. Esto es similar a **Kotlin**, donde los m√©todos son cerrados por defecto y deben marcarse como `open` para ser sobrescribibles.

```scala showLineNumbers
class ExampleClass {
  final def calculate: Int = 42
}
```

<Explanation>
  Aqu√≠, `calculate` es `final`, lo que impide su sobrescritura.
</Explanation>

#### üõ†Ô∏è M√©todos `final` en `traits`

Una particularidad de **Scala** es que permite definir m√©todos `final` dentro de un **`trait`**, algo que no es posible en **Kotlin**.

```scala showLineNumbers
trait Logger {
  final def log(message: String): Unit = 
    println(s"LOG: $message")
}
```

<Explanation>
  En este ejemplo, cualquier clase que implemente `Logger` debe utilizar la implementaci√≥n de `log` sin posibilidad de modificarla.
</Explanation>

## ‚öñÔ∏è Comparaci√≥n Final

| **Caracter√≠stica**              | **Scala**                                                                                                                  | **Kotlin**                                                                                                                 |
|--------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|
| **Clases abiertas por defecto** | S√≠. Se deben marcar como `final` para evitar herencia.   | No. Se deben marcar como `open` para permitir herencia.  |
| **M√©todos sobrescribibles**     | S√≠, salvo que sean `final`.                             | No, salvo que sean `open`.                              |
| **Clases abstractas**           | Siempre abiertas.                                       | Siempre abiertas.                                       |
| **Miembros `final` en traits**  | S√≠, permite definir m√©todos `final` en `traits`.        | No, no se pueden definir m√©todos `final` en interfaces. |       |

### ‚úÖ Beneficios y Limitaciones ‚ö†Ô∏è

<ProCons>
    <Pros>
        - **Flexibilidad en Traits**: Scala permite marcar m√©todos en `traits` como `final`, asegurando que ciertas implementaciones permanezcan inmutables. Esto proporciona un nivel adicional de control y consistencia en el dise√±o de interfaces, lo cual es beneficioso para proteger comportamientos cr√≠ticos.
        - **Compatibilidad con Java**: Dado que Scala se dise√±√≥ para interoperar con Java, su enfoque abierto en clases y m√©todos mantiene una mayor compatibilidad con bibliotecas y frameworks de Java, permitiendo un uso m√°s fluido de componentes ya existentes en el ecosistema de Java.
        - **Control Preciso**: Al poder marcar clases y m√©todos como `final` o dejarlos abiertos por defecto, Scala proporciona una gran flexibilidad para que las personas desarrolladoras decidan expl√≠citamente d√≥nde permitir la herencia, adaptando el dise√±o a las necesidades espec√≠ficas del proyecto.
    </Pros>
    <Cons>
        - **Riesgo de Herencia Accidental**: Debido a que las clases en Scala son abiertas por defecto, hay un mayor riesgo de herencia accidental si quienes desarrollan no son cuidadosos en marcar las clases y m√©todos cr√≠ticos como `final`, lo que puede conducir a problemas de dise√±o en proyectos grandes o colaborativos.
        - **Menos Restricciones en Interfaces Comparado con Kotlin**: Aunque Scala permite m√°s flexibilidad en `traits`, la falta de restricciones m√°s estrictas en sus interfaces (en comparaci√≥n con Kotlin) podr√≠a dar lugar a API menos seguras y a un dise√±o menos robusto si no se aplica un control adecuado.
    </Cons>
</ProCons>

## üìå **Conclusiones**  

En esta lecci√≥n, exploramos las diferencias clave en el manejo de clases abiertas y cerradas en **Scala** y **Kotlin**, as√≠ como el impacto de `final` en clases, m√©todos y traits.

### **üîë Puntos clave**  

1. **Clases abiertas y cerradas**  
   - **Scala**: Las clases son **abiertas por defecto** y deben marcarse como `final` para evitar la herencia.  
   - **Kotlin**: Las clases son **cerradas por defecto** y deben marcarse como `open` para permitir la herencia.  
2. **M√©todos y sobrescritura**  
   - En **Scala**, los m√©todos son sobrescribibles por defecto, pero se pueden marcar con `final` para evitar modificaciones.  
   - En **Kotlin**, los m√©todos son cerrados por defecto y deben marcarse como `open` para ser sobrescribibles.  
3. **Clases abstractas**  
   - Tanto en **Scala** como en **Kotlin**, las clases abstractas son **abiertas por naturaleza**, ya que est√°n dise√±adas para ser heredadas.  
4. **Miembros `final` en traits**  
   - Scala permite definir m√©todos `final` dentro de **traits**, asegurando que no puedan ser modificados en clases que los implementen.  
   - En **Kotlin**, las interfaces no permiten definir miembros `final`, lo que limita la capacidad de proteger implementaciones en este contexto.  

### **üöÄ Reflexi√≥n final**  

El manejo de herencia en **Scala** y **Kotlin** sigue filosof√≠as distintas:  
- **Scala** brinda mayor flexibilidad, pero requiere m√°s atenci√≥n para evitar herencia accidental.  
- **Kotlin** opta por una estrategia m√°s restrictiva por defecto, favoreciendo la seguridad y el dise√±o estable.  

Ambos enfoques tienen ventajas y desventajas, por lo que elegir entre ellos depender√° de las necesidades del proyecto y del nivel de control que se quiera tener sobre la herencia y la sobrescritura de m√©todos.

<References references={[
  {
      title: "Scala | Final",
      url: "https://www.geeksforgeeks.org/scala-final/",
      accessedDate: "8 de octubre de 2024",
      type: "web",
  },
]}/>
