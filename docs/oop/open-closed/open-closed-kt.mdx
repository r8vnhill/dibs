---
title: Clases abiertas y cerradas para herencia
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard, JavaCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="object-oriented-programming-kt" />

<ModuleSetup module='open-closed' task='setupOpenClosedModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupOpenClosedModule") {
        group = "setup"
        description = "Creates the necessary files for the lesson on open/closed classes."
        module = "open-closed"
        doLast {
            createFiles(
                "database",
                main to "DatabaseConnection.kt",
                main to "EncryptedDatabaseConnection.kt",
            )
        }
    }
    ```
</ModuleSetup>

Cuando dise√±amos una biblioteca de software, debemos tomar decisiones conscientes sobre qu√© partes de nuestro c√≥digo deber√≠an poder extenderse y cu√°les no. Permitir herencia sin restricciones puede facilitar la reutilizaci√≥n, pero tambi√©n puede volver nuestro c√≥digo m√°s fr√°gil y dif√≠cil de mantener, especialmente si otros proyectos dependen de nuestras clases base.

Kotlin aborda este problema con una decisi√≥n de dise√±o simple pero poderosa: **las clases y m√©todos son cerrados por defecto**. Esto significa que no pueden ser heredados ni sobrescritos a menos que lo autoricemos expl√≠citamente usando el modificador `open`. Este enfoque ayuda a prevenir errores comunes asociados con la herencia no controlada, promoviendo un dise√±o m√°s robusto y seguro.

En esta lecci√≥n, veremos c√≥mo aplicar esta idea en la pr√°ctica para **proteger la estabilidad de nuestras bibliotecas** sin sacrificar la extensibilidad cuando sea necesaria. Exploraremos el problema de la base fr√°gil, aprenderemos a usar `open` de forma controlada, y discutiremos los beneficios y limitaciones de esta estrategia en el contexto del dise√±o de APIs.

## üß® Problema de la base fr√°gil

Cuando desarrollamos una biblioteca de software, es crucial minimizar el riesgo de introducir cambios que afecten negativamente a quienes consumen la API. El **problema de la base fr√°gil** ocurre cuando una clase base es modificada sin considerar las dependencias de sus subclases, lo que puede provocar errores o romper funcionalidades inesperadamente. Este riesgo es especialmente alto en bibliotecas utilizadas por m√∫ltiples proyectos, donde cada actualizaci√≥n debe ser cuidadosamente planificada y documentada.

Joshua Bloch, en su libro *Effective Java*, ofrece una recomendaci√≥n clave para el dise√±o de bibliotecas:

> "Dise√±a y documenta pensando en la herencia, o de lo contrario, proh√≠bela."

Esta idea sugiere que, al desarrollar una biblioteca, deber√≠as **dise√±ar y documentar expl√≠citamente** aquellas clases y m√©todos que se espera que sean heredados o sobrescritos por lxs usuarixs. Si no puedes garantizar un comportamiento predecible al extenderlos, lo m√°s seguro es **prohibir su herencia**.

Este enfoque est√° directamente alineado con el **principio Open/Closed**, que establece que *una clase debe estar abierta para extensi√≥n pero cerrada para modificaci√≥n*. Es decir, deber√≠amos permitir que el comportamiento pueda extenderse sin tener que alterar el c√≥digo fuente original. Para lograr esto de forma segura, es necesario definir con claridad qu√© partes de una clase pueden extenderse y cu√°les deben permanecer estables.

Al aplicar este principio, reducimos el riesgo de romper contratos impl√≠citos con lxs usuarixs de nuestra biblioteca y favorecemos un dise√±o m√°s robusto, mantenible y predecible.

### üí• Ejemplo de base fr√°gil

Supongamos que una biblioteca escrita en Scala define la siguiente clase:

```scala showLineNumbers
class Document:
  def render(): String = "Rendering base document"
```

Unx usuarix de la biblioteca decide extenderla:

```scala showLineNumbers
class Invoice extends Document:
  override def render(): String = "Rendering invoice"
```

M√°s adelante, lxs autores de la biblioteca actualizan `Document` para agregar l√≥gica interna importante:

```scala showLineNumbers
class Document:
  def render(): String =
    val header = renderHeader()
    val body = renderBody()
    s"$header\n$body"

  protected def renderHeader(): String = "Header"
  protected def renderBody(): String = "Body"
```

:::danger L√≥gica omitida inesperadamente

La clase `Invoice` contin√∫a sobrescribiendo `render()` sin enterarse de los cambios, **omitiendo por completo** la nueva l√≥gica introducida por la biblioteca. Esto rompe expectativas, puede producir errores sutiles y hace que el comportamiento del sistema sea menos predecible.

:::

## üß∑ Clases abiertas y cerradas en Kotlin

En Kotlin, las clases son **cerradas por defecto**, lo que representa una gran ventaja al dise√±ar bibliotecas. Esto significa que, a menos que marques expl√≠citamente una clase o m√©todo como `open`, **no podr√°n ser heredados ni sobrescritos**. As√≠, se evita que lxs usuarixs modifiquen su comportamiento sin tu consentimiento, lo cual ayuda a proteger la integridad del c√≥digo y prevenir el problema de la base fr√°gil.

### üìò Ejemplo de uso

Supongamos que est√°s desarrollando una biblioteca para manejar **conexiones a bases de datos**. Tienes una clase base `DatabaseConnection` que define c√≥mo abrir y cerrar una conexi√≥n. Quieres permitir que otras clases especializadas puedan **personalizar ciertos aspectos del comportamiento**, pero sin comprometer la l√≥gica cr√≠tica.

#### Clase `DatabaseConnection` (abierta para herencia controlada)

```kotlin showLineNumbers title="open-closed/src/main/kotlin/com/github/username/database/DatabaseConnection.kt"
package com.github.username.database

open class DatabaseConnection(protected val url: String) {

    fun startConnection() = println("Connecting to $url")

    open fun closeConnection() = println("Closing connection to $url")
}
```

<Explanation>
    - **Clase abierta**: La clase `DatabaseConnection` est√° marcada como `open`, lo que permite que otras clases la hereden.
    - **Control expl√≠cito sobre qu√© se puede sobrescribir**: Solo el m√©todo `closeConnection()` es `open`, permitiendo que las subclases cambien su implementaci√≥n. El m√©todo `startConnection()` est√° cerrado, lo que protege la l√≥gica de apertura de conexiones contra modificaciones accidentales o inseguras.
    - **Dise√±o seguro**: Esta estrategia de herencia controlada permite extender funcionalidades sin poner en riesgo el comportamiento central de la clase base, una pr√°ctica esencial al dise√±ar bibliotecas robustas.
</Explanation>

#### Subclase especializada

Ahora, lxs usuarixs de tu biblioteca pueden extender la clase y sobrescribir √∫nicamente el m√©todo `closeConnection` si necesitan cerrar la conexi√≥n de una forma personalizada, mientras se garantiza que el m√©todo `startConnection` **no puede ser modificado**:

```kotlin showLineNumbers title="open-closed/src/main/kotlin/com/github/username/database/EncryptedDatabaseConnection.kt"
package com.github.username.database

class EncryptedDatabaseConnection(url: String) : DatabaseConnection(url) {

    override fun closeConnection() = println("Closing encrypted connection to $url")
}
```

<Explanation>
    - La clase `EncryptedDatabaseConnection` hereda de `DatabaseConnection` e invoca el constructor de la clase base pasando el par√°metro `url`.
    - El m√©todo `closeConnection` se sobrescribe utilizando la palabra clave `override`, que en Kotlin es **obligatoria** para indicar que se est√° redefiniendo un m√©todo de una superclase.
    - El m√©todo `startConnection`, al no estar marcado como `open`, **no puede ser sobrescrito**, lo que protege su implementaci√≥n original.
    - Este enfoque permite a lxs usuarixs personalizar el comportamiento deseado sin arriesgar la estabilidad de la clase base.
</Explanation>

Esto permite que la biblioteca sea flexible **sin comprometer su integridad**, ya que el comportamiento sensible se mantiene bajo control.

:::note Herencia en clases abstractas

En Kotlin, las clases y funciones abstractas son **abiertas por naturaleza**, lo que significa que **no es necesario marcarlas como `open`** para que puedan ser heredadas o sobrescritas. Esto tiene sentido, ya que su prop√≥sito es justamente servir de base para implementaciones concretas.  
Por ejemplo:

```kotlin
abstract class Animal {
    abstract fun speak()
}
```

Aqu√≠, `speak()` es autom√°ticamente sobrescribible, y `Animal` se puede extender sin necesidad de agregar `open`.

:::

## üß≠ ¬øQu√© abrir y qu√© cerrar?

Uno de los desaf√≠os al dise√±ar bibliotecas es decidir **qu√© partes del c√≥digo deben estar abiertas a la extensi√≥n** y **cu√°les deben mantenerse cerradas** para proteger la l√≥gica interna. Kotlin facilita esta tarea al exigir que la herencia sea expl√≠cita mediante el modificador `open`, pero la decisi√≥n sigue siendo responsabilidad de quien dise√±a la API.

### üîê Mantener cerrado si...

- La l√≥gica **es cr√≠tica para la seguridad o consistencia interna** del sistema.
- El m√©todo **no tiene un contrato claro de extensi√≥n** o su modificaci√≥n puede romper invariantes.
- Se espera que el comportamiento sea **estable y predecible en todas las implementaciones**.
- El m√©todo ya es parte de una **secuencia de pasos controlada**, como en un patr√≥n Template.

### üîì Abrir si...

- Quieres permitir que lxs usuarixs de la biblioteca **personalicen parte del comportamiento** sin duplicar c√≥digo.
- El m√©todo es **una extensi√≥n natural o prevista** del flujo l√≥gico del sistema.
- La documentaci√≥n puede establecer con claridad **qu√© se espera del comportamiento sobrescrito**.
- Existen **casos de uso m√∫ltiples o variables** que tu biblioteca no puede cubrir directamente.

:::tip Regla pr√°ctica

Si no puedes documentar f√°cilmente qu√© hace una subclase al sobrescribir un m√©todo, probablemente ese m√©todo deber√≠a mantenerse cerrado.

:::

Esta distinci√≥n te permite aplicar el **principio de m√≠nimo privilegio** tambi√©n en el dise√±o de clases: exp√≥n solo lo necesario, protege lo dem√°s.

### ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Control expl√≠cito de la herencia**: Las clases cerradas por defecto en Kotlin protegen el comportamiento de la clase base, evitando que cambios internos afecten de forma inesperada a subclases. Esto es especialmente √∫til en bibliotecas p√∫blicas, donde es fundamental mantener la compatibilidad.
        - **Dise√±o consciente y predecible**: Al requerir el uso expl√≠cito de `open`, se obliga a lxs desarrolladorxs a pensar en c√≥mo se espera que una clase sea utilizada y extendida. Esto fomenta la documentaci√≥n y la previsi√≥n, reduciendo ambig√ºedades en el uso de la API.
        - **Menor riesgo de errores sutiles**: Limitar la herencia reduce la posibilidad de que peque√±as modificaciones en una clase base generen errores complejos o dif√≠ciles de rastrear en subclases.
        - **Facilita el mantenimiento**: Un dise√±o con herencia controlada es m√°s f√°cil de mantener y refactorizar, ya que hay menos puntos de extensi√≥n que puedan romper la l√≥gica interna del sistema.
    </Pros>
    <Cons>
        - **Menor flexibilidad en sistemas abiertos**: En arquitecturas que requieren una extensibilidad din√°mica, como plugins o frameworks altamente configurables, el enfoque cerrado puede entorpecer la personalizaci√≥n.
        - **Sobrecarga inicial para usuarixs avanzadxs**: Quienes deseen extender el comportamiento de la biblioteca podr√≠an encontrar limitaciones que los obliguen a copiar c√≥digo o proponer cambios en la API.
        - **Posible necesidad de redise√±o**: En algunos casos, bloquear la herencia puede llevar a soluciones alternativas m√°s complejas o a una reestructuraci√≥n para lograr la extensibilidad deseada sin romper el encapsulamiento.
    </Cons>
</ProCons>

## üéØ Conclusiones

Dise√±ar bibliotecas implica tomar decisiones cuidadosas sobre qu√© aspectos deben ser **extensibles** y cu√°les deben permanecer **protegidos**. El **problema de la base fr√°gil** nos recuerda que permitir herencia sin control puede generar errores sutiles, romper contratos con lxs usuarixs y dificultar el mantenimiento a largo plazo.

Kotlin ofrece una estrategia clara para evitar estos problemas: **cerrar las clases por defecto**. Este enfoque obliga a que la extensibilidad sea una **decisi√≥n deliberada**, usando el modificador `open` solo cuando hay una necesidad real y justificada. Esta pr√°ctica no solo protege la integridad del c√≥digo, sino que tambi√©n facilita la comprensi√≥n, el uso y la evoluci√≥n de la API.

En esta lecci√≥n aprendimos a aplicar el principio **Open/Closed** de forma segura en Kotlin: mantener cerradas las clases por defecto, y abrir √∫nicamente lo que tenga sentido extender. Esta estrategia equilibra la flexibilidad con la estabilidad, lo que es clave al construir bibliotecas reutilizables.

### üîë Puntos clave

1. **Kotlin cierra clases y m√©todos por defecto**, lo que evita herencias accidentales.
2. **La herencia debe planearse y documentarse**, sobre todo en bibliotecas p√∫blicas.
3. **El modificador `open` permite controlar de forma precisa qu√© puede extenderse**.
4. **El principio Open/Closed** nos ayuda a extender el comportamiento sin modificar el c√≥digo existente.
5. **La herencia controlada mejora la mantenibilidad y la seguridad de nuestras APIs**.

### üß∞ ¬øQu√© nos llevamos?

La herencia es una herramienta poderosa, pero tambi√©n una fuente com√∫n de errores si no se usa con cuidado. En esta lecci√≥n vimos c√≥mo Kotlin promueve un enfoque m√°s seguro al **cerrar las clases por defecto**, forz√°ndonos a pensar antes de permitir la extensi√≥n.

Nos llevamos una estrategia clara:

> Cerrar por defecto, abrir con intenci√≥n.

Este principio no solo protege nuestras bibliotecas de modificaciones inesperadas, sino que tambi√©n da se√±ales claras a quienes las usan sobre qu√© partes pueden extenderse y c√≥mo hacerlo de forma segura.

Dise√±ar para la extensi√≥n controlada no es una limitaci√≥n, sino una invitaci√≥n a pensar en **contratos estables**, **comportamientos previsibles** y **APIs que crecen sin romperse**. Es una forma de escribir c√≥digo que cuida tanto a quienes lo consumen como a quienes lo mantienen.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Logo_C_sharp.svg/1200px-Logo_C_sharp.svg.png"
        language="C#"
        link="csharp"
    />
    <JavaCard link="/docs/oop/open-closed/java"/>
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/800px-Python-logo-notext.svg.png"
        language="Python"
        link="python"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala"
        link="/docs/oop/open-closed/scala"
    />
    <LanguageCard
        logoSrc="https://cdn-icons-png.flaticon.com/512/3984/3984314.png"
        language="Swift"
        link="/docs/oop/open-closed/swift"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

- üìö Classes and Interfaces. (2018). En Joshua Bloch, Effective Java (Third edition, pp. 73‚Äì116). Addison-Wesley.
