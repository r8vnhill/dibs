---
title: Polimorfismo Paramétrico
---
import References from "../../src/components/ReferencesComponent";
import ReadingTime from "../../src/components/ReadingTime";

<ReadingTime/>

El **polimorfismo paramétrico** es una característica esencial en Kotlin que permite a las clases y funciones operar sobre cualquier tipo sin especificar el tipo exacto de antemano. Esto facilita la creación de **código reutilizable** y **genérico**, manteniendo la seguridad del sistema de tipos. En esta lección, profundizaremos en aspectos básicos y avanzados del polimorfismo paramétrico en Kotlin, incluyendo **upper bounds**, **varianza en el sitio de declaración** y **varianza en el sitio de uso**.

<details>
    <summary>
        Un poco de historia: Polimorfismo paramétrico en ML
    </summary>

    El **polimorfismo paramétrico** fue introducido y popularizado por el lenguaje **ML (MetaLanguage)** en la década de 1970, convirtiéndose en una piedra angular para muchos lenguajes modernos.

    #### Orígenes en ML

    **ML** fue desarrollado por Robin Milner y sus colegas en los Laboratorios de Investigación de la Universidad de Cambridge como un lenguaje de programación para la inteligencia artificial y el razonamiento formal. Una de las contribuciones más significativas de ML fue la introducción de un sistema de tipos robusto que soporta polimorfismo paramétrico, permitiendo una mayor abstracción y reutilización de código.

    #### Características del Polimorfismo Paramétrico en ML

    - **Generics**: Permite definir funciones y estructuras de datos genéricas que pueden trabajar con cualquier tipo. Por ejemplo, la función de identidad en ML se define de manera que puede aceptar y devolver cualquier tipo.
        ```ml
        (* Función de identidad en ML *)
        let identity x = x
        ```
        Aquí, `identity` tiene el tipo `'a -> 'a`, donde `'a` es un tipo genérico que puede ser cualquier tipo concreto.
    - **Reutilización de Código**: Gracias al polimorfismo paramétrico, es posible escribir código más abstracto y reutilizable, evitando la duplicación de funciones para diferentes tipos.
    - **Seguridad de Tipos**: El sistema de tipos de ML verifica que las operaciones realizadas sobre los tipos sean seguras, previniendo errores comunes como los de tipos incompatibles en tiempo de compilación.

    #### Ejemplo de Uso

    Un ejemplo clásico de polimorfismo paramétrico es la implementación de listas en ML:

    ```ml
    (* Definición de una lista genérica en ML *)
    type 'a list =
        | Nil
        | Cons of 'a * 'a list
    ```

    Esta definición permite crear listas de cualquier tipo, como `int list`, `string list`, etc., manteniendo la consistencia y seguridad del sistema de tipos.

    #### Influencia y Evolución

    El polimorfismo paramétrico de ML influyó en el diseño de muchos otros lenguajes de programación, incluyendo **Haskell**, **OCaml**, **Scala**, y **Rust**. Esta característica ha sido fundamental para el desarrollo de la programación genérica y ha mejorado la capacidad de los lenguajes para abstraer sobre tipos, aumentando la expresividad y la seguridad del código.

    Además, el polimorfismo paramétrico es una piedra angular en el diseño de **tipos algebraicos** y **sistemas de tipos avanzados**, que permiten la creación de abstracciones poderosas y seguras en la programación moderna.
</details>

## Genéricos Básicos en Kotlin

Los **genéricos** permiten que clases, interfaces y funciones operen sobre cualquier tipo, mientras mantienen la seguridad de tipos.

### Ejemplo de una Clase Genérica

```kotlin showLineNumbers
class Box<T>(val value: T)
```

- `Box` es una clase genérica que almacena un valor de tipo `T`.
- `T` es un parámetro de tipo que puede ser cualquier tipo.

Podemos usar esta clase para almacenar valores de cualquier tipo:

```kotlin showLineNumbers
val intBox = Box(42)         // Box<Int>
val stringBox = Box("Hello")  // Box<String>
```

### Ejemplo de una Función Genérica

```kotlin showLineNumbers
fun <T> identity(value: T): T = value
```

Esta función toma un valor de cualquier tipo `T` y lo devuelve tal cual.

```kotlin showLineNumbers
println(identity(42))         // Devuelve 42
println(identity("Hello"))    // Devuelve "Hello"
```


## Upper Bounds en Kotlin

Los **upper bounds** (cotas superiores) permiten restringir los tipos que pueden ser utilizados como argumentos para los parámetros de tipo genérico. Esto asegura que los tipos utilizados cumplan con ciertos requisitos, como heredar de una clase específica o implementar una interfaz determinada.

### Sintaxis con `:` y `where`

Kotlin proporciona dos formas principales de definir upper bounds: usando el símbolo `:` directamente en la declaración del tipo y utilizando cláusulas `where` para condiciones más complejas.

#### Usando `:`

La sintaxis con `:` se utiliza para establecer una única restricción en el parámetro de tipo.

```kotlin showLineNumbers
fun <T : Number> add(a: T, b: T): Double = a.toDouble() + b.toDouble()

fun main() {
    println(add(5, 10))       // Output: 15.0
    println(add(5.5, 10.2))   // Output: 15.7
    // println(add("5", "10")) // Error: Type argument is not within its bounds
}
```

En este ejemplo, el parámetro de tipo `T` está restringido a subtipos de `Number`. Intentar usar un tipo que no hereda de `Number` resultará en un error de compilación.

:::note Inferencia de Tipos
En Kotlin, la inferencia de tipos permite omitir la especificación del tipo de argumento cuando es obvio a partir del contexto. Por ejemplo, `add(5, 10)` infiere que `T` es `Int` porque los argumentos son enteros.
:::

#### Usando `where`

La cláusula `where` permite definir múltiples restricciones y condiciones más complejas.

```kotlin showLineNumbers
fun <T> process(input: T)
    where T : CharSequence,
          T : Comparable<T> {
    println("Length of input: ${input.length}")
    println("Input is greater than itself: ${input > input}")
}

fun main() {
    val input: String = "Hello, Kotlin!"
    process(input) // Funciona porque String implementa CharSequence y Comparable<String>
    // val number = 10
    // process(number) // Error: Int no implementa CharSequence
}
```

## Varianza en el Sitio de Declaración

La **varianza** define cómo los tipos genéricos se comportan en relación con la herencia. En Kotlin, la varianza se especifica en el **sitio de declaración** utilizando las palabras clave `out` y `in`.

### Covarianza con `out`

La **covarianza** permite que un tipo genérico sea sustituido por uno de sus subtipos. Se utiliza la palabra clave `out` cuando el parámetro de tipo solo produce valores (es decir, solo se usa en posiciones de retorno).

Formalmente:

$$
T_1 <: T_2 \Rightarrow C[T_1] <: C[T_2]
$$

```kotlin showLineNumbers
interface Producer<out T> {
    fun produce(): T
}

class StringProducer : Producer<String> {
    override fun produce() = "Hello, Kotlin!"
}

fun main() {
    val stringProducer: Producer<String> = StringProducer()
    val anyProducer: Producer<Any> = stringProducer // Covarianza permite esto
    println(anyProducer.produce()) // Output: Hello, Kotlin!
}
```

En este ejemplo, `Producer<String>` puede ser tratado como `Producer<Any>` debido a la covarianza, ya que `String` es un subtipo de `Any`.

### Contravarianza con `in`

La **contravarianza** permite que un tipo genérico sea sustituido por uno de sus supertipos. Se utiliza la palabra clave `in` cuando el parámetro de tipo solo consume valores (es decir, solo se usa en posiciones de entrada).

Formalmente:

$$
T_1 <: T_2 \Rightarrow C[T_2] <: C[T_1]
$$

```kotlin showLineNumbers
interface Consumer<in T> {
    fun consume(item: T)
}

class AnyConsumer : Consumer<Any> {
    override fun consume(item: Any) = println("Consumed: $item")
}

fun main() {
    val anyConsumer: Consumer<Any> = AnyConsumer()
    val stringConsumer: Consumer<String> = anyConsumer // Contravarianza permite esto
    stringConsumer.consume("Hello, Kotlin!") // Output: Consumed: Hello, Kotlin!
}
```

Aquí, `Consumer<Any>` puede ser tratado como `Consumer<String>` debido a la contravarianza, ya que `Any` es un supertipo de `String`.

<details>
    <summary>
        Get-Put Principle
    </summary>

    El **Principio Get-Put** es una guía fundamental para comprender la varianza en los sistemas de tipos genéricos. Este principio ayuda a determinar si un tipo genérico debe ser covariante (`out`) o contravariante (`in`) basado en cómo se utiliza el parámetro de tipo dentro de la clase o interfaz.

    #### Definición del Principio

    - **Get**: Si una clase o interfaz **obtiene** (lee) valores de un tipo genérico, entonces el parámetro de tipo debe ser **covariante** (`out`).
    - **Put**: Si una clase o interfaz **coloca** (escribe) valores en un tipo genérico, entonces el parámetro de tipo debe ser **contravariante** (`in`).
    - **Get-Put**: Si una clase o interfaz realiza **ambas operaciones** (obtiene y coloca), el parámetro de tipo **no puede ser variante** y debe ser **invariante**.

    #### Aplicación del Principio en Kotlin

    En Kotlin, las palabras clave `out` y `in` se utilizan para declarar la varianza de los parámetros de tipo, estos nombres provienen directamente del Principio Get-Put:

    - **`out`**: Indica que el tipo solo se **produce** (se obtiene). Es covariante.
    - **`in`**: Indica que el tipo solo se **consume** (se coloca). Es contravariante.

    :::warning Invarianza por defecto
    En Kotlin, si no se especifica `in` o `out`, el parámetro de tipo es **invariante** por defecto, lo que significa que no se permite la covarianza ni la contravarianza.
    :::
</details>

## Varianza en el Sitio de Uso

Además de declarar la varianza en el sitio de declaración, Kotlin permite especificar varianza en el **sitio de uso** mediante **proyecciones**. Esto proporciona flexibilidad adicional al trabajar con tipos genéricos.

### Proyección Covariante

La proyección covariante se usa cuando solo necesitamos leer datos de una estructura genérica.

```kotlin showLineNumbers
fun printAll(producer: Producer<out Any>) = println(producer.produce())

fun main() {
    val stringProducer: Producer<String> = StringProducer()
    printAll(stringProducer) // Output: Hello, Kotlin!
}
```

En este caso, `Producer<out Any>` permite pasar un `Producer<String>` a la función `printAll`, ya que es seguro leer cualquier tipo de `Any` desde el productor.

### Proyección Contravariante

La proyección contravariante se usa cuando solo necesitamos escribir datos en una estructura genérica.

```kotlin showLineNumbers
fun addItem(consumer: Consumer<in String>) = consumer.consume("Hello, Kotlin!")

fun main() {
    val anyConsumer: Consumer<Any> = AnyConsumer()
    addItem(anyConsumer) // Output: Consumed: Hello, Kotlin!
}
```

Aquí, `Consumer<in String>` permite pasar un `Consumer<Any>` a la función `addItem`, ya que es seguro consumir un `String` en cualquier consumidor de `Any`.

Aquí tienes la sección sobre **Lower Bounds** en Kotlin:

## Lower Bounds en Kotlin

Los **lower bounds** (cotas inferiores) en Kotlin permiten restringir los tipos que pueden ser usados como argumentos en los parámetros genéricos, asegurando que los tipos utilizados sean supertipos de un tipo específico. Este concepto es clave cuando una función o clase requiere un tipo más general para poder procesar un rango más amplio de valores.

En Kotlin, los **lower bounds** se utilizan principalmente en la **contravarianza**, la cual se especifica con la palabra clave `in`. Esto significa que un tipo genérico puede aceptar cualquier supertipo del tipo especificado, permitiendo una mayor flexibilidad al trabajar con tipos en posiciones de entrada.

### Ejemplo de Lower Bounds

Un ejemplo típico de lower bounds es una función que trabaja con una lista de elementos genéricos, pero acepta cualquier tipo que sea un supertipo de `String`:

```kotlin showLineNumbers
fun addStrings(list: MutableList<in String>) {
    list.add("Hello")
    list.add("World")
}
```

En este ejemplo:

- La función `addStrings` acepta una lista mutable con un parámetro genérico `in String`, lo que indica que puede aceptar cualquier lista cuyos elementos sean `String` o un supertipo de `String`.
- Esto significa que puedes pasar una lista de `Any` o cualquier otro tipo que sea un supertipo de `String` a esta función.

Aquí tienes el resumen:

## Resumen

En esta lección, exploramos los fundamentos y aspectos avanzados del **polimorfismo paramétrico** en Kotlin. Vimos cómo los **genéricos** permiten crear clases, interfaces y funciones reutilizables que operan sobre cualquier tipo, manteniendo la seguridad del sistema de tipos.

### Puntos clave:
- **Upper Bounds**: Los upper bounds restringen los tipos que pueden usarse como argumentos genéricos, asegurando que los tipos sean subtipos de una clase o interfaz específica.
- **Lower Bounds**: Utilizados principalmente en contravarianza (`in`), los lower bounds permiten trabajar con supertipos de un tipo determinado, ofreciendo mayor flexibilidad en posiciones de entrada.
- **Varianza en el Sitio de Declaración**: Se utiliza `out` para definir covarianza y `in` para contravarianza en la declaración de tipos genéricos, facilitando la herencia en sistemas de tipos.
- **Varianza en el Sitio de Uso**: Las proyecciones permiten especificar varianza en el sitio de uso, proporcionando flexibilidad adicional al trabajar con tipos genéricos en funciones y métodos.

Aplicar correctamente estos conceptos es esencial para escribir código genérico eficiente y seguro, mejorando la reutilización y mantenibilidad en el desarrollo de aplicaciones en Kotlin.

<References references={[
    {
        title: "9. Generics",
        bookTitle: "Kotlin in action",
        pages: "223–253",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
    },
]}/>
