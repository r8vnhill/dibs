## Ruby

En **Ruby**, las propiedades (también llamadas *accessors*) se gestionan mediante los métodos `attr_reader`, `attr_writer`, y `attr_accessor`. Estos métodos permiten definir getters y setters de manera muy concisa. Similar a **Kotlin** y **Python**, Ruby también permite personalizar estos métodos si se requiere un comportamiento específico.

### Propiedades en Ruby

Ruby ofrece tres formas simples de definir accesos a los atributos de una clase:

- **`attr_reader`**: Define solo un getter.
- **`attr_writer`**: Define solo un setter.
- **`attr_accessor`**: Define tanto el getter como el setter.

### Ejemplo de Propiedades Básicas en Ruby

```ruby
class Person
  attr_accessor :name   # Define tanto el getter como el setter para 'name'

  def initialize(name)
    @name = name
  end
end

# Uso
person = Person.new("John")
puts person.name    # Getter
person.name = "Doe" # Setter
puts person.name
```

En este ejemplo:
- **`attr_accessor`**: Define automáticamente tanto el getter como el setter para la propiedad `name`.
- El atributo interno `@name` es la variable de instancia en Ruby, accesible a través del getter y setter generados.

### Propiedades con Getter y Setter Personalizados

Al igual que en **Kotlin** y **Python**, Ruby permite personalizar los getters y setters si se requiere un comportamiento adicional al acceder o modificar una propiedad.

```ruby
class Person
  def initialize(name)
    @name = name
  end

  def name  # Getter personalizado
    @name.capitalize
  end

  def name=(value)  # Setter personalizado
    @name = value.downcase
  end
end

# Uso
person = Person.new("john")
puts person.name    # Output: "John" (getter personalizado capitaliza)
person.name = "DOE" # Setter personalizado convierte a minúsculas
puts person.name    # Output: "Doe"
```

En este ejemplo:
- El **getter** personalizado devuelve el valor capitalizado.
- El **setter** personalizado convierte el valor a minúsculas antes de almacenarlo.

### Propiedades de Solo Lectura

Si una propiedad debe ser solo de lectura (similar a un `val` en **Kotlin**), podemos utilizar `attr_reader`, lo que genera únicamente un getter, pero no un setter.

```ruby
class Person
  attr_reader :age   # Solo lectura

  def initialize(age)
    @age = age
  end
end

# Uso
person = Person.new(25)
puts person.age  # Getter funciona
# person.age = 30  # Esto dará un error, ya que no hay setter
```

### Comparación entre Kotlin y Ruby

| **Característica**         | **Kotlin**                                   | **Ruby**                                             |
|----------------------------|----------------------------------------------|------------------------------------------------------|
| **Propiedades**            | Uso de `val` y `var`                         | Uso de `attr_reader`, `attr_writer`, `attr_accessor` |
| **Propiedad Calculada**    | Uso de `get()` en propiedades                | Getter personalizado                                 |
| **Setter Privado**         | Definido con `private set`                   | Definir manualmente sin un `attr_writer`             |
| **Flexibilidad de Acceso** | Control de visibilidad (`public`, `private`) | Definir getter o setter personalizado                |
