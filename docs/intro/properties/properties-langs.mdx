---
title: Propiedades en otros lenguajes
---

## TypeScript

### Ejemplo de propiedad con getter y setter personalizados en TypeScript

En TypeScript, las propiedades se pueden definir utilizando métodos `get` y `set`, similares a los de Kotlin. Aquí un ejemplo:

```typescript
class GettersAndSetters {
    private _name: string = "John";

    get name(): string { // Getter personalizado
        return this._name;
    }

    set name(value: string) { // Setter personalizado
        this._name = value;
    }
}
```

Notemos que aquí estamos usando una estrategia similar a usar un _backing field_ en Kotlin.

### Similitudes

- Ambos lenguajes permiten definir getters y setters personalizados para controlar el acceso a las propiedades.
- Tanto Kotlin como TypeScript utilizan una variable privada para almacenar el valor interno, accedida mediante `field` en Kotlin y `this._name` en TypeScript.

### Diferencias

- En Kotlin, `field` es una palabra clave reservada que se utiliza exclusivamente dentro de los getters y setters para referirse al valor subyacente. En TypeScript, es necesario definir explícitamente un campo privado, como `_name`.
- En TypeScript, los getters y setters están definidos como métodos dentro de la clase y no están directamente vinculados a una propiedad `val` o `var`, como en Kotlin.

### Propiedades calculadas en TypeScript

Al igual que en Kotlin, es posible definir **propiedades calculadas** en TypeScript utilizando un getter. El valor de la propiedad se calcula cada vez que se accede a ella:

```typescript
class GettersAndSetters {
    get now(): string {
        return new Date().toISOString();
    }
}
```

### Propiedades de solo lectura en TypeScript

En TypeScript, puedes definir una propiedad como **readonly**, lo que significa que su valor solo se puede asignar una vez, ya sea durante su declaración o dentro del constructor:

```typescript
class GettersAndSetters {
    readonly age: number;

    constructor(age: number) {
        this.age = age;
    }
}
```

Esto es equivalente a una propiedad `val` en Kotlin, donde el valor es inmutable después de su asignación inicial.

