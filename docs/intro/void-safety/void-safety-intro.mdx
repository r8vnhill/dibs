---
title: Introducci√≥n a Void Safety
sidebar_label: Void Safety
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />

## üö´ ¬øQu√© es "Void Safety"?

Una de las causas m√°s frecuentes de errores en aplicaciones es el uso incorrecto de valores *ausentes* o *nulos*. Este problema ocurre cuando una variable que se espera que contenga una referencia v√°lida en realidad contiene `null`. Al intentar acceder a sus m√©todos o propiedades, se generan fallos cr√≠ticos en tiempo de ejecuci√≥n, como el temido **NullPointerException**.

Este tipo de error es tan com√∫n que Tony Hoare, creador del `null` moderno, lo llam√≥ ‚Äú[el error de mil millones de d√≥lares](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)‚Äù.

:::info ¬øPor qu√© es importante la seguridad contra vac√≠os?

**Void safety** ‚Äîo *seguridad contra vac√≠os*‚Äî es una propiedad que ofrecen algunos lenguajes para prevenir que referencias nulas o vac√≠as causen fallas en tiempo de ejecuci√≥n. Esto se logra a trav√©s del sistema de tipos, forzando a que quien desarrolla maneje expl√≠citamente los casos en los que un valor puede estar ausente.

:::

En el desarrollo de **bibliotecas de software**, estos errores pueden ser a√∫n m√°s cr√≠ticos: no solo afectan al c√≥digo interno, sino que tambi√©n se propagan hacia quienes consumen la biblioteca. Una API que no gestiona adecuadamente la nulabilidad puede comprometer la estabilidad de m√∫ltiples proyectos y generar errores dif√≠ciles de diagnosticar.

## üí° Motivaci√≥n

El manejo inadecuado de valores *nulos* (o *vac√≠os*) es una de las causas m√°s frecuentes de errores en tiempo de ejecuci√≥n. Estos errores son dif√≠ciles de detectar, costosos de corregir y pueden comprometer la estabilidad de un sistema completo.

Un ejemplo cl√°sico en Scala:

```scala showLineNumbers
val name: String = null
println(name.length) // üî• NullPointerException
```

Puedes probar este c√≥digo en un compilador en l√≠nea, como [Scastie](https://scastie.scala-lang.org).

Aqu√≠, el programa compila sin advertencias, pero falla en tiempo de ejecuci√≥n. No hay ninguna protecci√≥n est√°tica que impida acceder a `length` cuando `name` es `null`.

Este riesgo se agrava en sistemas grandes. Y cuando se trata de **bibliotecas de software**, el impacto se multiplica: si una API permite valores nulos sin restricciones, los errores pueden propagarse a todas las aplicaciones que la utilizan.

Por eso, gestionar correctamente la presencia (o ausencia) de valores no es solo una buena pr√°ctica: es una necesidad para garantizar **la calidad, previsibilidad y fiabilidad** del software que ofrecemos a otras personas.

El objetivo de *void safety* es justamente ese: **prevenir accesos inv√°lidos a valores vac√≠os antes de que el programa se ejecute**, ya sea usando el sistema de tipos, verificaciones expl√≠citas o alternativas m√°s seguras a `null`.

<details>
    <summary>
        üß† La teor√≠a de `null` ‚Äî objetos iniciales y terminales
    </summary>

    En teor√≠a de categor√≠as, se habla de **objetos iniciales** y **objetos terminales**:

    - Un **objeto inicial** es uno que puede sustituir a cualquier otro valor, pero no puede ser inspeccionado ni utilizado directamente.
    - Un **objeto terminal** es uno que puede ser el resultado de cualquier operaci√≥n, pero no se le puede aplicar ninguna otra operaci√≥n sin fallar.

    `null` en Scala (como en Java) cumple **ambos roles a la vez**, y eso es parte del problema:

    #### üîÑ Como objeto inicial

    Puede asignarse a cualquier variable de tipo referencia:

    ```scala
    val name: String = null       // se espera un String
    val items: List[String] = null // se espera una lista
    ```

    Esto permite que `null` entre al sistema en cualquier punto, incluso donde no tiene sentido.

    #### üß® Como objeto terminal

    Muchas funciones pueden devolver `null` si algo sale mal. Pero si olvidas comprobarlo, puedes provocar fallos:

    ```scala
    def findUsername(): String = null

    val user = findUsername()
    println(user.toUpperCase()) // üî• NullPointerException
    ```

    Este doble rol hace que `null` sea **peligroso**: se mueve libremente, pero su uso puede causar fallos si no se verifica constantemente.

    #### üìå ¬øPor qu√© importa?

    En el dise√±o de bibliotecas, permitir que `null` forme parte de nuestras APIs **obliga a quienes las usan a escribir c√≥digo defensivo constantemente**. Esto contradice un principio esencial del dise√±o de software: *haz que lo f√°cil sea seguro*.

    Por eso, lenguajes como Scala (cuando se usa `Option`), Kotlin, Swift o Rust han adoptado mecanismos que restringen o eliminan el uso libre de `null`, y promueven alternativas m√°s seguras.
</details>

<details>
    <summary>üîç ¬øEn qu√© se diferencia `null` de `Unit`, `Nothing` o incluso `Any`?</summary>

    Aunque `null` suele interpretarse como "no hay valor", su uso es ambiguo. Lenguajes con sistemas de tipos expresivos, como Scala o Kotlin, distinguen entre varios conceptos que en otros lenguajes tienden a confundirse bajo `null`.

    | Concepto   | Prop√≥sito                                               | Diferencia clave                                              |
    |------------|----------------------------------------------------------|--------------|
    | `null`     | Representa ausencia de valor/referencia                  | Valor especial que puede colarse en casi cualquier tipo       |
    | `Unit`     | Indica que una funci√≥n no retorna un valor significativo|  Tiene un √∫nico valor `()`; representa ‚Äúnada √∫til que devolver‚Äù|
    | `Nothing`  | Representa una operaci√≥n que nunca retorna               | Tipo sin instancias; √∫til para se√±ales como errores o abortos |
    | `Any`      | S√∫per tipo de todos los tipos de valor                   | Se puede recibir desde cualquier tipo ‚Äî excepto `null`        |

    #### üìå Desde la teor√≠a de tipos

    Desde la teor√≠a de tipos, podemos clasificar algunos valores especiales seg√∫n su rol en el sistema de tipos:

    - `Any` es un **tipo terminal**: cualquier valor puede convertirse en `Any`. Es el supertipo de todos los tipos, y se puede operar con √©l de forma segura (puedes hacer `.toString`, `.hashCode`, etc.).
    - `Nothing` es un **tipo inicial**: representa una ausencia total de valor. No tiene instancias, pero puede usarse donde se espera cualquier tipo. Es √∫til para modelar errores o funciones que no retornan.
    - `null`, en cambio, es un caso peculiar: **se comporta tanto como tipo inicial como tipo terminal**.

    ##### üîÅ ¬øQu√© significa eso?

    - Como **tipo inicial**, `null` puede ser asignado a cualquier referencia (`String`, `List`, `User`, etc.), actuando como un valor que ‚Äúcabe en cualquier lado‚Äù.
    - Como **tipo terminal**, `null` puede aparecer como resultado de cualquier operaci√≥n fallida o incompleta, como una funci√≥n que no encontr√≥ lo que buscaba.

    Pero a diferencia de `Any`, que es seguro de usar, **`null` no es operativo**: cualquier intento de interactuar con √©l (llamar m√©todos, acceder a propiedades) produce un error en tiempo de ejecuci√≥n. 

    ##### ‚ö†Ô∏è El problema

    Esto convierte a `null` en una especie de ‚Äú**valor polimorfo ileg√≠timo**‚Äù: puede estar en cualquier lugar, pero no puede usarse de forma segura sin verificaciones adicionales.

    Y eso es precisamente lo que lo hace **tan peligroso**: carece de sem√°ntica clara, puede infiltrarse en cualquier parte del sistema, y su uso inadvertido puede hacer que un programa falle sin previo aviso.


    #### ‚úÖ Ejemplo con `Unit`: operaci√≥n sin valor relevante

    ```scala
    def log(msg: String): Unit =
    println(s"[log] $msg")

    val result = log("Inicio") // retorna (), no indica error
    ```

    #### üí• Ejemplo con `Nothing`: aborta la ejecuci√≥n

    ```scala
    def fail(): Nothing =
    throw new Exception("Fall√≥")

    val x = fail() // esta l√≠nea nunca retorna
    ```

    Separar estos conceptos permite expresar **intenciones claras** y escribir c√≥digo m√°s seguro. `null`, en cambio, rompe esa claridad al actuar como un ‚Äúcomod√≠n t√≥xico‚Äù.
</details>

## üîç ¬øQu√© abordaremos en esta subunidad?

Esta subunidad est√° compuesta por dos lecciones breves pero importantes:

1. **Null / Void safety en Kotlin**  
   Explicaremos c√≥mo Kotlin trata el `null`, qu√© operadores proporciona (`?.`, `?:`, `!!`, `let`) y c√≥mo el compilador ayuda a evitar errores de nulidad.

2. **Option, Result y alternativas a null**  
   Exploraremos alternativas m√°s expresivas al `null`, como `Option` y `Result`, que permiten modelar expl√≠citamente la ausencia de valor o los posibles errores sin depender de valores nulos.

<Explanation>
    Esta subunidad es especialmente importante para quienes dise√±an bibliotecas: una buena API no debe obligar a sus usuarixs a adivinar si algo puede ser `null`.  
    Debe **hacerlo expl√≠cito**, ya sea usando el sistema de tipos del lenguaje o proporcionando estructuras m√°s seguras.
</Explanation>

## üéØ Objetivos de aprendizaje

Al finalizar esta subunidad, deber√≠as ser capaz de:

- Identificar y evitar errores causados por referencias nulas.
- Comprender c√≥mo Kotlin implementa void safety a trav√©s de su sistema de tipos.
- Elegir entre usar `null`, `Option`, `Result` u otras alternativas seg√∫n el caso.
- Dise√±ar APIs m√°s seguras y expresivas, minimizando la posibilidad de errores en tiempo de ejecuci√≥n.

üëâ Vamos a comenzar con la primera lecci√≥n: **Null / Void safety en Kotlin**.
