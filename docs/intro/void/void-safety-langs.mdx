---
title: Void-Safety en otros lenguajes
---
import References from "../../../src/components/ReferencesComponent";
import ReadingTime from '../../../src/components/ReadingTime';

<ReadingTime />

## Eiffel

### Eiffel: El pionero en void-safety

**Eiffel** es uno de los primeros lenguajes en abordar de manera explícita el problema de la **void-safety** mediante su sistema de contratos. Desde su creación, Eiffel introdujo un enfoque formal para manejar la nulabilidad a través de **Design by Contract (DbC)**, lo que ayudó a evitar los problemas comunes causados por referencias nulas.

#### Enfoque de void-safety en Eiffel

Eiffel hace uso de contratos para garantizar que las referencias nunca sean nulas a menos que se especifique de forma explícita. El lenguaje asegura que todos los punteros se inicialicen correctamente, y permite declarar si una referencia puede o no ser nula, gestionando estas restricciones con una verificación en tiempo de compilación.

- **Precondiciones y postcondiciones**: Eiffel utiliza precondiciones y postcondiciones para definir los estados válidos de un objeto antes y después de la ejecución de un método. Esto ayuda a que las referencias nulas sean controladas explícitamente.

```eiffel showLineNumbers
class
    PERSON

feature
    name: STRING

    set_name (a_name: STRING)
        require
            not_void: a_name /= Void -- Precondición: a_name no puede ser nulo
        do
            name := a_name
        ensure
            name_assigned: name = a_name -- Postcondición: name debe ser asignado
        end
end
```

En este ejemplo de Eiffel, la precondición **`not_void`** garantiza que el parámetro `a_name` no sea nulo antes de ejecutar el método, lo que evita errores de nulidad durante la ejecución.

### Comparación: Eiffel vs Kotlin

| Aspecto                                   | Eiffel                                                                                                  | Kotlin                                                                                          |
|-------------------------------------------|---------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **Pionero en void-safety**                | Eiffel fue uno de los primeros lenguajes en abordar void-safety explícitamente.                         | Kotlin ha adoptado un enfoque moderno, inspirado en Eiffel, con tipos anulables y no anulables. |
| **Verificación en tiempo de compilación** | Eiffel utiliza contratos para verificar la nulabilidad y otros aspectos antes de la ejecución.          | Kotlin usa un sistema de tipos fuerte para evitar nulos en tiempo de compilación.               |
| **Manejo de nulabilidad**                 | Contratos y precondiciones/postcondiciones aseguran que las referencias no sean nulas si no se permite. | Tipos anulables (`String?`) y operadores (`?.`, `?:`) para manejar nulos.                       |
| **Lidiando con valores nulos**            | El lenguaje fuerza la definición explícita de la nulabilidad en los contratos.                          | El sistema de tipos diferencia explícitamente entre referencias anulables y no anulables.       |
| **Error en tiempo de ejecución**          | Eiffel previene errores en tiempo de ejecución mediante el uso de contratos.                            | Kotlin previene `NullPointerException` usando un sistema de tipos fuerte.                       |

## Swift

**Swift** introdujo el sistema de tipos **optional** para manejar la nulabilidad de manera segura y explícita. Este enfoque obliga a lxs desarrolladorxs a considerar la posibilidad de valores nulos en tiempo de compilación, evitando errores en tiempo de ejecución como los `NullPointerException`.

#### Optionals en Swift

En Swift, cualquier tipo puede ser declarado como **optional** usando el sufijo `?`. Esto indica que la variable puede contener un valor del tipo especificado o `nil`.

```swift
var a: String = "No nil allowed"
var b: String? = "Maybe nil"

a = nil // Error: a is not optional
b = nil // Allowed: b is optional
```

#### Manejo de Optionals

Swift proporciona varias herramientas para manejar valores opcionales de manera segura:

- **Optional Binding (`if let`)**: Permite comprobar si un optional contiene un valor y, de ser así, asignarlo a una variable temporal.

  ```swift
  if let unwrapped = b {
      print("Length: \(unwrapped.count)")
  } else {
      print("b is nil")
  }
    ```

- **Optional Chaining (`?.`)**: Permite acceder a propiedades o métodos de un optional de manera segura, devolviendo `nil` si el optional es `nil`.

  ```swift
  let length = b?.count
    ```

- **Nil-Coalescing Operator (`??`)**: Proporciona un valor por defecto si el optional es `nil`.

  ```swift
  let length = b?.count ?? 0
    ```

- **Forced Unwrapping (`!`)**: Permite acceder al valor de un optional, asumiendo que no es `nil`. Esto puede causar un error en tiempo de ejecución si el optional es `nil`.

  ```swift
  let length = b!.count
    ```

#### Propagación de Optionals

Swift permite propagar la nulabilidad de manera concisa utilizando el operador `?` en combinaciones con optional chaining y binding, facilitando la composición de funciones sin múltiples verificaciones explícitas.

```swift
func processString(_ str: String?) {
    if let unwrapped = str?.uppercased() {
        print("Uppercased: \(unwrapped)")
    } else {
        print("String is nil")
    }
}
```

### Comparación: Kotlin vs Swift

| Aspecto                                | Kotlin                                                                                                         | Swift                                                                                               |
|----------------------------------------|----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| **Sistema de Tipos**                   | Diferencia entre tipos anulables (`String?`) y no anulables (`String`).                                        | Uso de optionals (`String?`) para indicar que una variable puede ser `nil`.                         |
| **Declaración de Nulabilidad**         | Usa el sufijo `?` para declarar tipos anulables.                                                               | Usa el sufijo `?` para declarar optionals.                                                          |
| **Operadores de Manejo de Nulos**      | `?.`, `?:`, y `let` para manejar valores nulos de manera segura.                                               | `?.`, `??`, y optional binding (`if let`) para manejar valores opcionales.                          |
| **Propagación de Nulabilidad**         | Usa el operador `?.` y funciones como `let` para propagar nulos de manera concisa.                             | Usa optional chaining (`?.`) y binding (`if let`) para propagar nulos de manera concisa.            |
| **Sintaxis de Unwrapping Forzado**     | Usa el operador `!!` para forzar el unwrapping, lanzando una excepción si el valor es nulo.                    | Usa `!` para forzar el unwrapping de un optional, lo que puede causar un error si es `nil`.         |
| **Funciones y Métodos para Nulos**     | Funciones como `let`, `runCatching`, y otros operadores para manejar nulos funcionalmente.                     | Funciones como `map`, `flatMap`, y otras para manejar optionals funcionalmente.                     |
| **Impacto en la Seguridad del Código** | Reduce `NullPointerException` a través de verificaciones en tiempo de compilación y manejo explícito de nulos. | Reduce errores de referencia nula a través de optionals y verificaciones en tiempo de compilación.  |
| **Integración en el Lenguaje**         | Integrado en el sistema de tipos, promoviendo un manejo explícito y seguro de valores nulos.                   | Integrado en el sistema de tipos, con características específicas como optional chaining y binding. |
