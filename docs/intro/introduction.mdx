---
title: Introducción al desarrollo de bibliotecas de software
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

El desarrollo de bibliotecas de software es una parte esencial en la creación de herramientas reutilizables que permiten a otras aplicaciones y desarrolladorxs resolver problemas comunes de manera eficiente. En lugar de reescribir código repetitivo en cada proyecto, las bibliotecas proporcionan **funcionalidades encapsuladas y optimizadas** que pueden ser integradas fácilmente en distintos entornos de desarrollo.

Desde cálculos científicos hasta manipulación de datos, las bibliotecas están en el núcleo del software moderno. **Algunos ejemplos ampliamente utilizados incluyen:**  

- 🧮 **NumPy** *(Python)*: proporciona estructuras y operaciones optimizadas para cálculos numéricos de alto rendimiento.  
- 📦 **Lodash** *(JavaScript)*: ofrece herramientas para manipular arreglos, objetos y funciones de manera eficiente.  
- ⚡ **Arrow** *(Kotlin)*: facilita la programación funcional y la gestión segura de errores mediante estructuras como `Either` y `Validated`.  
- 🔗 **Boost** *(C++)*: extiende las capacidades estándar del lenguaje con estructuras de datos avanzadas y herramientas de concurrencia.  

Cada una de estas bibliotecas demuestra cómo un buen diseño de API y una implementación eficiente pueden **reducir la complejidad del código**, mejorar la productividad y fomentar la reutilización.

En este artículo, exploraremos los principios clave del diseño de bibliotecas de software, destacando **las mejores prácticas para crear APIs efectivas y fáciles de usar**. También analizaremos ejemplos de bibliotecas populares que aplican estos conceptos en la práctica, desde **JavaScript hasta Kotlin**.

## 🔗 APIs: La Base del Desarrollo de Software Moderno

Una **API** (*Application Programming Interface*) es un conjunto de reglas y herramientas que define cómo interactuar con una biblioteca o sistema. Actúa como un **bloque de construcción reutilizable**, permitiendo que aplicaciones y desarrolladorxs agreguen funcionalidades de manera eficiente y estandarizada.  

Las APIs son esenciales en el desarrollo moderno de software y suelen proporcionarse mediante **bibliotecas**, como **NumPy** para cálculos numéricos en Python o **Lodash** para manipulación de datos en JavaScript.

### ✅ Características de una Buena API

#### 🎯 1. Modelar el Problema Correctamente  

Una API bien diseñada debe proporcionar una **abstracción clara y efectiva** del problema que resuelve.  

✔️ **Propósito claro** → Cada función, clase y variable debe estar bien definida.  
✔️ **Consistencia** → Los nombres y estructuras deben ser uniformes para facilitar su uso.  

🔹 **Ejemplo (kotlinx-datetime)**:

```kotlin
val now: Instant = Clock.System.now()
val localDateTime = now.toLocalDateTime(TimeZone.UTC)
```

<Explanation>
    - `Clock.System.now()` modela de forma explícita el concepto de "tiempo actual" desde un reloj del sistema.
    - `toLocalDateTime` deja claro que estamos convirtiendo un `Instant` a una fecha local, y exige que se indique la `TimeZone`, lo que evita ambigüedad.
    - La API evita nombres genéricos como `convert` o `getTime`, y utiliza nombres que **describen con precisión la transformación o propósito**.
</Explanation>

:::tip Resultado

Esta API modela el dominio del tiempo y las zonas horarias de forma clara y predecible, lo que facilita su uso correcto y evita errores comunes como la omisión de zonas horarias.

:::

#### 🔒 2. Ocultar Detalles de Implementación  

Una API debe **esconder los detalles internos**, permitiendo modificaciones sin afectar a quienes la utilizan.  

✔️ **Encapsulación** → Expone solo lo necesario mediante métodos públicos.  
✔️ **Interfaz clara** → Permite interactuar con la API sin conocer su implementación interna.  
✔️ **Separación de preocupaciones** → Divide la API en módulos bien definidos.  

🔹 **Ejemplo real: [Ktor (Kotlin)](https://github.com/ktorio/ktor)**

```kotlin
val client = HttpClient()
val response: HttpResponse = client.get("https://lufia-api.example.com/ancient-cave/floor/20")

println(response.status)
println(response.bodyAsText())
```

<Explanation>
    Este ejemplo demuestra cómo Ktor aplica el principio de ocultar detalles de implementación:

    - **Encapsulación**: Clases como `HttpClient`, `HttpResponse` o `HttpRequestBuilder` exponen una interfaz limpia. Internamente, Ktor utiliza múltiples módulos y clases con `internal` o `private` para proteger su lógica de serialización, construcción de solicitudes, manejo de errores, etc.
    - **Interfaz clara**: El usuario interactúa con funciones como `get()` o `bodyAsText()` sin necesidad de conocer cómo se gestiona la conexión, el parseo del cuerpo o los encabezados HTTP.
    - **Separación de preocupaciones**: Ktor divide su funcionalidad en módulos (`client-core`, `client-json`, `client-logging`, etc.). Cada uno cumple una función específica y puede ser intercambiado o desactivado sin modificar el resto de la API pública.
</Explanation>

:::tip Resultado

Ktor permite construir clientes HTTP modulares con una interfaz sencilla, mientras oculta detalles como la serialización, el manejo de errores o la infraestructura de conexión. Puedes pedir los datos del *Ancient Cave* sin saber si fueron obtenidos por sockets, corutinas o magia de Artea.

:::

#### ⚖️ 3. Diseño Basado en la Simplicidad

> *"Cada elemento público en tu API es una promesa: una promesa de que soportarás esa funcionalidad por toda la vida de la API."*  
> — *Reddy, 2011*  

Una API debe ser **lo más pequeña posible** para facilitar su mantenimiento y comprensión.

✔️ **Simplicidad** → Reduce el número de elementos públicos.  
✔️ **Evita duplicación (DRY)** → No repitas funcionalidades.  
✔️ **Principio de responsabilidad única** → Cada componente debe tener **una única responsabilidad**.

🔹 **Ejemplo real: [Lodash (JavaScript)](https://github.com/lodash/lodash)**

¡Claro! Aquí tienes el ejemplo adaptado con datos del universo de **Durarara!!**, manteniendo la claridad del ejemplo original y alineado con los principios de simplicidad, no duplicación y responsabilidad única:

```javascript
import _ from 'lodash';

const characters = [
  { name: "Celty", alias: "The Headless Rider" },
  { name: "Shizuo", alias: "The Strongest Man in Ikebukuro" },
  { name: "Izaya", alias: "Information Broker" }
];

const names = _.map(characters, "name");

console.log(names); // ["Celty", "Shizuo", "Izaya"]
```

<Explanation>

Este ejemplo refleja cómo Lodash promueve un diseño basado en la simplicidad:

- **Simplicidad**: `_.map()` permite extraer un campo con solo pasar el nombre de la propiedad, sin necesidad de definir una función personalizada para cada caso.
- **No duplicación (DRY)**: Evita que cada extracción de nombres se haga con lógica repetida como `characters.map(c => c.name)`, promoviendo reutilización.
- **Responsabilidad única**: `_.map()` solo transforma cada elemento de la colección, delegando cualquier otra transformación o filtrado a funciones distintas como `_.filter`, `_.pick` o `_.sortBy`.

</Explanation>

:::tip Resultado

Lodash mantiene una API minimalista, coherente y reutilizable. Sus funciones hacen exactamente una cosa y la hacen bien — siguiendo el espíritu de *menos es más*.

:::

#### 🛠️ 4. Fácil de Usar y Difícil de Usar Incorrectamente  

✔️ **Intuitiva** → El uso de la API debe ser evidente con solo ver los nombres de los métodos.  
✔️ **Difícil de usar mal** → Diseñada para prevenir errores comunes.  
✔️ **Evita abreviaciones y siglas confusas** → Usa nombres descriptivos y estándar.  

🔹 **Ejemplo (Kotlin)**:  
```kotlin
fun sendEmail(to: String, subject: String, body: String) { /* ... */ }
```
📌 **Mala práctica**:  
```kotlin
fun sndMl(addr: String, subj: String, txt: String) { /* ??? */ }
```
📌 **Buena práctica**: Usa nombres claros como `sendEmail()` en lugar de `sndMl()`.  

#### 🔗 5. Cohesión Alta y Bajo Acoplamiento  

✔️ **Alta cohesión** → Un módulo debe centrarse en **una sola tarea**.  
✔️ **Bajo acoplamiento** → Los componentes deben poder cambiar sin afectar a otros.  

🔹 **Ejemplo (Kotlin - Separación de Módulos)**:  
```kotlin
class AuthService {
    fun login(user: String, pass: String): Boolean { /* ... */ }
}

class UserProfile {
    fun loadProfile(user: String): User { /* ... */ }
}
```
📌 **Buena práctica**: `AuthService` gestiona autenticación, mientras `UserProfile` maneja perfiles.  

#### 🔍 6. Estabilidad, Documentación y Pruebas  

✔️ **Estabilidad** → Usa versionado y evita cambios incompatibles.  
✔️ **Documentación** → Explica la API con ejemplos claros.  
✔️ **Pruebas** → La API debe contar con **tests automatizados**.  

🔹 **Ejemplo (Kotlin - Deprecación de Métodos Viejos)**:  
```kotlin
@Deprecated("Use sendSecureEmail instead", ReplaceWith("sendSecureEmail(to, subject, body)"))
fun sendEmail(to: String, subject: String, body: String) { /* ... */ }
```
📌 **Buena práctica**: Indica claramente qué método reemplaza al obsoleto.  

🔹 **Ejemplo (Kotlin - Prueba Unitaria con Kotest)**:  
```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class AuthServiceTest : StringSpec({
    "should return true when credentials are valid" {
        val auth = AuthService()
        auth.login("user", "password") shouldBe true
    }
})
```
📌 **Buena práctica**: Las pruebas aseguran la estabilidad de la API a largo plazo.  

---

Una API bien diseñada no solo facilita su uso, sino que también mejora la **modularidad, mantenibilidad y seguridad** del software. Al aplicar estos principios:  

✅ **Modela el problema** de forma clara.  
✅ **Oculta detalles innecesarios** y favorece la encapsulación.  
✅ **Prioriza la simplicidad** y evita agregar funciones innecesarias.  
✅ **Es intuitiva** y **difícil de usar mal**.  
✅ **Promueve cohesión alta y bajo acoplamiento**.  
✅ **Garantiza estabilidad** con documentación y pruebas.  

Si sigues estas prácticas, tu API será más eficiente, fácil de mantener y adoptada con mayor rapidez por otrxs desarrolladorxs. 🚀

## 📚 ¿Qué es una biblioteca de software?

Una **biblioteca** es un conjunto de funciones, clases y herramientas reutilizables que facilitan tareas comunes en el desarrollo de software. Permiten a quienes desarrollan escribir menos código, mejorar la modularidad y evitar la repetición de lógica.

Ejemplos:
- **NumPy** (Python) → Computación científica.
- **Lodash** (JavaScript) → Manipulación de arrays y objetos.
- **Guava** (Java) → Colecciones avanzadas y utilidades.

### 🔍 Diferencias entre una biblioteca y una aplicación

| 📌 Característica   | 📚 Bibliotecas | 🖥️ Aplicaciones |
|--------------------|--------------|---------------|
| **Finalidad**      | Proveer funcionalidades reutilizables | Resolver un problema específico |
| **Ejecutables**    | ❌ No pueden ejecutarse por sí solas | ✅ Pueden ejecutarse de forma independiente |
| **Interacción**    | API para desarrolladorxs | Interfaz para usuarixs (UI/CLI) |
| **Ejemplos**       | NumPy, Guava, Boost | Chrome, Photoshop, IntelliJ |

### 🏗️ Principios de Diseño de Bibliotecas

Para que una biblioteca sea efectiva, debe cumplir con ciertos principios de diseño.

#### 🏛️ 1. Interfaces Simples y Coherentes

✔️ **API fácil de usar** → Debe ser intuitiva sin necesidad de leer documentación extensa.  
✔️ **Consistencia** → Uso uniforme de nombres y estructuras.

```kotlin
// ❌ Inconsistente (nombres y orden de parámetros diferentes)
parseJSON(validate = true, "data.json")
readXml("data.xml", validate = true)

// ✅ Consistente (sigue un mismo patrón)
Parser.json("data.json", validate = true)
Parser.xml("data.xml", validate = true)
```

#### 🔒 2. Encapsulación y Ocultamiento de Implementación

✔️ **Solo exponer lo necesario** → Los detalles internos deben estar ocultos.  
✔️ **Modularidad** → Cada parte de la biblioteca debe ser independiente.

```kotlin
class Database private constructor() {
    private val connection = connectToDatabase() // 🔒 Oculto

    fun query(sql: String): ResultSet = connection.executeQuery(sql)

    companion object {
        fun create(): Database = Database()
    }
}
```
📌 **El usuario solo interactúa con `query()` sin preocuparse por la conexión interna.**

#### ⚖️ 3. Cohesión y Bajo Acoplamiento

✔️ **Alta cohesión** → Cada módulo debe hacer una sola cosa bien.  
✔️ **Bajo acoplamiento** → Los cambios en una parte no deben afectar otras.

```kotlin
// ❌ Mal diseño: la clase maneja tanto autenticación como validación de datos.
class AuthService {
    fun login(user: String, pass: String) { /*...*/ }
    fun isValidEmail(email: String): Boolean { /*...*/ }
}

// ✅ Buen diseño: separación de responsabilidades.
class AuthService { fun login(user: String, pass: String) { /*...*/ } }
class Validator { fun isValidEmail(email: String): Boolean { /*...*/ } }
```


### 🔥 Ejemplos de Bibliotecas Populares

#### 1️⃣ Lodash (JavaScript) – Utilidades para Arrays y Objetos

📌 **Facilita la manipulación de datos en JavaScript.**
```typescript
import _ from 'lodash';
const numbers = [1, 2, 3, 4, 5];
console.log(_.chunk(numbers, 2)); // [[1, 2], [3, 4], [5]]
```

#### 2️⃣ NumPy (Python) – Computación Numérica

📌 **Optimiza operaciones matemáticas con arrays y matrices.**
```python
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.dot(a, b))  # Output: 32
```

#### 3️⃣ Guava (Java) – Colecciones y Utilidades

📌 **Extiende las capacidades estándar de Java con estructuras de datos avanzadas.**
```java
Multimap<String, String> multimap = ArrayListMultimap.create();
multimap.put("fruit", "apple");
multimap.put("fruit", "banana");
System.out.println(multimap); // {fruit=[apple, banana]}
```

#### 4️⃣ Boost (C++) – Extensiones para C++

📌 **Proporciona herramientas avanzadas para manipulación de datos.**

```cpp
#include <boost/algorithm/string.hpp>
std::string str = "Hello Boost";
boost::to_upper(str);
std::cout << str;  // Output: HELLO BOOST
```

#### 5️⃣ Arrow (Kotlin) – Programación Funcional

📌 **Simplifica el manejo de errores y estructuras de datos inmutables.**

```kotlin
import arrow.core.*

fun divide(a: Int, b: Int): Either<String, Int> =
    if (b == 0) "Cannot divide by zero".left() else (a / b).right()

println(divide(4, 2))  // Output: Right(2)
```

## 📌 Conclusiones

El desarrollo de bibliotecas de software es un componente esencial en la creación de herramientas reutilizables y eficientes. A lo largo de este artículo, exploramos los principios clave para diseñar **APIs efectivas**, asegurando que sean intuitivas, flexibles y fáciles de mantener.  

### 🚀 Puntos Clave

1. **Las bibliotecas facilitan la reutilización de código y la modularidad**, evitando la duplicación innecesaria y mejorando la productividad.  
2. **Una API bien diseñada debe ser clara, coherente y difícil de usar incorrectamente**, siguiendo principios como encapsulación, cohesión y bajo acoplamiento.  
3. **La simplicidad es clave**: una API debe ser lo más pequeña posible, exponiendo solo las funcionalidades esenciales sin introducir complejidad innecesaria.  
4. **Ocultar detalles internos mejora la mantenibilidad**: una API debe proporcionar una interfaz estable y separar las preocupaciones para evitar dependencias rígidas.  
5. **Las pruebas y la documentación son esenciales**: una API debe estar respaldada por **pruebas automatizadas** y contar con documentación clara que incluya ejemplos de uso.  
6. **Las bibliotecas populares como NumPy, Lodash, Guava y Arrow demuestran estos principios en la práctica**, mostrando cómo se pueden aplicar en diferentes lenguajes de programación.  

### 🏆 **Reflexión Final**  

El diseño de bibliotecas de software va más allá de simplemente escribir código reutilizable. Implica tomar decisiones cuidadosas sobre la **estructura, la API expuesta y la experiencia de quienes la usan**. Aplicando estos principios, podemos desarrollar bibliotecas **eficientes, confiables y escalables**, que no solo resuelvan problemas técnicos, sino que también sean adoptadas y valoradas por la comunidad.  

Siguiendo estas buenas prácticas, puedes construir **bibliotecas robustas y mantenibles**, asegurando que sean herramientas útiles a largo plazo.

<References references={[
    {
        "title": "Introduction",
        "bookTitle": "API Design for C++",
        "pages": "1–24",
        "location": "Amsterdam Heidelberg",
        "year": "2011",
        "type": "book"
    },
    {
        "title": "Qualities",
        "bookTitle": "API Design for C++",
        "pages": "25–80",
        "location": "Amsterdam Heidelberg",
        "year": "2011",
        "type": "book"
    },
]}/>
