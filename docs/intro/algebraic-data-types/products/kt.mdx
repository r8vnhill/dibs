---
title: Tipos Producto
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime />

## üß± ¬øQu√© son los tipos producto?

Los **tipos producto** son una de las construcciones fundamentales de los **tipos de datos algebraicos** (ADTs). Su nombre proviene del √°lgebra: si un tipo $A$ tiene $|A|$ valores posibles y otro tipo $B$ tiene $|B|$, entonces el tipo compuesto $A \times B$ puede representar $|A| \cdot |B|$ combinaciones. En programaci√≥n, esto se traduce en estructuras que **agrupan m√∫ltiples valores simult√°neamente**.

Por ejemplo, para representar la posici√≥n de un personaje en un juego, podr√≠as declarar dos variables:

```kotlin
val x = 10
val y = 5
```

Pero nada garantiza que se usen juntas de manera coherente. Una mejor opci√≥n es combinarlas en un solo valor:

```kotlin
val position = Pair(10, 5)
```

Este `Pair` es un **tipo producto**: un valor que representa dos datos a la vez, con tipos potencialmente distintos.

En Kotlin, puedes construir un `Pair` de dos formas equivalentes:

```kotlin
val pair1 = Pair(1, true)
val pair2 = 1 to true
```

Ambas expresiones crean un `Pair<Int, Boolean>`, con un espacio total de representaciones igual a:

$$
|\text{Int} \times \text{Boolean}| = 2^{32} \cdot 2 = 2^{33}
$$

Los tipos producto no solo aportan claridad sem√°ntica, sino que **incrementan el espacio de representaci√≥n** de forma multiplicativa. Son ideales para modelar coordenadas, rangos, dimensiones, configuraciones y cualquier estructura donde varios valores est√©n l√≥gicamente conectados.

## üì¶ Representaciones b√°sicas: `Triple` y tuplas

Kotlin incluye tipos producto simples listos para usar, como `Pair<A, B>` y `Triple<A, B, C>`:

```kotlin
val dimensions = Triple(1920, 1080, 60)
val resolution = "${dimensions.first}x${dimensions.second}@${dimensions.third}Hz"
```

Estos tipos son √∫tiles para valores temporales o resultados intermedios. Sin embargo, **no son recomendables para estructuras con significado sem√°ntico claro**, ya que sus campos se acceden con nombres gen√©ricos (`first`, `second`, `third`), lo que reduce la legibilidad del c√≥digo.

Aunque Kotlin no tiene un sistema general de tuplas como otros lenguajes funcionales, cualquier clase con m√∫ltiples propiedades puede actuar como una tupla nombrada. Incluso podr√≠as anidar `Pair`s para simular tuplas m√°s grandes:

```kotlin
val nested = Pair("A", Pair("B", "C"))  // equivalente a una triple tupla
```

Pero esta pr√°ctica se vuelve r√°pidamente ilegible. En su lugar, Kotlin ofrece una alternativa m√°s robusta: **las clases y `data class`**, que permiten nombrar expl√≠citamente cada campo y aprovechar funcionalidades como igualdad estructural, desestructuraci√≥n y generaci√≥n autom√°tica de m√©todos.

## üèóÔ∏è Clases comunes como tipos producto

Adem√°s de estructuras como `Pair` y `Triple`, Kotlin permite definir **tipos producto personalizados** usando clases. Una clase con m√∫ltiples propiedades representa un tipo que contiene simult√°neamente un valor por cada campo: esa es precisamente la definici√≥n de un **tipo producto**.

Por ejemplo, para representar la posici√≥n de un personaje en un juego:

```kotlin
class Position(val x: Int, val y: Int)
```

Este tipo modela directamente el producto $ \text{Int} \times \text{Int} $, agrupando ambos valores en una sola entidad:

```kotlin
val pos = Position(10, 5)
println(pos.x)  // 10
println(pos.y)  // 5
```

::::tip Instanciaci√≥n sin `new`

En Kotlin, **no se utiliza la palabra clave `new`** para crear objetos. Basta con llamar al constructor como si fuera una funci√≥n:

```kotlin title="Kotlin"
val hunter = DemonHunter("Dante", "Rebellion")
```

Esto hace que la sintaxis sea m√°s limpia y coherente con la idea de que una clase tambi√©n puede comportarse como una funci√≥n.

En contraste, lenguajes como **Java**, **C#** o **C++** requieren la palabra clave `new` para instanciar clases:

```java title="Java"
final var hunter = new DemonHunter("Dante", "Rebellion");
```

:::note `final var` en Java

En Java, `var` permite **inferir el tipo** de la variable, mientras que `final` impide que la referencia sea **reasignada** despu√©s de su inicializaci√≥n.  
Esto es similar al uso de `val` en Kotlin, que tambi√©n declara una **referencia inmutable**.

Ten en cuenta que esta inmutabilidad **no es profunda**: si el objeto es mutable, su contenido a√∫n puede cambiar.

:::

Este cambio puede parecer sutil, pero refleja el enfoque de Kotlin hacia una sintaxis m√°s **concisa**, **expresiva** y **funcionalmente inspirada**, donde la creaci√≥n de objetos no requiere ruido adicional como `new`.

::::

A diferencia de `Pair`, una clase permite **nombrar claramente los campos** y agregar **comportamiento adicional**:

```kotlin
class Position(val x: Int, val y: Int) {
    fun isOrigin(): Boolean = x == 0 && y == 0
}
```

Esto permite encapsular tanto datos como operaciones relevantes al dominio, mejorando la expresividad y mantenibilidad.

## üß± Constructores primarios y secundarios

Kotlin ofrece dos mecanismos para construir objetos: el **constructor primario** y los **constructores secundarios**. Ambos se pueden usar para inicializar tipos producto con distintos niveles de control.

### üîπ Constructor primario

Se declara directamente junto al encabezado de la clase, ideal para inicializar propiedades de forma concisa:

```kotlin showLineNumbers
class Person(val name: String, var age: Int)
```

Cuando necesitas l√≥gica adicional durante la construcci√≥n, puedes usar un bloque `init`:

```kotlin showLineNumbers
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age must be non-negative" }
    }
}
```

:::note `require`, `check` y `error`

- `require(...)`: valida argumentos de entrada. Lanza `IllegalArgumentException`.
- `check(...)`: valida el estado del objeto. Lanza `IllegalStateException`.
- `error(...)`: lanza incondicionalmente un `IllegalStateException`.

Utilizar la funci√≥n adecuada mejora la claridad y precisi√≥n de los errores.

:::

### üîπ Constructor secundario

Los **constructores secundarios** permiten definir m√∫ltiples formas de crear una instancia. Se usan dentro del cuerpo de la clase y deben delegar al constructor primario con `this(...)`.

```kotlin showLineNumbers
class Person(val name: String) {
    var age: Int = 0

    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```

Son √∫tiles cuando:

- Se necesita interoperabilidad con Java.
- Se requieren m√∫ltiples caminos de inicializaci√≥n.
- Se aplica herencia con l√≥gica de construcci√≥n espec√≠fica.

:::tip Par√°metros por defecto

En Kotlin, los **par√°metros por defecto** suelen eliminar la necesidad de constructores secundarios:

```kotlin showLineNumbers
class Person(val name: String, var age: Int = 0)
```

Esta versi√≥n es m√°s idiom√°tica y concisa.

:::

## üß± Representaciones sem√°nticas: `data class`

Cuando un tipo producto tiene **significado propio dentro del dominio del problema**, Kotlin ofrece una herramienta espec√≠fica y expresiva: la `data class`. Estas clases est√°n pensadas para modelar estructuras de datos donde lo importante son los **valores contenidos**, no su identidad u operaciones complejas.

```kotlin title="Ejemplo b√°sico"
data class Position(val x: Int, val y: Int)

val current = Position(10, 5)
val next = current.copy(y = 6)
```

Esta clase `Position` representa el producto $\text{Int} \times \text{Int}$, pero con nombres expl√≠citos y prop√≥sito claro, lo que mejora la **legibilidad**, **seguridad** y **mantenibilidad** del c√≥digo.

### ‚öôÔ∏è ¬øQu√© ofrece una `data class`?

Al declarar una clase con el modificador `data`, Kotlin genera autom√°ticamente varias funciones √∫tiles:

- `equals()` y `hashCode()` ‚Üí comparaci√≥n estructural y soporte para estructuras como `Set` y `Map`.
- `toString()` ‚Üí representaci√≥n legible que incluye nombre de clase y valores.
- `copy()` ‚Üí creaci√≥n de una nueva instancia modificando uno o m√°s campos.
- `componentN()` ‚Üí soporte para desestructuraci√≥n.

Esto permite representar tipos producto de forma concisa y segura, como en este ejemplo:

```kotlin title="Modelo de datos"
data class Person(val name: String, val age: Int)

val original = Person("Trish", 30)
val updated = original.copy(age = 31)
println(updated) // Person(name=Trish, age=31)
```

### üîç Equivalencia con una clase com√∫n

Para comprender cu√°nto trabajo ahorra una `data class`, aqu√≠ est√° la versi√≥n equivalente usando una clase normal:

```kotlin
class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false
        other as Person
        return name == other.name && age == other.age
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + age
        return result
    }

    override fun toString() = "Person(name='$name', age=$age)"

    fun copy(name: String = this.name, age: Int = this.age) = Person(name, age)

    operator fun component1() = name
    operator fun component2() = age
}
```

Adem√°s de reducir el c√≥digo, `data class` transmite inmediatamente la intenci√≥n de que esa clase representa **un conjunto de datos inmutable por defecto**, y no una entidad con l√≥gica compleja.

### üß† Cu√°ndo usar `data class`

Usa `data class` siempre que necesites:

- Representar **datos estructurados** con un significado claro.
- Comparar instancias por contenido, no por identidad.
- Aprovechar funciones como `copy` o la desestructuraci√≥n de objetos.
- Reducir el c√≥digo repetitivo al modelar estructuras simples.

En resumen, `data class` es la forma idiom√°tica en Kotlin de declarar tipos producto **ricos en significado**, claros y reutilizables ‚Äîuna herramienta clave en el dise√±o de bibliotecas bien estructuradas.
