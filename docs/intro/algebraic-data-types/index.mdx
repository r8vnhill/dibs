---
title: Tipos de Datos Algebraicos
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

## üß© ¬øQu√© son los Tipos de Datos Algebraicos?

Los **tipos de datos algebraicos** (Algebraic Data Types, o ADTs) son una forma de definir nuevos tipos combinando otros tipos m√°s simples, siguiendo las reglas del √°lgebra: **suma** y **producto**.

:::warning No deben confundirse con los *tipos de datos abstractos* (Abstract Data Types)

Mientras que los ADTs algebraicos se refieren a c√≥mo se *estructura* un tipo, los ADTs abstractos se enfocan en c√≥mo se *comporta* un tipo (por ejemplo, una pila, una cola o un diccionario, definidos por sus operaciones).

:::

### üß† Desde la teor√≠a‚Ä¶

En √°lgebra, podemos componer conjuntos usando dos operaciones:

- **Producto ($\times$)**: combina elementos de dos conjuntos para formar pares. Por ejemplo, si tienes un conjunto de colores $\{\text{Rojo}, \text{Verde}\}$ y un conjunto de tallas $\{ \mathbf{S}, \mathbf{M}, \mathbf{L} \}$, su producto contiene todas las combinaciones posibles, como $\left(\text{Rojo},\, \mathbf{S}\right)$, $\left( \text{Verde},\, \mathbf{L} \right)$, etc.
- **Suma ($+$)**: representa una elecci√≥n entre alternativas. Si tienes un conjunto de monedas $\{ \text{Peso}, \text{Euro} \}$ y uno de criptomonedas $\{ Bitcoin \}$, su suma representa un valor que puede ser una **moneda** o una **cripto**, pero no ambas a la vez.

### üîç ‚Ä¶hacia un ejemplo concreto

Imagina que est√°s construyendo una biblioteca para manejar √≥rdenes de compra. Quieres representar el **estado de una orden**.

Una primera aproximaci√≥n podr√≠a ser usar una cadena de texto para guardar estados como `"pending"`, `"shipped"`, `"cancelled"`‚Ä¶ pero eso es propenso a errores: el c√≥digo no puede validar f√°cilmente que todos los valores sean correctos.

En cambio, puedes definir un tipo de datos que contenga solo los estados v√°lidos. Este nuevo tipo ser√≠a un **tipo suma**, porque una orden puede estar en *uno entre varios estados posibles*, pero **no en m√°s de uno al mismo tiempo**. Al definir estos estados de forma expl√≠cita, evitas valores inv√°lidos y habilitas validaciones autom√°ticas en tiempo de compilaci√≥n.

Del mismo modo, podr√≠as querer representar la **direcci√≥n de entrega** de una orden como un conjunto de campos: calle, n√∫mero, ciudad y pa√≠s. Este es un **tipo producto**, porque todos esos campos se combinan para formar una direcci√≥n completa.

## ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Mayor seguridad en tiempo de compilaci√≥n**: Los ADTs permiten que el compilador detecte errores de l√≥gica relacionados con casos no manejados, gracias a la exhaustividad en estructuras como `when`.
        - **Modelado expl√≠cito y expresivo**: Los tipos suma y producto te obligan a pensar en todos los casos posibles y a reflejarlos directamente en el tipo, lo que **documenta la l√≥gica del dominio en el c√≥digo**.
        - **Evitan valores inv√°lidos**: Al no depender de valores m√°gicos (como strings o enteros arbitrarios), reducen la posibilidad de errores por mal uso o errores tipogr√°ficos.
        - **Facilitan el mantenimiento y la evoluci√≥n**: Si agregas un nuevo caso a un tipo suma, el compilador se√±alar√° todos los lugares que deben actualizarse, lo que hace m√°s segura la evoluci√≥n de la API.
        - **Integraci√≥n natural con funciones puras**: Son ideales para ser combinados con funciones sin efectos secundarios, lo que facilita su uso en estilos funcionales y pruebas automatizadas.
    </Pros>
    <Cons>
        - **Menor flexibilidad en contextos din√°micos**: En entornos donde los casos v√°lidos se definen en tiempo de ejecuci√≥n (por ejemplo, configuraciones externas), los ADTs pueden ser demasiado r√≠gidos o requerir re-compilaci√≥n para cada cambio.
        - **Posible explosi√≥n de casos en dominios grandes**: Si el dominio tiene muchos estados, combinaciones o variantes, modelar todo con tipos algebraicos puede derivar en una gran cantidad de clases o ramas de c√≥digo.
        - **No siempre son intuitivos para quienes vienen de OOP puro**: Desarrolladorxs acostumbradxs a jerarqu√≠as de clases pueden tener una curva de aprendizaje al adoptar modelado basado en ADTs.
        - **Requieren disciplina de dise√±o**: Usar ADTs de forma efectiva requiere un esfuerzo consciente por modelar el dominio correctamente desde el principio. Si no se hace bien, se puede caer en modelos r√≠gidos o poco expresivos.
    </Cons>
</ProCons>

## ‚úÖ Entonces... ¬øTodos los ADTs son suma, producto o una combinaci√≥n?

**S√≠**. Por definici√≥n, los **tipos de datos algebraicos** se construyen usando operaciones de **suma**, **producto**, o una **combinaci√≥n de ambas**.

Esto abarca:

- **Tipos producto puros**: estructuras que agrupan m√∫ltiples valores al mismo tiempo.  
  Ejemplo: `data class Person(val name: String, val age: Int)`
- **Tipos suma puros**: valores que pueden ser una de varias opciones posibles, pero nunca m√°s de una a la vez.  
  Ejemplo: `enum class Result { Success, Failure }`
- **Tipos mixtos (suma de productos)**: estructuras donde cada alternativa (tipo suma) puede tener su propia combinaci√≥n de campos (tipo producto).  
  Ejemplo: una jerarqu√≠a sellada (`sealed class`) con varias subclases que tienen propiedades distintas.

Perfecto. Aqu√≠ tienes ambas opciones para reforzar la idea visualmente: una **representaci√≥n formal concisa** y un **diagrama con cajas** que se alinea con la forma en que suelen presentarse los ADTs.

---

### ‚úèÔ∏è Representaci√≥n simb√≥lica

```text
ADT ::= Suma
      | Producto
      | Suma(Productos)
```

- `Suma`: Un valor que puede ser **una de varias alternativas**.
- `Producto`: Un valor que **contiene varios campos al mismo tiempo**.
- `Suma(Productos)`: Alternativas que cada una contienen su propia estructura de campos.

---

### üì¶ Diagrama visual

```text
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   Tipo de Datos    ‚îÇ
                ‚îÇ   Algebraico (ADT) ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                   ‚îÇ                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Suma      ‚îÇ     ‚îÇ Producto   ‚îÇ       ‚îÇ Suma de Productos  ‚îÇ
‚îÇ (Sum Type) ‚îÇ     ‚îÇ(Product...)‚îÇ       ‚îÇ (Mixto / Sealed...)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

Si us√°s Mermaid para diagramas en tu sitio, tambi√©n puedo darte una versi√≥n en c√≥digo:

````mdx
```mermaid
graph TD
  ADT[Tipo de Datos Algebraico (ADT)]
  ADT --> Sum[Suma]
  ADT --> Prod[Producto]
  ADT --> Mix[Suma de Productos]
```
````

¬øQuer√©s que lo incluya ya integrado en el contenido de la lecci√≥n?
---

## ü§î ¬øPuede haber algo m√°s?

Lo que puede causar confusi√≥n es que **algunas estructuras no parecen sumas ni productos a simple vista**, pero **internamente se modelan como tales**. Por ejemplo:

### üì¶ Otras formas relacionadas pero no ADTs estrictos

1. **Tipos funci√≥n (A ‚Üí B)**: No son ADTs, pero son comunes en programaci√≥n funcional. Tienen una sem√°ntica diferente (se consideran *exponenciales* en la analog√≠a algebraica).
2. **Tipos recursivos**: Como listas (`List<T>`) o √°rboles. Aunque parecen otra cosa, **se definen a partir de ADTs** recursivos:  
   ```kotlin
   sealed class List<out T> {
       data class Cons<T>(val head: T, val tail: List<T>) : List<T>()
       object Nil : List<Nothing>()
   }
   ```
   Aqu√≠ hay una **suma (Cons o Nil)** y en `Cons` hay un **producto (head √ó tail)**.
3. **Tipos unitarios y vac√≠os**:
   - El tipo `Unit` es un producto "degenerado" de cero elementos (tiene un solo valor).
   - El tipo `Nothing` puede verse como una suma vac√≠a (no tiene valores posibles).
4. **Tipos de opci√≥n**: como `Option<T>` o `Nullable<T>` tambi√©n son **tipos suma**, t√≠picamente `Some(value)` o `None`.

---

## üéì Conclusi√≥n

Aunque a veces se vean envueltos en formas m√°s complejas o abstractas, **todos los ADTs pueden descomponerse en combinaciones de tipos suma y producto**.

Por eso, entender estas dos operaciones es **la base fundamental** para comprender c√≥mo modelar datos en lenguajes funcionales y orientados a la seguridad en el dise√±o de tipos.

Excelente pregunta ü§ì

En el mundo de los **tipos de datos algebraicos**, las operaciones de **suma** y **producto** tienen significados claros y bien establecidos:

- **Suma** ‚Üí uni√≥n disjunta (tipo que puede ser A *o* B).  
- **Producto** ‚Üí combinaci√≥n (tipo que tiene A *y* B).  

Pero‚Ä¶ ¬øqu√© pasa con la **resta** y la **divisi√≥n**? ¬øTienen sentido?  
La respuesta es que **s√≠**, pero son m√°s sutiles y menos comunes en el dise√±o pr√°ctico de tipos. Veamos:

---

## ‚ûñ ¬øQu√© ser√≠a una "resta" de tipos?

Formalmente, la resta se puede asociar con el concepto de **subtipado o restricci√≥n**.  
En teor√≠a de tipos, a veces se interpreta como:

> **A ‚àí B** = todos los valores de A que no est√°n en B

Esto se parece a un *tipo excluyente*, o incluso al uso de tipos condicionales o filtros.

En algunos lenguajes avanzados con tipos dependientes o refinados (como en **TypeScript**, **Idris** o **F\***), uno puede definir algo como:

```typescript
type WithoutCancelled<T extends DeliveryState> = Exclude<T, DeliveryState.CANCELLED>
```

Pero en la mayor√≠a de los lenguajes convencionales (como Kotlin), no existe una forma directa de expresar "todos los valores de este tipo menos uno" sin usar validaciones a mano.

---

## ‚ûó ¬øQu√© ser√≠a una "divisi√≥n" de tipos?

La **divisi√≥n de tipos** es a√∫n m√°s abstracta.  
En la teor√≠a de tipos categ√≥rica, se relaciona con los **tipos de funciones parciales**, **continuaciones** o **exponentes**.

Si el producto corresponde a una tupla `(A, B)`, la divisi√≥n puede verse como:

> **A √∑ B** ‚âà una funci√≥n que necesita un valor de tipo B para producir un valor de tipo A.  
> Formalmente: `B ‚Üí A`

Esto se basa en una propiedad del √°lgebra de tipos:

```text
B ‚Üí A ‚âÖ A^B
```

Que es an√°loga a c√≥mo los exponentes funcionan en √°lgebra tradicional, y esto se conoce como **exponenciaci√≥n de tipos**.

---

## üéì En resumen

| Operaci√≥n | Interpretaci√≥n en Tipos | Ejemplo             |
|-----------|--------------------------|----------------------|
| Suma      | Uni√≥n disjunta (OR)      | `sealed class Result<Success, Failure>` |
| Producto  | Composici√≥n (AND)        | `data class Person(val name: String, val age: Int)` |
| Resta     | Diferencia / Exclusi√≥n   | `Exclude<A, B>` en TypeScript, validaciones manuales |
| Divisi√≥n  | Funci√≥n o dependencia    | `B ‚Üí A`, tipos funcionales |

---

¬øTe gustar√≠a que incluy√©ramos un bloque como este en la lecci√≥n para enriquecer la perspectiva te√≥rica?
-----------

Los **tipos de datos algebraicos** (no confundir con tipos de datos abstractos) son una forma de construir tipos de datos complejos a partir de otros m√°s simples, utilizando operaciones similares a las de la suma y el producto en √°lgebra. Son comunes en lenguajes que admiten programaci√≥n funcional como Haskell, OCaml, Scala, Kotlin y Rust.

Hay dos tipos principales:

1. **Tipos Producto (Product Types):**
    - Combina varios tipos en una sola estructura.
    - Cada valor del tipo contiene un valor de cada uno de sus componentes.
    - **Ejemplo sencillo:** Una estructura o registro.
    - Imagina una `Persona` que tiene un `nombre` y una `edad`. Cada persona tiene ambos atributos.
    - Se llaman "producto" porque el n√∫mero total de posibles valores es el producto de los posibles valores de sus componentes.

2. **Tipos Suma (Sum Types) o Tipos Uni√≥n:**
    - Representa un valor que puede ser de uno entre varios tipos posibles.
    - **Ejemplo sencillo:** Una enumeraci√≥n o variante.
    - Imagina un tipo `Forma` que puede ser un `C√≠rculo` o un `Rect√°ngulo`.
    - Se llaman "suma" porque el n√∫mero total de posibles valores es la suma de los posibles valores de cada opci√≥n.

## **Formalizaci√≥n**

Formalmente, los tipos de datos algebraicos se definen utilizando operaciones algebraicas de **suma** y **producto** sobre conjuntos de valores.

1. **Tipo Producto $(A \times B)$:**
    - Si tienes dos tipos $A$ y $B$, el tipo producto consiste en todas las combinaciones posibles de valores de $A$ y $B$.
    - **Tama√±o del tipo:** $|A| \times |B|$, donde $|A|$ es el n√∫mero de posibles valores de $A$.
    - **Matem√°ticamente:** Es el **producto cartesiano** de los conjuntos $A$ y $B$.
    - **Ejemplo:**
        - Si $A = \{true, false\}$ y $B = \{0, 1\}$, entonces $A \times B$ tiene 4 valores: $(true, 0)$, $(true, 1)$, $(false, 0)$, $(false, 1)$.

2. **Tipo Suma $(A + B)$:**
    - Combina tipos permitiendo que el valor sea de uno u otro tipo, pero no ambos a la vez.
    - **Tama√±o del tipo:** $|A| + |B|$.
    - **Matem√°ticamente:** Es la **uni√≥n disjunta** de los conjuntos $A$ y $B$.
    - **Ejemplo:**
        - Si $A = \{0, 1\}$ y $B = \{\text{`a'}, \text{`b'}\}$, entonces $A + B$ tiene 4 valores: $0$, $1$, $\text{`a'}$, $\text{`b'}$.
