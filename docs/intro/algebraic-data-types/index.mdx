---
title: Tipos de Datos Algebraicos
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

Cuando dise√±amos bibliotecas, uno de los desaf√≠os m√°s comunes es representar los datos de forma precisa, segura y expresiva. Necesitamos tipos que transmitan claramente su prop√≥sito, que impidan estados inv√°lidos, y que puedan evolucionar sin romper el c√≥digo que los usa.

Los **tipos de datos algebraicos** (Algebraic Data Types, o *ADTs*) son una herramienta fundamental para lograr esto. Nos permiten construir nuevos tipos combinando otros m√°s simples, siguiendo las reglas del √°lgebra: **producto** para agrupar informaci√≥n, y **suma** para expresar alternativas.

Estos conceptos no solo son importantes desde el punto de vista te√≥rico, sino que aparecen constantemente en el dise√±o de bibliotecas modernas: desde c√≥mo definimos estructuras de datos hasta c√≥mo representamos flujos de ejecuci√≥n, errores, validaciones, eventos, o incluso estados de interfaz.

En este bloque exploraremos c√≥mo Kotlin ‚Äîal igual que muchos lenguajes modernos‚Äî nos permite expresar este tipo de construcciones usando `data class`, `enum class` y `sealed class`. Aprender√°s no solo a identificarlos, sino tambi√©n a utilizarlos para crear modelos de datos robustos, mantenibles y alineados con los principios de claridad y seguridad que caracterizan a las buenas bibliotecas.

## üß© ¬øQu√© son los Tipos de Datos Algebraicos?

Los **tipos de datos algebraicos** (Algebraic Data Types, o *ADTs*) son una forma de construir nuevos tipos combinando otros m√°s simples, siguiendo los principios del √°lgebra: **suma** (elecci√≥n) y **producto** (composici√≥n). Son una herramienta esencial para modelar datos de forma clara, segura y expresiva.

:::warning No confundir con *Abstract Data Types (ADTs)*

Los ADTs algebraicos describen c√≥mo se **estructura** un tipo (como `Either` o `Pair`), mientras que los ADTs abstractos describen c√≥mo se **comporta** (como `Stack`, `Queue`, o `Map`).

:::

### üß† Desde la teor√≠a‚Ä¶

En √°lgebra, podemos componer conjuntos usando dos operaciones:

- **Producto ($\times$)**: combina elementos de dos conjuntos para formar pares. Por ejemplo, si tienes un conjunto de colores $\{\text{Rojo}, \text{Verde}\}$ y un conjunto de tallas $\{ \mathbf{S}, \mathbf{M}, \mathbf{L} \}$, su producto contiene todas las combinaciones posibles, como $\left(\text{Rojo},\, \mathbf{S}\right)$, $\left( \text{Verde},\, \mathbf{L} \right)$, etc.
- **Suma ($+$)**: representa una elecci√≥n entre alternativas. Si tienes un conjunto de monedas $\{ \text{Peso}, \text{Euro} \}$ y uno de criptomonedas $\{ Bitcoin \}$, su suma representa un valor que puede ser una **moneda** o una **cripto**, pero no ambas a la vez.

### üîç ‚Ä¶hacia un ejemplo concreto

Imagina que est√°s construyendo una biblioteca para manejar √≥rdenes de compra. Quieres representar el **estado de una orden**.

Una primera aproximaci√≥n podr√≠a ser usar una cadena de texto para guardar estados como `"pending"`, `"shipped"`, `"cancelled"`‚Ä¶ pero eso es propenso a errores: el c√≥digo no puede validar f√°cilmente que todos los valores sean correctos.

En cambio, puedes definir un tipo de datos que contenga solo los estados v√°lidos. Este nuevo tipo ser√≠a un **tipo suma**, porque una orden puede estar en *uno entre varios estados posibles*, pero **no en m√°s de uno al mismo tiempo**. Al definir estos estados de forma expl√≠cita, evitas valores inv√°lidos y habilitas validaciones autom√°ticas en tiempo de compilaci√≥n.

Del mismo modo, podr√≠as querer representar la **direcci√≥n de entrega** de una orden como un conjunto de campos: calle, n√∫mero, ciudad y pa√≠s. Este es un **tipo producto**, porque todos esos campos se combinan para formar una direcci√≥n completa.

## üß© ¬øQu√© tipos de ADTs existen?

Los **tipos de datos algebraicos** se construyen combinando dos operaciones fundamentales: **producto** y **suma**. Esto nos da tres formas b√°sicas de definir tipos:

- **Producto**: Un valor que **contiene varios campos al mismo tiempo**.  
  Ejemplo: `data class Person(val name: String, val age: Int)`
- **Suma**: Un valor que representa **una entre varias alternativas**.  
  Ejemplo: `enum class Result { Success, Failure }`
- **Suma de productos**: Cada alternativa tiene su propia estructura de campos.  
  Ejemplo: `sealed class Shape` con subtipos como `Circle(radius)` y `Rectangle(width, height)`

Esta √∫ltima forma es la m√°s expresiva y com√∫n en dise√±o de tipos modernos.

### ‚úèÔ∏è Representaci√≥n formal

Podemos expresar estas combinaciones usando una notaci√≥n inspirada en gram√°ticas formales:

```text
ADT ::= Producto
      | Suma
      | Suma(Productos)
```

- `Producto`: Agrupa varios valores simult√°neamente.  
- `Suma`: Representa una elecci√≥n entre varias opciones.  
- `Suma(Productos)`: Une ambas ideas: cada opci√≥n puede tener su propia estructura.

```mermaid
graph TD
  ADT["Tipo de Datos Algebraico (ADT)"]
  ADT --> Prod["Producto"]
  ADT --> Sum["Suma"]
  ADT --> Mix["Suma de Productos"]
```

## ü§î ¬øHay algo m√°s adem√°s de suma y producto?

Aunque los **tipos de datos algebraicos** se basan en combinaciones de suma y producto, hay otros tipos que no encajan directamente en esa clasificaci√≥n pero que aparecen con frecuencia y tienen un papel importante en la teor√≠a de tipos:

### 1. Funciones ($A \to B$)

Las funciones no son ADTs, ya que no representan estructuras de datos, sino transformaciones entre ellas. Sin embargo, en la analog√≠a algebraica, se consideran **exponenciales**, porque el n√∫mero de funciones posibles de `A` a `B` es `B^A`. Son esenciales en programaci√≥n funcional, especialmente cuando combinamos funciones con tipos algebraicos.

### 2. Tipos especiales: `Unit` y `Nothing`

Estos tipos son casos l√≠mite que completan el panorama:

- **`Unit`**: Representa un tipo con **un √∫nico valor posible** (`Unit`). Puede verse como un **producto vac√≠o**, es decir, una tupla de cero elementos.
- **`Nothing`**: Representa un tipo sin valores posibles. Se interpreta como una **suma vac√≠a**, ya que no hay ninguna alternativa disponible.

Estos tipos no solo son √∫tiles en teor√≠a: tambi√©n aparecen en la pr√°ctica, por ejemplo, como retornos de funciones que no devuelven informaci√≥n (`Unit`) o funciones que nunca terminan (`Nothing`).

## üîç ¬øQu√© aprender√°s en este bloque?

A lo largo de este bloque tem√°tico, profundizaremos en el uso de **tipos de datos algebraicos** en Kotlin con un enfoque orientado al dise√±o de bibliotecas reutilizables y expresivas. Aprender√°s a:

- Reconocer cu√°ndo usar tipos **producto**, **suma**, o **mixtos** para modelar estructuras de datos.
- Aplicar el dise√±o con **data classes**, **enums** y **clases selladas** (`sealed`) para capturar relaciones l√≥gicas y casos posibles de manera segura.
- Evitar estructuras d√©biles como cadenas o enteros sin sem√°ntica clara, reemplaz√°ndolas por tipos expl√≠citos y verificables en tiempo de compilaci√≥n.
- Entender las ventajas de los ADTs frente a modelos menos expresivos, especialmente en APIs p√∫blicas o dominios complejos.
- Ver c√≥mo estas ideas se conectan con otros lenguajes funcionales y se traducen a patrones robustos de dise√±o en bibliotecas.

Dividiremos este bloque en tres lecciones principales, cada una centrada en un tipo de construcci√≥n:

- **Tipos producto**: estructuras con m√∫ltiples campos a la vez.
- **Tipos suma**: valores que representan una entre varias posibilidades.
- **Tipos mixtos**: combinaciones de ambas formas (la m√°s potente y com√∫n en modelado de datos).

Cada lecci√≥n incluir√° teor√≠a, ejemplos, ejercicios y comparaciones para ayudarte a incorporar estas herramientas en tu repertorio como dise√±adorx de bibliotecas.

## üéØ Objetivos de aprendizaje

Al finalizar este bloque ser√°s capaz de:

- Explicar qu√© son los tipos de datos algebraicos y distinguir entre producto, suma y suma de productos.
- Modelar datos usando `data class`, `enum class` y `sealed class` en Kotlin de forma idiom√°tica.
- Elegir el tipo m√°s adecuado seg√∫n el problema a resolver, priorizando claridad, seguridad y expresividad.
- Construir modelos de datos robustos y mantenibles como parte de bibliotecas que otros puedan reutilizar.

Este conocimiento ser√° clave para construir APIs seguras, evitar errores comunes en estructuras de datos, y mantener una base de c√≥digo m√°s expresiva, predecible y f√°cil de probar.
