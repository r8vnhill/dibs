---
title: Tipos producto como clases
sidebar_label: Clases
---
import ReadingTime from '@site/src/components/ReadingTime'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />

En lecciones anteriores vimos que los **tipos producto** nos permiten representar m√∫ltiples valores de forma conjunta, y c√≥mo estructuras como `Pair` y `Triple` ofrecen una soluci√≥n r√°pida para ello. Sin embargo, estas opciones gen√©ricas no son ideales cuando necesitamos expresar con claridad la intenci√≥n de nuestros datos, especialmente al dise√±ar bibliotecas reutilizables.

En esta lecci√≥n aprenderemos c√≥mo **las clases comunes en Kotlin** nos permiten definir tipos producto m√°s expresivos, nombrando expl√≠citamente cada campo y encapsulando operaciones relevantes. Veremos c√≥mo se declaran, c√≥mo funcionan los **constructores primarios y secundarios**, y por qu√© resultan esenciales para construir tipos que no solo agrupen datos, sino que **comuniquen prop√≥sito**.

Este enfoque nos prepara para usar t√©cnicas m√°s avanzadas y idiom√°ticas, como las `data class`, que estudiaremos en la pr√≥xima lecci√≥n.

## üèóÔ∏è Clases comunes como tipos producto

Adem√°s de estructuras como `Pair` y `Triple`, Kotlin permite definir **tipos producto personalizados** usando clases. Una clase con m√∫ltiples propiedades representa un tipo que contiene simult√°neamente un valor por cada campo: esa es precisamente la definici√≥n de un **tipo producto**.

Por ejemplo, para representar la posici√≥n de un personaje en un juego:

```kotlin
class Position(val x: Int, val y: Int)
```

Este tipo modela directamente el producto $ \text{Int} \times \text{Int} $, agrupando ambos valores en una sola entidad:

```kotlin
val pos = Position(10, 5)
println(pos.x)  // 10
println(pos.y)  // 5
```

::::tip Instanciaci√≥n sin `new`

En Kotlin, **no se utiliza la palabra clave `new`** para crear objetos. Basta con llamar al constructor como si fuera una funci√≥n:

```kotlin title="Kotlin"
val hunter = DemonHunter("Dante", "Rebellion")
```

Esto hace que la sintaxis sea m√°s limpia y coherente con la idea de que una clase tambi√©n puede comportarse como una funci√≥n.

En contraste, lenguajes como **Java**, **C#** o **C++** requieren la palabra clave `new` para instanciar clases:

```java title="Java"
final var hunter = new DemonHunter("Dante", "Rebellion");
```

:::note `final var` en Java

En Java, `var` permite **inferir el tipo** de la variable, mientras que `final` impide que la referencia sea **reasignada** despu√©s de su inicializaci√≥n.  
Esto es similar al uso de `val` en Kotlin, que tambi√©n declara una **referencia inmutable**.

Ten en cuenta que esta inmutabilidad **no es profunda**: si el objeto es mutable, su contenido a√∫n puede cambiar.

:::

Este cambio puede parecer sutil, pero refleja el enfoque de Kotlin hacia una sintaxis m√°s **concisa**, **expresiva** y **funcionalmente inspirada**, donde la creaci√≥n de objetos no requiere ruido adicional como `new`.

::::

A diferencia de `Pair`, una clase permite **nombrar claramente los campos** y agregar **comportamiento adicional**:

```kotlin
class Position(val x: Int, val y: Int) {
    fun isOrigin(): Boolean = x == 0 && y == 0
}
```

Esto permite encapsular tanto datos como operaciones relevantes al dominio, mejorando la expresividad y mantenibilidad.

## üß± Constructores primarios y secundarios

En Kotlin, una clase puede tener **un constructor primario** y **uno o m√°s constructores secundarios**. El constructor primario se declara directamente en el encabezado de la clase, y es la forma idiom√°tica de inicializar sus propiedades.

### üîπ Constructor primario

El constructor primario se escribe despu√©s del nombre de la clase. Si no contiene anotaciones ni modificadores de visibilidad, la palabra clave `constructor` puede omitirse:

```kotlin
class Person(val name: String, var age: Int)
```

Si el constructor necesita una **anotaci√≥n** (como `@Inject`) o un **modificador de visibilidad** (como `private`, `protected` o `internal`), entonces **es obligatorio usar la palabra clave `constructor`**:

```kotlin
class Person @Inject internal constructor(val name: String)
```

Esto es com√∫n cuando se utilizan frameworks de **inyecci√≥n de dependencias** como [Dagger](https://dagger.dev/), [Koin](https://insert-koin.io/) o [Hilt](https://developer.android.com/training/dependency-injection/hilt-android), que requieren anotar los constructores para que el sistema pueda crearlos autom√°ticamente.

:::info `internal` en Kotlin

El modificador `internal` restringe el uso del constructor a **dentro del mismo m√≥dulo**. Aunque a√∫n no hemos visto qu√© es un m√≥dulo (lo exploraremos m√°s adelante en la unidad sobre *build systems*), puedes pensar en √©l como una **unidad de compilaci√≥n separada**, como una biblioteca o subproyecto.

Este modificador es especialmente √∫til al dise√±ar bibliotecas: permite que una clase sea visible para quienes la usan, pero **controla desde d√≥nde puede instanciarse**, evitando usos indebidos fuera del contexto esperado.

:::

Cuando se requiere ejecutar l√≥gica adicional al crear la instancia, se utilizan **bloques `init`** dentro del cuerpo de la clase:

```kotlin
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age must be non-negative" }
    }
}
```

El bloque `init` se ejecuta justo despu√©s de la evaluaci√≥n de los argumentos del constructor. Se pueden tener m√∫ltiples bloques `init`, y se ejecutan en orden de aparici√≥n.

:::note `require`, `check` y `error`

- `require(...)` valida argumentos de entrada. Lanza `IllegalArgumentException`.
- `check(...)` valida el estado interno del objeto. Lanza `IllegalStateException`.
- `error(...)` lanza incondicionalmente un `IllegalStateException`.

Estas funciones ayudan a capturar errores temprano con mensajes claros y espec√≠ficos.

:::

En Kotlin, el encabezado de la clase **no puede contener c√≥digo ejecutable**. Por eso, toda la l√≥gica de inicializaci√≥n debe colocarse en bloques `init`, lo cual favorece una estructura m√°s limpia y clara.

### üîπ Constructor secundario

Los **constructores secundarios** permiten definir m√∫ltiples formas de crear una instancia. Se usan dentro del cuerpo de la clase y deben **delegar obligatoriamente al constructor primario** utilizando `this(...)`:

```kotlin showLineNumbers
class Person(val name: String) {
    var age: Int = 0

    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```

Esta delegaci√≥n debe hacerse **como parte de la cabecera del constructor**, no dentro de su cuerpo. Esto garantiza que **el constructor primario sea siempre invocado primero**, lo que elimina ambig√ºedades en la inicializaci√≥n del objeto.

Son √∫tiles cuando:

- Se necesita interoperabilidad con Java.
- Se requieren m√∫ltiples caminos de inicializaci√≥n.
- Se aplica herencia con l√≥gica de construcci√≥n espec√≠fica.

:::tip Par√°metros por defecto

En Kotlin, los **par√°metros con valores por defecto** suelen eliminar la necesidad de constructores secundarios:

```kotlin showLineNumbers
class Person(val name: String, var age: Int = 0)
```

Esta versi√≥n es m√°s idiom√°tica, m√°s concisa y m√°s f√°cil de mantener.

:::

#### üîç Diferencia importante

En lenguajes como **Java** y **Swift**, la llamada a otro constructor con `this(...)` (o su equivalente) es una **instrucci√≥n dentro del cuerpo del constructor**, no parte de su definici√≥n. En cambio, en Kotlin, la delegaci√≥n al constructor primario **se declara en la cabecera del constructor secundario**, lo que **obliga a que ocurra primero**, sin excepciones.

<details>
    <summary>üîç ¬øPor qu√© importa esta diferencia?</summary>

    En muchos lenguajes como **Java**, **Swift** o **Objective-C**, la delegaci√≥n a otro constructor (`this(...)`, `self.init(...)`, etc.) se trata como **una instrucci√≥n dentro del cuerpo del constructor**, y aunque suele exigirse que ocurra primero, esa regla **no est√° reforzada por la sintaxis**.

    Esto puede permitir que otras instrucciones se ejecuten antes de delegar correctamente, lo que en algunos lenguajes puede derivar en objetos mal inicializados.

    #### üß® Ejemplo real: Objective-C

    En **Objective-C**, la inicializaci√≥n no est√° estrictamente controlada por la sintaxis. El siguiente c√≥digo es **v√°lido** y compila, pero puede generar errores si se accede a campos antes de inicializar `self` correctamente:

    <BoxedTabs>
        <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
            ```objc showLineNumbers
            - (instancetype)init {
                NSLog(@"Antes de delegar: %@", self.name); // ‚ö†Ô∏è Acceso a propiedad antes de inicializar self
                self = [self initWithName:@"Default"];
                return self;
            }
            ```
        </TabItem>
        <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
            ```objc showLineNumbers
            #import <Foundation/Foundation.h>

            @interface Person : NSObject
            @property (nonatomic, strong) NSString *name;
            - (instancetype)initWithName:(NSString *)name;
            @end

            @implementation Person

            - (instancetype)init {
                NSLog(@"Antes de delegar: %@", self.name); // ‚ö†Ô∏è Acceso a propiedad antes de inicializar self
                self = [self initWithName:@"Default"];
                return self;
            }

            - (instancetype)initWithName:(NSString *)name {
                self = [super init];
                if (self) {
                    self.name = name;
                }
                return self;
            }

            @end

            int main() {
                Person *p = [[Person alloc] init];
                return 0;
            }
            ```
        </TabItem>
    </BoxedTabs>
    
    Si `self` a√∫n no ha sido inicializado, acceder a propiedades puede producir **comportamiento indefinido** o errores en tiempo de ejecuci√≥n. A diferencia de Kotlin, no hay forma de prevenir esto en la sintaxis del lenguaje.

    #### ‚úÖ Kotlin lo previene desde la sintaxis

    En Kotlin, **la delegaci√≥n al constructor primario se declara en la cabecera**, antes de abrir las llaves del constructor secundario. Esto impide que cualquier l√≥gica se ejecute antes de inicializar correctamente el objeto:

    ```kotlin title="Kotlin ‚Äì Seguro por dise√±o"
    class Person(val name: String) {
        var age: Int = 0

        constructor(name: String, age: Int) : this(name) {
            this.age = age
        }
    }
    ```

    üîê Esto garantiza que el constructor primario **siempre se invoque primero**, evitando errores de inicializaci√≥n.

    #### üìö Otros lenguajes con delegaci√≥n flexible (y riesgos potenciales)

    - **Objective-C**: se puede acceder a `self` antes de llamar a `init`, con consecuencias impredecibles.
    - **Dart** (`factory constructors`): permiten ejecutar l√≥gica libre antes de retornar una instancia.
    - **Java** y **Swift**: imponen orden con verificaci√≥n sem√°ntica, pero no mediante la sintaxis.

    #### ‚úÖ Comparaci√≥n r√°pida

    | Lenguaje       | ¬øDelegaci√≥n forzada por la sintaxis? | ¬øRiesgo de inicializaci√≥n incorrecta? |
    | -------------- | ------------------------------------ | ------------------------------------- |
    | Kotlin         | ‚úÖ S√≠ (en cabecera)                  | ‚ùå Bajo                               |
    | Java           | ‚ùå No (verificaci√≥n sem√°ntica)       | ‚ö†Ô∏è Medio                              |
    | Objective-C    | ‚ùå No                                | ‚ö†Ô∏è Alto                               |
    | Dart (factory) | ‚ùå No                                | ‚ö†Ô∏è Medio                              |

    Kotlin evita este tipo de errores al **incorporar la delegaci√≥n en la sintaxis misma**, favoreciendo una inicializaci√≥n **m√°s segura, clara y robusta**, especialmente en bibliotecas reutilizables.
</details>

## üéØ Conclusiones

A lo largo de esta lecci√≥n exploramos c√≥mo las **clases comunes** en Kotlin pueden representar tipos producto, es decir, estructuras que agrupan m√∫ltiples valores en una √∫nica unidad coherente. A diferencia de tipos gen√©ricos como `Pair` o `Triple`, las clases permiten **nombrar cada campo**, **encapsular l√≥gica relevante** y **estructurar el dominio del problema de forma clara y extensible**.

Tambi√©n vimos c√≥mo Kotlin facilita la construcci√≥n de estas clases mediante **constructores primarios** y **bloques `init`**, y ofrece mecanismos adicionales como **constructores secundarios** y **par√°metros por defecto** para adaptarse a distintos escenarios.

### üîë Puntos clave

- Una **clase com√∫n** que declara varias propiedades representa un **tipo producto**: un valor que contiene simult√°neamente un valor por cada campo.
- Kotlin permite instanciar objetos sin usar `new`, lo que mejora la **concisi√≥n y legibilidad**.
- El **constructor primario** es la forma idiom√°tica de inicializar clases. Los **bloques `init`** permiten incluir validaciones o l√≥gica adicional.
- Los **constructores secundarios** son √∫tiles en casos especiales, pero a menudo pueden reemplazarse por **par√°metros con valores por defecto**.
- Las clases permiten encapsular tanto datos como comportamiento, lo que no es posible con estructuras gen√©ricas como `Pair`.

### üß∞ ¬øQu√© nos llevamos?

Entender c√≥mo usar clases comunes como tipos producto es un paso esencial para construir **tipos seguros, expresivos y reutilizables** en Kotlin. Esta capacidad es especialmente importante en el dise√±o de bibliotecas, donde cada tipo que definimos forma parte del contrato con quienes las consumen.

Esto no solo mejora la expresividad interna, sino que tambi√©n **define contratos m√°s claros para quienes consumen nuestras bibliotecas**, haciendo expl√≠cita la estructura y el prop√≥sito de los datos expuestos.

A medida que una biblioteca crece, las clases con nombres sem√°nticos y campos bien definidos **evitan ambig√ºedades, mejoran la legibilidad y facilitan cambios futuros**, a diferencia de las tuplas gen√©ricas, que tienden a volverse opacas.

Al dominar estas herramientas, no solo est√°s entendiendo c√≥mo funciona Kotlin: est√°s aprendiendo a **modelar tu dominio de forma robusta y expresiva**, eligiendo representaciones que hacen expl√≠citas las intenciones de tu c√≥digo. Este principio ‚Äî**que el c√≥digo comunique su prop√≥sito**‚Äî es clave en el dise√±o de bibliotecas limpias, mantenibles y comprensibles para otrxs.

Aprendiste a construir tus propios tipos producto desde cero. En la pr√≥xima lecci√≥n, **descubrir√°s c√≥mo Kotlin puede generar por ti muchos de los detalles repetitivos** mediante `data class`, llev√°ndote a√∫n m√°s cerca de escribir c√≥digo claro, conciso y expresivo.

## üìñ Referencias

### üî• Recomendadas

- üåê Classes | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 9 de abril de 2025, de https://kotlinlang.org/docs/classes.html

### üîπ Adicionales

- üì∞ Vukovic, M. (2024, diciembre 26). Pairs and triples in Kotlin (and why you shouldn‚Äôt use them). Nutrient. https://www.nutrient.io/blog/pairs-and-triples-in-kotlin-and-why-you-shouldnt-use-them/

