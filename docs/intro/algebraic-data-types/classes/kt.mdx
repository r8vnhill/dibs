---
title: Tipos producto como clases
sidebar_label: Clases
---
import ReadingTime from '@site/src/components/ReadingTime'

<ReadingTime />

En lecciones anteriores vimos que los **tipos producto** nos permiten representar m√∫ltiples valores de forma conjunta, y c√≥mo estructuras como `Pair` y `Triple` ofrecen una soluci√≥n r√°pida para ello. Sin embargo, estas opciones gen√©ricas no son ideales cuando necesitamos expresar con claridad la intenci√≥n de nuestros datos, especialmente al dise√±ar bibliotecas reutilizables.

En esta lecci√≥n aprenderemos c√≥mo **las clases comunes en Kotlin** nos permiten definir tipos producto m√°s expresivos, nombrando expl√≠citamente cada campo y encapsulando operaciones relevantes. Veremos c√≥mo se declaran, c√≥mo funcionan los **constructores primarios y secundarios**, y por qu√© resultan esenciales para construir tipos que no solo agrupen datos, sino que **comuniquen prop√≥sito**.

Este enfoque nos prepara para usar t√©cnicas m√°s avanzadas y idiom√°ticas, como las `data class`, que estudiaremos en la pr√≥xima lecci√≥n.

## üèóÔ∏è Clases comunes como tipos producto

Adem√°s de estructuras como `Pair` y `Triple`, Kotlin permite definir **tipos producto personalizados** usando clases. Una clase con m√∫ltiples propiedades representa un tipo que contiene simult√°neamente un valor por cada campo: esa es precisamente la definici√≥n de un **tipo producto**.

Por ejemplo, para representar la posici√≥n de un personaje en un juego:

```kotlin
class Position(val x: Int, val y: Int)
```

Este tipo modela directamente el producto $ \text{Int} \times \text{Int} $, agrupando ambos valores en una sola entidad:

```kotlin
val pos = Position(10, 5)
println(pos.x)  // 10
println(pos.y)  // 5
```

::::tip Instanciaci√≥n sin `new`

En Kotlin, **no se utiliza la palabra clave `new`** para crear objetos. Basta con llamar al constructor como si fuera una funci√≥n:

```kotlin title="Kotlin"
val hunter = DemonHunter("Dante", "Rebellion")
```

Esto hace que la sintaxis sea m√°s limpia y coherente con la idea de que una clase tambi√©n puede comportarse como una funci√≥n.

En contraste, lenguajes como **Java**, **C#** o **C++** requieren la palabra clave `new` para instanciar clases:

```java title="Java"
final var hunter = new DemonHunter("Dante", "Rebellion");
```

:::note `final var` en Java

En Java, `var` permite **inferir el tipo** de la variable, mientras que `final` impide que la referencia sea **reasignada** despu√©s de su inicializaci√≥n.  
Esto es similar al uso de `val` en Kotlin, que tambi√©n declara una **referencia inmutable**.

Ten en cuenta que esta inmutabilidad **no es profunda**: si el objeto es mutable, su contenido a√∫n puede cambiar.

:::

Este cambio puede parecer sutil, pero refleja el enfoque de Kotlin hacia una sintaxis m√°s **concisa**, **expresiva** y **funcionalmente inspirada**, donde la creaci√≥n de objetos no requiere ruido adicional como `new`.

::::

A diferencia de `Pair`, una clase permite **nombrar claramente los campos** y agregar **comportamiento adicional**:

```kotlin
class Position(val x: Int, val y: Int) {
    fun isOrigin(): Boolean = x == 0 && y == 0
}
```

Esto permite encapsular tanto datos como operaciones relevantes al dominio, mejorando la expresividad y mantenibilidad.

## üß± Constructores primarios y secundarios

Kotlin ofrece dos mecanismos para construir objetos: el **constructor primario** y los **constructores secundarios**. Ambos se pueden usar para inicializar tipos producto con distintos niveles de control.

### üîπ Constructor primario

Se declara directamente junto al encabezado de la clase, ideal para inicializar propiedades de forma concisa:

```kotlin showLineNumbers
class Person(val name: String, var age: Int)
```

Cuando necesitas l√≥gica adicional durante la construcci√≥n, puedes usar un bloque `init`:

```kotlin showLineNumbers
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age must be non-negative" }
    }
}
```

:::note `require`, `check` y `error`

- `require(...)`: valida argumentos de entrada. Lanza `IllegalArgumentException`.
- `check(...)`: valida el estado del objeto. Lanza `IllegalStateException`.
- `error(...)`: lanza incondicionalmente un `IllegalStateException`.

Utilizar la funci√≥n adecuada mejora la claridad y precisi√≥n de los errores.

:::

### üîπ Constructor secundario

Los **constructores secundarios** permiten definir m√∫ltiples formas de crear una instancia. Se usan dentro del cuerpo de la clase y deben delegar al constructor primario con `this(...)`.

```kotlin showLineNumbers
class Person(val name: String) {
    var age: Int = 0

    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```

Son √∫tiles cuando:

- Se necesita interoperabilidad con Java.
- Se requieren m√∫ltiples caminos de inicializaci√≥n.
- Se aplica herencia con l√≥gica de construcci√≥n espec√≠fica.

:::tip Par√°metros por defecto

En Kotlin, los **par√°metros por defecto** suelen eliminar la necesidad de constructores secundarios:

```kotlin showLineNumbers
class Person(val name: String, var age: Int = 0)
```

Esta versi√≥n es m√°s idiom√°tica y concisa.

:::

## üéØ Conclusiones

A lo largo de esta lecci√≥n exploramos c√≥mo las **clases comunes** en Kotlin pueden representar tipos producto, es decir, estructuras que agrupan m√∫ltiples valores en una √∫nica unidad coherente. A diferencia de tipos gen√©ricos como `Pair` o `Triple`, las clases permiten **nombrar cada campo**, **encapsular l√≥gica relevante** y **estructurar el dominio del problema de forma clara y extensible**.

Tambi√©n vimos c√≥mo Kotlin facilita la construcci√≥n de estas clases mediante **constructores primarios** y **bloques `init`**, y ofrece mecanismos adicionales como **constructores secundarios** y **par√°metros por defecto** para adaptarse a distintos escenarios.

### üîë Puntos clave

- Una **clase com√∫n** que declara varias propiedades representa un **tipo producto**: un valor que contiene simult√°neamente un valor por cada campo.
- Kotlin permite instanciar objetos sin usar `new`, lo que mejora la **concisi√≥n y legibilidad**.
- El **constructor primario** es la forma idiom√°tica de inicializar clases. Los **bloques `init`** permiten incluir validaciones o l√≥gica adicional.
- Los **constructores secundarios** son √∫tiles en casos especiales, pero a menudo pueden reemplazarse por **par√°metros con valores por defecto**.
- Las clases permiten encapsular tanto datos como comportamiento, lo que no es posible con estructuras gen√©ricas como `Pair`.

### üß∞ ¬øQu√© nos llevamos?

Entender c√≥mo usar clases comunes como tipos producto es un paso esencial para construir **tipos seguros, expresivos y reutilizables** en Kotlin. Esta capacidad es especialmente importante en el dise√±o de bibliotecas, donde cada tipo que definimos forma parte del contrato con quienes las consumen.

Al preferir clases con nombres significativos y estructuras claras, no solo escribimos mejor c√≥digo: tambi√©n **facilitamos su comprensi√≥n, prueba, documentaci√≥n y evoluci√≥n**. En las siguientes lecciones exploraremos c√≥mo **las `data class` llevan estos principios a√∫n m√°s lejos**, automatizando la generaci√≥n de comportamientos comunes como igualdad, copia y desestructuraci√≥n.

## üìñ Referencias

### üî• Recomendadas

- üåê Classes | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 9 de abril de 2025, de https://kotlinlang.org/docs/classes.html

{/* ### üîπ Adicionales */}
