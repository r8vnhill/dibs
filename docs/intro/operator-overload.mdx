---
title: Sobrecarga de Operadores
---
import References from "../../src/components/ReferencesComponent";
import ReadingTime from "../../src/components/ReadingTime";

<ReadingTime />

La sobrecarga de operadores es una característica de algunos lenguajes de programación, como Kotlin, que permite a lxs desarrolladorxs definir comportamientos personalizados para operadores estándar como `+`, `-`, `*`, `/`, entre otros. Esta capacidad es útil cuando trabajamos con tipos de datos definidos por el usuario y queremos que estos interactúen de manera más natural con los operadores predefinidos.

## Cómo Funciona la Sobrecarga de Operadores

En Kotlin, para sobrecargar un operador, se declara una función utilizando la palabra clave `operator` antes de `fun`. El nombre de la función debe coincidir con una de las funciones de operador predefinidas, como `plus`, `minus`, `times`, entre otras.

Por ejemplo, la función `plus` se utiliza para sobrecargar el operador `+`. Esto permite que cuando utilices el operador `+` con objetos de esa clase, Kotlin sepa qué operación ejecutar.

## Ejemplo Práctico: Sobrecarga del Operador `+` para Números Complejos

Veamos un ejemplo práctico utilizando una clase `Complex` que representa un número complejo (con partes reales e imaginarias). En este ejemplo, sobrecargamos el operador `+` para permitir la suma de dos números complejos de forma natural.

```kotlin
class Complex(val real: Double, val imaginary: Double) {
    operator fun plus(other: Complex) =
        Complex(real + other.real, imaginary + other.imaginary)
}
```

En este código:
- `Complex` es una clase que almacena dos propiedades: `real` (la parte real) e `imaginary` (la parte imaginaria).
- La función `plus` está marcada con el modificador `operator`, lo que indica que estamos sobrecargando el operador `+`.
- El método toma como parámetro otro objeto `Complex` y devuelve un nuevo objeto `Complex` cuya parte real e imaginaria es la suma de los respectivos valores de los dos números complejos.

## Uso de la Sobrecarga de Operadores

Gracias a esta sobrecarga, podemos sumar números complejos de manera intuitiva usando el operador `+` como si fueran tipos primitivos:

```kotlin
val number1 = Complex(1.0, 2.0)
val number2 = Complex(3.0, 4.0)
val sum = number1 + number2
println("Suma: (${sum.real}, ${sum.imaginary})")
```

:::warning
La sobrecarga de operadores es una herramienta poderosa que puede mejorar la legibilidad y expresividad de las APIs. Sin embargo, debe usarse con precaución, ya que un mal uso puede conducir a un código confuso o engañoso, comprometiendo su claridad y coherencia.

**Ejemplo de mal uso:**

```kotlin
class Employee(val name: String, val salary: Double) {
    operator fun plus(employee: Employee) =
        Employee("$name & ${employee.name}", salary + employee.salary)
}

val emp1 = Employee("Alice", 5000.0)
val emp2 = Employee("Bob", 4500.0)
val combined = emp1 + emp2  // ¿Suma de salarios o algo más?
```

En este caso, la sobrecarga del operador `+` puede inducir a pensar que simplemente está sumando valores numéricos, cuando en realidad combina nombres y suma salarios, lo que puede ser confuso.
:::

## Ejemplos en otros lenguajes

<details>
    <summary>Ver ejemplos en otros lenguajes</summary>

    ### C++

    En **C++**, puedes sobrecargar operadores definiendo una función `operator+`, `operator-`, etc. Aquí hay un ejemplo para sumar números complejos:

    ```cpp
    #include <iostream>
    using namespace std;

    class Complex {
        public:
        double real, imaginary;
        Complex(double r, double i) : real(r), imaginary(i) {}

        Complex operator+(const Complex& other) {
            return Complex(real + other.real, imaginary + other.imaginary);
        }
};

    int main() {
        Complex num1(1.0, 2.0), num2(3.0, 4.0);
        Complex sum = num1 + num2;
        cout << "Suma: (" << sum.real << ", " << sum.imaginary << ")" << endl;
    }
    ```

    ### Python

    En **Python**, puedes sobrecargar operadores usando métodos especiales como `__add__`. Aquí tienes un ejemplo para sumar números complejos:

    ```python
    class Complex:
        def __init__(self, real, imaginary):
            self.real = real
            self.imaginary = imaginary

        def __add__(self, other):
            return Complex(self.real + other.real, self.imaginary + other.imaginary)

    if __name__ == "__main__":
        num1 = Complex(1.0, 2.0)
        num2 = Complex(3.0, 4.0)
        sum = num1 + num2
        print(f"Suma: ({sum.real}, {sum.imaginary})")
    ```

    ### Swift

    En **Swift**, la sobrecarga de operadores se hace con la palabra clave `static func`. Aquí un ejemplo de cómo sumar números complejos:

    ```swift
    struct Complex {
        var real: Double
        var imaginary: Double

        static func +(lhs: Complex, rhs: Complex) -> Complex {
            return Complex(real: lhs.real + rhs.real, imaginary: lhs.imaginary + rhs.imaginary)
        }
    }

    let num1 = Complex(real: 1.0, imaginary: 2.0)
    let num2 = Complex(real: 3.0, imaginary: 4.0)
    let sum = num1 + num2
    print("Suma: (\(sum.real), \(sum.imaginary))")
    ```

    ### C#

    En **C#**, puedes sobrecargar operadores utilizando `operator`. Aquí tienes un ejemplo para números complejos:

    ```csharp
    using System;

    public class Complex {
        public double Real { get; }
        public double Imaginary { get; }

        public Complex(double real, double imaginary) {
            Real = real;
            Imaginary = imaginary;
        }

        public static Complex operator +(Complex a, Complex b) {
            return new Complex(a.Real + b.Real, a.Imaginary + b.Imaginary);
        }
    }

    public class Program {
        public static void Main() {
            Complex num1 = new Complex(1.0, 2.0);
            Complex num2 = new Complex(3.0, 4.0);
            Complex sum = num1 + num2;
            Console.WriteLine($"Suma: ({sum.Real}, {sum.Imaginary})");
        }
    }
    ```

    ### Ruby

    En **Ruby**, puedes sobrecargar operadores definiendo métodos como `+`. Aquí un ejemplo para sumar números complejos:

    ```ruby
    class Complex
        attr_accessor :real, :imaginary

        def initialize(real, imaginary)
            @real = real
            @imaginary = imaginary
        end

        def +(other)
            Complex.new(@real + other.real, @imaginary + other.imaginary)
        end
    end

    num1 = Complex.new(1.0, 2.0)
    num2 = Complex.new(3.0, 4.0)
    sum = num1 + num2
    puts "Suma: (#{sum.real}, #{sum.imaginary})"
    ```

</details>

<References references={[
    {
        title: "7. Operator overloading and other conventions",
        bookTitle: "Kotlin in action",
        pages: "173–199",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
    },
    {
        accessedDate: '22 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Operator Overloading | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/operator-overloading.html',
    },
    {
        accessedDate: '22 de septiembre de 2024',
        siteOrAuthor: 'Kotlin',
        title: 'Operator overloading - Kotlin language specification',
        type: 'web',
        url: 'https://kotlinlang.org/spec/operator-overloading.html',
    },
]}/>
