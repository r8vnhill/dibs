---
title: C√≥digo limpio y mantenible
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />


Escribir **c√≥digo limpio** no es solo una cuesti√≥n de estilo, sino un aspecto cr√≠tico para el √©xito de un proyecto. Un c√≥digo desordenado genera errores, dificulta la colaboraci√≥n y hace que cualquier cambio sea un riesgo.  

> **üìå Ejemplo real:**  
>
> Un equipo de desarrollo estaba implementando un sistema de control de acceso. Una variable llamada `auth` fue utilizada en el c√≥digo, pero distintos desarrolladorxs la interpretaron de manera diferente:  
> - **Algunxs pensaron que significaba "authentication"** (autenticaci√≥n, es decir, el proceso de verificar la identidad de un usuario).  
> - **Otrxs asumieron que significaba "authorization"** (autorizaci√≥n, es decir, los permisos que tiene un usuario despu√©s de autenticarse).  
>
> Como resultado, en algunos m√≥dulos del sistema, `auth` verificaba credenciales de usuario, mientras que en otros se usaba para comprobar permisos. Esto llev√≥ a problemas de seguridad en los que personas sin autorizaci√≥n pudieron acceder a recursos restringidos. El error pas√≥ desapercibido durante semanas debido a la confusi√≥n sem√°ntica.  
>
> ‚úÖ **Soluci√≥n:** En lugar de `auth`, se debieron usar nombres m√°s expl√≠citos como `userAuthentication` y `userAuthorization`, eliminando la ambig√ºedad.

En esta lecci√≥n, exploraremos **c√≥mo evitar estos problemas** con principios clave de c√≥digo limpio, nombres descriptivos, funciones peque√±as y buenas pr√°cticas de formateo.

## üëÄ C√≥digo f√°cil de leer y entender

Un c√≥digo bien escrito no solo facilita su lectura, sino que tambi√©n reduce errores, mejora la colaboraci√≥n y permite la evoluci√≥n del software sin generar deuda t√©cnica. Algunas pr√°cticas esenciales incluyen:

- **Nombres descriptivos**: Es fundamental usar nombres que sean claros y expresivos tanto para las variables como para las funciones. Los nombres deben reflejar su prop√≥sito de forma que el c√≥digo sea m√°s f√°cil de leer y entender.

    <BoxedTabs>
        <TabItem title="Ejemplo poco descriptivo" value="Ejemplo poco descriptivo">
            ```kotlin
            fun cx(cxPb: Double): Gt {
                // ...
            }
            ```
            üìå **Problemas:**
            - `cx` no indica su prop√≥sito.
            - `cxPb` no deja claro su significado.
            - `Gt` como tipo de retorno es ambiguo.
        </TabItem>
        <TabItem title="Ejemplo descriptivo" value="Ejemplo descriptivo">
            ```kotlin
            fun performCrossover(crossoverProbability: Double): Genotype {
                // ...
            }
            ```
            ‚úÖ **Mejoras:**
            - `performCrossover` deja claro que se trata de un operador de cruce.
            - `crossoverProbability` describe exactamente qu√© representa el par√°metro.
            - `Genotype` como retorno indica claramente el resultado esperado.
        </TabItem>
    </BoxedTabs>

- **Facilitar el trabajo en equipo**: Un c√≥digo limpio y estructurado mejora la colaboraci√≥n. Nuevos miembros pueden integrarse r√°pidamente y hacer revisiones m√°s efectivas.

- **Soporte a la evoluci√≥n del software**: Un c√≥digo mantenible permite realizar cambios y agregar nuevas funcionalidades de manera eficiente, reduciendo la deuda t√©cnica y minimizando riesgos.

## üöÄ Impacto de un C√≥digo Claro y Mantenible

Escribir c√≥digo limpio no solo mejora la comprensi√≥n inmediata, sino que tambi√©n reduce costos de mantenimiento y facilita su crecimiento.

### üìå Beneficios en el desarrollo diario

- üèó **Facilidad de entendimiento** ‚Üí Permite a cualquier persona del equipo comprender y modificar el c√≥digo sin esfuerzo.
- üöÄ **Menos errores** ‚Üí Reduce la posibilidad de errores cr√≠ticos al hacer el c√≥digo m√°s legible.
- üîÑ **Evoluci√≥n eficiente** ‚Üí Facilita la adici√≥n de nuevas funcionalidades sin romper el c√≥digo existente.

### üìà Beneficios a largo plazo

- üîß **Reutilizaci√≥n de componentes** ‚Üí Un c√≥digo modular puede aplicarse en distintos proyectos sin modificaciones innecesarias.
- üìä **Adaptabilidad a nuevos requisitos** ‚Üí Un dise√±o limpio permite extender la funcionalidad sin necesidad de grandes refactorizaciones.
- üë• **Mayor eficiencia del equipo** ‚Üí El c√≥digo claro reduce la fricci√≥n en el trabajo colaborativo, evitando errores y malentendidos.

## üéØ Principios de c√≥digo limpio

### üè∑Ô∏è Nombres descriptivos

Los nombres en el c√≥digo deben **describir su prop√≥sito sin necesidad de explicaciones adicionales**. Un buen nombre **act√∫a como documentaci√≥n impl√≠cita** y evita la dependencia de comentarios innecesarios. Si una funci√≥n o variable requiere un comentario para aclarar su prop√≥sito, probablemente el nombre no sea lo suficientemente expresivo.

<BoxedTabs>
    <TabItem title="Nombres poco descriptivos" value="Nombres poco descriptivos">
        ```kotlin
        fun getThem(theList: List<IntArray>): List<IntArray> {
            val list1 = mutableListOf<IntArray>()
            for (x in theList) {
                if (x[0] == 4) {
                    list1.add(x)
                }
            }
            return list1
        }
        ```

        üìå **¬øPor qu√© es problem√°tico?**  
        - `getThem`: No queda claro **qu√© obtiene**.  
        - `theList`: No describe su contenido.  
        - `list1`: Un nombre gen√©rico que no aporta informaci√≥n.  
        - `x[0] == 4`: No explica **qu√© representa el 4**.
    </TabItem>

    <TabItem title="Nombres descriptivos" value="Nombres descriptivos">
        ```kotlin
        fun getFlaggedCells(gameBoard: List<IntArray>): List<IntArray> {
            val flaggedCells = mutableListOf<IntArray>()
            for (cell in gameBoard) {
                if (cell[STATUS_VALUE] == FLAGGED) {
                    flaggedCells.add(cell)
                }
            }
            return flaggedCells
        }
        ```

        ‚úÖ **Mejoras:**  
        - `getFlaggedCells`: Describe claramente qu√© devuelve la funci√≥n.  
        - `gameBoard`: Indica que la lista representa un tablero.  
        - `flaggedCells`: Especifica que almacena celdas marcadas.  
        - `cell[STATUS_VALUE] == FLAGGED`: Hace que la condici√≥n sea comprensible.
    </TabItem>
</BoxedTabs>

Este enfoque no solo mejora la legibilidad del c√≥digo, sino que tambi√©n facilita el mantenimiento y la colaboraci√≥n en equipo. Nombres descriptivos permiten comprender r√°pidamente el prop√≥sito de una funci√≥n o variable sin necesidad de buscar explicaciones adicionales.

### ‚ö†Ô∏è Evitar nombres confusos

Evita nombres que var√≠an ligeramente, ya que pueden causar confusi√≥n:

- *Incorrecto*: `XYZControllerForEfficientHandlingOfStrings` vs `XYZControllerForEfficientStorageOfStrings`

Evita usar nombres secuenciales como `a1`, `a2`, ..., `aN`, ya que no aportan informaci√≥n sobre el prop√≥sito o contenido de las variables.

<BoxedTabs>
    <TabItem title="Ejemplo con nombres poco informativos" value="Ejemplo con nombres poco informativos">
    ```kotlin
    fun copyChars(a1: CharArray, a2: CharArray) {
        for (i in a1.indices) {
            a2[i] = a1[i]
        }
    }
    ```

    En este ejemplo, los nombres `a1` y `a2` no proporcionan contexto sobre qu√© representan estas variables, lo que complica la comprensi√≥n de la funci√≥n.
    </TabItem>

    <TabItem title="Ejemplo mejorado con nombres descriptivos" value="Ejemplo mejorado con nombres descriptivos">
    ```kotlin
    fun copyChars(source: CharArray, destination: CharArray) {
        for (i in source.indices) {
            destination[i] = source[i]
        }
    }
    ```

    En este caso, al usar nombres descriptivos como `source` y `destination`, el prop√≥sito de la funci√≥n es mucho m√°s claro, facilitando su lectura y entendimiento.
    </TabItem>
</BoxedTabs>

### üîä Nombres pronunciables

Es fundamental que los nombres sean pronunciables. Como dice Robert C. Martin en *Clean Code*:

> "If you can't pronounce it, you can't discuss it without sounding like an idiot. (...) This matters because programming is a social activity."

<BoxedTabs>
    <TabItem title="Ejemplo con nombre poco pronunciable" value="Ejemplo con nombre poco pronunciable">
    ```kotlin
    val genymdhms: String = TODO() // "generation date, year, month, day, hour, minute, and second"
    ```

    El nombre `genymdhms` es complicado de pronunciar y recordar, lo que obstaculiza la comunicaci√≥n entre desarrolladores y la comprensi√≥n del c√≥digo.
    </TabItem>
    
    <TabItem title="Ejemplo con nombre pronunciable" value="Ejemplo con nombre pronunciable">
    ```kotlin
    val generationDateTime: String = TODO()
    ```

    Cambiarlo a `generationDateTime` lo hace m√°s f√°cil de pronunciar y comprender, mejorando la comunicaci√≥n y la legibilidad del c√≥digo.
    </TabItem>
</BoxedTabs>

Usar nombres pronunciables facilita las discusiones sobre el c√≥digo, lo que es clave para un trabajo en equipo eficiente y la claridad a largo plazo.

### üõ†Ô∏è Funciones

- Las funciones deben ser peque√±as. Como se√±ala Robert C. Martin en *Clean Code*:
    > "The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that."
- Las funciones deben tener un solo prop√≥sito claro y no dividirse en secciones.
- El n√∫mero ideal de argumentos de una funci√≥n es 0, seguido por 1 y luego 2. Tres o m√°s deben estar fuertemente justificados.
- Las funciones deben hacer algo o responder una pregunta, pero no ambas.

### üó®Ô∏è Comentarios

Robert C. Martin tambi√©n nos recuerda que:

> "The proper use of comments is to compensate for our failure to express ourselves in code."

- Los comentarios son propensos a quedar obsoletos, por lo que deben mantenerse actualizados.
- Deben usarse cuando el c√≥digo por s√≠ solo no sea suficiente para expresar la intenci√≥n, pero no como sustituto de un c√≥digo claro.

<details>
    <summary>
        Comentarios: ¬øCu√°ndo son √∫tiles y cu√°ndo redundantes?
    </summary>
    
    Los comentarios deben usarse con moderaci√≥n y solo cuando aporten un valor real que el c√≥digo por s√≠ mismo no puede expresar. Veamos algunos ejemplos:

    <BoxedTabs>
        <TabItem title="Ejemplo de comentario redundante" value="redundante">

            ```kotlin
            // Esta variable almacena el nombre de usuario
            val userName = "Alice"
            ```

            En este caso, el nombre de la variable (`userName`) ya es suficientemente descriptivo. El comentario no aporta informaci√≥n adicional y puede convertirse en una distracci√≥n.
        </TabItem>

        <TabItem title="Ejemplo de comentario √∫til" value="util">

            ```kotlin
            // Debido a un bug en la API X,
            // necesitamos crear esta instancia antes de la llamada principal.
            val apiClient = ApiClient().apply {
                initializeLegacyDependencies()
            }
            ```

            Aqu√≠, el comentario explica un comportamiento no evidente en el c√≥digo y detalla un motivo hist√≥rico o t√©cnico (un bug externo) que no se desprende directamente de la implementaci√≥n.
        </TabItem>
    </BoxedTabs>

    <Explanation>
        - **Comentario redundante**: El c√≥digo es tan claro que no se necesita explicaci√≥n adicional, de modo que el comentario simplemente repite lo que ya se ve.
        - **Comentario √∫til**: Proporciona informaci√≥n de contexto, hist√≥rico o t√©cnico que no es obvio con solo leer el c√≥digo.    
    </Explanation>

    Este criterio te ayudar√° a decidir cu√°ndo un comentario en tu c√≥digo aporta valor real en t√©rminos de comprensi√≥n o justifica decisiones de dise√±o, y cu√°ndo es mejor confiar en un buen nombre de variable o funci√≥n para transmitir la intenci√≥n.
</details>

### üìê Formato de c√≥digo

- **Archivos peque√±os**: Son m√°s f√°ciles de manejar y leer.
- **Orden l√≥gico**: El c√≥digo se lee de arriba hacia abajo, por lo que debe estar organizado de manera que su flujo sea l√≥gico.
- **Est√°ndares de formato**: Es importante definir y seguir est√°ndares de formato en el proyecto para asegurar la consistencia.
- **Herramientas de an√°lisis est√°tico**: Estas herramientas pueden ayudar a detectar problemas de formato y garantizar que el c√≥digo cumpla con los est√°ndares establecidos.

Mantener un formato de c√≥digo coherente no solo mejora la legibilidad, sino que tambi√©n facilita la colaboraci√≥n y el mantenimiento a largo plazo.

<details>
    <summary>
        Errores frecuentes de formato de c√≥digo y sus correcciones
    </summary>
    
    Mantener un formato coherente a lo largo del proyecto es clave para facilitar la lectura y el mantenimiento del c√≥digo. A continuaci√≥n, se muestran algunos de los **errores m√°s comunes** y c√≥mo corregirlos.

    <BoxedTabs>
        <TabItem title="Antes: Formato Incorrecto" value="antes">

            ```kotlin
            fun myFunc(  name:String,age:Int):Boolean 
            {   if(name.isEmpty()) {return false}
                else{
            return age>=18}   }
            ```

            **Problemas notables:**
            - **Indentaci√≥n inconsistente** (espacios al azar).
            - **Espacios y saltos de l√≠nea** mal ubicados.
            - **Llaves mal colocadas** (la abertura de la funci√≥n en otra l√≠nea).
            - **Falta de espacios alrededor de operadores** (`:` y `>=`).
            - **Corte de l√≠nea** que dificulta la lectura (`else` y su bloque en la misma l√≠nea).

        </TabItem>
        <TabItem title="Despu√©s: Formato Correcto" value="despues">

            ```kotlin
            fun myFunc(name: String, age: Int): Boolean {
                if (name.isEmpty()) {
                    return false
                } else {
                    return age >= 18
                }
            }
            ```

            **Correcciones aplicadas:**
            - **Indentaci√≥n clara y consistente**: Cada nivel de anidaci√≥n tiene 4 espacios de indentaci√≥n (o el est√°ndar que se haya definido).
            - **Espacios alrededor de operadores**: Mejoran la legibilidad (por ejemplo, `age >= 18`).
            - **Llaves alineadas**: Tanto la definici√≥n de la funci√≥n como los bloques `if-else` se abren y cierran de manera coherente.
            - **L√≠neas separadas para cada bloque**: Facilita la lectura y el mantenimiento del c√≥digo.

        </TabItem>
    </BoxedTabs>

    <Explanation>
        **Consejos adicionales:**
        1. **Usar una herramienta de formateo autom√°tico**: IDEs como IntelliJ IDEA, Android Studio o Visual Studio Code pueden aplicar las reglas de estilo definidas para tu equipo.
        2. **Definir un est√°ndar**: Acordar una gu√≠a de estilo y formateo en tu proyecto (como [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html)) ayuda a mantener coherencia.
        3. **Mantener l√≠neas cortas**: Evita l√≠neas muy largas; se suelen recomendar 100-120 caracteres m√°ximos para mejorar la lectura.
        4. **Agrupar secciones l√≥gicamente**: Deja l√≠neas en blanco antes y despu√©s de bloques de c√≥digo que representen una funcionalidad o secci√≥n distinta.

        La consistencia en el formato de c√≥digo no solo facilita la lectura inmediata, sino que tambi√©n agiliza el trabajo en equipo y la detecci√≥n de conflictos en sistemas de control de versiones.
    </Explanation>
</details>

## üéØ Conclusiones

Escribir **c√≥digo limpio y mantenible** no es solo una buena pr√°ctica, sino una necesidad para el desarrollo de software eficiente y escalable. A lo largo de esta lecci√≥n, exploramos principios clave que ayudan a mejorar la calidad del c√≥digo, facilitando su lectura, mantenimiento y colaboraci√≥n en equipo.

### üìå Puntos clave:
- **Nombres descriptivos** ‚Üí Evitar nombres ambiguos y optar por aquellos que reflejen claramente el prop√≥sito de funciones, variables y clases.  
- **Funciones peque√±as y enfocadas** ‚Üí Cada funci√≥n debe realizar una √∫nica tarea clara, evitando el exceso de par√°metros y responsabilidades.  
- **Comentarios √∫tiles y justificados** ‚Üí Solo deben usarse para explicar decisiones t√©cnicas o contextos que el c√≥digo no pueda expresar por s√≠ mismo.  
- **Formato consistente** ‚Üí Seguir convenciones de estilo, mantener una estructura l√≥gica y utilizar herramientas de an√°lisis est√°tico para detectar problemas de legibilidad.  
- **C√≥digo modular y reutilizable** ‚Üí Dise√±ar componentes que puedan ser reaprovechados sin necesidad de modificaciones extensas.  

### üöÄ Beneficios de aplicar c√≥digo limpio
- **Menos errores** ‚Üí Un c√≥digo claro reduce la probabilidad de fallos y facilita la detecci√≥n temprana de problemas.  
- **Mayor productividad** ‚Üí Facilita la colaboraci√≥n entre desarrolladorxs, acelerando revisiones y mantenimiento.  
- **Escalabilidad del proyecto** ‚Üí Un c√≥digo bien estructurado permite agregar nuevas funcionalidades sin comprometer la estabilidad.  
- **Menos deuda t√©cnica** ‚Üí Evita la acumulaci√≥n de problemas que dificultan la evoluci√≥n del software en el futuro.  

Siguiendo estos principios, se pueden construir sistemas m√°s **robustos, flexibles y f√°ciles de mantener**, asegurando que el c√≥digo no solo funcione hoy, sino que sea sostenible a largo plazo.

<References references={
    [
        {
            title: "Comments",
            type: "book",
            bookTitle: "Clean code: a handbook of agile software craftsmanship",
            author: "Martin, Robert C.",
            pages: "53‚Äì74",
            publisher: "Prentice Hall",
            year: "2009",
            location: "Upper Saddle River, NJ",
        },
        {
            title: "Formatting",
            type: "book",
            bookTitle: "Clean code: a handbook of agile software craftsmanship",
            author: "Martin, Robert C.",
            pages: "75‚Äì92",
            publisher: "Prentice Hall",
            year: "2009",
            location: "Upper Saddle River, NJ",
        },
        {
            title: "Functions",
            type: "book",
            bookTitle: "Clean code: a handbook of agile software craftsmanship",
            author: "Martin, Robert C.",
            pages: "27‚Äì52",
            publisher: "Prentice Hall",
            year: "2009",
            location: "Upper Saddle River, NJ",
        },
        {
            title: "Meaningful Names",
            type: "book",
            bookTitle: "Clean code: a handbook of agile software craftsmanship",
            author: "Martin, Robert C.",
            pages: "33‚Äì50",
            publisher: "Prentice Hall",
            year: "2009",
            location: "Upper Saddle River, NJ",
        }
    ]
} />
