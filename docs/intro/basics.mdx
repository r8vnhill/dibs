---
title: Fundamentos del lenguaje Kotlin
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo=""/>

Kotlin es un lenguaje moderno que se destaca por su pragmatismo, claridad y seguridad. En la lecci√≥n anterior exploramos su filosof√≠a, sus ventajas en el desarrollo de bibliotecas y vimos un primer ejemplo ejecutable. Ahora es momento de profundizar en su estructura b√°sica y sus reglas de construcci√≥n.

En esta lecci√≥n nos enfocaremos en los **fundamentos del lenguaje Kotlin**, cubriendo los conceptos esenciales que toda persona que programe en Kotlin debe conocer: **expresiones y declaraciones**, **funciones**, **variables y constantes**, **estructuras de control** como `if` y `when`, y **rangos** para iteraci√≥n. Tambi√©n aprender√°s c√≥mo usar la funci√≥n `main` y c√≥mo aprovechar la **interpolaci√≥n de cadenas** para generar mensajes din√°micos.

Estos elementos forman la base de cualquier programa en Kotlin, y nos preparan para avanzar hacia t√©cnicas m√°s avanzadas como la programaci√≥n funcional, la definici√≥n de tipos personalizados y la creaci√≥n de bibliotecas idiom√°ticas.

## üßÆ Expresiones vs. Declaraciones

Es importante distinguir entre **expresiones** y **declaraciones**, ya que desempe√±an roles diferentes en la estructura de un programa. En Kotlin, estas diferencias son claras, aunque en otros lenguajes como Scala o Rust, las distinciones pueden ser m√°s difusas.

<Definition title="Expresiones">
    Las **expresiones** son fragmentos de c√≥digo que **producen un valor** y pueden combinarse con otras expresiones. En Kotlin, una expresi√≥n puede ser algo tan simple como una constante, o tan complejo como una funci√≥n an√≥nima. Ejemplos comunes son las operaciones aritm√©ticas, los operadores l√≥gicos y las llamadas a funciones.
</Definition>

<Definition title="Declaraciones">
    Las **declaraciones** ejecutan una acci√≥n pero **no retornan un valor**. A diferencia de las expresiones, no pueden combinarse con otras declaraciones. Ejemplos en Kotlin incluyen la asignaci√≥n de variables, la ejecuci√≥n de bucles y la definici√≥n de funciones.
</Definition>

| Ejemplo                     | ¬øExpresi√≥n o declaraci√≥n? | ¬øDevuelve valor?        |
| --------------------------- | ------------------------- | ----------------------- |
| `val x = 5`                 | Declaraci√≥n               | No                      |
| `if (a > b) a else b`       | Expresi√≥n                 | S√≠ (valor de `a` o `b`) |
| `fun greet() { println() }` | Declaraci√≥n               | No                      |

En resumen, las expresiones siempre devuelven un valor que puede ser utilizado, mientras que las declaraciones simplemente realizan una acci√≥n.

## üß© Declaraci√≥n de funciones

Una **funci√≥n** en Kotlin es un bloque de c√≥digo que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es:

```kotlin showLineNumbers title="Pseudo-Kotlin"
fun functionName(parameter1: Type1, parameter2: Type2, ...): ReturnType {
    // Cuerpo de la funci√≥n
    return result
}
```

<Explanation>
    - **`fun`**: Palabra clave que define la funci√≥n.
    - **`functionName`**: Nombre de la funci√≥n.
    - **`parameter1`, `parameter2`**: Par√°metros junto con sus tipos.
    - **`ReturnType`**: Tipo de dato que devuelve la funci√≥n.
</Explanation>

### ‚ûï Ejemplo: Sumar dos n√∫meros

```kotlin showLineNumbers
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

Cuando una funci√≥n tiene una sola expresi√≥n, el cuerpo de la funci√≥n se puede simplificar:

```kotlin showLineNumbers
fun sum(a: Int, b: Int): Int = a + b
```

En funciones simples de una sola expresi√≥n, el tipo de retorno puede deducirse y omitirse:

```kotlin showLineNumbers
fun sum(a: Int, b: Int) = a + b
```

Esto hace que el c√≥digo sea m√°s conciso y legible.


::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n en funci√≥n del contexto. En el ejemplo anterior, como la funci√≥n es de una sola expresi√≥n, el tipo de retorno se puede inferir autom√°ticamente.

:::warning No abusar de la inferencia de tipos

Aunque la inferencia de tipos puede hacer que el c√≥digo sea m√°s limpio y conciso, es importante no abusar de ella. En algunos casos, especificar expl√≠citamente los tipos puede mejorar la legibilidad y la claridad del c√≥digo.

:::

::::


## üì¶ Declaraci√≥n de variables

Kotlin permite declarar variables usando `val` (inmutable) o `var` (mutable):

```kotlin showLineNumbers
val/var variableName: Type = value
```

### üîç Uso pr√°ctico

```kotlin showLineNumbers
val a: Int = 1
var b = 2
b = 3 // Reasignaci√≥n permitida para `var`
val c: Int
c = 3 // Asignaci√≥n diferida
```

:::tip[¬°Prefiere `val`!]

En general, es una buena pr√°ctica **preferir `val` sobre `var`** siempre que sea posible, ya que la inmutabilidad reduce la complejidad y facilita el razonamiento sobre el c√≥digo.
Declara variables mutables solo cuando sea necesario.

:::

:::danger Inmutabilidad

Aunque `val` denota inmutabilidad, el objeto referenciado puede ser mutable. Por ejemplo, si `val list = mutableListOf(1, 2, 3)`, la lista en s√≠ es mutable, pero no puedes reasignar `list` a otro objeto.

:::

## üìè Declaraci√≥n de constantes

Las constantes se declaran con `const` y su valor se establece en tiempo de compilaci√≥n:

```kotlin showLineNumbers
const val ZERO_KELVIN = -273.15
```

Las constantes solo pueden ser de tipos que tenemos seguridad que no cambiaran en tiempo de ejecuci√≥n
y no necesitan ser instanciados como objetos. Ejemplos de tipos que no pueden ser modificados son los tipos primitivos como los valores num√©ricos y los Strings. Ejemplos que no pueden ser constantes son los tipos que son instancias de objetos como las listas, diccionarios, y clases.

:::tip ¬øPor qu√© usar `const`?

Las constantes son √∫tiles debido a que, al calcularse en tiempo de compilaci√≥n, reducen la cantidad de c√≥mputos que deben hacerse en tiempo de ejecuci√≥n, mejorando as√≠ el rendimiento.

:::

:::info Nivel de archivo

Las constantes con `const val` solo se permiten **a nivel de archivo**, o dentro de `object` o `companion object`.

:::

### üü£ Ejercicio: C√°lculo del √Årea de un C√≠rculo

<Exercise>
    Implementa una funci√≥n `circleArea` que reciba el radio de un c√≠rculo y calcule su √°rea utilizando la f√≥rmula:

    $$
    A(r) = \pi r^2
    $$

    Donde:
    - $A(r)$ es el √°rea del c√≠rculo.
    - $\pi$ es la constante PI. Considera $\pi = 3.14159$.
    - $r$ es el radio del c√≠rculo.

    <Solution>
        ```kotlin showLineNumbers
        const val PI = 3.14159

        fun circleArea(radius: Double): Double = PI * radius * radius
        ```
    </Solution>
</Exercise>

## üîÄ Expresi√≥n `if`

El `if` en Kotlin puede usarse como una declaraci√≥n de control o una expresi√≥n que devuelve un valor:

```kotlin showLineNumbers
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

## üéõÔ∏è Expresi√≥n `when`

`when` es una forma m√°s flexible y clara de manejar m√∫ltiples condiciones:

```kotlin showLineNumbers
fun describe(obj: Any): String = when (obj) {
    1 -> "One"
    "Hello" -> "Greeting"
    is Long -> "Long"
    !is String -> "Not a string"
    else -> "Unknown"
}
```

:::warning Diferencia con pattern matching

Aunque `when` en Kotlin es similar al **pattern matching** en otros lenguajes, no es tan poderoso. Por ejemplo, no puede descomponer objetos en partes m√°s peque√±as como en Rust o Scala.

:::

### üîÅ Ejercicio: Reescribir usando `when`

<Exercise>
    Reescribe la funci√≥n `login` utilizando una expresi√≥n `when`.

    ```kotlin showLineNumbers
    fun login(username: String, password: String): Boolean {
        if (loginAttempts >= MAX_LOGIN_ATTEMPTS) {
            return false
        }
        if (isValidPassword(password)) {
            loginAttempts = 0
            return true
        }
        loginAttempts++
        return false
    }
    ```

    <Solution>
        ```kotlin showLineNumbers
        fun login(username: String, password: String): Boolean = when {
            loginAttempts >= MAX_LOGIN_ATTEMPTS -> false
            isValidPassword(password) -> {
                loginAttempts = 0
                true
            }
            else -> {
                loginAttempts++
                false
            }
        }
        ```
    </Solution>
</Exercise>

## üéØ Rangos

Kotlin permite crear rangos para iterar sobre secuencias de n√∫meros:

```kotlin showLineNumbers
for (i in 1..5) print(i) // Imprime: 12345
for (i in 5 downTo 1) print(i) // Imprime: 54321
for (i in 1..5 step 2) print(i) // Imprime: 135
for (i in 1..<5) print(i) // Imprime: 1234
for (i in 1 until 5) print(i) // Equivalente a 1..<5
```

### üî¢ Ejercicio: Suma de un rango

<Exercise>
    Implementa una funci√≥n que calcule la suma de todos los n√∫meros entre $a$ y $b$, incluyendo ambos extremos.

    ```kotlin showLineNumbers
    fun sumRange(a: Int, b: Int): Int {
        // Implementaci√≥n
    }
    ```


    <Hint hints={[
        <>
            En el caso de que $a$ sea mayor que $b$, puedes usar el rango descendente <code>a downTo b</code>.
        </>
    ]} />

    <Solution>
        ```kotlin showLineNumbers
        fun sumRange(a: Int, b: Int): Int {
            var sum = 0
            if (a <= b) {
                for (i in a..b) {
                    sum += i
                }
            } else {
                for (i in a downTo b) {
                    sum += i
                }
            }
            return sum
        }
        ```
    </Solution>

    <Solution title={"mejorada"}>
        ```kotlin showLineNumbers
        fun sumRange(a: Int, b: Int): Int {
            val range = if (a <= b) a..b else a downTo b
            return range.sum()
        }
        ```
    </Solution>
</Exercise>


## üö™ Funci√≥n `main`

La funci√≥n `main` es el punto de entrada de un programa Kotlin. Aqu√≠ hay un ejemplo simple:

```kotlin showLineNumbers
fun main() {
    println("Hello, World!")
}
```

<details>
    <summary>`println` como expresi√≥n</summary>

    En Kotlin, `println` es una funci√≥n que retorna un valor de tipo `Unit`, lo que significa que puede usarse como **una expresi√≥n**, no solo como una instrucci√≥n.

    Gracias a esto, podemos escribir la funci√≥n `main` de forma m√°s concisa utilizando la sintaxis de expresi√≥n √∫nica:

    ```kotlin showLineNumbers
    fun main() = println("Hello, World!")
    ```

    Aunque esta forma es perfectamente v√°lida, **no es tan com√∫n** en la pr√°ctica para funciones `main`, ya que suele preferirse la forma tradicional con bloques expl√≠citos. Aun as√≠, es √∫til saber que esta sintaxis es posible y puede resultar conveniente para programas simples o ejemplos breves.
</details>

:::note `println` y `print`

El nombre `println` proviene de *"print line"*, y su comportamiento refleja justamente eso: **imprime el texto seguido de un salto de l√≠nea**. En cambio, la funci√≥n `print` **imprime el texto tal cual**, sin agregar un salto de l√≠nea al final. Esto las hace √∫tiles en contextos distintos, seg√∫n si deseas continuar la salida en la misma l√≠nea o en una nueva.

Por ejemplo:

```kotlin showLineNumbers
for (i in 1..5) {
    print(i) // Imprime: 12345
    println(i) // Imprime: 1, 2, 3, 4, 5 (cada n√∫mero en una nueva l√≠nea)
}
```

Esto hace que `println("Texto")` sea equivalente a `print("Texto\n")`.

:::

### üßµ Interpolaci√≥n de cadenas

La **interpolaci√≥n de cadenas** en Kotlin permite insertar valores de variables o resultados de expresiones directamente dentro de un `String`, utilizando el s√≠mbolo `$`. Para variables simples, basta con `$variable`. Para expresiones m√°s complejas, se usan llaves: `${expresi√≥n}`.

#### Ejemplo:

En este ejemplo, mostramos el estado de un personaje seg√∫n sus puntos de vida (`hp`):

```kotlin showLineNumbers
val name = "Leif"
val hp = 24

println("Unit: $name | Status: ${if (hp <= 0) "defeated" else "active"}")
```

Esto generar√° la siguiente salida:

```plaintext
Unit: Leif | Status: active
```

La interpolaci√≥n de cadenas te permite construir mensajes din√°micos de forma concisa y expresiva, sin necesidad de concatenar manualmente con operadores como `+`.

<details>
    <summary>
        Funci√≥n `main` con argumentos de l√≠nea de comandos
    </summary>
    
    La funci√≥n `main` tambi√©n puede recibir argumentos de l√≠nea de comandos. Aqu√≠ hay un ejemplo:

    ```kotlin showLineNumbers
    fun main(args: Array<String>) {
        println("Welcome to Fabletown, ${args[0]}!")
    }
    ```

    #### üöÄ ¬øC√≥mo ejecutar este programa?

    Para compilar y ejecutar este programa desde la l√≠nea de comandos con Kotlin, sigue estos pasos:

    1. Guarda el archivo como `Main.kt`.
    2. Comp√≠lalo usando el compilador de Kotlin:
        ```bash
        kotlinc Main.kt -include-runtime -d main.jar
        ```
    3. Ejecuta el archivo `.jar` con argumentos:
        ```bash
        java -jar main.jar "Snow White"
        ```

    Esto mostrar√° la salida:
    ```
    Welcome to Fabletown, Snow White!
    ```

    :::warning[Argumentos y posici√≥n]
    
    Recuerda que `args[0]` acceder√° al **primer argumento** proporcionado. Si no se pasa ninguno, el programa lanzar√° una excepci√≥n `ArrayIndexOutOfBoundsException`.
    
    :::
</details>

## üéØ Conclusiones

En esta lecci√≥n aprendimos los fundamentos esenciales del lenguaje Kotlin, necesarios para construir programas claros, concisos y expresivos.

### üîë Puntos clave

- Kotlin distingue claramente entre **expresiones** (devuelven un valor) y **declaraciones** (ejecutan una acci√≥n).
- Las **funciones** pueden declararse de forma tradicional o como expresiones, aprovechando la inferencia de tipos para reducir el c√≥digo repetitivo.
- Las variables pueden ser **inmutables** (`val`) o **mutables** (`var`), y Kotlin favorece la inmutabilidad.
- Las **constantes** (`const val`) se eval√∫an en tiempo de compilaci√≥n y deben usarse para valores fijos primitivos.
- `if` y `when` son expresiones vers√°tiles que permiten control de flujo sin sacrificar expresividad.
- Los **rangos** permiten construir bucles claros y legibles, incluyendo rangos ascendentes, descendentes y con saltos.
- La funci√≥n `main` es el punto de entrada de cualquier programa Kotlin, y la **interpolaci√≥n de cadenas** permite construir mensajes din√°micos de manera elegante.

### üß∞ ¬øQu√© nos llevamos?

Esta base nos permitir√° comprender construcciones m√°s avanzadas de Kotlin y escribir c√≥digo m√°s idiom√°tico desde el principio. A medida que avancemos, estos conceptos nos servir√°n para dise√±ar funciones puras, aprovechar la programaci√≥n funcional, y escribir programas m√°s seguros y expresivos.

## üìñ Referencias

### üî• Recomendadas

- üåê Hello world | Kotlin. (2025, enero 25). Kotlin Help. https://kotlinlang.org/docs/kotlin-tour-hello-world.html
- üåê Basic types | Kotlin. (2024, septiembre 25). Kotlin Help. https://kotlinlang.org/docs/kotlin-tour-basic-types.html

### üîπ Adicionales

- üåê Strings | Kotlin. (2024, noviembre 27). Kotlin Help. https://kotlinlang.org/docs/strings.html
- üìö Hello, World! (2020). En Bruce Eckel & Svetlana Isakova, Atomic Kotlin (pp. 26‚Äì28). Leanpub.
