---
title: OOP en otros lenguajes
---

## Java

En esta sección, compararemos cómo se implementan los conceptos fundamentales de la **Programación Orientada a Objetos** en **Kotlin** y **Java**, resaltando las similitudes y diferencias entre ambos lenguajes.

### Objetos

En Java, para crear un singleton, se suele utilizar una clase con un constructor privado y un método estático que devuelve la única instancia. No existe una palabra clave específica como `object` en Kotlin.

```java
public class MySingleton {
    private static final MySingleton INSTANCE = new MySingleton();

    private MySingleton() {}

    public static MySingleton getInstance() {
        return INSTANCE;
    }

    public String name = "Singleton";

    public String greet() {
        return "Hello, " + name;
    }
}
```

#### Similitudes

- Ambos lenguajes permiten la creación de singletons para asegurar una única instancia de una clase u objeto.

#### Diferencias

- Kotlin proporciona la palabra clave `object` para crear singletons de manera concisa y sencilla.
- En Java, se requiere implementar manualmente el patrón singleton, lo que implica más código y cuidado para manejar posibles problemas de concurrencia.

### Clases

En Java, una clase se define con la palabra clave `class` y también puede contener campos (propiedades) y métodos. Para obtener el comportamiento similar al de las propiedades en Kotlin, se utilizan campos privados con métodos `get` y `set`, o una biblioteca como Lombok, veamos el segundo caso:

```java
public class Person {
    @Getter
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String greet() {
        return "Hello, " + name;
    }
}

Person person = new Person("Alice");
```

**Similitudes:**

- La sintaxis básica para definir clases es similar en ambos lenguajes.
- Ambos soportan instancias múltiples de clases.

**Diferencias:**

- Kotlin permite definir un constructor primario y propiedades directamente en la cabecera de la clase, lo que reduce la cantidad de código necesario.
- En Java, se requiere definir campos y constructores por separado, lo que puede resultar en código más extenso.

### Interfaces

En Java (a partir de Java 8), las interfaces pueden contener métodos abstractos y métodos por defecto con implementación.

:::danger Problema del diamante
Tanto Java como Kotlin permiten herencia múltiple a través de interfaces, lo que puede llevar a problemas de ambigüedad si dos interfaces tienen métodos con la misma firma. Este problema se conoce como el **problema del diamante** y lo analizaremos en detalle más adelante en el curso.
:::

```java
public interface Greeter {
    default String greet() {
        return "Hello";
    }
}

public class Person implements Greeter {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String greet() {
        return "Hello, " + name;
    }
}
```

**Similitudes:**

- Ambos lenguajes permiten definir interfaces con métodos abstractos y métodos con implementación por defecto.

**Diferencias:**

- En Kotlin, las interfaces pueden contener propiedades abstractas o con implementación, mientras que en Java las interfaces no pueden tener campos de instancia, solo constantes (`public static final`).

### Clases Abstractas

En Java, las clases abstractas también pueden contener métodos abstractos y métodos con implementación, y no pueden ser instanciadas.

```java
public abstract class AbstractAnimal {
    public abstract String sound();
    public String walk() {
        return "Walking...";
    }
}

public class Dog extends AbstractAnimal {
    @Override
    public String sound() {
        return "Woof";
    }
}
```

**Similitudes:**

- El concepto y uso de clases abstractas es prácticamente idéntico en ambos lenguajes.

**Diferencias:**

- La sintaxis varía ligeramente debido a las diferencias de lenguaje, pero el comportamiento es el mismo.

### Encapsulación

Java utiliza modificadores de acceso similares:

- `public`: Accesible desde cualquier lugar.
- `private`: Accesible solo dentro de la clase donde se declara.
- `protected`: Accesible en la clase, sus subclases y clases del mismo paquete.
- *Default* (sin modificador): Accesible dentro del mismo paquete (package-private).

:::warning package-private
Si bien *package-private* ofrece un nivel de encapsulación adicional, no es completamente seguro, especialmente en bibliotecas de software, ya que lxs usuarixs pueden definir clases en el mismo paquete y acceder a los miembros *package-private*. Por esta razón Kotlin no incluye un modificador equivalente. Dicho esto, *package-private* sigue siendo útil, pero debe usarse con precaución.
:::

```java
public class Person {
    private String name = "Alice";
    protected int age = 30;

    String greet() { // Package-private
        return "Hello, " + name;
    }
}
```

**Similitudes:**

- Ambos lenguajes proporcionan modificadores de acceso para controlar la visibilidad y encapsulación.

**Diferencias:**

- Kotlin introduce el modificador `internal`, que restringe la visibilidad al módulo.
- En Java, el acceso *package-private* se logra omitiendo el modificador, mientras que en Kotlin no existe un modificador equivalente.

### Constructores Primarios y Secundarios

En Java, todos los constructores se definen dentro del cuerpo de la clase. No existe una distinción explícita entre constructores primarios y secundarios.

```java
public class Person {
    private String name;
    private int age;

    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**Similitudes:**

- Ambos lenguajes permiten tener múltiples constructores con diferentes parámetros (sobrecarga de constructores).

**Diferencias:**

- Kotlin ofrece una sintaxis más concisa con el constructor primario en la cabecera de la clase.
- En Kotlin, el bloque `init` permite agregar lógica de inicialización que se ejecuta después del constructor primario.

Para hacer una comparación similar entre **Kotlin** y **Python** en cuanto a la Programación Orientada a Objetos (OOP), debemos tener en cuenta las características de **Python** como un lenguaje dinámico que recientemente ha introducido **protocols**, los cuales son similares a las interfaces de Kotlin. A continuación, presentamos una sección comparativa de conceptos clave.

## Python

Para abordar las diferencias entre los constructores secundarios en Kotlin y su equivalente en Python, podemos destacar cómo Python logra un comportamiento similar mediante parámetros por defecto, `*args` y `**kwargs`.

### Constructores en Python

En Python, no hay una distinción explícita entre constructores primarios y secundarios, pero podemos replicar comportamientos similares usando parámetros por defecto o manejando argumentos variables con `*args` y `**kwargs`. Esto permite definir una lógica más flexible de inicialización.

```python
class Person:
    def __init__(self, name, age=0, *args, **kwargs):
        self.name = name
        self.age = age
        # args y kwargs permiten agregar más argumentos opcionales
```

### `__new__` vs `__init__`

En Python, el método `__new__` es responsable de la creación de la instancia del objeto, mientras que `__init__` se encarga de inicializar los atributos después de que el objeto ha sido creado. `__new__` es crucial en casos como el patrón singleton, donde se necesita controlar la creación de la instancia antes de que se inicialice.

```python
class MySingleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(MySingleton, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        self.name = "Singleton"
```

- **`__new__`**: Es invocado primero para crear una nueva instancia. Ideal para control avanzado sobre la creación, como en los singletons.
- **`__init__`**: Se invoca después de `__new__` y se utiliza para inicializar la instancia.

Esto permite que `__new__` controle cuántas veces se crea una instancia (como en un singleton), mientras que `__init__` configura los atributos una vez que la instancia está asegurada.

### Clases

En Python, al igual que en Kotlin, se pueden definir clases con un constructor y métodos.

```python
class Person:
    def __init__(self, name):
        self.name = name

    def greet(self):
        return f"Hello, {self.name}"

person = Person("Alice")
```

**Similitudes:**

- Ambos lenguajes permiten definir clases con un constructor, y se pueden instanciar múltiples veces.

**Diferencias:**

- Kotlin define propiedades y el constructor principal en la cabecera de la clase, mientras que en Python se usa el método especial `__init__` para inicializar los atributos de una instancia.

### Protocols (similares a las Interfaces en Kotlin)

Con la introducción de **protocols** en Python (a partir de Python 3.8), es posible definir un contrato de comportamiento que las clases deben implementar, similar a las interfaces en Kotlin.

```python
from typing import Protocol

class Greeter(Protocol):
    def greet(self) -> str:
        ...

class Person:
    def __init__(self, name: str):
        self.name = name

    def greet(self) -> str:
        return f"Hello, {self.name}"

person = Person("Alice")
```

**Similitudes:**

- Tanto las interfaces en Kotlin como los protocols en Python permiten definir métodos abstractos que las clases deben implementar.

**Diferencias:**

- En Python, los **protocols** permiten la definición de contratos de comportamiento para clases, pero no son estrictamente necesarios, ya que Python es un lenguaje dinámico. En cambio, en Kotlin, las **interfaces** son más estrictas y forman parte integral del sistema de tipos.

### Clases Abstractas

En Python, las clases abstractas se definen mediante el módulo `abc`. Estas clases pueden tener métodos abstractos y no pueden ser instanciadas directamente.

```python
from abc import ABC, abstractmethod

class AbstractAnimal(ABC):
    @abstractmethod
    def sound(self):
        pass

    def walk(self):
        return "Walking..."

class Dog(AbstractAnimal):
    def sound(self):
        return "Woof"

dog = Dog()
```

**Similitudes:**

- En ambos lenguajes, las clases abstractas proporcionan un contrato que debe ser implementado por las subclases, y no pueden ser instanciadas directamente.

**Diferencias:**

- Python utiliza el módulo `abc` y los decoradores para definir clases abstractas, mientras que Kotlin utiliza la palabra clave `abstract` directamente en la definición de la clase y sus métodos.

### Encapsulación

En Python, la encapsulación se maneja a través de convenciones y modificadores de acceso. Se utiliza un guion bajo (`_`) para indicar que un atributo es privado, aunque no es estrictamente obligatorio.

```python
class Person:
    def __init__(self, name):
        self._name = name  # Private by convention

    def greet(self):
        return f"Hello, {self._name}"

person = Person("Alice")
```

También se puede utilizar el prefijo `__` (doble guion bajo) para señalar que un atributo es privado, lo que activa el **name mangling**. Esto significa que Python cambiará internamente el nombre del atributo para evitar que sea fácilmente accesible desde fuera de la clase. Sin embargo, no es una verdadera restricción de acceso, ya que aún se puede acceder a estos atributos con técnicas específicas.

```python
class Person:
    def __init__(self, name):
        self.__name = name  # Name mangling (private by convention)

    def greet(self):
        return f"Hello, {self.__name}"

person = Person("Alice")
print(person._Person__name)  # Accede al atributo privado
```

Este mecanismo simplemente dificulta el acceso accidental, pero no lo impide.

**Similitudes:**

- Ambos lenguajes soportan la encapsulación, aunque de manera diferente.

**Diferencias:**

- En Kotlin, los modificadores de acceso como `private` y `internal` son explícitos y proporcionan control más estricto. En Python, la privacidad es una convención, y no hay un sistema de encapsulación tan rígido como en Kotlin.

### Constructores Primarios y Secundarios

En Python, solo se utiliza un constructor (`__init__`), no hay distinción explícita entre constructores primarios y secundarios como en Kotlin.

```python
class Person:
    def __init__(self, name, age=0):
        self.name = name
        self.age = age
```

**Similitudes:**

- Ambos lenguajes permiten tener múltiples formas de inicializar una clase (Kotlin con constructores secundarios, Python con parámetros opcionales).

**Diferencias:**

- Kotlin permite un constructor primario y secundarios explícitos, mientras que en Python, se gestiona con argumentos opcionales en el método `__init__`.
