---
title: Programación Orientada a Objetos en Swift
---
import {Cons, ProCons, Pros} from "/src/components/cajitas/ProCons";
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<ReadingTime/>

En Swift, la programación orientada a objetos (OOP) sigue principios similares a los de Kotlin, pero con algunas diferencias clave en la implementación y capacidades que vale la pena destacar. A continuación, veremos cómo ambos lenguajes abordan conceptos fundamentales de OOP y resaltaremos lo que es posible en un lenguaje pero no en el otro.

### Singleton

En **Swift**, los singletons se definen usando `static let` dentro de una clase o estructura. A diferencia de Kotlin, que tiene una palabra clave específica (`object`), en Swift se utiliza una implementación de patrón de diseño:

```swift
class MySingleton {
    static let shared = MySingleton()
    var name = "Singleton"

    func greet() -> String {
        return "Hello, \(name)"
    }
}
```

#### Diferencias y Limitaciones

- En **Kotlin**, el uso de `object` simplifica la creación de un singleton al no necesitar una clase separada. Esto lo hace más conciso y claro.
- En **Swift**, la implementación requiere definir una clase y luego crear una instancia estática compartida, lo cual es más manual.

### Clases e Inicialización

Swift permite una **inicialización más flexible** con **convenience initializers**, una funcionalidad que no está presente en Kotlin. Los **convenience initializers** permiten definir constructores adicionales que llaman a un inicializador designado, facilitando la sobrecarga de constructores en un enfoque estructurado.

```swift
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }

    convenience init(name: String) {
        self.init(name: name, age: 0)
    }
}
```

#### Diferencias y Capacidades

- **Swift**: La capacidad de tener múltiples inicializadores y los **convenience initializers** otorgan más flexibilidad para inicializar objetos.
- **Kotlin**: En Kotlin, se usa un constructor primario y, si se requiere más de un constructor, se definen **constructores secundarios** con lógica adicional, pero no hay una forma directa de tener inicializadores tan flexibles como en Swift.

### Propiedades y Encapsulación

Ambos lenguajes permiten encapsulación y tienen **modificadores de acceso** similares, pero con diferencias sutiles:

- **Swift** introduce `fileprivate`, que permite la visibilidad solo dentro del archivo de origen. Esta es una distinción útil que no existe en Kotlin, donde los niveles de acceso son `public`, `private`, `protected`, e `internal`.
- **Kotlin** utiliza `internal` para limitar el acceso al módulo, lo cual no existe en Swift.

### Protocolos (Interfaces en Kotlin)

En Swift, los **protocolos** son similares a las **interfaces** en Kotlin, pero con diferencias en su aplicabilidad. Los protocolos pueden ser aplicados a **clases**, **estructuras** y **enumeraciones**, mientras que en Kotlin, las **interfaces** pueden ser implementadas tanto por **clases** como por **enumeraciones**, pero no por **estructuras**, ya que Kotlin no admite `structs`.

```swift
protocol Greeter {
    func greet() -> String
}

struct Person: Greeter {
    var name: String
    func greet() -> String {
        return "Hello, \(name)"
    }
}
```

#### Diferencias y Capacidades

- En **Swift**, los protocolos son más versátiles porque se pueden aplicar a **classes**, **structs**, y **enums**, proporcionando un enfoque más amplio y reutilizable.
- En **Kotlin**, las interfaces se pueden aplicar a **clases** y **enumeraciones**, pero no a estructuras (ya que no existen en el lenguaje). Además, Kotlin permite **interfaces con implementaciones predeterminadas**, mientras que Swift no admite métodos predeterminados en protocolos, lo que hace que Kotlin tenga un enfoque diferente en la reutilización de código.

### Clases Abstractas vs. Protocolos con Implementaciones

Kotlin tiene **clases abstractas** que permiten definir métodos implementados y no implementados. En Swift, en lugar de clases abstractas, se usa una combinación de protocolos y **extensions** para lograr comportamientos similares:

```swift
protocol Animal {
    func sound() -> String
}

extension Animal {
    func walk() -> String {
        return "Walking..."
    }
}
```

En Swift, las **extensions** de protocolos pueden añadir comportamientos predeterminados, pero no pueden almacenar estado (propiedades). Esto significa que en Swift no se puede replicar completamente el comportamiento de una clase abstracta con estado como en Kotlin.

## Comparación Final

| **Característica**               | **Swift**                                                                                   | **Kotlin**                                                                                   |
|----------------------------------|---------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| ...                              | ...                                                                                         | ...                                                                                          |
<ProCons>
    <Pros>

    </Pros>
    <Cons>

    </Cons>
</ProCons>