---
title: Sobrecarga de operadores en otros lenguajes
---

## C++

En **C++**, la sobrecarga de operadores es una característica poderosa que permite a los programadores definir o redefinir el comportamiento de operadores para tipos de datos definidos por el usuario. Esto permite que los objetos se manipulen utilizando notación matemática estándar, mejorando la legibilidad y usabilidad del código.

### Sobrecarga de Operadores en C++

Para sobrecargar un operador en C++, se define una función miembro o una función amiga con una firma específica. Por ejemplo, para sobrecargar el operador `+`, se puede hacer lo siguiente:

```cpp
class Complex {
public:
    double real;
    double imaginary;

    Complex(double r, double i) : real(r), imaginary(i) {}

    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imaginary + other.imaginary);
    }

    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << "(" << c.real << ", " << c.imaginary << ")";
        return os;
    }
};
```

En este código:

- **`operator+`**: Es una función miembro que sobrecarga el operador `+`, permitiendo sumar dos objetos `Complex`.
- **`operator<<`**: Es una función amiga que sobrecarga el operador de inserción en flujo `<<` para facilitar la impresión del objeto.

:::info ``<<`` y ``friend``
La palabra clave friend permite que una función no miembro de la clase acceda a los miembros privados y protegidos de dicha clase. En este ejemplo, ``operator<<`` es una función amiga que permite usar ``std::cout`` para imprimir objetos ``Complex``, accediendo directamente a sus atributos.
:::

### Uso en C++

Podemos utilizar los operadores sobrecargados de manera intuitiva:

```cpp
#include <iostream>

int main() {
    Complex number1(1.0, 2.0);
    Complex number2(3.0, 4.0);
    Complex sumResult = number1 + number2;
    std::cout << "Suma: " << sumResult << std::endl;
    return 0;
}
```

La salida será:

```
Suma: (4.0, 6.0)
```

### Comparación

| Característica         | Kotlin                              | C++                                       |
|------------------------|-------------------------------------|-------------------------------------------|
| Definición de operador | `operator fun plus(other: Complex)` | `Complex operator+(const Complex&)`       |
| Palabra clave          | `operator`                          | `operator` forma parte del nombre         |
| Nombre del método      | Predefinido (e.g., `plus` para `+`) | `operator+`, `operator-`, etc.            |
| Expresividad           | Similar a las funciones regulares   | Funciones miembro o amigas                |
| Uso en código          | `val result = obj1 + obj2`          | `Complex result = obj1 + obj2;`           |

## Python

Tanto Kotlin como Python permiten la sobrecarga de operadores, pero lo hacen de maneras ligeramente diferentes. Mientras que Kotlin utiliza la palabra clave `operator` y nombres de funciones predefinidas, Python aprovecha métodos especiales con nombres predefinidos, conocidos como *dunder methods* (por el prefijo y sufijo doble de guión bajo, como `__add__`).

### Sobrecarga de Operadores en Python

En Python, la sobrecarga de operadores se realiza definiendo estos métodos especiales dentro de una clase. Por ejemplo, para sobrecargar el operador `+`, se implementa el método `__add__`.

```python
class Complex:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __add__(self, other):
        return Complex(self.real + other.real, self.imaginary + other.imaginary)

    def __str__(self):
        return f"({self.real}, {self.imaginary})"
```

En este código:
- `Complex` es una clase que almacena las partes real e imaginaria de un número complejo.
- El método `__add__` sobrecarga el operador `+`, permitiendo la suma de dos objetos `Complex`.
- `__str__` está definido para que, al imprimir el objeto, se muestre de manera legible.

### Uso en Python

De manera similar a Kotlin, podemos sumar números complejos de una manera intuitiva utilizando el operador `+`:

```python
number1 = Complex(1.0, 2.0)
number2 = Complex(3.0, 4.0)
sum_result = number1 + number2
print(f"Suma: {sum_result}")
```

La salida será:

```plaintext
Suma: (4.0, 6.0)
```

### Comparación

| Característica         | Kotlin                              | Python                                    |
|------------------------|-------------------------------------|-------------------------------------------|
| Definición de operador | `operator fun plus(other: Complex)` | `def __add__(self, other):`               |
| Palabra clave          | `operator`                          | No es necesaria                           |
| Nombre del método      | Predefinido (e.g., `plus` para `+`) | Dunder methods (e.g., `__add__` para `+`) |
| Expresividad           | Similar a las funciones regulares   | Métodos especiales con sintaxis estándar  |
| Uso en código          | `val result = obj1 + obj2`          | `result = obj1 + obj2`                    |

## Scala

En **Scala**, no existe el concepto de "sobrecarga de operadores" como en otros lenguajes, ya que todos los operadores son simplemente funciones con nombres simbólicos. Esto significa que puedes definir cualquier función con un símbolo como nombre (como `+`, `-`, `*`, etc.), y el compilador lo tratará como si fuera un operador.

### Definición de funciones con nombres simbólicos en Scala

En lugar de sobrecargar operadores, en Scala simplemente se define una función con el símbolo deseado como nombre. Por ejemplo, para la clase `Complex`, podemos definir una función `+` de la siguiente manera:

```scala
case class Complex(real: Double, imaginary: Double) {

  def +(other: Complex): Complex =
    Complex(this.real + other.real, this.imaginary + other.imaginary)

  override def toString: String = s"($real, $imaginary)"
}
```

### Uso en Scala

El uso de funciones con nombres simbólicos en Scala se ve igual que el uso de operadores tradicionales en otros lenguajes:

```scala
object Main extends App {
  val number1 = Complex(1.0, 2.0)
  val number2 = Complex(3.0, 4.0)
  val sumResult = number1 + number2
  println(s"Suma: $sumResult")
}
```

Salida:

```
Suma: (4.0, 6.0)
```

### Comparación

| Característica         | Kotlin                              | Scala                                     |
|------------------------|-------------------------------------|-------------------------------------------|
| Definición de operador | `operator fun plus(other: Complex)` | `def +(other: Complex): Complex`          |
| Palabra clave          | `operator`                          | No es necesaria                           |
| Operadores predefinidos| Solo operadores específicos         | Los operadores son nombres simbólicos     |
| Expresividad           | Similar a las funciones regulares   | Cualquier símbolo puede ser usado         |
| Uso en código          | `val result = obj1 + obj2`          | `val result = obj1 + obj2`                |

### Semejanzas con Kotlin

- **Simplicidad**: Ambos lenguajes permiten definir funciones que se comportan como operadores de manera simple y clara, mejorando la legibilidad del código.
- **Inmutabilidad**: Tanto en Kotlin como en Scala, las operaciones que involucran objetos como `Complex` no modifican el estado del objeto, sino que devuelven un nuevo objeto.
- **Concisión**: Ambos lenguajes permiten escribir código conciso, y las funciones se comportan como operadores de una manera muy intuitiva.

### Diferencias con Kotlin

- **Palabra clave `operator`**: En Kotlin, la palabra clave `operator` es necesaria para marcar una función que puede usarse como un operador, mientras que en Scala no se requiere ninguna palabra clave especial.
- **Uso de cualquier símbolo en Scala**: Scala permite una mayor flexibilidad al permitir que cualquier símbolo sea el nombre de una función, mientras que Kotlin tiene un conjunto predefinido de operadores que se pueden sobrecargar.
- **Funciones simbólicas en general**: Mientras que Kotlin restringe los operadores a un conjunto limitado de nombres, Scala permite que cualquier método con nombre simbólico (no solo `+` o `-`, por ejemplo) se use de forma similar a los operadores, lo que ofrece más expresividad y flexibilidad.
