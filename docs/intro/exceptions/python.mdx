---
title: Excepciones en Python
---
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>

Al igual que **Kotlin**, Python también tiene un manejo de excepciones basado en bloques `try-catch` (o `try-except`), aunque con algunas diferencias en su sintaxis y convenciones. A continuación, se destacan las similitudes y diferencias clave.

## Lanzar Excepciones

En ambos lenguajes, se puede lanzar una excepción usando `throw` en Kotlin y `raise` en Python. Sin embargo, existe una diferencia importante en las convenciones. En Python, se usa la palabra **`Error`** en los nombres de las excepciones para indicar un fallo esperado, como `ValueError`, mientras que en Kotlin **`Error`** denota algo más grave y que típicamente no debería capturarse, como en el caso de errores fatales del sistema (`OutOfMemoryError`).

```python
raise ValueError("Cannot divide by zero")
```

En Kotlin, las excepciones que lanzamos son generalmente subclases de `Exception`, mientras que `Error` en Kotlin se refiere a fallos catastróficos que el programa no debería intentar manejar.

## Capturar Excepciones

Ambos lenguajes usan `try-catch` (o `try-except` en Python) para capturar excepciones. Sin embargo, en Python se puede usar un bloque `else` para definir código que debe ejecutarse si **no** se lanza ninguna excepción, una característica que no existe en Kotlin.

```python showLineNumbers
def safe_divide(a: float, b: float) -> float | None:
    try:
        return a / b
    except ZeroDivisionError as e:
        print(f"Error: {e}")
        return None
    else:
        print("Division successful")
```

## Bloque `finally`

En ambos lenguajes, el bloque `finally` se ejecuta siempre, independientemente de si una excepción fue lanzada o no. Esto se utiliza típicamente para la liberación de recursos.

```python
try:
    # Some code
except Exception as e:
    # Handle exception
finally:
    print("Cleaning up resources")
```

## Excepciones Personalizadas

En ambos lenguajes, puedes definir excepciones personalizadas. En Python, se sigue la convención de agregar "Error" al nombre de la excepción, mientras que en Kotlin las excepciones suelen derivar de `Exception`.

```python
class CustomError(Exception):
    def __init__(self, message):
        super().__init__(message)
```

## Comparación final

| Aspecto                            | Kotlin                                                                       | Python                                                                                                    |
|------------------------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|
| **Lanzar Excepciones**             | `throw` para lanzar excepciones, como `IllegalArgumentException`.            | `raise` para lanzar excepciones, como `ValueError`.                                                       |
| **Convención de nombres**          | `Error` se reserva para fallos críticos, como `OutOfMemoryError`.            | Las excepciones personalizadas y del sistema terminan en **`Error`** (ej. `ValueError`, `TypeError`).     |
| **Capturar Excepciones**           | `try-catch` para capturar excepciones.                                       | `try-except` para capturar excepciones. Incluye un bloque `else`.                                         |
| **Bloque `finally`**               | Ejecuta siempre, independientemente de si se lanzó una excepción.            | Funciona igual que en Kotlin, siempre se ejecuta.                                                         |
| **Excepciones Personalizadas**     | Heredan de `Exception`. Ejemplo: `class CustomException : Exception()`.      | Heredan de `Exception` con la convención de terminar en `Error`. Ejemplo: `class CustomError(Exception)`. |
| **Else en Captura de Excepciones** | No disponible.                                                               | `else` se ejecuta si no se lanza ninguna excepción en el bloque `try`.                                    |
| **Chequeo de Excepciones**         | No tiene excepciones chequeadas.                                             | Tampoco tiene excepciones chequeadas.                                                                     |
| **Manejo de errores**              | Uso preferido de tipos anulables (`nullable`) y `Result`.                    | Se manejan principalmente con excepciones.                                                                |
| **Propagación de Excepciones**     | Las excepciones se propagan si no se capturan, sin necesidad de declararlas. | Funciona de manera similar a Kotlin.                                                                      |

## Resumen

Kotlin y Python manejan las excepciones de manera similar en muchos aspectos, pero tienen diferencias importantes en cuanto a las convenciones y las funcionalidades adicionales, como el uso del bloque `else` en Python. Además, Kotlin introduce enfoques adicionales como los tipos anulables para manejar errores sin lanzar siempre excepciones.
