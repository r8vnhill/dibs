---
title: Excepciones en Java
---
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>

Al igual que **Kotlin**, **Java** es conocido por su manejo de excepciones robusto. Sin embargo, aunque comparten muchas similitudes, existen diferencias clave entre cómo se gestionan las excepciones en estos lenguajes. A continuación, exploraremos esas diferencias y similitudes.

## Lanzar Excepciones

En ambos lenguajes, para lanzar una excepción se utiliza `throw`. En Java, al igual que en Kotlin, podemos lanzar cualquier subclase de `Throwable`, como `Exception` o `RuntimeException`.

```java
public int divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("Cannot divide by zero");
    }
    return a / b;
}
```

### Diferencia clave: Excepciones Chequeadas

Una diferencia importante es que en Java existen **excepciones chequeadas** y **no chequeadas**. Las excepciones chequeadas (subclases de `Exception`, excepto `RuntimeException`) deben ser manejadas o declaradas explícitamente en la firma del método usando la palabra clave `throws`. En Kotlin, **no existen excepciones chequeadas**, lo que simplifica el manejo de excepciones.

```java
public void riskyOperation() throws IOException {
    throw new IOException("Something went wrong");
}
```

## Capturar Excepciones

Ambos lenguajes utilizan bloques `try-catch` para manejar excepciones, pero la sintaxis de Kotlin es más compacta y puede devolver valores directamente dentro del bloque `try`.

```java
public Integer safeDivide(int a, int b) {
    try {
        return a / b;
    } catch (ArithmeticException e) {
        System.out.println("Error: " + e.getMessage());
        return null;
    }
}
```

### Bloque `finally`

El comportamiento del bloque `finally` es idéntico en ambos lenguajes: se ejecuta siempre, tanto si ocurre una excepción como si no. Esto se utiliza normalmente para liberar recursos como conexiones a bases de datos o archivos.

```java
try {
    // Código que puede lanzar una excepción
} catch (Exception e) {
    // Manejo de la excepción
} finally {
    System.out.println("Cleaning up resources");
}
```

## Excepciones Personalizadas

En ambos lenguajes, puedes crear excepciones personalizadas heredando de `Exception`. El proceso en Java es prácticamente idéntico a Kotlin:

```java
public class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

## Comparación Final

| Aspecto                        | Kotlin                                                              | Java                                                                 |
|--------------------------------|---------------------------------------------------------------------|----------------------------------------------------------------------|
| **Lanzar Excepciones**         | `throw` para lanzar excepciones, como `IllegalArgumentException`.   | Igual que Kotlin, `throw` para lanzar excepciones.                   |
| **Chequeo de Excepciones**     | No tiene excepciones chequeadas.                                    | Tiene excepciones chequeadas que deben declararse o manejarse.       |
| **Capturar Excepciones**       | Usa `try-catch` y puede devolver valores dentro del bloque `try`.   | Usa `try-catch` pero no permite devolver valores directamente.       |
| **Bloque `finally`**           | Igual que en Java, se ejecuta siempre.                              | Se ejecuta siempre, independientemente de si se lanzó una excepción. |
| **Excepciones Personalizadas** | Heredan de `Exception` o `RuntimeException`.                        | Heredan de `Exception` o `RuntimeException`.                         |
| **Propagación de Excepciones** | Se propagan sin necesidad de declararlas explícitamente.            | Las excepciones chequeadas deben declararse con `throws`.            |
| **Optimización Funcional**     | Puede usar tipos anulables o `Result` para un manejo más funcional. | Principalmente usa excepciones para manejar errores.                 |

## Resumen

Si vienes de Java, verás que el manejo de excepciones en Kotlin es muy similar, con algunas simplificaciones notables como la **ausencia de excepciones chequeadas** y la posibilidad de devolver valores directamente en bloques `try-catch`. Además, en Kotlin es común preferir estructuras funcionales como `Result` o tipos anulables para manejar errores, reduciendo la necesidad de excepciones en muchos casos.

<References references={[
    {
        title: "",
        url: "",
        type: "article",
        author: "",
        publishedDate: "",
    },
    {
        accessedDate: '',
        siteOrAuthor: '',
        title: '',
        type: 'web',
        url: '',
    },
    {
        title: "",
        bookTitle: "",
        pages: "",
        location: "",
        publisher: "",
        year: "",
        type: "book",
        author: ''
    },
]}/>
