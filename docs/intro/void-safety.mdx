---
title: Void-Safety
---
import References from "../../src/components/ReferencesComponent";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## El Problema de los Punteros Nulos

Los punteros o referencias nulas, descritos por Tony Hoare como "[el error de mil millones de dólares](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)", son una fuente común de errores en tiempo de ejecución. Este problema ocurre cuando una variable, que se espera que contenga una referencia a un objeto, en realidad contiene un valor nulo. Al intentar acceder a los métodos o propiedades de dicho objeto nulo, se producen fallos críticos.

## Motivación

El manejo inadecuado de valores nulos es una causa importante de errores difíciles de detectar y que pueden comprometer la estabilidad y seguridad del software. En proyectos grandes, estos errores son aún más peligrosos y costosos de corregir. Por ello, es fundamental gestionar correctamente los valores nulos para asegurar la calidad y fiabilidad del software desde el inicio.

## Enfoques en Diferentes Lenguajes

- **Java**: En Java, las referencias nulas son comunes, lo que obliga a lxs desarrolladorxs a realizar verificaciones constantes para evitar errores, lo que lleva a código redundante y difícil de mantener. Las excepciones `NullPointerException` son frecuentes si no se manejan adecuadamente.

- **C#**: En C#, los tipos de referencia son no anulables por defecto, pero se pueden declarar como anulables utilizando `?`. Esto obliga a lxs desarrolladorxs a tener más cuidado con los valores nulos y mejora la seguridad del código.

- **Scala**: Scala introduce el tipo `Option`, el cual obliga a lxs desarrolladorxs a manejar explícitamente la posibilidad de que no haya un valor (`None`). Sin embargo, no elimina por completo el riesgo de `NullPointerException`, ya que `Option` puede contener un valor nulo si no se maneja correctamente.

## Solución en Kotlin: Seguridad de Tipos frente a Nulos

Kotlin introduce un sistema de tipos que diferencia entre referencias anulables y no anulables, evitando así la mayoría de los errores de `NullPointerException` en tiempo de ejecución.

### Tipos no anulables y no anulables

En Kotlin, las variables son no anulables por defecto, lo que significa que no pueden contener `null` a menos que se declare explícitamente con `?`:

```kotlin
var a: String = "Not null"
var b: String? = "Maybe null"
a = null // Error: a is not nullable
b = null // Allowed: b is nullable
```

### Inferencia de tipos y nulabilidad

La inferencia de tipos en Kotlin también aplica a los valores anulables, siguiendo las mismas reglas:

```kotlin
var c = "Hello" // Inferred type as String, not nullable
c = null // Error: c is not nullable
```

### Llamadas Seguras en Kotlin

Kotlin maneja las variables nulas de forma explícita, asegurando que no se acceda a métodos o propiedades sin verificar primero si son nulas. Si una variable puede ser nula, debes validar su estado antes de usarla:

```kotlin
val a: String? = TODO()
if (a != null) {
    println(a.length) // Acceso seguro
} else {
    println("a is null")
}
```

Kotlin utiliza los [Smart Casts](https://kotlinlang.org/docs/typecasts.html#smart-casts) para permitir el acceso seguro a las propiedades de una variable tras verificar su nulabilidad.

Para simplificar este proceso, puedes usar el **operador de llamada segura** (`?.`), que realiza la operación solo si la variable no es nula:

```kotlin
println(a?.length)
```

Aquí, `a?.length` devolverá `null` si `a` es nulo, evitando errores en tiempo de ejecución.

#### Función `let`

La función `let` es útil para ejecutar un bloque de código solo cuando una variable no es nula. Este método toma la variable no nula y la pasa como argumento al bloque de código que se ejecuta dentro de `let`:

```kotlin
a?.let { str -> println(str.length) }
```

En este caso, si `a` no es nulo, el valor de `a` es pasado al bloque como `str`. Dentro del bloque, puedes acceder a las propiedades y métodos de `a` de forma segura utilizando `str`. Si `a` es nulo, el bloque de código no se ejecuta y el programa continúa sin lanzar excepciones.

Esto hace que `let` sea una forma limpia y segura de manejar valores opcionales, evitando verificaciones manuales de nulabilidad y mejorando la legibilidad del código.

:::note Variable implícita `it`
En Kotlin, cuando se pasa un solo parámetro a una función lambda, puedes referirte a él de forma implícita como `it`. Esto es útil para reducir la verbosidad del código y hacerlo más legible.

Por ejemplo, en `a?.let { println(it.length) }`, `it` representa el valor de `a` dentro del bloque de código de `let`, haciéndolo equivalente a `a?.let { str -> println(str.length) }`.
:::

### Operador Elvis

El operador Elvis (`?:`) ofrece una forma eficiente de manejar valores nulos, permitiendo retornar un valor por defecto cuando una expresión resulta nula:

```kotlin
val a: String? = TODO()
val l = a?.length ?: -1 // Si 'a' es nulo, 'l' será -1
```

Este operador es muy útil para evitar valores nulos en el flujo de datos sin agregar condicionales complejos, lo que hace que el código sea más limpio y fácil de leer.

:::tip Ejercicio
<Tabs>
    <TabItem value="Enunciado" label="Enunciado">
        1. **Datos de Entrada**: Crea una lista de cadenas opcionales (`List<String?>`). Algunas cadenas pueden ser `null`, y el objetivo es procesar esta lista.
        2. **Procesamiento de Datos**:
            - Imprime el largo de cada cadena si no es nula.
            - Si una cadena es nula, imprime `"Cadena no disponible"`.
            - Para las cadenas no nulas, convierte el texto a mayúsculas y muéstralo.
        3. **Salida del Programa**: Imprime el largo de cada cadena, o `"Cadena no disponible"` si es nula. Después, imprime el texto en mayúsculas si la cadena no es nula.
    </TabItem>
    <TabItem value="Solución" label="Solución">
        ```kotlin
        fun procesarCadenas(cadenas: List<String?>) {
            for (cadena in cadenas) {
                // Usar el operador Elvis ?: para manejar el caso de cadenas nulas
                val longitud = cadena?.length ?: "Cadena no disponible"
                println("Longitud: $longitud")

                // Usar let para convertir las cadenas no nulas a mayúsculas
                cadena?.let {
                    println("Texto en mayúsculas: ${it.uppercase()}")
                } ?: println("Texto en mayúsculas no disponible")
            }
        }

        fun main() {
            val cadenas = listOf("Hola", null, "Kotlin", null, "Mundo")
            procesarCadenas(cadenas)
        }
        ```
    </TabItem>
</Tabs>
:::

<details>
    <summary>Ejemplos en otros lenguajes</summary>
    ## Ejemplos en Otros Lenguajes

    ### Scala

    Utiliza `Option`, `map`, y `foreach` para trabajar con valores opcionales de forma funcional, similar a cómo Kotlin usa `?.let`.

    ```scala
    val cadenas = List(Some("Hola"), None, Some("Scala"), None, Some("Mundo"))

    cadenas.foreach { cadena =>
        val longitud = cadena.map(_.length).getOrElse("Cadena no disponible")
        println(s"Longitud: $longitud")

        cadena.map(_.toUpperCase).foreach { texto =>
            println(s"Texto en mayúsculas: $texto")
        }
    }
    ```

    Aquí, `map` se utiliza para transformar los valores opcionales y `getOrElse` para proporcionar un valor predeterminado en caso de `None`. `foreach` se usa para imprimir el resultado cuando el valor está presente.

    ### Rust

    En **Rust**, puedes usar `map` y `and_then` (equivalente a `flatMap`) para trabajar con valores de tipo `Option`.

    ```rust
    let cadenas: Vec<Option<&str>> = vec![
        Some("Hola"),
        None,
        Some("Rust"),
        None,
        Some("Mundo"),
    ];

    for cadena in cadenas {
        let longitud = cadena.map(|texto| texto.len()).unwrap_or_else(|| {
            println!("Longitud: Cadena no disponible");
            return 0;
        });

        if longitud > 0 {
            println!("Longitud: {}", longitud);
        }

        cadena.map(|texto| texto.to_uppercase())
            .map(|texto| println!("Texto en mayúsculas: {}", texto))
            .unwrap_or_else(|| println!("Texto en mayúsculas no disponible"));
    }
    ```

    En este ejemplo, `map` transforma los valores cuando están presentes, y `unwrap_or_else` proporciona un valor predeterminado o ejecuta un bloque en caso de `None`. `and_then` (alias `flatMap`) no es necesario en este caso, ya que `map` es suficiente para las transformaciones simples.

    ### TypeScript

    Aunque **TypeScript** no tiene un manejo explícito de `null` como Kotlin o Scala, puedes usar validaciones similares con `?.` y el operador `??`.

    ```typescript
    const cadenas: (string | null)[] = ["Hola", null, "TypeScript", null, "Mundo"];

    cadenas.forEach(cadena => {
        const longitud = cadena?.length ?? "Cadena no disponible";
        console.log(`Longitud: ${longitud}`);

        cadena?.toUpperCase
            ? console.log(`Texto en mayúsculas: ${cadena.toUpperCase()}`)
            : console.log("Texto en mayúsculas no disponible");
    });
    ```
    ### Swift

    En **Swift**, puedes usar `Optional` y `map` para trabajar con valores opcionales de manera segura, similar a `let` en Kotlin.

    ```swift
    let cadenas: [String?] = ["Hola", nil, "Swift", nil, "Mundo"]

    for cadena in cadenas {
        let longitud = cadena?.count ?? "Cadena no disponible"
        print("Longitud: \(longitud)")

        cadena.map { texto in
            print("Texto en mayúsculas: \(texto.uppercased())")
        } ?? print("Texto en mayúsculas no disponible")
    }
    ```

    ### Elixir

    En **Elixir**, se puede usar `case` y `with` para manejar valores que podrían ser nulos o `nil`.

    ```elixir
    cadenas = ["Hola", nil, "Elixir", nil, "Mundo"]

    for cadena <- cadenas do
        longitud =
            case cadena do
                nil -> "Cadena no disponible"
                _ -> String.length(cadena)
            end

        IO.puts("Longitud: #{longitud}")

        case cadena do
            nil -> IO.puts("Texto en mayúsculas no disponible")
            _ -> IO.puts("Texto en mayúsculas: #{String.upcase(cadena)}")
        end
    end
    ```
</details>

## En resumen

La seguridad ante valores nulos, o **void-safety**, es un aspecto clave para evitar errores comunes y costosos en los sistemas de software. Como hemos visto, lenguajes como Kotlin proporcionan herramientas poderosas para manejar estos escenarios, con un sistema de tipos que diferencia claramente entre referencias nulas y no nulas. Al utilizar operadores como `?.` y `?:`, junto con funciones como `let`, Kotlin garantiza que las operaciones con valores opcionales sean seguras, eliminando la posibilidad de errores de `NullPointerException` en tiempo de ejecución.

Otras soluciones, como las que hemos visto en lenguajes como Scala y Rust, también abordan el problema de los valores nulos a través de tipos como `Option`, que obligan a manejar de forma explícita la posibilidad de que un valor no esté presente. Estas soluciones mejoran la claridad y seguridad del código, y proporcionan herramientas eficientes para trabajar con valores opcionales, evitando verificaciones manuales y errores difíciles de detectar.

Manejar la nulabilidad correctamente no solo mejora la calidad del código, sino que también hace que el software sea más robusto y mantenible. En la próxima lección, exploraremos cómo manejar la entrada de usuario.

<References references={[
    {
        title: "6. The Kotlin type system",
        bookTitle: "Kotlin in action",
        pages: "133–170",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
    },
    {
        accessedDate: '22 de septiembre de 2024',
        siteOrAuthor: 'Wikipedia',
        title: 'Void Safety',
        type: 'web',
        url: 'https://en.wikipedia.org/w/index.php?title=Void_safety&oldid=1245392044',
    },
    {
        accessedDate: '22 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Null Safety | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/null-safety.html',
    },
]}/>
