---
title: Expresiones condicionales
---
import Exercise from '@site/src/components/exercise/Exercise'
import Explanation from '@site/src/components/admonitions/Explanation'
import Solution from '@site/src/components/exercise/Solution'
import ReadingTime from '@site/src/components/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Las estructuras condicionales son uno de los pilares del control de flujo en cualquier lenguaje de programaci√≥n.  
Sin embargo, **Kotlin ofrece una perspectiva m√°s expresiva y funcional**, al permitir que construcciones como `if` y `when` sean no solo declaraciones, sino tambi√©n **expresiones que devuelven valores**.

Este enfoque habilita un estilo m√°s **conciso**, **declarativo** y alineado con la escritura de **funciones puras y reutilizables**. En esta lecci√≥n aprenderemos a **distinguir entre declaraciones y expresiones condicionales**, y a aprovechar la expresividad que ofrece Kotlin para construir funciones m√°s limpias y mantenibles.

Tambi√©n exploraremos el uso idiom√°tico de `when`, una alternativa poderosa a m√∫ltiples `if` anidados, y discutiremos sus diferencias con el *pattern matching* presente en lenguajes como Scala o Rust.

## üîÄ Expresi√≥n `if`

En Kotlin, `if` puede usarse como una **expresi√≥n** que retorna un valor, no solo como una declaraci√≥n de control, como en muchos lenguajes imperativos.

```kotlin showLineNumbers title="if como expresi√≥n (app/src/main/kotlin/cl/ravenhill/math/maxOf.kt)"
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

Esto permite escribir funciones m√°s concisas y expresivas.

Tambi√©n puedes usar `if` como **declaraci√≥n**, cuando solo te interesa ejecutar c√≥digo condicional sin obtener un valor:

```kotlin showLineNumbers title="if como declaraci√≥n (app/src/main/kotlin/cl/ravenhill/user/login.kt)"
if (isLoggedIn) {
    println("Welcome back!")
} else {
    println("Please sign in.")
}
```

:::danger Sin `else`, no hay valor

Cuando `if` se usa como expresi√≥n, **el bloque `else` es obligatorio**.  
Si lo omites, el compilador no podr√° determinar qu√© valor devolver:

```kotlin
val result = if (x > 0) "Positive" // ‚ùå Error: falta `else`
```

:::

:::info Llaves en `if`: ¬øcu√°ndo son necesarias?

- Si el bloque `if` o `else` tiene **m√°s de una l√≠nea**, las llaves `{}` son **obligatorias**.
- Si tiene **una sola l√≠nea**, puedes omitirlas, aunque es recomendable incluirlas para evitar errores al extender el c√≥digo.
- Cuando usas `if` como **expresi√≥n**, **el valor del bloque ser√° el de la √∫ltima l√≠nea evaluada**.

```kotlin
val result = if (x > 0)
    "positivo"
else
    "negativo"
```

Este bloque es una **expresi√≥n**: devuelve `"positivo"` o `"negativo"`, seg√∫n el caso.  
Si usas llaves, **la √∫ltima l√≠nea ejecutada dentro de cada rama es la que se retorna**:

```kotlin
val result = if (x > 0) {
    println("Evaluando...")
    "positivo"
} else {
    println("Evaluando...")
    "negativo"
}
```

:::

## üéõÔ∏è Expresi√≥n `when`

La expresi√≥n `when` en Kotlin es una alternativa m√°s concisa, segura y expresiva a m√∫ltiples estructuras `if-else if`. Adem√°s, **devuelve un valor**, lo que la convierte en una herramienta vers√°til para el control de flujo.

```kotlin showLineNumbers title="when con argumento"
when (status) {
    200, 201, 204 -> "Success"
    400 -> "Bad Request"
    404 -> "Not Found"
    500 -> "Internal Server Error"
    "timeout" -> "The request timed out"
    is Int -> "Unhandled status code: $status"
    !is String -> "Unknown type"
    else -> "Unhandled string: $status"
}
```

<Explanation>
    - **`when (status)`** eval√∫a el valor de `status` y lo compara contra distintos casos.
    - **Se pueden agrupar m√∫ltiples valores** en una sola rama usando comas, como en `200, 201, 204 ->`.
    - Tambi√©n permite **verificaciones de tipo** como `is Int` o `!is String`.
    - **`else`** act√∫a como caso por defecto y es obligatorio si no se cubren todos los posibles valores.
    - Al ser una **expresi√≥n**, `when` puede usarse directamente en asignaciones o como valor de retorno.
</Explanation>

<details>
    <summary>Diferencias con <code>switch</code> en otros lenguajes</summary>

    A diferencia de estructuras como `switch` en C, Java o JavaScript, **Kotlin no permite que la ejecuci√≥n "caiga" (fall-through) a la siguiente rama**.  
    **No es necesario usar `break`** para detener la ejecuci√≥n tras una coincidencia.

    Esto elimina una fuente com√∫n de errores, como se ve en este ejemplo en Java:

    ```java title="Java"
    switch (status) {
        case 200:
            System.out.println("Success");
        case 400:
            System.out.println("Bad Request");
    }
    ```

    Si `status` es `200`, el programa imprimir√°:

    ```
    Success
    Bad Request
    ```

    Esto ocurre porque **sin `break`**, el control sigue ejecutando los siguientes casos, incluso si no coinciden.  
    Este comportamiento se llama *fall-through*.

    En Kotlin, esto no puede ocurrir:

    ```kotlin title="Kotlin"
    when (status) {
        200 -> println("Success")
        400 -> println("Bad Request")
    }
    ```

    Si `status` es `200`, solo se imprimir√°:

    ```
    Success
    ```

    Cada rama en `when` es **independiente y cerrada**, lo que hace que el flujo de control sea **m√°s predecible, seguro y f√°cil de leer**.
</details>

:::tip Tambi√©n se puede usar sin argumento

Puedes omitir el valor entre par√©ntesis para evaluar condiciones arbitrarias, similar a un bloque `if-else if`:

```kotlin showLineNumbers title="when sin argumento (app/src/main/kotlin/cl/ravenhill/weather/temperature.kt)"
when {
    temperature < 0 -> "Below freezing"
    temperature <= 15 -> "Cold"
    temperature <= 25 -> "Mild"
    temperature <= 35 -> "Warm"
    else -> "Hot"
}
```

:::

:::info Uso de llaves `{}` en `when`

En Kotlin, **las llaves `{}` dentro de una rama de `when` son necesarias** cuando se quiere ejecutar **m√°s de una instrucci√≥n** en esa rama:

```kotlin
val message = when (code) {
    404 -> {
        println("Not Found")
        logError(code)
        "Not Found" // üëà Esta es la expresi√≥n final, se devuelve como resultado
    }
    else -> "Unhandled"
}
```

Si la rama contiene **solo una expresi√≥n**, puedes omitir las llaves:

```kotlin
val message = when (code) {
    404 -> "Not Found" // ‚úÖ sin llaves
    else -> "Other"
}
```

‚úÖ **Cuando usas `when` como expresi√≥n**, la rama debe terminar en un valor:  
- Si usas llaves, **la √∫ltima l√≠nea** del bloque es la que se utiliza como resultado.  
- Si no usas llaves, la expresi√≥n directamente se usa como resultado.

Esto se aplica tanto si usas `when` como expresi√≥n (que retorna un valor), como si lo usas como bloque de control (sin valor de retorno).

:::

:::warning Diferencias con pattern matching real
    
Aunque `when` se parece al **pattern matching** de Scala o Rust, tiene algunas limitaciones:

- No soporta destructuring directo (como `case (a, b)`).
- No permite patrones anidados ni coincidencias estructurales complejas.
- **Las condiciones tipo `case x if cond` existen**, pero son **experimentales** (requieren habilitar `-Xwhen-guards`) y no est√°n activadas por defecto.
    ```kotlin
    // Requiere: -Xwhen-guards
    when (animal) {
        is Dog -> feedDog()
        is Cat if !animal.mouseHunter -> feedCat()
        else if animal.eatsPlants -> giveLettuce()
        else -> println("Unknown animal")
    }
    ```

:::

### üîÅ Ejercicio: Reescribir usando `when`

<Exercise>
    Reescribe la funci√≥n `login` utilizando una expresi√≥n `when`.

    ```kotlin showLineNumbers
    fun login(username: String, password: String): Boolean {
        if (loginAttempts >= maxLoginAttempts) {
            return false
        }
        if (isValidPassword(password)) {
            loginAttempts = 0
            return true
        }
        loginAttempts++
        return false
    }
    ```

    <Solution>
        ```kotlin showLineNumbers
        fun login(username: String, password: String): Boolean = when {
            loginAttempts >= maxLoginAttempts -> false
            isValidPassword(password) -> {
                loginAttempts = 0
                true
            }
            else -> {
                loginAttempts++
                false
            }
        }
        ```
    </Solution>
</Exercise>

## üéØ Conclusiones

Kotlin transforma estructuras condicionales cl√°sicas como `if` y `switch` en expresiones vers√°tiles que devuelven valores. Esto permite escribir c√≥digo m√°s expresivo, conciso y seguro, especialmente en funciones puras y construcciones declarativas.

Tanto `if` como `when` pueden usarse como **expresiones** o **declaraciones**, pero cuando se usan como expresiones, **devuelven un valor** y se comportan de forma m√°s predecible. Esta distinci√≥n es clave para comprender el estilo idiom√°tico de Kotlin.

### üîë Puntos clave

- Kotlin permite usar `if` y `when` como **expresiones que devuelven un valor**, no solo como declaraciones de control.
- Cuando `if` se usa como expresi√≥n, el bloque `else` es obligatorio.
- En expresiones con llaves `{}`, el valor devuelto ser√° el de **la √∫ltima l√≠nea evaluada** del bloque.
- La expresi√≥n `when` es una alternativa poderosa a m√∫ltiples `if-else if`, y admite comprobaci√≥n de tipo, valores m√∫ltiples y evaluaci√≥n sin argumento.
- Las llaves son necesarias en `when` si se ejecutan **varias instrucciones** en una rama.
- Aunque `when` se asemeja al **pattern matching**, no soporta patrones estructurales ni destructuring directo como en Scala o Rust.
- El `when` sin argumento es √∫til para evaluar condiciones booleanas complejas de forma m√°s clara que m√∫ltiples `if-else if`.

### üß∞ ¬øQu√© nos llevamos?

Esto resulta especialmente √∫til en el dise√±o de bibliotecas, donde necesitamos tomar decisiones basadas en condiciones sin introducir efectos secundarios ni estructuras verbosas. Aqu√≠, `if` y `when` no solo controlan el flujo: tambi√©n **producen valores**, lo que nos permite escribir funciones m√°s limpias, m√°s breves y m√°s expresivas.

Este cambio de perspectiva ‚Äîver las condiciones no solo como instrucciones, sino como **expresiones evaluables**‚Äî es una puerta de entrada a un estilo de programaci√≥n m√°s declarativo, m√°s funcional, y m√°s alineado con el dise√±o de bibliotecas reutilizables.

Entender estas diferencias nos prepara para abordar con mayor claridad temas como lambdas, funciones puras y expresiones de control m√°s complejas. A partir de ahora, podremos decidir con m√°s intenci√≥n cu√°ndo usar una expresi√≥n, cu√°ndo usar una declaraci√≥n, y c√≥mo escribir c√≥digo que comunique mejor nuestras ideas.

## üìñ Referencias

### üî• Recomendadas

- üåê Conditions and loops | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 5 de abril de 2025, de https://kotlinlang.org/docs/control-flow.html

### üîπ Adicionales

- üìö Kotlin basics. (2017). En Dmitry Jemerov & Svetlana Isakova, Kotlin in action (pp. 17‚Äì43). Manning Publications Co.
