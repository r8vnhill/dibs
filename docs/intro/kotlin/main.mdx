---
title: Punto de entrada
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />

Antes de construir bibliotecas reutilizables, necesitamos comprender c√≥mo se ejecuta un programa en Kotlin. Aunque en este curso nos enfocaremos en el dise√±o de componentes modulares y reutilizables, saber c√≥mo funciona el punto de entrada ‚Äîla funci√≥n `main`‚Äî es esencial para realizar pruebas r√°pidas, crear ejemplos ilustrativos y escribir peque√±as utilidades auxiliares.

En esta lecci√≥n exploraremos c√≥mo se define y ejecuta un programa Kotlin desde la l√≠nea de comandos. Aprenderemos a imprimir mensajes en la consola, a recibir argumentos desde la terminal, y a usar Gradle para compilar y ejecutar nuestros programas.  
Todo esto nos permitir√° establecer una base s√≥lida para experimentar con el lenguaje y documentar nuestras bibliotecas de forma interactiva.

## üö™ Funci√≥n `main`

La funci√≥n `main` es el **punto de entrada** de cualquier programa ejecutable en Kotlin. A continuaci√≥n, presentamos un ejemplo simple inspirado en una galaxia muy, muy lejana:

```kotlin showLineNumbers title="app/src/main/kotlin/com/github/username/app.kt"
package com.github.username

fun main() {
    val message = """
        Hello there.
        General Kenobi!
        You are a bold one.
    """.trimIndent()

    println(message)
}
```

<Explanation>
    Este programa imprime un mensaje multil√≠nea en la consola utilizando `println`.  
    - **`message`** se define como un bloque de texto (string con triple comillas `"""`) que conserva los saltos de l√≠nea.  
    - El m√©todo `trimIndent()` elimina cualquier indentaci√≥n innecesaria al comienzo de cada l√≠nea.  
    - Finalmente, `println(message)` imprime el mensaje completo seguido de un salto de l√≠nea.  
    Es una forma elegante de mostrar texto multil√≠nea en Kotlin, ideal para ejemplos, banners o di√°logos √©picos.
</Explanation>

Aunque el enfoque de este curso est√° en el **desarrollo de bibliotecas de software**, es importante comprender el rol de la funci√≥n `main`, ya que nos servir√° para construir ejemplos ilustrativos y ejecutar peque√±os experimentos.  
Su uso ser√° menos frecuente a medida que adoptemos **pruebas automatizadas** como estrategia principal para verificar el comportamiento de nuestros componentes.

<details>
    <summary>`println` como expresi√≥n</summary>

    En Kotlin, `println` es una funci√≥n que retorna un valor de tipo `Unit`, lo que significa que puede usarse como **una expresi√≥n**, no solo como una instrucci√≥n.

    Gracias a esto, podemos escribir la funci√≥n `main` de forma m√°s concisa utilizando la sintaxis de expresi√≥n √∫nica:

    ```kotlin showLineNumbers
    fun main() = println("Hello, World!")
    ```

    Aunque esta forma es perfectamente v√°lida, **no es tan com√∫n** en la pr√°ctica para funciones `main`, ya que suele preferirse la forma tradicional con bloques expl√≠citos. Aun as√≠, es √∫til saber que esta sintaxis es posible y puede resultar conveniente para programas simples o ejemplos breves.
</details>

:::note `println` y `print`

El nombre `println` proviene de *"print line"*, y su comportamiento refleja justamente eso: **imprime el texto seguido de un salto de l√≠nea**. En cambio, la funci√≥n `print` **imprime el texto tal cual**, sin agregar un salto de l√≠nea al final. Esto las hace √∫tiles en contextos distintos, seg√∫n si deseas continuar la salida en la misma l√≠nea o en una nueva.

Por ejemplo:

```kotlin showLineNumbers
for (i in 1..5) {
    print(i) // Imprime: 12345
    println(i) // Imprime: 1, 2, 3, 4, 5 (cada n√∫mero en una nueva l√≠nea)
}
```

Esto hace que `println("Texto")` sea equivalente a `print("Texto\n")`.

:::

## ‚ñ∂Ô∏è Ejecutando el programa

Para ejecutar la aplicaci√≥n desde la terminal usando Gradle, puedes utilizar el siguiente comando:

```bash
./gradlew :app:run
```

La salida deber√≠a ser similar a esta:

```plaintext
> Task :app:run
Hello there.
General Kenobi!
You are a bold one.
```

Este comando compila el proyecto (si es necesario) y ejecuta la funci√≥n `main` definida en el m√≥dulo `app`.

## üß≥ Funci√≥n `main` con argumentos de l√≠nea de comandos

La funci√≥n `main` tambi√©n puede recibir **argumentos externos** al momento de ejecutar el programa. Esto permite modificar su comportamiento seg√∫n los valores proporcionados en la terminal.

A continuaci√≥n se muestra un ejemplo simple:

```kotlin showLineNumbers
fun main(args: Array<String>) {
    println("Welcome to Fabletown, ${args.joinToString(" ")}!")
}
```

<Explanation>
    Este programa recibe argumentos desde la l√≠nea de comandos y los utiliza para personalizar el mensaje de bienvenida.

    - **`args: Array<String>`** es el par√°metro que recibe la funci√≥n `main`. Contiene los valores que se pasan al ejecutar el programa desde la terminal.
    - **`joinToString(" ")`** concatena todos los elementos del arreglo `args`, separ√°ndolos con un espacio. Esto permite capturar nombres completos u otros argumentos con varias palabras.
    - Finalmente, **`println(...)`** imprime el saludo con los argumentos interpolados directamente dentro de la cadena de texto.

    Esta forma de uso es m√°s robusta que acceder solo a `args[0]`, ya que evita errores si se pasan m√∫ltiples palabras o si falta un argumento.
</Explanation>

### üöÄ ¬øC√≥mo ejecutar este programa?

Desde la ra√≠z del proyecto, puedes pasar argumentos a la funci√≥n `main` utilizando el plugin `application` de Gradle:

```bash
./gradlew :app:run --args="Snow White"
```

üì¶ **Salida esperada**:

```plaintext
> Task :app:run
Welcome to Fabletown, Snow White!
```

## üéØ Conclusiones

En esta lecci√≥n exploramos el **punto de entrada de los programas en Kotlin**: la funci√≥n `main`. Vimos c√≥mo se utiliza para ejecutar peque√±os programas y c√≥mo puede recibir argumentos desde la l√≠nea de comandos, lo que permite adaptar el comportamiento del programa en tiempo de ejecuci√≥n.

Tambi√©n repasamos funciones b√°sicas como `print` y `println`, aprendimos a imprimir mensajes en la consola con formato e indentaci√≥n, y comprendimos c√≥mo ejecutar nuestra aplicaci√≥n con Gradle, tanto con como sin argumentos.

### üîë Puntos clave

- La funci√≥n `main` es el punto de partida para cualquier programa ejecutable en Kotlin.
- `println` imprime texto con un salto de l√≠nea; `print` no.
- Kotlin permite definir `main` como una **expresi√≥n √∫nica** cuando solo contiene una l√≠nea.
- `main` puede recibir argumentos (`args: Array<String>`) desde la terminal.
- Usar `joinToString(" ")` sobre `args` permite capturar m√∫ltiples palabras sin errores.
- Podemos ejecutar la aplicaci√≥n y pasarle argumentos usando `./gradlew :app:run --args="..."`.

### üß∞ ¬øQu√© nos llevamos?

Aunque el desarrollo de bibliotecas no gira en torno a la funci√≥n `main`, entender c√≥mo funcionan los **programas ejecutables**, c√≥mo se imprime informaci√≥n, y c√≥mo se reciben argumentos, **nos da herramientas clave para construir ejemplos, depurar c√≥digo, o crear utilidades auxiliares**.

Esta lecci√≥n nos permiti√≥ poner en pr√°ctica muchos de los elementos b√°sicos del lenguaje, como el manejo de strings, funciones y ejecuci√≥n desde la terminal. A medida que avancemos, usaremos `main` con menos frecuencia, ya que adoptaremos **pruebas automatizadas** como m√©todo principal para validar nuestras bibliotecas. Sin embargo, todo lo aprendido aqu√≠ seguir√° siendo √∫til para construir peque√±os experimentos, utilidades de desarrollo y documentaci√≥n ejecutable.

## üìñ Referencias

### üî• Recomendadas

- üåê Hello world | Kotlin. (2025, enero 25). Kotlin Help. https://kotlinlang.org/docs/kotlin-tour-hello-world.html

### üîπ Adicionales

- üìö Hello, World! (2020). En Bruce Eckel & Svetlana Isakova, Atomic Kotlin (pp. 26‚Äì28). Leanpub.
