---
title: Declaraci√≥n de funciones y variables
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Kotlin es un lenguaje que promueve la claridad, la expresividad y la seguridad. En la lecci√≥n anterior exploramos su filosof√≠a y vimos un primer ejemplo que nos permiti√≥ reconocer su sintaxis y estilo. Ahora es momento de enfocarnos en dos elementos esenciales para cualquier programa: las **funciones** y las **variables**.

En esta lecci√≥n aprender√°s a declarar funciones de forma tradicional y como expresiones, a aprovechar la **inferencia de tipos** para evitar redundancias, y a elegir entre **val** y **var** seg√∫n la necesidad de mutabilidad. Tambi√©n discutiremos convenciones de estilo que mejoran la legibilidad del c√≥digo y ayudan a construir bibliotecas idiom√°ticas y consistentes.

Estas bases nos permitir√°n escribir c√≥digo m√°s limpio, reutilizable y seguro desde el comienzo.

## üß© Funciones en Kotlin

Una **funci√≥n** en Kotlin es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es:

```kotlin title="Estructura general"
fun functionName(param1: Type1, param2: Type2, ...): ReturnType {
    // Cuerpo de la funci√≥n
    return result
}
```

<Explanation>
    - **`fun`**: Palabra clave para definir la funci√≥n.
    - **`functionName`**: Identificador de la funci√≥n.
    - **`param1`, `param2`**: Par√°metros que recibe la funci√≥n, con sus respectivos tipos.
    - **`ReturnType`**: Tipo de dato que devuelve la funci√≥n.
</Explanation>

### ‚ûï Ejemplo: Sumar dos n√∫meros

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int): Int {
    return a + b
}
```

Cuando una funci√≥n tiene una sola expresi√≥n, se puede simplificar con la sintaxis de asignaci√≥n directa:

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int): Int = a + b
```

Y a√∫n m√°s, el tipo de retorno puede deducirse autom√°ticamente:

```kotlin showLineNumbers title="app/src/main/kotlin/cl/ravenhill/math/sum.kt"
fun sum(a: Int, b: Int) = a + b
```

Esto hace que el c√≥digo sea m√°s conciso y legible.

:::note Si vienes de Scala...

En Kotlin, **la palabra clave `return` es necesaria** cuando se usa el bloque cl√°sico `{ ... }`. A diferencia de Scala, donde la √∫ltima expresi√≥n de una funci√≥n se devuelve impl√≠citamente, en Kotlin eso solo ocurre cuando usas la sintaxis de una sola expresi√≥n (`= ...`).

:::

::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n en funci√≥n del contexto. En el ejemplo anterior, como la funci√≥n tiene una √∫nica expresi√≥n, el tipo de retorno se infiere autom√°ticamente.

:::warning No abuses de la inferencia

Aunque la inferencia de tipos puede hacer el c√≥digo m√°s limpio, **no siempre es conveniente** omitir los tipos. En funciones p√∫blicas o m√°s complejas, declararlos expl√≠citamente mejora la claridad y la mantenibilidad.

:::
::::

::::tip Estilo de nombres

En Kotlin, **los nombres de funciones y variables siguen la convenci√≥n `camelCase`**. Esto significa que:

- El nombre comienza con min√∫scula.
- Cada palabra posterior se une sin espacios, iniciando con may√∫scula.

Ejemplos correctos:
- `calculateTotal`
- `printMessage`
- `main`

Usar un estilo consistente mejora la legibilidad del c√≥digo y se alinea con las pr√°cticas recomendadas del lenguaje.

:::danger Ejemplos incorrectos

Evita estos estilos comunes en otros lenguajes o por h√°bitos anteriores:

- `CalculateTotal` ‚Üí ‚ùå Estilo PascalCase (usado en clases, no funciones)
- `calculate_total` ‚Üí ‚ùå Snake_case (com√∫n en Python, no en Kotlin)
- `calculate-total` ‚Üí ‚ùå Kebab-case (no permitido como identificador en Kotlin)
- `CALCULATE_TOTAL` ‚Üí ‚ùå Usado para constantes, no para funciones

:::
::::


## üì¶ Declaraci√≥n de variables

En Kotlin puedes declarar variables utilizando `val` para valores **inmutables** o `var` para valores **mutables**:

```kotlin title="Sintaxis general"
val/var variableName: Type = value
```

- Usa `val` cuando el valor no debe cambiar (constante de referencia).
- Usa `var` cuando necesites reasignar el valor m√°s adelante.

### üîç Ejemplos pr√°cticos

```kotlin showLineNumbers
val a: Int = 1        // Valor fijo, no puede ser reasignado
var b = 2             // Tipo inferido, pero puede cambiar
b = 3                 // ‚úÖ Permitido con `var`

val c: Int
c = 3                 // ‚úÖ Asignaci√≥n diferida con `val`, v√°lida si solo se hace una vez
```

:::tip ¬°Prefiere `val`!

Siempre que sea posible, **prefiere `val` en lugar de `var`**. La inmutabilidad hace que el c√≥digo sea m√°s f√°cil de entender, mantener y menos propenso a errores.

Usa `var` solo cuando realmente necesites cambiar el valor de una variable.

:::

:::danger Inmutabilidad ‚â† inmutabilidad profunda

Usar `val` impide cambiar la referencia, pero **no garantiza que el contenido sea inmutable**.

```kotlin
val numbers = mutableListOf(1, 2, 3)
numbers.add(4) // ‚úÖ Esto es v√°lido: modificamos el contenido, no la referencia
numbers = listOf(5, 6, 7) // ‚ùå Error: no puedes reasignar `val`
```

Si necesitas que el contenido tambi√©n sea inmutable, considera usar tipos como `listOf` o dise√±ar tus propios tipos inmutables.

:::

## üéØ Conclusiones

En esta lecci√≥n exploramos dos de los pilares fundamentales de cualquier lenguaje de programaci√≥n: las **funciones** y las **variables**. Aprendimos c√≥mo se declaran en Kotlin, c√≥mo se comportan, y c√≥mo aprovechar sus reglas para escribir c√≥digo m√°s expresivo, seguro y legible.

Kotlin promueve un estilo claro y pragm√°tico en la definici√≥n de funciones, apoy√°ndose en la inferencia de tipos, la sintaxis de una sola expresi√≥n y un fuerte √©nfasis en la legibilidad. Tambi√©n introduce una distinci√≥n clara entre **referencias mutables** (`var`) e **inmutables** (`val`), lo que permite fomentar una programaci√≥n m√°s segura y predecible desde el principio.

### üîë Puntos clave

- Las funciones pueden definirse con bloques (`{ ... }`) o como **expresiones √∫nicas** (`= ...`), lo que permite un estilo m√°s conciso.
- La **inferencia de tipos** hace que el c√≥digo sea m√°s limpio, aunque declarar los tipos expl√≠citamente sigue siendo recomendable en contextos p√∫blicos o complejos.
- Kotlin distingue entre **val** (inmutable) y **var** (mutable), promoviendo el uso de `val` por defecto.
- La **inmutabilidad de `val`** aplica solo a la referencia, no necesariamente al objeto referenciado.
- Los identificadores siguen la convenci√≥n `camelCase`, y respetar este estilo mejora la coherencia y legibilidad del c√≥digo.

### üß∞ ¬øQu√© nos llevamos?

Estas herramientas nos permiten escribir funciones peque√±as, reutilizables y con menor riesgo de errores. Entender c√≥mo y cu√°ndo usar `val`, `var` y las distintas formas de definir funciones nos prepara para construir c√≥digo m√°s idiom√°tico, expresivo y mantenible, que es la base del dise√±o de bibliotecas elegantes en Kotlin.

## üìñ Referencias

### üî• Recomendadas

- üåê Basic syntax | Kotlin. (s.¬†f.). Kotlin Help. Recuperado 3 de abril de 2025, de https://kotlinlang.org/docs/basic-syntax.html
