---
title: Tareas personalizadas en otros frameworks
---

## Javascript/Typescript: Gulp

En el ecosistema de JavaScript, una alternativa a Gradle es usar **NPM** junto con **Gulp**, pero en este caso usaremos **TypeScript** en lugar de JavaScript para definir las tareas personalizadas. En lugar de un DSL como el de Gradle, NPM y Gulp utilizan **JavaScript** o **TypeScript** para configurar las tareas.

### Definición de Tareas en Gulp (TypeScript)

En Gulp, podemos definir tareas personalizadas de manera similar a Gradle, pero utilizando TypeScript. Un ejemplo equivalente a la tarea `greet` de Gradle sería:

```typescript title="gulpfile.ts"
import { task, series } from 'gulp';

task('greet', (done) => {
    console.log('Hello, Gulp with TypeScript!');
    done();
});
```

### Ejecución de Tareas

Al igual que en Gradle, puedes ejecutar esta tarea personalizada con el siguiente comando:

```bash
gulp greet
```

#### Similitudes
- Tanto Gradle como Gulp permiten definir tareas personalizadas para acciones específicas en un proyecto.
- Gradle y Gulp permiten definir dependencias entre tareas y establecer acciones específicas que se ejecutan antes o después de otras tareas.

#### Diferencias
- **Sistema de dependencias**: Gradle maneja las dependencias de manera integrada, mientras que Gulp requiere NPM, Yarn o PNPM para gestionar las dependencias externas.
- **Configuración diferida**: Gradle permite diferir la configuración de tareas con `tasks.register`, mientras que en Gulp las tareas son configuradas y ejecutadas inmediatamente cuando son requeridas.

### Acciones y Dependencias en Gulp

De manera similar a las acciones `doFirst` y `doLast` en Gradle, Gulp permite encadenar tareas usando `series` o `parallel`. Aquí tienes un ejemplo equivalente a las acciones y dependencias de Gradle, pero utilizando TypeScript:

```typescript title="gulpfile.ts"
import { task, series } from 'gulp';

task('message', (done) => {
    console.log('Calculating the Fibonacci sequence...');
    done();
});

task('fib', (done) => {
    let first = 0;
    let second = 1;

    for (let i = 0; i < 10; i++) {
        console.log(first);
        second += first;
        first = second - first;
    }
    console.log(`The 10th Fibonacci number is: ${first}`);
    done();
});

export default series('message', 'fib');
```

Al igual que en Gradle, la tarea `message` se ejecutará antes de `fib`, utilizando la función `series` de Gulp para crear la dependencia.

### Tareas Basadas en Otras Tareas

En Gulp, no existe un mecanismo específico para "heredar" o basarse en una tarea existente como en Gradle. Sin embargo, es posible componer nuevas tareas utilizando funciones como `series` o `parallel` para encadenar tareas ya definidas. Esto es similar a cómo en Gradle puedes registrar tareas basadas en otras existentes.

Por ejemplo, si quisiéramos definir una tarea como cuando nos basamos en ``Copy``, podríamos lograr un comportamiento similar definiendo una tarea que dependa de otras y realice una operación personalizada, como copiar archivos, usando el paquete `gulp.src()` y `gulp.dest()`:

```typescript title="gulpfile.ts"
import { task, series, src, dest } from 'gulp';

task('copyCompiledClasses', (done) => {
    src('build/classes/**/*.js')
        .pipe(dest('compiled-classes'));
    done();
});

task('build', series('compile', 'copyCompiledClasses'));
```

#### Similitudes

- En ambos casos, se puede crear una nueva tarea personalizada basada en tareas preexistentes.
- Tanto Gradle como Gulp permiten usar la salida de una tarea para alimentar otra (por ejemplo, copiar archivos después de compilar).

#### Diferencias

- Gradle permite un manejo más robusto de tareas preexistentes, proporcionando acciones específicas como `doFirst` y `doLast`. Gulp, por otro lado, se basa en el encadenamiento mediante `series` o `parallel` para manejar dependencias entre tareas.
- Gulp requiere el uso de `src()` y `dest()` para manejar operaciones como la copia de archivos, mientras que Gradle permite hacerlo directamente con tareas como `Copy`.

### Comparación Final

**Gradle** es más robusto para proyectos grandes que requieren tanto la gestión de tareas como de dependencias dentro de un mismo sistema. **Gulp** con **NPM** (en este caso con TypeScript) es una solución más ligera para automatizar tareas específicas, como la compilación o la minificación de archivos en proyectos web.

En ambos sistemas puedes:
- Definir tareas personalizadas.
- Encadenar tareas con dependencias.
- Ejecutar scripts que realicen operaciones específicas dentro del proyecto.

La diferencia principal radica en el ecosistema y en el lenguaje que usan. Gradle es ideal para proyectos JVM (Java, Kotlin, Groovy), mientras que Gulp con TypeScript está orientado a proyectos en el ecosistema de JavaScript.

## JVM: Maven

En Maven, las tareas personalizadas equivalentes se logran mediante **plugins**. Los plugins en Maven son responsables de todas las tareas de construcción, y las tareas personalizadas se definen agregando configuraciones específicas de los plugins dentro del archivo `pom.xml`. A diferencia de Gradle, Maven no tiene un mecanismo directo para registrar tareas personalizadas de manera dinámica, como `tasks.register` en Gradle. Aquí se usa el concepto de "objetivos" de los plugins.

### Ejemplo: Crear una tarea para imprimir un mensaje

En Maven, podrías usar el **Maven Antrun Plugin** para ejecutar scripts personalizados como una tarea que imprima un mensaje.

```xml
<project>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>1.8</version>
                <executions>
                    <execution>
                        <id>greet</id>
                        <phase>validate</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <configuration>
                            <tasks>
                                <echo message="Hello, Maven!"/>
                            </tasks>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

En este ejemplo, hemos configurado una tarea que se ejecuta durante la fase de `validate`, similar a cómo en Gradle definimos una tarea con `tasks.register`.

#### Similitudes

- Ambos frameworks permiten definir acciones personalizadas que pueden ejecutarse durante el ciclo de vida del proyecto (como el ciclo de vida de Gradle).
- En ambos, puedes definir tareas que impriman mensajes o realicen acciones específicas antes o después de la ejecución de otras tareas.

#### Diferencias

- **Gradle** permite registrar tareas dinámicamente con `tasks.register`, mientras que **Maven** requiere la configuración previa de objetivos dentro de plugins específicos.
- En **Maven**, las tareas se ejecutan en fases predefinidas del ciclo de vida (como `validate`, `compile`, etc.), mientras que en **Gradle**, las tareas pueden ser configuradas y encadenadas más dinámicamente con `dependsOn` u otras propiedades.

### Ejemplo: Dependencias entre Tareas en Maven

Para configurar dependencias entre tareas en Maven, puedes usar el concepto de fases y objetivos. Por ejemplo, si quisieras que una tarea se ejecute después de compilar el proyecto, configurarías el plugin en la fase `compile` o posterior.

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-antrun-plugin</artifactId>
            <version>1.8</version>
            <executions>
                <execution>
                    <id>greet-after-compile</id>
                    <phase>compile</phase>
                    <goals>
                        <goal>run</goal>
                    </goals>
                    <configuration>
                        <tasks>
                            <echo message="Compilation is done!"/>
                        </tasks>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

#### Similitudes

- Tanto en Gradle como en Maven se puede definir la secuencia de ejecución de tareas, asegurando que una tarea dependa de otra.

#### Diferencias

- En **Gradle**, se utiliza `dependsOn` para establecer dependencias directas entre tareas específicas, mientras que en **Maven** las dependencias entre tareas se gestionan a través de las fases del ciclo de vida y los objetivos de los plugins.

### Tareas Basadas en Otras Tareas en Maven

En lugar de extender o crear nuevas tareas basadas en otras como en Gradle, en **Maven** puedes usar configuraciones dentro del mismo plugin para realizar múltiples acciones. Sin embargo, la flexibilidad es más limitada en comparación con Gradle, ya que no puedes crear tareas tan dinámicas o complejas sin recurrir a la creación de un plugin personalizado.

## Python: Invoke

En el ecosistema de **Python**, **Invoke** es una herramienta muy similar a **Gradle** o **Gulp**, diseñada para la automatización de tareas y scripts. Permite definir tareas personalizadas y sus dependencias utilizando **Python** como lenguaje de configuración.

### Definición de Tareas en Invoke

En **Invoke**, puedes definir tareas personalizadas de manera muy similar a Gradle, utilizando decoradores de funciones para marcar las tareas. A continuación, un ejemplo de cómo definir una tarea personalizada para imprimir un saludo, equivalente a la tarea `greet` de Gradle.

```python
from invoke import task

@task
def greet(c):
    print("Hello, Invoke!")
```

### Ejecución de Tareas

Para ejecutar esta tarea personalizada, solo necesitas correr el siguiente comando desde la terminal:

```bash
invoke greet
```

### Similitudes con Gradle

- **Definición de Tareas**: Tanto Gradle como Invoke permiten definir tareas personalizadas para automatizar acciones específicas dentro de un proyecto.
- **Dependencias entre Tareas**: Ambos frameworks permiten definir dependencias entre tareas para garantizar un orden de ejecución específico.
- **Lenguaje de Configuración**: Al igual que Gradle utiliza Groovy o Kotlin, **Invoke** utiliza **Python**, lo que permite aprovechar todo el poder del lenguaje para crear scripts avanzados.

### Acciones y Dependencias en Invoke

De manera similar a las acciones `doFirst` y `doLast` en Gradle, **Invoke** permite definir dependencias entre tareas y ejecutar funciones en serie. Aquí tienes un ejemplo equivalente a las acciones y dependencias de Gradle utilizando Python:

```python
from invoke import task

@task
def message(c):
    print("Calculating the Fibonacci sequence...")

@task(pre=[message])
def fib(c):
    first, second = 0, 1
    for _ in range(10):
        print(first)
        first, second = second, first + second
    print(f"The 10th Fibonacci number is: {first}")
```

En este ejemplo, la tarea `message` se ejecuta antes de `fib`, de manera similar a cómo se gestionan las dependencias en Gradle con `dependsOn`.

### Tareas Basadas en Otras Tareas

En **Invoke**, no existe un concepto directo de "herencia" entre tareas como en Gradle. Sin embargo, es posible componer tareas utilizando la lista `pre` para establecer dependencias entre ellas, lo que permite un comportamiento similar. Si quisieras, por ejemplo, definir una tarea que copie archivos después de la compilación, podrías hacerlo así:

```python
from invoke import task
import shutil

@task
def compile(c):
    print("Compiling project...")

@task(pre=[compile])
def copy_compiled_files(c):
    shutil.copytree('src', 'compiled')
    print("Compiled files copied to 'compiled' directory.")
```

### Comparación Final

**Invoke** es una herramienta liviana y flexible para automatización de tareas en **Python**, similar a **Gradle** en su enfoque, pero con la ventaja de usar un lenguaje interpretado. **Gradle**, en cambio, es más robusto para la gestión de proyectos y dependencias dentro de su ecosistema JVM, mientras que **Invoke** es más adecuado para tareas de automatización de scripts y proyectos ligeros en **Python**.