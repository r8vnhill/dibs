---
title: Tareas como clases
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ReadingTime from "../../../src/components/ReadingTime";

<ReadingTime/>

## Definiendo Tareas Personalizadas como Clases en Gradle

A veces necesitamos definir tareas más complejas que requieren lógica más avanzada o necesitamos reutilizar tareas en
diferentes contextos. En estos casos, es posible definir tareas como clases en Gradle, lo que permite encapsular la
lógica y reutilizarla fácilmente en diferentes partes del proyecto.

Estas tareas pueden definirse en archivos `*.gradle.kts`, como se hace normalmente con tareas regulares, o en
archivos `.kt` como cualquier otra clase en Kotlin. Para este ejemplo, utilizaremos el enfoque de definir la tarea
en un archivo `.kt`.

### Ejemplo: Fibonacci Revisited

Hasta ahora, hemos creado una tarea que imprime los primeros 10 números de la secuencia de Fibonacci. Supongamos que
ahora queremos extender esta tarea para calcular la secuencia hasta un número específico proporcionado por el
usuario. Para hacer esto, definiremos la tarea como una clase en un archivo `.kt`.

Primero, creamos un paquete llamado `tasks` en el directorio `src/main/kotlin` del módulo `convention-plugins`.
Dentro de este paquete, crearemos un archivo llamado `FibonacciTask.kt` con el siguiente contenido:

```kotlin title="convention-plugins/src/main/kotlin/FibonacciTask.kt"
package tasks

import org.gradle.api.DefaultTask
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.StopExecutionException
import org.gradle.api.tasks.TaskAction

abstract class FibonacciTask : DefaultTask() {  // (1)
    @get:Input  // (2)
    abstract val number: Property<Int>  // (3)

    @TaskAction // (4)
    fun calculateFibonacci() {
        val n = number.get()  // (5)
        if (n < 0) {
            throw StopExecutionException("The number must be greater than or equal to 0")  // (6)
        }
        var first = 0
        var second = 1
        repeat(n) {
            print("$first ")
            second += first
            first = second - first
        }
        println("The $n-th Fibonacci number is: $first")
    }
}
```

### Explicación:

1. **Clase `FibonacciTask`**: Definimos una clase que extiende `DefaultTask`. Todas las tareas en Gradle deben
heredar de `DefaultTask`. Notamos que la clase es **abstracta**, lo que indica que ciertos parámetros de la
tarea, como el input, deben ser definidos antes de usarla.
2. **Anotación `@get:Input`**: Anotamos la propiedad `number` para indicarle a Gradle que este valor es un input de
la tarea. Esto permite que Gradle detecte cambios y decida si es necesario ejecutar la tarea nuevamente.
3. **Propiedad `number`**: Utilizamos un `Property<Int>` para almacenar el número hasta el cual queremos calcular la
secuencia de Fibonacci.
4. **Método `@TaskAction`**: Este método contiene la lógica principal de la tarea. Gradle lo ejecuta automáticamente
cuando la tarea se llama, ejecutándose entre los bloques `doFirst` y `doLast`.

### Registro de la tarea en un archivo `*.gradle.kts`

Para usar nuestra tarea, debemos registrarla en algún archivo `*.gradle.kts`. Aquí te mostramos cómo hacerlo en el
archivo `playground.gradle.kts`:

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
import tasks.FibonacciTask

// ...

tasks.register<FibonacciTask>("fib_10") {
    number = 10
    doFirst {
        println("Calculating the 10th Fibonacci number...")
    }
    doLast {
        println("Calculation complete.")
    }
}

tasks.register<FibonacciTask>("fib_20") {
    number = 20
    doFirst {
        println("Calculating the 20th Fibonacci number...")
    }
    doLast {
        println("Calculation complete.")
    }
}
```

En este ejemplo:

- **Registro de la Tarea `fib_10`**: Definimos una instancia de `FibonacciTask` con la propiedad `number`
configurada en 10.
- **`doFirst` y `doLast`**: Estos bloques definen acciones adicionales que se ejecutan antes y después de la lógica
principal de la tarea.


### Ejecución de las tareas

Podemos ejecutar las tareas desde la línea de comandos de Gradle:

```bash
./gradlew fib_10
./gradlew fib_20
```

Esto imprimirá en la consola los primeros 10 o 20 números de la secuencia de Fibonacci, dependiendo de la tarea que
se ejecute.

:::tip Ejercicio
<Tabs>
    <TabItem value="Ejercicio">
        ¿Qué imprime ejecutar la tarea `fib_10`? ¿Por qué?
    </TabItem>
    <TabItem value="Solución">
        Ejecutar la tarea `fib_10` imprimirá:

        ```plaintext
        > Task :fib_10
        Calculating the 10th Fibonacci number...
        0 1 1 2 3 5 8 13 21 34 The 10-th Fibonacci number is: 55
        Calculation complete.
        ```

        Esto se debe a que `doFirst` imprime un mensaje antes de calcular la secuencia de Fibonacci, y `doLast`
        imprime un mensaje al finalizar el cálculo.
    </TabItem>
</Tabs>
:::

### Ejemplo: Procesar texto

Implementaremos una tarea para procesar archivos de texto. Tendremos archivos de entrada y salida. El texto debe ser
tomado de un archivo de texto (input), transformado en mayúsculas, y ser guardado en otro archivo de texto (output).

```kotlin title="convention-plugins/src/main/kotlin/TextProcessingTask.kt"
package tasks

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.util.*

abstract class TextProcessingTask : DefaultTask() {
    @get:InputFile  // (1)
    abstract var inputFile: File

    @get:OutputFile // (2)
    abstract var outputFile: File

    @TaskAction
    fun processText() {
        val text = inputFile.readText()
        val processedText = text.uppercase(Locale.getDefault())
        outputFile.writeText(processedText)
    }
}
```

1. **Anotación `@get:InputFile`**: Anotamos la propiedad `inputFile` para indicar que es un archivo de entrada.
2. **Anotación `@get:OutputFile`**: Anotamos la propiedad `outputFile` para indicar que es un archivo de salida.

Ahora, registramos la tarea en un archivo `*.gradle.kts`:

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
import tasks.TextProcessingTask

tasks.register<TextProcessingTask>("processText") {
    inputFile = file("input.txt")
    outputFile = file("output.txt")
    doFirst { println("Processing text...") }
    doLast { println("Processing complete.") }
}
```

Finalmente, ejecutamos la tarea desde la línea de comandos de Gradle:

```powershell title="powershell"
"Este es el contenido del archivo" > input.txt  # Crear un archivo de texto con contenido
./gradlew processText
Get-Content output.txt                          # Mostrar el contenido del archivo de salida
```

```bash title="bash"
echo "Este es el contenido del archivo" > input.txt  # Crear un archivo de texto con contenido
./gradlew processText
cat output.txt                                      # Mostrar el contenido del archivo de salida
```

Con esto deberíamos ver el contenido del archivo de entrada en mayúsculas en el archivo de salida.

```plaintext
> Task :processText
Processing text...
Processing complete.
# ...
ESTE ES EL CONTENIDO DEL ARCHIVO
```

:::tip Ejercicio: Verificación de Números Pares e Impares
<Tabs>
    <TabItem value="Ejercicio">
        Vamos a implementar una tarea personalizada que procese un archivo de texto con una lista de números (uno por
        línea). La tarea verificará si cada número es par o impar y luego escribirá los resultados en un archivo de
        salida,
        indicando si el número es "par" o "impar", o si el contenido no es un número válido.

        ### Pasos:

        1. **Crea un archivo `NumbersTask.kt` en el paquete `tasks`** dentro del directorio
        `src/main/kotlin/convention-plugins`. Este archivo contendrá una clase que extienda `DefaultTask` y será
        responsable de procesar el archivo de entrada y generar el archivo de salida.

        2. **Configura la tarea con dos archivos, uno como entrada y otro como salida:**
            - Un archivo de entrada `input.txt` que contenga números, uno por línea.
            - Un archivo de salida `output.txt`, donde se escribirán los resultados.

        3. **Lógica de la tarea:**
            - Leer el archivo de entrada línea por línea.
            - Verificar si cada número es par o impar.
            - Escribir los resultados en el archivo de salida, indicando si el número es "par" o "impar". Si no es un
                número válido, escribe un mensaje que lo indique.

        4. **Registra la tarea y configúrala en el archivo `playground.gradle.kts`.**

        Puedes utilizar la función `readLines(): List<String>` de la clase `File` para leer el archivo línea por línea.
        Para convertir las líneas en números, usa `toInt()` de la clase `String`, manejando la excepción
        `NumberFormatException` para los casos donde el contenido no sea un número válido.

        ### Ejecución de las tareas

        Crea un archivo `input.txt` con una lista de números como el siguiente ejemplo:

        ```plaintext title="input.txt"
        12
        7
        cinco
        22
        9
        ```

        Ejecuta la tarea desde la línea de comandos:

        ```bash
        ./gradlew processNumbers
        ```

        El archivo `output.txt` debería generar un resultado similar al siguiente:

        ```plaintext title="output.txt"
        12: par
        7: impar
        cinco: no es un número válido
        22: par
        9: impar
        ```
    </TabItem>

    <TabItem value="Solución">

        ```kotlin title="convention-plugins/src/main/kotlin/tasks/NumbersTask.kt"
        package tasks

        import org.gradle.api.DefaultTask
        import org.gradle.api.tasks.InputFile
        import org.gradle.api.tasks.OutputFile
        import org.gradle.api.tasks.TaskAction
        import java.io.File

        abstract class NumbersTask : DefaultTask() {
            @get:InputFile
            abstract var inputFile: File

            @get:OutputFile
            abstract var outputFile: File

            @TaskAction
            fun processNumbers() {
                val lines = inputFile.readLines()
                val results = mutableListOf<String>()  // Lista para almacenar los resultados
                for (line in lines) {
                    try {
                        val num = line.toInt()  // Convertir el valor leído a entero
                        val result = if (num % 2 == 0) "$num: par" else "$num: impar"
                        results.add(result)
                    } catch (e: NumberFormatException) {
                        results.add("$line: no es un número válido")
                    }
                }
                outputFile.writeText(results.joinToString("\n"))
            }
        }
        ```
    </TabItem>
    <TabItem value="Solución (más corta)">
        ```kotlin title="convention-plugins/src/main/kotlin/tasks/NumbersTask.kt"
        package tasks

        import org.gradle.api.DefaultTask
        import org.gradle.api.tasks.InputFile
        import org.gradle.api.tasks.OutputFile
        import org.gradle.api.tasks.TaskAction
        import java.io.File

        abstract class NumbersTask : DefaultTask() {
            @get:InputFile
            abstract var inputFile: File

            @get:OutputFile
            abstract var outputFile: File

            @TaskAction
            fun processNumbers() {
                inputFile.readLines().map { line ->
                    try {
                        val num = line.toInt()
                        "$num: ${if (num % 2 == 0) "par" else "impar"}"
                    } catch (e: NumberFormatException) {
                        "$line: no es un número válido"
                    }
                }.let { results -> outputFile.writeText(results.joinToString("\n")) }
            }
        }
        ```
    </TabItem>
</Tabs>
:::

## Definiendo Tareas Personalizadas como Clases en Distintos Frameworks

Muchos frameworks permiten definir tareas personalizadas utilizando clases, lo que facilita la encapsulación de lógica
compleja y su reutilización. A continuación, exploraremos cómo definir tareas como clases en varios lenguajes y
herramientas.

### **Gulp (JavaScript/TypeScript)**

Gulp es un popular framework de automatización en JavaScript que permite definir tareas utilizando funciones. Sin
embargo, es posible definir tareas encapsuladas como clases utilizando TypeScript para obtener un mayor control sobre la
lógica.

```typescript title="Gulp - TypeScript"
import { task } from 'gulp';

class CustomTask {
    execute() {
        console.log("Executing a custom task in Gulp!");
    }
}

// Registro de la tarea en Gulp
task('customTask', () => {
    const task = new CustomTask();
    task.execute();
});
```

### **Rake (Ruby)**

Rake es un sistema de construcción en Ruby, similar a Make, que permite definir tareas mediante clases.

```ruby title="Rake - Ruby"
class CustomTask
    def execute
        puts "Executing a custom task in Rake!"
    end
end

task :custom_task do
    CustomTask.new.execute
end
```

### **Invoke (Python)**

Invoke es un framework de automatización para Python que permite definir tareas como funciones, pero también admite la
encapsulación de tareas dentro de clases para reutilización.

```python title="Invoke - Python"
from invoke import task

class CustomTask:
    def execute(self):
        print("Executing a custom task in Invoke!")

@task
def custom_task(c):
    task = CustomTask()
    task.execute()
```

### **Make (C++)**

En Make, las tareas no se definen como clases directamente, pero podemos encapsular la lógica en clases C++ y luego
invocarlas desde los archivos Make.

```cpp title="Make - C++"
#include <iostream>

class CustomTask {
    public:
    void execute() {
        std::cout << "Executing a custom task in C++!" << std::endl;
    }
};
```

```makefile title="Makefile"
all:
    g++ -o task task.cpp
    ./task
```

### **Maven (Java)**

En Maven, las tareas personalizadas se definen mediante **mojos**, que son clases Java que implementan la interfaz
`org.apache.maven.plugin.Mojo`. Estas clases se encapsulan en un plugin de Maven, y luego pueden ejecutarse como una
tarea (goal).

#### Definir un Mojo Personalizado

```java title="CustomMojo.java"
package com.example;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;

@Mojo(name = "custom-task", defaultPhase = LifecyclePhase.COMPILE)
public class CustomMojo extends AbstractMojo {

    public void execute() throws MojoExecutionException {
        getLog().info("Executing a custom task in Maven!");
    }
}
```

Para usar este Mojo, primero se necesita empaquetar la clase en un plugin y registrar el plugin en el archivo `pom.xml`:

```xml title="pom.xml"
<build>
    <plugins>
        <plugin>
            <groupId>com.example</groupId>
            <artifactId>custom-maven-plugin</artifactId>
            <version>1.0-SNAPSHOT</version>
            <executions>
                <execution>
                    <goals>
                        <goal>custom-task</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
Una vez configurado el plugin, puedes ejecutar la tarea personalizada usando el siguiente comando de Maven:

```bash
mvn com.example:custom-maven-plugin:1.0-SNAPSHOT:custom-task
```

## ¿Qué hemos visto?

En esta sección hemos aprendido a definir tareas personalizadas en Gradle utilizando clases en Kotlin. Estas tareas
encapsulan lógica reutilizable y más avanzada, lo que nos permite tener un control más preciso sobre la ejecución de las
mismas. También vimos cómo usar anotaciones para definir inputs y outputs de nuestras tareas, y cómo registrarlas para
ser ejecutadas desde la línea de comandos. Finalmente, implementamos ejemplos prácticos, como el cálculo de la secuencia
de Fibonacci y el procesamiento de archivos de texto.

Además, exploramos cómo hacer nuestras tareas más flexibles permitiendo el manejo de errores y entradas no válidas, como
fue el caso de la tarea de verificación de números pares e impares.
