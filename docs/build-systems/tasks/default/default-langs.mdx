---
title: Tareas predefinidas en otros frameworks
---

## JVM: Maven

Al igual que Gradle, **Maven** ofrece un conjunto de tareas predefinidas (o **fases del ciclo de vida**) para facilitar la automatización de tareas comunes como la compilación, empaquetado, y ejecución de pruebas en proyectos de software. Sin embargo, mientras que Gradle es más flexible en la configuración de tareas a través de scripts en Groovy o Kotlin, Maven sigue un enfoque basado en XML mediante el archivo `pom.xml`.

### Fases Principales del Ciclo de Vida en Maven

Maven tiene varias fases predefinidas, algunas de las más utilizadas son:

### `clean`

La fase `clean` en Maven es equivalente a la tarea `clean` en Gradle. Elimina los archivos generados por compilaciones anteriores:

```bash
mvn clean
```

Esto eliminará el directorio `target/` y otros archivos temporales generados.

### `compile`

La fase `compile` se encarga de compilar el código fuente del proyecto:

```bash
mvn compile
```

Al ejecutarla, Maven compilará el código del proyecto y dejará los artefactos en el directorio `target/classes`.

### `test`

La fase `test` ejecuta las pruebas unitarias del proyecto utilizando frameworks como **JUnit** o **TestNG**. Se puede personalizar de manera similar a Gradle configurando el plugin de pruebas en `pom.xml`.

```bash
mvn test
```

Esto ejecutará todas las pruebas unitarias definidas en el proyecto y mostrará los resultados en la consola.

### `package`

La fase `package` empaqueta el código compilado en un formato distribuible, como un JAR o WAR:

```bash
mvn package
```

Maven generará un archivo JAR o WAR en el directorio `target/`.

### `verify`

Esta fase verifica que el proyecto es válido y cumple con los criterios de calidad especificados:

```bash
mvn verify
```

Maven ejecutará todas las pruebas de verificación, incluyendo validaciones de integridad y calidad.

### Configuración de Tareas Predefinidas en Maven

Si bien Maven es menos flexible que Gradle en cuanto a la configuración de tareas, también permite ajustar tareas predefinidas, como la ejecución de pruebas, a través de plugins como el **maven-surefire-plugin**. A continuación, un ejemplo de cómo configurar la fase `test` para usar JUnit y especificar eventos de prueba:

```xml title="pom.xml"
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M5</version>
            <configuration>
                <includes>
                    <include>**/*Test.java</include>
                </includes>
                <testFailureIgnore>false</testFailureIgnore>
                <forkCount>1</forkCount>
                <reuseForks>true</reuseForks>
                <reportFormat>brief</reportFormat>
            </configuration>
        </plugin>
    </plugins>
</build>
```

En este ejemplo:
- Se configura el plugin `maven-surefire-plugin` para ejecutar las pruebas unitarias del proyecto.
- La propiedad `forkCount` permite controlar el paralelismo en la ejecución de pruebas.
- El `reportFormat` se define como "brief" para mostrar un resumen de los resultados de las pruebas.
