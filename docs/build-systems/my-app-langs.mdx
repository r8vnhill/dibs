---
title: Creación de aplicaciones en otros frameworks
---

## Herramienta Multilenguaje: **Buck**

**Buck** es una herramienta de construcción de código abierta desarrollada por Facebook, diseñada para proyectos grandes y escalables, soportando múltiples lenguajes, incluyendo **C++**, **Java**, **Python**, **Go**, **Rust**, y más. Al igual que **Gradle**, **Buck** permite compilar, empaquetar y ejecutar aplicaciones, pero con un enfoque en la velocidad y la eficiencia de construcciones incrementales.

### Ejemplo de Aplicación Kotlin con Buck

En **Buck**, los pasos son ligeramente diferentes. Al ser una herramienta más orientada a la optimización de grandes proyectos, **Buck** no tiene una equivalencia directa a los comandos `run` y `installDist` de **Gradle**, pero sigue permitiendo construir y ejecutar aplicaciones de forma eficiente.

1. **Configuración de Buck para Kotlin**
    **Buck** utiliza archivos `BUCK` para definir cómo se construyen los proyectos. Aquí tienes un ejemplo básico de cómo configurar un proyecto **Kotlin** en **Buck**.

    ```python title="BUCK" showLineNumbers
    kotlin_library(
        name = "echo_lib",
        srcs = glob(["*.kt"]),
        deps = [
            "//third_party:kotlinx-datetime",
        ],
    )

    kotlin_binary(
        name = "echo_app",
        srcs = ["EchoApp.kt"],
        deps = [":echo_lib"],
        main_class = "cl.ravenhill.echo.EchoAppKt",
    )
    ```

    - **kotlin_library**: Define una biblioteca Kotlin.
    - **kotlin_binary**: Define un binario ejecutable, similar a `installDist` en Gradle.

2. **Construir la aplicación**:
    A diferencia de Gradle, **Buck** no tiene un comando directo para ejecutar la aplicación sin antes construirla. Para construir la aplicación, utilizamos el siguiente comando:

    ```bash
    buck build //:echo_app
   ```

    Esto generará un archivo binario en el directorio `buck-out/gen/`.

3. **Ejecutar la aplicación**:

    Una vez construida, podemos ejecutar la aplicación con el comando `buck run`, similar al `gradle run` de Gradle:

    ```bash
    buck run //:echo_app -- "Hello, world!"
   ```

    Al igual que en Gradle, se pueden pasar argumentos directamente al ejecutable utilizando `--` seguido de los argumentos.

### Comparación Entre Gradle y Buck

| Característica                               | Gradle                                     | Buck                                                                         |
|----------------------------------------------|--------------------------------------------|------------------------------------------------------------------------------|
| **Ejecutar aplicación directamente**         | `gradle run`                               | `buck run`                                                                   |
| **Generar archivo ejecutable independiente** | `gradle installDist`                       | `buck build` (genera el binario, pero sin empaquetado detallado como Gradle) |
| **Lenguajes soportados**                     | Principalmente JVM (Kotlin, Java)          | Multilenguaje (C++, Python, Go, Rust, Kotlin, etc.)                          |
| **Soporte para dependencias**                | Repositorios como MavenCentral, JCenter    | Archivos externos o integraciones personalizadas                             |
| **Caché**                                    | Local y remoto, con configuración opcional | Caché avanzado distribuido por defecto                                       |
| **Curva de aprendizaje**                     | Más amigable para proyectos JVM            | Mayor curva de aprendizaje, pero escalable para proyectos grandes            |

## C/C++: CMake

**CMake** es una herramienta de automatización de la construcción de software que genera archivos de proyecto para compiladores como **Make** o **Ninja**. Aunque no es un sistema de construcción en sí mismo, su flexibilidad y compatibilidad con múltiples lenguajes lo hacen una opción popular en proyectos C, C++ y más.

### Estructura del Proyecto en CMake

A diferencia de **Gradle**, donde las configuraciones están dispersas en varios archivos (`build.gradle.kts`, `settings.gradle.kts`), en **CMake** la configuración principal del proyecto se define en un solo archivo llamado `CMakeLists.txt`. Aquí se definen los objetivos (`targets`), las fuentes del proyecto y las configuraciones de compilación.

#### Ejemplo: Proyecto CMake Básico

Veamos un ejemplo de un proyecto en **CMake** que hace eco de un mensaje de texto, similar a la aplicación **EchoApp** que creamos con Gradle.

Primero, creamos un archivo `CMakeLists.txt` para definir la configuración del proyecto:

```cmake title="CMakeLists.txt"
cmake_minimum_required(VERSION 3.10)

# Nombre del proyecto y versión
project(EchoApp VERSION 1.0)

# Añadir el ejecutable al proyecto
add_executable(echo_app main.cpp)
```

Y el archivo fuente `main.cpp` contiene la lógica de la aplicación:

```cpp title="main.cpp"
#include <iostream>
#include <chrono>
#include <ctime>

void echo(const std::string& message) {
    auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::cout << std::ctime(&now) << " - " << message << std::endl;
}

int main(int argc, char* argv[]) {
    for (int i = 1; i < argc; ++i) {
        echo(argv[i]);
    }
    return 0;
}
```

#### Similitudes con Gradle

- **Definición del Proyecto**: En ambos lenguajes, se comienza definiendo el proyecto con un nombre y versión. En **Gradle**, usamos `build.gradle.kts` para este propósito, mientras que en **CMake**, utilizamos `CMakeLists.txt`.
- **Objetivos Ejecutables**: Tanto Gradle como CMake permiten definir un objetivo ejecutable (en Gradle, el plugin `application`, y en CMake, la función `add_executable`).

#### Diferencias

- **Simplicidad**: Gradle tiene una estructura más modular con múltiples archivos (`build.gradle.kts`, `settings.gradle.kts`, etc.), mientras que CMake agrupa toda la configuración en un único archivo (`CMakeLists.txt`).
- **Ecosistema de Bibliotecas**: En Gradle, las dependencias se gestionan fácilmente a través de repositorios como **Maven Central**. En CMake, debes gestionar las bibliotecas de manera más manual, por ejemplo, utilizando `find_package` o añadiendo rutas específicas de bibliotecas.

### Agregando Bibliotecas Externas

En **CMake**, añadir dependencias externas puede ser más laborioso que en Gradle. Por ejemplo, si quisiéramos añadir una biblioteca para manejar fechas y horas en C++, tendríamos que hacer lo siguiente:

```cmake
find_package(Date REQUIRED)  # Buscar la biblioteca Date

# Incluir la biblioteca al objetivo ejecutable
target_link_libraries(echo_app PRIVATE Date::Date)
```

En Gradle, la adición de bibliotecas se hace de manera más directa, como hemos visto con la inclusión de `kotlinx-datetime`:

```kotlin
dependencies {
    implementation(libs.kotlinx.datetime)
}
```

### Publicando la Aplicación

En **Gradle**, puedes generar un archivo ejecutable empaquetado utilizando el comando `installDist`, que crea un directorio con los archivos necesarios para ejecutar la aplicación sin necesidad de instalar Gradle. En **CMake**, la generación de un ejecutable empaquetado se realiza con la siguiente secuencia de comandos:

```bash
mkdir build
cd build
cmake ..
make
```

Esta secuencia compila y genera el binario `echo_app`, que puedes ejecutar de manera independiente.

### Similitudes en la Publicación

- **Ambos sistemas permiten empaquetar aplicaciones ejecutables** que pueden ser distribuidas sin depender del sistema de construcción (Gradle o CMake).
- Ambos utilizan un directorio `build` para almacenar los archivos generados.

### Diferencias en la Publicación

- **Instalación**: Gradle usa el comando `installDist` para crear un directorio con un script ejecutable, mientras que CMake requiere la creación manual de un directorio `build` y la ejecución de comandos como `cmake` y `make`.
- **Scripts de Ejecución**: Gradle genera scripts de ejecución que simplifican el proceso para el usuario final. En CMake, debes asegurarte de que los binarios generados estén configurados correctamente para ejecutarse en diferentes sistemas.

## JVM: Maven

Mientras Gradle utiliza archivos de configuración basados en Groovy o Kotlin DSL para gestionar proyectos, **Maven** usa archivos XML llamados `pom.xml` (Project Object Model). Aunque los dos sistemas de construcción son muy diferentes en cuanto a sintaxis y enfoques, los conceptos que manejan son similares. Vamos a explorar cómo lograr una configuración equivalente a la aplicación **Echo App** usando Maven.

### Configuración básica en Maven

En Maven, la estructura del proyecto y los archivos de configuración están organizados alrededor del archivo `pom.xml`. Aquí, configuramos nuestras dependencias, el plugin de compilación de Kotlin y el main class.

#### Dependencias

En lugar de un archivo `libs.versions.toml` como en Gradle, en Maven definimos las versiones directamente dentro del `pom.xml`. Para incluir la dependencia `kotlinx-datetime`, se utiliza la siguiente configuración dentro del bloque `<dependencies>`:

```xml
<dependencies>
    <dependency>
        <groupId>org.jetbrains.kotlinx</groupId>
        <artifactId>kotlinx-datetime</artifactId>
        <version>0.6.1</version>
    </dependency>
    <!-- Otras dependencias -->
</dependencies>
```

### Repositorios en Maven

Al igual que en Gradle, necesitamos asegurarnos de que Maven pueda buscar las dependencias en el repositorio correcto. Para esto, añadimos el repositorio de Maven Central en el `pom.xml` dentro del bloque `<repositories>`:

```xml
<repositories>
    <repository>
        <id>central</id>
        <url>https://repo.maven.apache.org/maven2</url>
    </repository>
</repositories>
```

### Plugin de Kotlin

Maven requiere que añadamos explícitamente el plugin de Kotlin para compilar nuestro código. Esto se realiza en el bloque `<build>`:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-maven-plugin</artifactId>
            <version>2.0.20</version>
            <executions>
                <execution>
                    <goals>
                        <goal>compile</goal>
                        <goal>test-compile</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

### Especificando el `mainClass`

Para hacer la aplicación ejecutable con Maven, se define la clase principal de la aplicación en el plugin `maven-jar-plugin`:

```xml
<build>
    <plugins>
        <!-- Plugin de Kotlin -->
        <plugin>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-maven-plugin</artifactId>
            <!-- ... -->
        </plugin>

        <!-- Plugin para empaquetar la aplicación -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>3.2.0</version>
            <configuration>
                <archive>
                    <manifest>
                        <addClasspath>true</addClasspath>
                        <mainClass>cl.ravenhill.echo.EchoAppKt</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### Crear y Ejecutar la Aplicación

Para compilar y ejecutar la aplicación con Maven, puedes utilizar los siguientes comandos:

- **Compilar**: `mvn compile`
- **Ejecutar**: `mvn exec:java -Dexec.mainClass="cl.ravenhill.echo.EchoAppKt" -Dexec.args="Hello, World!"`

### Empaquetar y Distribuir

Para empaquetar la aplicación en un **JAR ejecutable**, utilizamos el siguiente comando:

```bash
mvn package
```

Esto genera un archivo `.jar` en la carpeta `target/`. El JAR se puede ejecutar independientemente de Maven usando:

```bash
java -jar target/echo-app-1.0-SNAPSHOT.jar "Hello, World!"
```

### Comparación con Gradle

- **Simplicidad de configuración**: Mientras Gradle tiene una sintaxis más concisa, Maven utiliza XML, lo cual puede ser más verboso. Sin embargo, ambos sistemas de construcción permiten manejar dependencias y configurar plugins de forma efectiva.
- **Uso de plugins**: En Gradle, aplicamos plugins directamente en el archivo `build.gradle.kts` usando la palabra clave `plugins`. En Maven, los plugins se configuran dentro del bloque `<build>` en el archivo `pom.xml`.
- **Declaración de dependencias**: En Maven, las dependencias se declaran en XML dentro del bloque `<dependencies>`, mientras que en Gradle se utilizan bloques `dependencies { }` más concisos.
- **Ejecución de la aplicación**: En Gradle, usamos `gradle run` para ejecutar la aplicación durante el desarrollo, mientras que en Maven se utiliza `mvn exec:java`.
