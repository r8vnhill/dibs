---
title: Creando un Proyecto B√°sico con CMake
---
import GitHubRepoLink from "@site/src/components/git/GitHubRepoLink";
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime/>
<GitHubRepoLink repo={"echo-app-cmake"} user={"r8vnhill"} />

## üß∞ Paso 0: Instalar dependencias necesarias para CMake

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title=""
        
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title=""
        
        ```
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title=""
        
        ```
    </TabItem>
</BoxedTabs>

## üèóÔ∏è Crear un Proyecto con CMake

A diferencia de Gradle, CMake no tiene un comando `init` que genere estructuras por defecto. Normalmente, un proyecto se inicia creando manualmente los archivos.

### üß± Estructura t√≠pica del proyecto

```mermaid
graph TD
    A["üìÇ echo-app-cmake"]
    B["üìÇ src/"]
    C["üìÑ main.cpp"]
    D["üìÇ include/"]
    E["üìÇ build/"]
    F["üìÑ CMakeLists.txt"]

    A --> B
    B --> C
    A --> D
    A --> E
    A --> F
```

:::info[Explicaci√≥n]

Este diagrama muestra la estructura t√≠pica de un proyecto en C++ configurado con CMake:

- **`CMakeLists.txt`** es el archivo principal de configuraci√≥n del proyecto. Define el est√°ndar del lenguaje, los archivos fuente, el nombre del ejecutable, y cualquier configuraci√≥n adicional.
- **üìÇ `src/`** contiene el c√≥digo fuente del proyecto. Aqu√≠ se define la l√≥gica de la aplicaci√≥n. En este ejemplo, el archivo `main.cpp` es el punto de entrada.
- **üìÇ `include/`** suele contener los archivos de cabecera (`.h` o `.hpp`) que declaran interfaces, funciones, y estructuras utilizadas en el c√≥digo fuente.
- **üìÇ `build/`** es la carpeta destinada a contener los artefactos de compilaci√≥n. Es buena pr√°ctica mantenerla separada del c√≥digo fuente para permitir builds limpios y m√∫ltiples configuraciones (debug/release, etc.).

Esta estructura facilita la organizaci√≥n del c√≥digo, la reutilizaci√≥n de componentes, y el uso de herramientas como CMake sin mezclar archivos generados con archivos fuente.

:::

### üìÑ Contenido de `CMakeLists.txt`

```cmake showLineNumbers title="CMakeLists.txt"
cmake_minimum_required(VERSION 3.16)
project(echo_app)

set(CMAKE_CXX_STANDARD 17)

add_executable(echo-app src/main.cpp)
```

:::warning

A diferencia de Gradle, CMake **no gestiona dependencias autom√°ticamente**. La gesti√≥n de bibliotecas externas requiere herramientas adicionales como `vcpkg`, `FetchContent`, o integraciones personalizadas.

:::

### üî† Ejemplo de `main.cpp`

```cpp showLineNumbers title="src/main.cpp"
#include <iostream>

int main() {
    std::cout << "Hello, world" << std::endl;
    return 0;
}
```

### ‚öôÔ∏è Compilar el Proyecto

<BoxedTabs>
  <TabItem value="Windows" label="Windows">
    ```powershell
    mkdir build
    cd build
    cmake ..
    cmake --build .
    .\Debug\echo-app.exe
    ```

    <Explanation>
      Este conjunto de comandos compila y ejecuta el proyecto en Windows utilizando el generador predeterminado de CMake, que suele ser **Visual Studio**:

      - `mkdir build` crea un directorio de compilaci√≥n fuera del √°rbol de c√≥digo fuente.
      - `cd build` entra al directorio de compilaci√≥n.
      - `cmake ..` genera los archivos de soluci√≥n (`.sln`) y configuraciones del proyecto.
      - `cmake --build .` compila el proyecto usando el entorno de desarrollo detectado.
      - `.\Debug\echo-app.exe` ejecuta el binario generado, ubicado por defecto en la carpeta `Debug`.

      Este flujo es √∫til para trabajar con compiladores de Visual Studio directamente desde la terminal, sin necesidad de abrir el IDE.
    </Explanation>
  </TabItem>

  <TabItem value="Linux/Mac" label="Linux/Mac">
    ```bash
    mkdir build
    cd build
    cmake ..
    make
    ./echo-app
    ```

    <Explanation>
      Este conjunto de comandos compila y ejecuta el proyecto en sistemas Unix-like (como Ubuntu o macOS) utilizando `make`:

      - `mkdir build` crea un directorio de compilaci√≥n fuera del √°rbol de c√≥digo fuente.
      - `cd build` accede al nuevo directorio.
      - `cmake ..` genera los archivos de construcci√≥n a partir de `CMakeLists.txt`.
      - `make` compila el proyecto utilizando Makefiles generados por CMake.
      - `./echo-app` ejecuta el binario generado, que se encuentra en el mismo directorio.

      Esta pr√°ctica de **compilaci√≥n fuera de √°rbol** ayuda a mantener el proyecto limpio y facilita el manejo de configuraciones o builds paralelos.
    </Explanation>
  </TabItem>
</BoxedTabs>


## üìä Resumen comparativo

| **Aspecto**                      | **CMake**                                                                 | **Gradle (Kotlin DSL)**                                                   |
|----------------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------|
| **Inicializaci√≥n del proyecto** | Manual (`mkdir`, archivos a mano)                                         | `gradle init`, con opciones guiadas                                       |
| **Gesti√≥n de dependencias**     | No incluida; requiere `vcpkg`, `FetchContent`, etc.                       | Integrada (con `dependencies` y repositorios como Maven Central)         |
| **Lenguaje de configuraci√≥n**   | Propio DSL (declarativo, estilo CMakeLists)                               | Kotlin DSL (o Groovy)                                                     |
| **Soporte multiplataforma**     | Fuerte en C/C++, multiplataforma por naturaleza                          | Soporte para JVM, Android, JS, Native, multiplataforma con plugins       |
| **Sistema de tareas**           | No cuenta con un sistema de tareas general                               | Basado en tareas (`tasks`, `doLast`, `dependsOn`, etc.)                  |
| **Compilaci√≥n fuera del √°rbol** | S√≠, mediante `mkdir build && cd build`                                    | S√≠, pero no es una pr√°ctica obligatoria                                   |
| **Wrapper**                     | No tiene; depende de instalaci√≥n global de CMake                          | Tiene (`gradlew`), asegura versi√≥n unificada                             |
| **Plugins/extensiones**         | No tiene sistema de plugins integrado                                     | Soporte amplio con `plugins {}` y repositorios                            |
| **Integraci√≥n de pruebas**      | Manual (requiere `gtest`, configuraci√≥n adicional)                        | Integraci√≥n directa con frameworks como JUnit, Kotest, etc.              |
| **Publicaci√≥n de artefactos**   | Requiere configuraci√≥n manual o scripts externos                          | Soporte integrado (Maven, GitHub, Nexus, etc.)                           |
| **Curva de aprendizaje**        | Menor para proyectos peque√±os, pero puede crecer r√°pido                   | Algo m√°s empinada al principio, pero m√°s fluida con experiencia           |
| **Casos de uso comunes**        | Proyectos en C/C++, bibliotecas de sistemas, compiladores, herramientas   | Aplicaciones y bibliotecas en Kotlin/JVM, Android, multiplataforma       |
| **Compatibilidad con IDEs**     | Alta (Visual Studio, CLion, VS Code, etc.)                                | Alta (IntelliJ, Android Studio, VS Code, etc.)                           |

### ‚úÖ Beneficios / ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Altamente portable**: CMake permite generar archivos de proyecto para m√∫ltiples entornos (Make, Ninja, Visual Studio, Xcode), facilitando la compilaci√≥n cruzada y la portabilidad entre plataformas.
        - **Separaci√≥n clara entre c√≥digo y artefactos de compilaci√≥n**: La compilaci√≥n fuera del √°rbol (`out-of-source builds`) mantiene el repositorio limpio y facilita pruebas paralelas o builds separados.
        - **Gran compatibilidad con herramientas de C/C++**: CMake es el est√°ndar de facto para proyectos en C++ y tiene soporte nativo en muchos IDEs y herramientas de an√°lisis est√°tico.
        - **Soporta proyectos complejos**: Puede gestionar proyectos grandes con m√∫ltiples m√≥dulos, bibliotecas compartidas, y targets personalizados con l√≥gica condicional avanzada.
        - **Extensible**: Puedes escribir funciones propias en el DSL de CMake para encapsular configuraciones repetidas.
    </Pros>
    <Cons>
        - **No gestiona dependencias de forma nativa**: A diferencia de Gradle, CMake no incluye un sistema de resoluci√≥n de dependencias. Se requiere integrar herramientas como `vcpkg`, `FetchContent`, o realizar instalaciones manuales.
        - **DSL con sintaxis peculiar**: El lenguaje de configuraci√≥n de CMake puede ser menos intuitivo, especialmente al trabajar con listas, condiciones, o bucles.
        - **Falta un sistema de tareas integrado**: No tiene un mecanismo declarativo para definir tareas como `test`, `format`, `publish`, lo cual limita la automatizaci√≥n dentro del mismo sistema.
        - **Menor integraci√≥n con ecosistemas de publicaci√≥n**: Publicar bibliotecas o binarios requiere scripts adicionales o soluciones externas, a diferencia del enfoque plugin-driven de Gradle.
    </Cons>
</ProCons>

## üéØ Conclusiones

CMake es una herramienta poderosa y vers√°til para gestionar la compilaci√≥n de proyectos en C y C++. Aunque su enfoque es m√°s manual que el de herramientas como Gradle, ofrece gran flexibilidad y control sobre cada aspecto del proceso de construcci√≥n. A lo largo de esta lecci√≥n aprendiste a crear un proyecto b√°sico con CMake, organizar su estructura, compilarlo en diferentes sistemas operativos y contrastarlo con un enfoque m√°s automatizado como Gradle.

Mientras que Gradle ofrece una experiencia m√°s guiada y automatizada, CMake se destaca por su portabilidad, su compatibilidad con m√∫ltiples entornos y su uso extensivo en proyectos de software de sistemas.

### üîë Puntos clave

- **CMake no genera estructura autom√°ticamente**: Requiere crear los archivos y carpetas iniciales manualmente, lo que da m√°s control pero implica m√°s responsabilidad.
- **Compilaci√≥n fuera del √°rbol**: Es una pr√°ctica est√°ndar con CMake y ayuda a mantener el proyecto limpio y bien organizado.
- **CMakeLists.txt es el n√∫cleo del sistema**: Define c√≥mo debe compilarse el proyecto, qu√© archivos incluir y qu√© est√°ndar utilizar.
- **No incluye un sistema de dependencias**: A diferencia de Gradle, deber√°s integrar soluciones externas si necesitas bibliotecas de terceros.
- **Alta compatibilidad con IDEs y herramientas**: CMake es ampliamente soportado, lo que lo hace ideal para proyectos en C++ que necesitan portabilidad y flexibilidad.

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° de la configuraci√≥n b√°sica de un proyecto, trabajar con CMake nos invita a entender mejor el proceso de construcci√≥n del software. Al no depender de comandos autom√°ticos ni estructuras predefinidas, nos enfrentamos directamente con las decisiones de dise√±o que hay detr√°s de un sistema de build. Esta exposici√≥n no solo nos da mayor control, sino que tambi√©n profundiza nuestra comprensi√≥n de c√≥mo el c√≥digo fuente se transforma en binarios ejecutables.

A diferencia de Gradle, que abstrae muchas de estas decisiones, CMake exige una participaci√≥n m√°s activa, lo que puede parecer una barrera al principio, pero se convierte en una ventaja al escalar hacia proyectos m√°s complejos o multiplataforma. Comprender sus principios desde lo b√°sico nos prepara para afrontar escenarios reales de desarrollo en C y C++, donde el entorno, el compilador y la portabilidad son elementos clave.

As√≠, lo que nos llevamos no es solo un ejecutable funcional, sino una visi√≥n m√°s clara y precisa del rol que cumple un sistema de construcci√≥n en el ciclo de vida de una biblioteca o aplicaci√≥n.

## üìñ Referencias

### üî• Recomendadas

- üåê CMake Tutorial‚ÄîCMake 4.0.0-rc5 Documentation. (s.¬†f.). Recuperado 23 de marzo de 2025, de https://cmake.org/cmake/help/latest/guide/tutorial/index.html
