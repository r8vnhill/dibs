---
title: Creando un Proyecto B√°sico en Rust con Cargo
---

import ReadingTime from "@site/src/components/ReadingTime";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import GithubRepoLink from '@site/src/components/GithubRepoLink';
import Explanation from '@site/src/components/admonitions/Explanation';
import ReferenceList from '@site/src/components/references/ReferenceList';
import Book from '@site/src/components/references/Book';

<ReadingTime multiplier={2} />
<GithubRepoLink user="r8vnhill" repo="echo-app-rust" />

Esta lecci√≥n est√° pensada como una puerta de entrada pr√°ctica a Rust desde una perspectiva de dise√±o de bibliotecas y herramientas. Aprender√°s a instalar su toolchain, crear un proyecto reproducible desde cero y comprender c√≥mo organizarlo correctamente. Todo lo que necesitas para comenzar a construir con confianza en este nuevo ecosistema.

## üß∞ Paso 0: Instalar dependencias necesarias para Rust

Rust es un lenguaje moderno que combina **rendimiento a nivel de C++**, con un enfoque en **seguridad de memoria sin recolector de basura**. Es especialmente atractivo para desarrollo de sistemas, programaci√≥n embebida, bibliotecas de alto rendimiento y herramientas CLI seguras y reproducibles.

A diferencia de muchos lenguajes, Rust se distribuye con una herramienta oficial llamada **Cargo**, que unifica:

- Gesti√≥n de dependencias (`Cargo.toml`)
- Compilaci√≥n (`cargo build`)
- Ejecuci√≥n (`cargo run`)
- Pruebas (`cargo test`)
- Publicaci√≥n de paquetes (`cargo publish`)

Esto hace que iniciar y mantener proyectos sea m√°s consistente, productivo y reproducible ‚Äîincluso en equipos distribuidos o ambientes de CI.

:::note Nota

Usar Rust sin Cargo es t√©cnicamente posible, pero extremadamente raro. Cargo es parte integral del ecosistema, y la gran mayor√≠a de proyectos Rust lo utilizan como punto de partida.

:::

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="scripts/windows/Install-RustDependencies.ps1"
        function Install-RustDependencies {
            function Test-Installed([string[]] $CheckCommands) {
                foreach ($command in $CheckCommands) {
                    try {
                        & $command --version | Out-Null
                    } catch {
                        throw "‚ùå '$CheckCommand' was not found after installation."
                    }
                }
            }

            scoop install rustup
            Test-Installed rustup, rustc, cargo

            Write-Host "‚úÖ Rust toolchain is installed successfully." -ForegroundColor Green
        }

        Install-RustDependencies
        ```

        Guarda este script como `Install-RustDependencies.ps1` y ejec√∫talo:

        ```powershell
        .\Install-RustDependencies.ps1
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="scripts/macos/install_rust_dependencies.sh"
        #!/usr/bin/env bash

        set -euo pipefail

        # Function to check if commands are available by calling them with --version
        test_installed() {
            for cmd in "$@"; do
                if ! command -v "$cmd" &> /dev/null; then
                    echo "‚ùå '$cmd' was not found after installation. Check your PATH." >&2
                    exit 1
                fi
                "$cmd" --version > /dev/null || {
                    echo "‚ùå '$cmd' exists but failed to respond to --version." >&2
                    exit 1
                }
            done
        }

        install_rust_dependencies() {
            # Install rustup via Homebrew if not already installed
            if ! command -v rustup &> /dev/null; then
                echo "üì¶ Installing rustup using Homebrew..."
                brew install rustup-init
                rustup-init -y
            else
                echo "‚ÑπÔ∏è rustup is already installed."
            fi

            # Add the cargo bin directory to PATH
            if [ -f "$HOME/.cargo/env" ]; then
                . "$HOME/.cargo/env"
            else
                echo "‚ö†Ô∏è Warning: '$HOME/.cargo/env' not found. Ensure Rust is properly installed."
            fi
            
            # Ensure rustc and cargo are installed
            test_installed rustup rustc cargo
            
            echo "‚úÖ Rust toolchain is installed successfully."
        }

        install_rust_dependencies
        ```

        Guarda este script como `install_rust_dependencies.sh` y ejec√∫talo:

        ```bash
        bash install_rust_dependencies.sh
        ```
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title="Instalaci√≥n de Rust en Linux"
        #!/usr/bin/env bash

        set -euo pipefail

        # Function to check if commands are available by calling them with --version
        test_installed() {
            for cmd in "$@"; do
                if ! command -v "$cmd" &> /dev/null; then
                    echo "‚ùå '$cmd' was not found after installation. Check your PATH." >&2
                    exit 1
                fi
                "$cmd" --version > /dev/null || {
                    echo "‚ùå '$cmd' exists but failed to respond to --version." >&2
                    exit 1
                }
            done
        }

        install_rust_dependencies() {
            # Check if rustup is installed
            if ! command -v rustup &> /dev/null; then
                echo "üì¶ Installing rustup using the official script..."
                curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            else
                echo "‚ÑπÔ∏è rustup is already installed."
            fi

            # Add the cargo bin directory to PATH
            if [ -f "$HOME/.cargo/env" ]; then
                . "$HOME/.cargo/env"
            else
                echo "‚ö†Ô∏è Warning: '$HOME/.cargo/env' not found. Ensure Rust is properly installed."
            fi

            # Ensure rustc and cargo are installed
            test_installed rustup rustc cargo

            echo "‚úÖ Rust toolchain is installed successfully."
        }

        install_rust_dependencies
        ```

        Guarda este script como `install_rust_dependencies.sh` y ejec√∫talo:

        ```bash
        bash install_rust_dependencies.sh
        ```

        Luego, aseg√∫rate de que el directorio de Cargo est√© en tu `PATH`. Puedes agregar la siguiente l√≠nea a tu archivo `~/.bashrc` o `~/.zshrc`:

        ```bash
        export PATH="$HOME/.cargo/bin:$PATH"
        ```

        Despu√©s, recarga tu terminal para que los cambios surtan efecto y prueba que Rust est√° instalado correctamente:

        ```bash
        rustc --version
        cargo --version
        ```
    </TabItem>
</BoxedTabs>

## üì¶ Paso 1: Crear un proyecto nuevo

Con Cargo es trivial arrancar un proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="scripts/windows/Initialize-RustProject.ps1"
        function Initialize-RustProject {
            [CmdletBinding()]
            param (
                # Name of the Rust project to create.
                [string]$ProjectName
            )

            # Create a new Rust binary project with the specified name using Cargo.
            # This will generate a new directory containing a basic Rust project structure.
            cargo new $ProjectName

            # Change the current working directory to the newly created project folder.
            # This makes it easier to run further setup steps inside the project context.
            Push-Location $ProjectName
        }

        # Call the function to create and navigate into a new Rust project named "echo_app_rust"
        Initialize-RustProject -ProjectName "echo_app_rust"
        ```

        Guarda este script como `Initialize-RustProject.ps1` y ejec√∫talo:

        ```powershell
        .\Initialize-RustProject.ps1
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="scripts/macos/initialize_rust_project.sh"
        #!/usr/bin/env bash

        set -euo pipefail

        # Initializes a new Rust binary project and changes into its directory.
        # 
        # Arguments:
        #   $1 - Name of the Rust project to create
        initialize_rust_project() {
            local project_name="$1"

            # Create a new Rust binary project using Cargo
            cargo new "$project_name"

            # Change into the newly created project directory
            pushd "$project_name"
        }

        # Call the function with the desired project name
        initialize_rust_project "echo_app_rust"
        ```

        Guarda este script como `initialize_rust_project.sh` y ejec√∫talo:

        ```bash
        bash initialize_rust_project.sh
        ```
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title="scripts/linux/initialize_rust_project.sh"
        #!/usr/bin/env bash

        set -euo pipefail

        # Initializes a new Rust binary project and changes into its directory.
        # 
        # Arguments:
        #   $1 - Name of the Rust project to create
        initialize_rust_project() {
            local project_name="$1"

            # Create a new Rust binary project using Cargo
            cargo new "$project_name"

            # Change into the newly created project directory
            pushd "$project_name"
        }

        # Call the function with the desired project name
        initialize_rust_project "echo_app_rust"
        ```

        Guarda este script como `initialize_rust_project.sh` y ejec√∫talo:

        ```bash
        bash initialize_rust_project.sh
        ```
    </TabItem>
</BoxedTabs>

## üìÅ Estructura del Proyecto

Al crear un proyecto con `cargo new`, se genera autom√°ticamente una estructura clara y coherente para desarrollar en Rust. A continuaci√≥n se muestra la organizaci√≥n t√≠pica:

```mermaid
graph TD
    subgraph root[üìÅ echo_app_rust]
        direction LR

        target
        gitignore[".gitignore"]
        cargoLock["Cargo.lock"]
        cargoToml["Cargo.toml"]
        subgraph src["üìÅ src"]
            mainrs["main.rs"]
        end
    end
```

:::info Explicaci√≥n de la estructura

- **üìÅ `src/`**: Contiene el c√≥digo fuente del proyecto.
    - `main.rs`: Punto de entrada de una aplicaci√≥n binaria de Rust. Aqu√≠ empieza la ejecuci√≥n del programa.
- **`Cargo.toml`**: Archivo de configuraci√≥n del proyecto. Declara el nombre, versi√≥n, dependencias y configuraci√≥n general.
- **`Cargo.lock`**: Archivo generado autom√°ticamente por Cargo para bloquear las versiones exactas de las dependencias.
- **`.gitignore`**: Archivo usado por Git para ignorar archivos y carpetas no deseadas (como `target/`).
- **üìÅ `target/`**: Carpeta generada autom√°ticamente al compilar. Contiene los binarios, archivos intermedios y metadata del build.

:::

## üõ†Ô∏è Paso 2: Tomando el control de tu `Cargo.toml`

El archivo `Cargo.toml` es el coraz√≥n de cualquier proyecto Rust. Aqu√≠ defines no solo el nombre y versi√≥n del paquete, sino tambi√©n metadatos importantes, perfiles de compilaci√≥n y dependencias. Aprender a configurarlo correctamente es clave para construir proyectos mantenibles, portables y bien documentados.

```toml showLineNumbers title="Cargo.toml"
[package]
name = "echo_app_rust"
version = "0.1.0"
edition = "2024"
authors = ["Tu Nombre <correo@example.com>"]
description = "A basic echo app implemented in Rust."
license = "BSD-2"
repository = "https://github.com/tu_usuario/echo_app_rust"
keywords = ["echo", "cli", "example", "learning"]
categories = ["command-line-utilities"]

[dependencies]
# Aqu√≠ se declarar√°n las dependencias cuando las agregues

[profile.dev]
opt-level = 0               # Sin optimizaciones: compila r√°pido, ideal para desarrollo
overflow-checks = true      # Verifica desbordamientos aritm√©ticos
debug = true                # Incluye informaci√≥n de depuraci√≥n

[profile.release]
opt-level = 3               # Optimizaciones agresivas para producci√≥n
lto = true                  # Link Time Optimization para binarios m√°s peque√±os y r√°pidos
codegen-units = 1           # Compilaci√≥n m√°s lenta, pero con mejor rendimiento final
```

<Explanation>
    En este ejemplo ajustamos el archivo `Cargo.toml` para incluir informaci√≥n b√°sica del proyecto y mejorar el comportamiento de compilaci√≥n tanto en modo desarrollo como en modo producci√≥n. Estos perfiles permiten controlar c√≥mo se compila tu c√≥digo dependiendo del entorno y tus necesidades: rapidez para probar, o eficiencia para desplegar.
</Explanation>

:::tip

Recuerda reemplazar los valores de `authors` y `repository` con tu informaci√≥n real üòÑ

:::

## üåÑ Paso 3: Tu primer programa en Rust

Es momento de escribir tu primera funci√≥n `main`, el punto de entrada de toda aplicaci√≥n Rust. En este ejemplo, usaremos una cita inspiradora[^1] para ilustrar c√≥mo imprimir texto en consola, una tarea sencilla pero esencial para comenzar cualquier proyecto.

```rust showLineNumbers title="src/main.rs"
fn main() {
    println!("Even the darkest night will end and the sun will rise.");
}
```

<Explanation>
    Esta funci√≥n es el punto de entrada del programa. En Rust, la funci√≥n `main` se ejecuta autom√°ticamente al iniciar el binario. La macro `println!` imprime texto a la salida est√°ndar, similar a `println` en Kotlin.
</Explanation>

:::note ¬ø!?

En Rust, el signo `!` indica que estamos llamando a una **macro**, no a una funci√≥n normal. Las macros permiten generar c√≥digo durante la compilaci√≥n y ofrecen una sintaxis m√°s flexible que las funciones. En este caso, `println!` se comporta como una versi√≥n mejorada de `print`, con soporte para **interpolaci√≥n de variables**, saltos de l√≠nea autom√°ticos y otras comodidades.

::: 

### üöÄ Ejecutando tu programa

Ahora que escribiste tu primera funci√≥n `main`, ¬°es momento de ejecutarla!

Abre una terminal en la carpeta ra√≠z del proyecto (donde est√° tu archivo `Cargo.toml`) y ejecuta el siguiente comando:

```bash
cargo run
```

Ver√°s en la salida algo como esto:

```plaintext
   Compiling echo_app_rust v0.1.0 (path/to/echo_app_rust)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.82s
     Running `path/to/executable`
Even the darkest night will end and the sun will rise.
```

Rust compilar√° autom√°ticamente tu proyecto (si es la primera vez, tomar√° unos segundos) y luego ejecutar√° el binario generado.

:::tip ¬øQu√© hace `cargo run`?

Este comando hace **dos cosas**:
1. Compila el proyecto (si hay cambios).
2. Ejecuta el binario generado.

Es ideal para desarrollo, ya que te permite probar cambios r√°pidamente sin preocuparte por compilar manualmente cada vez.

:::

## üéØ Conclusiones

Comenzar con Rust puede parecer desafiante por su enfoque en la seguridad y el control, pero herramientas como Cargo simplifican enormemente el proceso. En esta lecci√≥n aprendiste a instalar las dependencias necesarias en distintos sistemas operativos, a crear y organizar un nuevo proyecto, y a configurar de forma consciente tu archivo `Cargo.toml`. Tambi√©n ejecutaste tu primer programa, entendiendo la sintaxis b√°sica de Rust y c√≥mo se estructura una aplicaci√≥n.

Adoptar buenas pr√°cticas desde el inicio ‚Äîcomo mantener una estructura clara, documentar tu proyecto, y entender los perfiles de compilaci√≥n‚Äî te permitir√° construir bibliotecas y herramientas m√°s robustas y sostenibles a largo plazo.

### üîë Puntos clave

- **Cargo** es la herramienta central del ecosistema Rust: gestiona dependencias, compila, ejecuta, prueba y publica.
- Crear un nuevo proyecto con `cargo new` establece una estructura limpia y coherente.
- El archivo `Cargo.toml` permite definir metadatos, dependencias y perfiles de compilaci√≥n de forma declarativa.
- Rust usa macros como `println!` para ofrecer funcionalidades potentes con una sintaxis simple.
- Ejecutar un proyecto con `cargo run` simplifica el ciclo de desarrollo, compilaci√≥n y prueba.

### üß∞ ¬øQu√© nos llevamos?

Al construir un proyecto b√°sico en Rust, sentamos las bases para dise√±ar bibliotecas seguras, eficientes y reproducibles. La experiencia de configurar desde cero con Cargo te prepara para escalar hacia proyectos m√°s complejos con confianza, sabiendo que el ecosistema de Rust promueve buenas pr√°cticas desde el primer paso. M√°s all√° de la sintaxis, te llevas una forma distinta de pensar la programaci√≥n: centrada en la seguridad, la claridad y la sostenibilidad del c√≥digo.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <Book
        chapter="Getting Started"
        pages={[1, 11]}
        book="The Rust Programming Language, 2nd Edition"
        author="Steve Klabnik & Carol Nichols"
    >
        Este cap√≠tulo presenta los fundamentos esenciales para comenzar a programar en Rust de forma reproducible y moderna. Explica c√≥mo instalar el compilador y el gestor de paquetes (<code>cargo</code>) en distintos sistemas operativos, c√≥mo compilar y ejecutar un programa sencillo con <code>rustc</code>, y luego c√≥mo crear y estructurar proyectos reales usando <code>cargo new</code>. Tambi√©n introduce conceptos clave como <code>Cargo.toml</code>, perfiles de compilaci√≥n (<code>debug</code> vs. <code>release</code>), uso de macros (<code>println!</code>), y buenas pr√°cticas de organizaci√≥n de proyectos. Es un recurso ideal para quienes comienzan su aprendizaje de Rust enfocado en la creaci√≥n de herramientas y bibliotecas robustas.
    </Book>
]}/>

[^1]: La cita ‚Äî‚ÄúEven the darkest night will end and the sun will rise‚Äù‚Äî proviene de *Les Mis√©rables* de Victor Hugo. Es un recordatorio de que, al igual que al aprender Rust, al principio puede parecer oscuro o dif√≠cil, pero si persistes, la claridad llega.
