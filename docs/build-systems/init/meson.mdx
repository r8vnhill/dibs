---
title: Creando un Proyecto B√°sico en C++ con Meson
---
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Explanation from '@site/src/components/admonitions/Explanation'
import ReadingTime from '@site/src/components/ReadingTime'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'

<GitHubRepoLink user="r8vnhill" repo="echo-app-cpp-meson" />

Una de las primeras habilidades que debemos dominar al construir software moderno ‚Äîespecialmente bibliotecas‚Äî es c√≥mo organizar y compilar nuestro c√≥digo de forma clara, eficiente y automatizada.

En esta lecci√≥n aprender√°s a crear un proyecto b√°sico en **C++** usando **Meson**, un sistema de construcci√≥n que destaca por su velocidad, simplicidad y soporte multiplataforma. Pero esto no se trata solo de compilar un ‚ÄúHello, World‚Äù: se trata de comprender y aplicar buenas pr√°cticas desde el primer archivo. Ver√°s c√≥mo herramientas como **Clang**, **Ninja** y **Meson** trabajan en conjunto, y aprender√°s a automatizar tanto su instalaci√≥n como la creaci√≥n de proyectos.

Adem√°s, ver√°s que aunque esta lecci√≥n usa C++ como ejemplo, lo que aprendes aqu√≠ se puede aplicar a muchos otros lenguajes. La clave est√° en aprender a estructurar bien, automatizar lo esencial y preparar el camino para un desarrollo mantenible.

:::info ¬øY por qu√© no usar CMake?

CMake es muy popular, pero puede volverse complejo r√°pidamente. **Meson ofrece una sintaxis m√°s clara, tiempos de configuraci√≥n m√°s r√°pidos y detecci√≥n autom√°tica de muchos detalles**. Es ideal para quienes comienzan y para proyectos modernos que priorizan la simplicidad y la automatizaci√≥n.

:::

## üß∞ Paso 0: Instalar dependencias necesarias para Meson

Antes de compilar o probar un proyecto con **Meson**, necesitamos contar con tres herramientas clave en nuestro entorno de desarrollo. A continuaci√≥n te explicamos **qu√© son**, **para qu√© se usan**, y luego te mostramos c√≥mo instalarlas autom√°ticamente seg√∫n tu sistema operativo.

Meson no act√∫a solo: **es el director de orquesta** en el proceso de construcci√≥n. Se encarga de interpretar tu configuraci√≥n, preparar todo el entorno y delegar las tareas concretas (como compilar) a otras herramientas especializadas. Por eso es fundamental que trabajen en conjunto:

| üõ†Ô∏è Herramienta | ¬øQu√© es? | ¬øPara qu√© la usamos? |
|----------------|----------|----------------------|
| **Meson** | Un sistema de construcci√≥n (*build system*) moderno, r√°pido y centrado en la simplicidad. Fue dise√±ado para reemplazar herramientas m√°s complejas como Autotools o CMake. Aunque es especialmente popular en proyectos en C y C++, **Meson tambi√©n puede usarse con otros lenguajes como Rust, Fortran o Java**, gracias a su enfoque modular. | Para **configurar** el proyecto y generar las instrucciones que controlan la compilaci√≥n (como los archivos que entiende Ninja). |
| **Ninja** | Un backend de compilaci√≥n minimalista y altamente eficiente, dise√±ado para ser usado junto con Meson. | Para **ejecutar la compilaci√≥n** real, siguiendo las reglas definidas por Meson. |
| **LLVM (Clang)** | Una infraestructura de compilaci√≥n moderna y modular, con herramientas de an√°lisis, optimizaci√≥n y compilaci√≥n. Clang es su frontend para los lenguajes C y C++. | Para **traducir** el c√≥digo fuente C o C++ a binarios ejecutables. Es el compilador real que se invoca al compilar con Ninja. |

> üß† **En conjunto:**  
> üß© **Meson** configura ‚Üí ‚ö° **Ninja** ejecuta ‚Üí üèóÔ∏è **Clang (LLVM)** compila tu c√≥digo.

Este ecosistema es ampliamente adoptado en proyectos modernos por su velocidad, claridad, y facilidad de integraci√≥n en entornos multiplataforma.

A continuaci√≥n, selecciona tu sistema operativo para ver c√≥mo instalarlas paso a paso:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="En PowerShell"
        function Install-MesonDependencies {
            [CmdletBinding()]
            param (
                [switch]$Quiet
            )

            # üîç Checks if a given command is available in the system
            function Test-Command {
                param ([string]$Command)
                return ($null -ne (Get-Command $Command -ErrorAction SilentlyContinue))
            }

            # üì¶ Installs a list of packages with Scoop if their associated command is missing
            function Install-PackagesWithScoop {
                param (
                    [hashtable]$CommandMap,
                    [switch]$Quiet
                )

                foreach ($pkg in $CommandMap.Keys) {
                    $command = $CommandMap[$pkg]

                    if (Test-Command {
                        Write-Host "üîπ $pkg is already available (via '$command'). Skipping Scoop." `
                            -ForegroundColor DarkGray
                        continue
                    }

                    Write-Host "üì¶ Installing $pkg with Scoop..." -ForegroundColor Cyan

                    if ($Quiet) {
                        scoop install $pkg *>&1 | Out-Null
                    } else {
                        scoop install $pkg
                    }

                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "‚úÖ $pkg installed successfully." -ForegroundColor Green
                    } else {
                        Write-Error "‚ùå Failed to install $pkg." -ForegroundColor Red
                        return 1
                    }
                }
            }

            # üß± Define which packages to install and how to verify them
            $commandMap = @{
                llvm  = 'clang'   # Required to compile C/C++ code
                meson = 'meson'   # Build system configuration tool
                ninja = 'ninja'   # Compilation executor
            }

            Install-PackagesWithScoop -CommandMap $commandMap @PSBoundParameters
        }
        ```

        ```powershell showLineNumbers title="Uso"
        Install-MesonDependencies         # Normal installation
        # Install-MesonDependencies -Quiet  # Uncomment for silent installation
        ```

        <Explanation>
            Esta funci√≥n permite instalar autom√°ticamente las herramientas necesarias para usar **Meson** en Windows, usando **Scoop** como gestor de paquetes.

            - ‚úÖ Comprueba si cada herramienta ya est√° disponible en el sistema.
            - ‚õî Si ya est√° instalada (como `clang` o `ninja`), se omite su instalaci√≥n.
            - üì¶ Si no est√°, la instala con `scoop install`.
            - üîï La opci√≥n `-Quiet` permite suprimir la salida del comando para scripts silenciosos.
        </Explanation>
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="En Terminal"
        install_meson_dependencies() {
            local llvm_method="$1"
            local quiet="$2"

            # ‚è± Waits for Xcode CLI installation to finish
            wait_for_xcode_cli() {
                echo "‚è≥ Waiting for installation to complete..."
                while ! xcode-select -p &>/dev/null; do
                    sleep 5
                done
            }

            # üì¶ Installs Xcode Command Line Tools
            install_xcode_cli() {
                local quiet="$1"

                echo "üß∞ Checking for Xcode Command Line Tools..."
                if ! xcode-select -p &>/dev/null; then
                    echo "üì¶ Installing Xcode Command Line Tools..."
                    if [[ "$quiet" == "quiet" ]]; then
                        xcode-select --install &>/dev/null
                    else
                        xcode-select --install
                    fi
                    wait_for_xcode_cli
                    echo "‚úÖ Xcode Command Line Tools installed successfully."
                else
                    echo "‚úÖ Xcode Command Line Tools are already installed."
                fi
            }

            # ‚ûï Appends a line to a file if not already present
            add_if_missing() {
                local file="$1"
                local line="$2"
                grep -Fxq "$line" "$file" || echo "$line" >> "$file"
            }

            # üîß Configures environment variables for LLVM based on the shell
            configure_llvm_env() {
                local shell_name file
                shell_name="$(basename "$SHELL")"
                echo "üîß Configuring environment for: $shell_name"

                case "$shell_name" in
                    bash) file="$HOME/.bashrc" ;;
                    zsh)  file="$HOME/.zshrc" ;;
                    fish)
                        file="$HOME/.config/fish/config.fish"
                        mkdir -p "$(dirname "$file")"
                        touch "$file"
                        ;;
                    *)
                        echo "‚ùå Unsupported shell: $shell_name"
                        return 1
                        ;;
                esac

                local env_lines=(
                    "PATH=\"/opt/homebrew/opt/llvm/bin:\$PATH\""
                    "LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\""
                    "CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\""
                )

                for line in "${env_lines[@]}"; do
                    if [[ "$shell_name" == "fish" ]]; then
                        add_if_missing "$file" "set -x ${line//=/ }"
                    else
                        add_if_missing "$file" "export $line"
                    fi
                done

                # Reload shell config
                if [[ "$shell_name" == "fish" ]]; then
                    fish -c "source $file"
                else
                    # shellcheck source=/dev/null
                    source "$file"
                fi

                echo "‚úÖ LLVM environment variables configured for $shell_name"
            }

            # üç∫ Installs any Homebrew package with optional quiet mode
            brew_install() {
                local package="$1"
                local quiet="$2"
                echo "üì¶ Installing $package..."
                if [[ "$quiet" == "quiet" ]]; then
                    brew install "$package" &>/dev/null
                else
                    brew install "$package"
                fi
                echo "‚úÖ $package installed successfully."
            }

            # üç∫ Installs LLVM with Homebrew and configures the environment
            install_llvm_brew() {
                local quiet="$1"
                brew_install llvm "$quiet"
                configure_llvm_env
            }

            # üöÄ Main LLVM installation dispatcher
            install_llvm() {
                local method="$1"
                local quiet="$2"

                case "$method" in
                    xcode) install_xcode_cli "$quiet" ;;
                    brew)  install_llvm_brew "$quiet" ;;
                    *)
                        echo "‚ùå Unknown LLVM installation method: '$method'"
                        echo "   Use: install_meson_dependencies xcode|brew [quiet]"
                        return 1
                        ;;
                esac
            }

            install_meson() { brew_install meson "$1"; }
            install_ninja() { brew_install ninja "$1"; }

            # ‚úÖ Validate input and install all
            if [[ "$llvm_method" != "brew" && "$llvm_method" != "xcode" ]]; then
                echo "‚ùå Invalid LLVM installation method: '$llvm_method'"
                echo "   Use: install_meson_dependencies xcode|brew [quiet]"
                return 1
            fi

            echo "üöÄ Installing dependencies for Meson using LLVM via $llvm_method..."

            install_llvm "$llvm_method" "$quiet" || return 1
            install_meson "$quiet" || return 1
            install_ninja "$quiet" || return 1

            echo "‚úÖ All Meson dependencies installed successfully."
        }
        ```

        ```bash showLineNumbers title="Uso"
        # Recommended if you already have Xcode
        install_meson_dependencies xcode        # Installs via xcode-select
        # install_meson_dependencies xcode quiet  # Silently installs

        # Alternatively, use Homebrew
        # install_meson_dependencies brew         # Installs via Homebrew
        # install_meson_dependencies brew quiet   # Silently installs
        ```

        <Explanation>
            Esta funci√≥n instala todas las herramientas necesarias para usar el sistema de construcci√≥n **Meson** en macOS. Puedes elegir entre instalar LLVM con **Xcode** o **Homebrew**.

            - `llvm`: proporciona `clang`, el compilador requerido para proyectos en C/C++.
            - `meson`: es el sistema de construcci√≥n que usaremos.
            - `ninja`: ejecuta el proceso de compilaci√≥n a partir de las instrucciones generadas por Meson.

            Si eliges la opci√≥n `brew`, tambi√©n se configuran las variables de entorno necesarias para usar LLVM de Homebrew correctamente (`PATH`, `LDFLAGS`, `CPPFLAGS`).

            La funci√≥n permite ocultar la salida con `quiet` para integrarse en scripts o procesos m√°s grandes sin ruido visual innecesario.
        </Explanation>
    </TabItem>
    <TabItem value="Debian/Ubuntu" label="Debian/Ubuntu">
        ```bash showLineNumbers title="En Terminal"
        install_meson_dependencies() {
            local quiet="$1"

            # üö´ Silences output if quiet mode is enabled
            run() {
                if [[ "$quiet" == "quiet" ]]; then
                    "$@" &>/dev/null
                else
                    "$@"
                fi
            }

            # ‚úÖ Installs a package if its command is missing
            install_if_missing() {
                local name="$1"     # Friendly name (for messages)
                local cmd="$2"      # Command to check
                local pkg="$3"      # Package to install

                echo "üîç Checking for $name..."
                if command -v "$cmd" &>/dev/null; then
                    echo "‚úÖ $name is already installed."
                else
                    echo "üì¶ Installing $name..."
                    if run sudo apt install -y "$pkg"; then
                        echo "‚úÖ $name installed successfully."
                    else
                        echo "‚ùå Failed to install $name." >&2
                        return 1
                    fi
                fi
            }

            echo "üîÑ Updating package list..."
            if ! run sudo apt update; then
                echo "‚ùå Failed to update package list." >&2
                return 1
            fi

            install_if_missing "Clang" "clang" "clang" || return 1
            install_if_missing "Meson" "meson" "meson" || return 1
            install_if_missing "Ninja" "ninja" "ninja-build" || return 1

            echo "‚úÖ All Meson dependencies installed successfully."
        }
        ```

        ```bash title="Uso"
        install_meson_dependencies           # Normal installation
        # install_meson_dependencies quiet   # Uncomment for silent installation
        ```

        <Explanation>
            Esta funci√≥n Bash instala todas las dependencias necesarias para trabajar con el sistema de construcci√≥n **Meson** en distribuciones basadas en Debian/Ubuntu.

            - `clang`: proporciona el compilador C/C++ usado por Meson para compilar el c√≥digo.
            - `meson`: es el sistema de construcci√≥n moderno que genera instrucciones de compilaci√≥n.
            - `ninja-build`: ejecuta esas instrucciones de forma eficiente y r√°pida.

            Antes de instalar, se actualiza la lista de paquetes (`apt update`) y se verifica si cada herramienta ya est√° disponible usando `command -v`.

            El argumento `quiet` permite suprimir la salida de los comandos para facilitar la integraci√≥n en scripts m√°s grandes.
        </Explanation>
    </TabItem>
</BoxedTabs>

### ‚úÖ Verificar la instalaci√≥n

Una vez instaladas todas las herramientas, es importante confirmar que quedaron correctamente configuradas y disponibles en tu sistema. Ejecuta el siguiente comando para verificar la versi√≥n de cada componente clave:

```bash
clang --version && clang++ --version && meson --version && ninja --version
```

Deber√≠as ver una salida similar a la siguiente (aunque los n√∫meros de versi√≥n pueden variar dependiendo del momento en que instales):

```plaintext title="Salida esperada (puede variar)"
clang version 20.1.2
Target: x86_64-pc-windows-msvc
Thread model: posix
InstalledDir: B:\scoop\apps\llvm\20.1.2\bin
clang version 20.1.2
Target: x86_64-pc-windows-msvc
Thread model: posix
InstalledDir: B:\scoop\apps\llvm\20.1.2\bin
1.7.1
1.12.1
```

:::tip 

Si alguna de las versiones no aparece o el comando falla, aseg√∫rate de que las herramientas est√©n correctamente instaladas y que sus rutas est√©n disponibles en el `PATH` del sistema.

:::

## üß± Paso 1: Crear la estructura inicial del proyecto

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="En PowerShell o como script"
        function New-MesonProject {
            [CmdletBinding()]
            param (
                [Parameter(Mandatory)]
                [string]$ProjectName,

                [string[]]$SourceFiles = @("main.cpp")
            )

            Write-Host "üöÄ Creating new Meson project: $ProjectName" `
                -ForegroundColor Cyan

            # Resolve full path and create base directory
            $projectPath = Resolve-Path -Path (
            New-Item -Path $ProjectName -ItemType Directory -Force
            ).FullName
            $srcPath = Join-Path $projectPath "src"

            Write-Host "üìÅ Creating folders and Meson files..."
            New-Item -Path (Join-Path $projectPath "meson.build") `
                    -ItemType File `
                    -Force | Out-Null
            New-Item -Path $srcPath `
                    -ItemType Directory `
                    -Force | Out-Null
            New-Item -Path (Join-Path $srcPath "meson.build") `
                    -ItemType File `
                    -Force | Out-Null

            foreach ($file in $SourceFiles) {
                $filePath = Join-Path $srcPath $file
                if (-not (Test-Path $filePath)) {
                    New-Item -Path $filePath `
                            -ItemType File `
                            -Force | Out-Null
                    Write-Host "üìÑ Created source file: $file"
                } else {
                    Write-Warning "‚ö†Ô∏è File already exists: $file"
                }
            }

            Write-Host "‚úÖ Meson project '$ProjectName' created successfully." `
                -ForegroundColor Green

            # Output path so it can be piped into Set-Location
            return $projectPath
        }
        ```

        ```powershell title="Uso"
        New-MesonProject -ProjectName 'echo-app-cpp-meson' | Set-Location
        ```

        <Explanation>
            Esta funci√≥n crea un proyecto b√°sico con la estructura que espera Meson:
            - Una carpeta principal con el nombre del proyecto.
            - Un archivo `meson.build` en la ra√≠z del proyecto.
            - Una subcarpeta `src/` con su propio `meson.build`.
            - Uno o m√°s archivos fuente, como `main.cpp`.

            Adem√°s, si usas esta funci√≥n con un pipe a `Set-Location`, podr√°s cambiar de directorio directamente al nuevo proyecto.
        </Explanation>

        Aunque podr√≠amos crear todo esto manualmente o con unos pocos comandos, encapsularlo en una funci√≥n como esta mejora la legibilidad, facilita su reutilizaci√≥n y permite extenderla en el futuro (por ejemplo, para autogenerar contenido base en los archivos). üéØ
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="En Terminal o como script"
        #!/bin/bash

        new_meson_project() {
            local project_name="$1"
            shift
            local source_files=("$@")
            local default_files=("main.cpp")

            if [[ -z "$project_name" ]]; then
                echo "‚ùå Project name is required." >&2
                return 1
            fi

            # Use default source file if none provided
            if [[ ${#source_files[@]} -eq 0 ]]; then
                source_files=("${default_files[@]}")
            fi

            echo "üöÄ Creating new Meson project: $project_name" >&2

            # Get absolute path
            local project_path
            if command -v realpath &>/dev/null; then
                project_path="$(realpath "$project_name")"
            else
                project_path="$PWD/$project_name"
            fi

            # Create base directory structure
            if ! mkdir -p "$project_path/src"; then
                echo "‚ùå Failed to create project structure." >&2
                return 1
            fi

            echo "üìÅ Creating folders and Meson files..." >&2
            : > "$project_path/meson.build"
            : > "$project_path/src/meson.build"

            for file in "${source_files[@]}"; do
                local file_path="$project_path/src/$file"
                if [[ ! -f "$file_path" ]]; then
                    : > "$file_path"
                    echo "üìÑ Created source file: $file" >&2
                else
                    echo "‚ö†Ô∏è File already exists: $file" >&2
                fi
            done

            echo "‚úÖ Meson project '$project_name' created successfully." >&2

            # Output path for chaining with cd
            echo "$project_path"
        }
        ```

        ```bash title="Uso"
        cd "$(new_meson_project 'echo-app-cpp-meson')"
        ```

        <Explanation>
            Esta funci√≥n crea un nuevo proyecto compatible con **Meson**, con la siguiente estructura:

            ```
            echo-app-cpp-meson/
            ‚îú‚îÄ‚îÄ meson.build
            ‚îî‚îÄ‚îÄ src/
                ‚îú‚îÄ‚îÄ meson.build
                ‚îî‚îÄ‚îÄ main.cpp
            ```

            - Usa `realpath` para entregar una ruta absoluta lista para ser usada con `cd`.
            - Todos los mensajes informativos se env√≠an a `stderr` (`>&2`), de forma que el √∫nico valor en `stdout` sea la ruta del proyecto.
            - Puede recibir una lista de archivos fuente opcionales. Si no se proporciona, crear√° `main.cpp` por defecto.
            - Si un archivo ya existe, lo informa sin sobrescribirlo.

            :::tip Ideal para scripts de inicializaci√≥n o flujos automatizados

            Puedes expandirla f√°cilmente para agregar contenido por defecto en los archivos o configurar opciones de compilaci√≥n.

            :::
        </Explanation>
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title="En Terminal o como script"
        #!/bin/bash

        new_meson_project() {
            local project_name="$1"
            shift
            local source_files=("$@")
            local default_files=("main.cpp")

            if [[ -z "$project_name" ]]; then
                echo "‚ùå Project name is required." >&2
                return 1
            fi

            # Use default source file if none provided
            if [[ ${#source_files[@]} -eq 0 ]]; then
                source_files=("${default_files[@]}")
            fi

            echo "üöÄ Creating new Meson project: $project_name" >&2

            # Get absolute path
            local project_path
            if command -v realpath &>/dev/null; then
                project_path="$(realpath "$project_name")"
            else
                project_path="$PWD/$project_name"
            fi

            # Create base directory structure
            if ! mkdir -p "$project_path/src"; then
                echo "‚ùå Failed to create project structure." >&2
                return 1
            fi

            echo "üìÅ Creating folders and Meson files..." >&2
            : > "$project_path/meson.build"
            : > "$project_path/src/meson.build"

            for file in "${source_files[@]}"; do
                local file_path="$project_path/src/$file"
                if [[ ! -f "$file_path" ]]; then
                    : > "$file_path"
                    echo "üìÑ Created source file: $file" >&2
                else
                    echo "‚ö†Ô∏è File already exists: $file" >&2
                fi
            done

            echo "‚úÖ Meson project '$project_name' created successfully." >&2

            # Output path for chaining with cd
            echo "$project_path"
        }
        ```

        ```bash title="Uso"
        cd "$(new_meson_project 'echo-app-cpp-meson')"
        ```

        <Explanation>
            Esta funci√≥n crea un nuevo proyecto compatible con **Meson**, con la siguiente estructura:

            ```
            echo-app-cpp-meson/
            ‚îú‚îÄ‚îÄ meson.build
            ‚îî‚îÄ‚îÄ src/
                ‚îú‚îÄ‚îÄ meson.build
                ‚îî‚îÄ‚îÄ main.cpp
            ```

            - Usa `realpath` para entregar una ruta absoluta lista para ser usada con `cd`.
            - Todos los mensajes informativos se env√≠an a `stderr` (`>&2`), de forma que el √∫nico valor en `stdout` sea la ruta del proyecto.
            - Puede recibir una lista de archivos fuente opcionales. Si no se proporciona, crear√° `main.cpp` por defecto.
            - Si un archivo ya existe, lo informa sin sobrescribirlo.

            :::tip Ideal para scripts de inicializaci√≥n o flujos automatizados

            Puedes expandirla f√°cilmente para agregar contenido por defecto en los archivos o configurar opciones de compilaci√≥n.

            :::
        </Explanation>
    </TabItem>
</BoxedTabs>

### üìÇ Estructura de archivos

Cuando creamos un proyecto b√°sico con Meson, se genera una estructura de carpetas y archivos que permite compilar el c√≥digo de forma organizada. A continuaci√≥n, se muestra un diagrama que ilustra c√≥mo se estructura el proyecto por defecto:

```mermaid
graph
    subgraph Root [üìÅ echo-app-cpp-meson]
        subgraph Src [üìÅ src]
            main[üìÑ main.cpp]
            srcBuild[üõ†Ô∏è meson.build]
        end

        rootBuild[üõ†Ô∏è meson.build]
    end
```

::::info Explicaci√≥n de la estructura de archivos

Esta es la estructura m√≠nima generada para un proyecto en C++ gestionado con **Meson**:

- **üìÅ echo-app-cpp-meson/**: Carpeta ra√≠z del proyecto.
    - **üõ†Ô∏è meson.build**: Archivo de configuraci√≥n principal del proyecto. Aqu√≠ se declara el nombre del proyecto, su versi√≥n, el compilador y los subdirectorios a incluir.
    - **üìÅ src/**: Carpeta donde vive el c√≥digo fuente.
        - **üìÑ main.cpp**: Archivo principal de c√≥digo en C++. Aqu√≠ estar√° tu funci√≥n `main()`.
        - **üõ†Ô∏è meson.build**: Archivo de configuraci√≥n espec√≠fico para el c√≥digo fuente. Aqu√≠ se declaran los archivos que conforman el ejecutable y las dependencias que requiere.

:::tip

Separar la configuraci√≥n del proyecto en varios archivos `meson.build` (uno por directorio) permite **modularizar tu proyecto** y facilita el mantenimiento a medida que crece.

:::

::::

## üßæ Paso 2: Definir el archivo de configuraci√≥n ra√≠z

El archivo `meson.build` ubicado en la ra√≠z del proyecto indica a Meson c√≥mo compilar el programa y qu√© subdirectorios deben incluirse durante el proceso de construcci√≥n. Es el punto de partida del sistema de build.

A continuaci√≥n, se muestra un ejemplo b√°sico:

```python showLineNumbers title="meson.build"
project('main', 'cpp', version : '0.1.0')
subdir('src')
```

<Explanation>
    - **`project('main', 'cpp', version : '0.1.0')`**: Declara un proyecto llamado `main`, escrito en C++ (`cpp`), con la versi√≥n `0.1.0`.
    - **`subdir('src')`**: Indica que Meson debe procesar tambi√©n el archivo `meson.build` ubicado dentro de la carpeta `src/`, donde se definir√° el ejecutable y sus fuentes.
</Explanation>

Este archivo es esencial para organizar la compilaci√≥n en proyectos modulares, ya que permite dividir la l√≥gica de construcci√≥n en distintos niveles y carpetas.

## üß© Paso 3: Definir la compilaci√≥n del ejecutable

Ahora que ya tenemos la estructura del proyecto y el archivo `meson.build` en la ra√≠z est√° apuntando al subdirectorio `src`, es momento de indicarle a Meson **qu√© archivo fuente compilar** y **c√≥mo generar el ejecutable**.

Edita el archivo `src/meson.build` con lo siguiente:

```python showLineNumbers title="src/meson.build"
main_sources = files('main.cpp')
main_exe = executable('main', main_sources)
```

<Explanation>
    En esta configuraci√≥n:

    - `files('main.cpp')` indica a Meson que incluya `main.cpp` como archivo fuente del proyecto. Puedes agregar m√°s archivos si los necesitas, como `'util.cpp'`, separ√°ndolos por comas.
    - `executable('main', main_sources)` crea un ejecutable llamado `main` a partir de los archivos listados en `main_sources`.
</Explanation>

## üéØ Paso 4: Escribir el archivo principal del programa

Ahora que configuraste tu proyecto y definiste las reglas de compilaci√≥n, es momento de escribir el c√≥digo fuente. Crearemos un archivo simple llamado `main.cpp` que imprimir√° un mensaje motivador en la consola.

```cpp showLineNumbers title="src/main.cpp"
#include <iostream>

int main() {
    std::cout << "Nothing can happen till you swing the bat\n";
    return 0;
}
```

<Explanation>
    Este archivo define el **punto de entrada** del programa en C++:

    - `#include <iostream>` permite usar `std::cout`, que se encarga de mostrar texto en la consola.
    - La funci√≥n `main` es donde comienza la ejecuci√≥n del programa.
    - `std::cout << "..."` imprime un mensaje motivacional seguido de un salto de l√≠nea.
        - En lugar de `std::endl`, se utiliza `\n` para mayor eficiencia: `std::endl` no solo agrega una nueva l√≠nea, sino que tambi√©n **fuerza el vaciado del buffer** (`flush`), lo cual puede tener un impacto en el rendimiento si se hace repetidamente.
    - Aunque en muchos compiladores modernos no es obligatorio, se recomienda incluir `return 0;` al final de `main()` para indicar que el programa finaliz√≥ correctamente.

    Este programa sirve como ejemplo m√≠nimo para comprobar que la configuraci√≥n del proyecto funciona correctamente.
</Explanation>

## üèóÔ∏è Paso 5: Compilar y ejecutar el proyecto

Una vez que has definido la estructura del proyecto, los archivos de configuraci√≥n y tu c√≥digo fuente, ya puedes compilar y ejecutar el programa.

### ‚öôÔ∏è Compilar con Meson y Ninja

Primero inicializa el entorno de compilaci√≥n y luego ejecuta la compilaci√≥n:

```bash showLineNumbers title="Compilaci√≥n"
meson setup build         # Crea la carpeta de compilaci√≥n y configura el proyecto
meson compile -C build    # Compila el proyecto dentro del directorio 'build'
```

### üöÄ Ejecutar el binario

Una vez compilado, el ejecutable estar√° ubicado dentro de la carpeta `build/src/`. Usa el siguiente comando seg√∫n tu sistema operativo:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="En PowerShell"
        .\build\src\main.exe
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="En Terminal"
        ./build/src/main
        ```
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title="En Terminal"
        ./build/src/main
        ```
    </TabItem>
</BoxedTabs>

```plaintext title="Salida esperada"
Nothing can happen till you swing the bat
```

<Explanation>
    - `meson setup build` crea una carpeta `build/` y genera dentro de ella los archivos de configuraci√≥n necesarios.
    - `meson compile -C build` ejecuta `ninja` en el directorio `build/` para compilar el proyecto.
    - El binario resultante se guarda en `build/src/`, ya que all√≠ fue definido en `src/meson.build`.

    Este flujo te permite mantener separados los archivos fuente y los archivos generados por la compilaci√≥n, lo cual es una buena pr√°ctica en proyectos de software.
</Explanation>

## üéØ Conclusiones

En esta lecci√≥n construimos desde cero un proyecto en C++ utilizando **Meson** como sistema de construcci√≥n. Aprendiste a instalar las herramientas necesarias, generar la estructura inicial, configurar la compilaci√≥n y ejecutar tu primer programa exitosamente.

M√°s all√° del cl√°sico "Hello World", lo importante fue comprender c√≥mo se relacionan las herramientas involucradas y por qu√© organizar el proyecto desde el comienzo marca la diferencia cuando el c√≥digo crece.

Este ejercicio, aunque b√°sico, refleja una pr√°ctica esencial en el desarrollo de bibliotecas de software: **construir una base clara, portable y automatizable**.

## üîë Puntos clave

- **Meson no compila c√≥digo por s√≠ solo**: genera las instrucciones que luego Ninja ejecuta.
- **Clang** (o cualquier compilador compatible) es quien traduce el c√≥digo fuente en binarios.
- Separar c√≥digo fuente y artefactos de compilaci√≥n usando una carpeta como `build/` mantiene tu proyecto limpio.
- La modularidad de `meson.build` permite escalar a estructuras m√°s complejas f√°cilmente.
- Usar funciones para automatizar la instalaci√≥n y creaci√≥n de proyectos mejora la productividad y promueve buenas pr√°cticas.

## üß∞ ¬øQu√© nos llevamos?

Este ejercicio nos muestra que incluso tareas simples como compilar un "Hello World" pueden convertirse en una oportunidad para practicar c√≥mo automatizar, estructurar y documentar un proyecto correctamente. Estas habilidades son fundamentales para dise√±ar **librer√≠as reutilizables** y **entornos de desarrollo sostenibles**.

A medida que avancemos, dejaremos atr√°s los scripts de terminal manuales y daremos paso a tareas automatizadas dentro del build system, lo que facilitar√° la portabilidad entre plataformas y equipos. Entender c√≥mo y por qu√© automatizar desde el principio es un paso necesario para convertir un conjunto de archivos fuente en una biblioteca profesional y mantenible.

:::info Ejemplos reales con Meson

- [GTK](https://gitlab.gnome.org/GNOME/gtk) y muchas bibliotecas del ecosistema GNOME usan Meson como build system principal.
- [Systemd](https://github.com/systemd/systemd) migr√≥ de Autotools a Meson por su claridad y velocidad.

Explorar estos proyectos puede darte ideas sobre c√≥mo estructurar bibliotecas complejas.

:::

## üìñ Referencias

### üî• Recomendadas

- [üåê "Introduction to meson build system"](https://twdev.blog/2022/09/meson/) en *twdev.blog* por **Tomasz Wisniewski**: Introducci√≥n pr√°ctica y progresiva al uso de Meson en proyectos C++. El art√≠culo muestra c√≥mo estructurar un proyecto con bibliotecas, pruebas automatizadas y dependencias externas usando subproyectos y el sistema de empaquetado WrapDB. A trav√©s del ejemplo `libmagick`, ense√±a a declarar bibliotecas compartidas, integrar `gtest` como framework de testing, y configurar distintos modos de compilaci√≥n. Es especialmente relevante para esta lecci√≥n porque ejemplifica **buenas pr√°cticas de organizaci√≥n, modularizaci√≥n y automatizaci√≥n** aplicadas desde el inicio del proyecto, alineadas con el objetivo del curso de construir software mantenible y profesional desde el primer archivo.

{/* ### üîπ Adicionales */}
