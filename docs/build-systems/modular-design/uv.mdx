---
title: Modularizando tu proyecto Python con uv
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/git/GitHubRepoLink";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import References from '@site/src/components/mdx/build-systems/modular-design/uv/references.mdx'
import CleanupSh from '@site/src/components/mdx/build-systems/modular-design/uv/cleanup-sh.mdx'

<ReadingTime />
<GitHubRepoLink repo={"echo-app-py-uv"} user={"r8vnhill"} />

En la lecci√≥n anterior dimos nuestros primeros pasos con `uv`, creando un proyecto simple en Python y ejecutando un *Hello, World!* en un entorno virtual aislado.

Ahora llevaremos esa base un paso m√°s all√°: **estructuraremos el proyecto en m√∫ltiples m√≥dulos**, separando la l√≥gica de negocio en una biblioteca (`core`) y la l√≥gica de ejecuci√≥n en una aplicaci√≥n (`app`) que la consume. Este enfoque modular no solo mejora la organizaci√≥n del c√≥digo, sino que tambi√©n permite una evoluci√≥n m√°s sostenible y profesional del proyecto.

En esta lecci√≥n aprender√°s a:

- Declarar m√∫ltiples m√≥dulos dentro de un workspace de `uv`.
- Crear la estructura base de carpetas y archivos para organizar paquetes de Python.
- Establecer dependencias locales entre m√≥dulos.
- Ejecutar una aplicaci√≥n que importa y utiliza c√≥digo de otro m√≥dulo.

Al finalizar, habr√°s transformado un script suelto en un proyecto con una **estructura escalable y responsabilidades bien definidas**, alineado con las buenas pr√°cticas de desarrollo profesional.

## üèóÔ∏è Estructura esperada del proyecto

Nuestro objetivo es organizar el repositorio en dos m√≥dulos independientes: una biblioteca llamada `core`, que contiene la l√≥gica de negocio, y una aplicaci√≥n llamada `app`, que consume esa biblioteca.

La estructura final ser√° la siguiente:

```mermaid
graph
    subgraph Root [üìÅ echo-app-py-uv]
        direction LR

        A1[üìÑ pyproject.toml]

        subgraph Core [üìÅ core]
            direction TB
            B1[üìÑ pyproject.toml]
            subgraph EchoCore [üìÅ echo_core]
                B2[üìÑ __init__.py]
            end
        end

        subgraph App [üìÅ app]
            direction TB
            C1[üìÑ pyproject.toml]
            subgraph EchoApp [üìÅ echo_app]
                C2[üìÑ __init__.py]
                C3[üìÑ main.py]
            end
        end
    end

    A1 -->|workspace| B1
    A1 -->|workspace| C1
    C3 -->|importa| EchoCore
```

:::info Explicaci√≥n de la estructura

Esta estructura representa un proyecto Python **multi-m√≥dulo**, organizado con `uv` como workspace. Est√° compuesta por:

- `pyproject.toml` en la ra√≠z: define el proyecto principal y declara `core` y `app` como miembros del workspace.
- `core/`: contiene la l√≥gica de negocio del proyecto. Dentro:
    - `echo_core/`: paquete Python que implementa la biblioteca.
    - `__init__.py`: habilita `echo_core` como m√≥dulo importable.
- `app/`: contiene la aplicaci√≥n que depende de `core`. Dentro:
    - `echo_app/`: paquete Python de la aplicaci√≥n.
    - `main.py`: punto de entrada de la app.
    - `__init__.py`: habilita `echo_app` como m√≥dulo.

Esta estructura modular permite mantener una **clara separaci√≥n entre l√≥gica de negocio y l√≥gica de aplicaci√≥n**, lo que facilita la escalabilidad, las pruebas unitarias independientes y la reutilizaci√≥n en otros proyectos.

:::

::::tip Limpieza

Puedes borrar los archivos creados en la lecci√≥n pasada o guardarlos como recuerdo.

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="scripts/ps1/CleanupProject.ps1"
        Remove-Item -Path 'main.py' -Verbose
        ```

        Puedes ejecutar el comando desde la terminal, o como script de PowerShell:

        ```powershell title="En PowerShell"
        .\scripts\ps1\CleanupProject.ps1
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <CleanupSh />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <CleanupSh />
    </TabItem>
</BoxedTabs>

::::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>

{/* #region Windows */}
<TabItem value="Windows" label="Windows">

```powershell showLineNumbers title="scripts/ps1/SetupModularProject.ps1"
@{
    App = @("app\pyproject.toml", "app\echo_app\__init__.py", "app\echo_app\main.py")
    Core = @("core\pyproject.toml", "core\echo_core\__init__.py")
}.GetEnumerator() | ForEach-Object {
    $module = $_.Key
    $files = $_.Value

    Write-Host "üìÅ Creating structure for module: $module" -ForegroundColor Cyan

    foreach ($file in $files) {
        $dir = Split-Path $file -Parent
        if (-not (Test-Path $dir)) {
            New-Item -Path $dir -ItemType Directory -Force | Out-Null
        }
        New-Item -Path $file -ItemType File -Force | Out-Null
        Write-Host "‚úÖ $file" -ForegroundColor Green
    }
}

Write-Host "üü¢ Project initialized successfully." -ForegroundColor Green
```

<Explanation>

Este script de PowerShell **automatiza la creaci√≥n de la estructura base del proyecto**. Lo que hace es:

1. **Definir los m√≥dulos** `App` y `Core`, junto con la lista de archivos que cada uno debe contener.
2. Recorrer esa informaci√≥n usando `GetEnumerator()` y `ForEach-Object`.
3. Para cada archivo:
   - **Verifica si la carpeta padre existe** (`Split-Path` + `Test-Path`) y la crea si no est√° (`New-Item -ItemType Directory`).
   - **Crea el archivo vac√≠o correspondiente** (`New-Item -ItemType File`).
   - Muestra un mensaje en consola por cada archivo creado.

</Explanation>

Puedes ejecutar los comandos desde la terminal, o como script de PowerShell:

```powershell title="En PowerShell"
.\scripts\ps1\SetupModularProject.ps1
```

</TabItem>
{/* #endregion */}

{/* region : macOS ----------------------------------------------------------------------------- */}
<TabItem value="macOS" label="macOS">

:::danger TODO

- [ ] A√±adir c√≥digo de creaci√≥n de estructura para macOS.

:::

```bash showLineNumbers title="scripts/sh/setup_modular_project.sh"

```

</TabItem>
{/* endregion macOS ---------------------------------------------------------------------------- */}

{/* region : Ubuntu/Debian --------------------------------------------------------------------- */}
<TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">

:::danger TODO

- [ ] A√±adir c√≥digo de creaci√≥n de estructura para Ubuntu/Debian (reusar el de macOS).

:::

```bash showLineNumbers title=""

```

</TabItem>
{/* endregion Ubuntu/Debian ------------------------------------------------------------------- */}

</BoxedTabs>

## ‚öôÔ∏è Paso 2: Declarar los m√≥dulos en el `pyproject.toml`

Para que `uv` reconozca que estamos trabajando en un proyecto con m√∫ltiples m√≥dulos, necesitamos declarar los subproyectos en el archivo `pyproject.toml` ra√≠z. Esto permitir√° que las dependencias entre m√≥dulos se resuelvan de forma local, sin necesidad de instalar ni publicar paquetes.

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```toml showLineNumbers title="pyproject.toml"
        [tool.uv.workspace]
        members = ["core", "app"]

        [tool.uv.sources]
        core = { workspace = true }
        app  = { workspace = true }
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```toml showLineNumbers
        [project]
        name = "echo-app-py-uv"
        version = "0.1.0"
        description = "Base project for the echo app"
        readme = "README.md"
        requires-python = ">=3.10"
        dependencies = []

        [tool.uv.workspace]
        members = ["core", "app"]

        [tool.uv.sources]
        core = { workspace = true }
        app  = { workspace = true }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este bloque declara que el proyecto ra√≠z es un workspace con dos m√≥dulos: `core` y `app`.  
    - La secci√≥n `[tool.uv.workspace]` enumera las carpetas que conforman el workspace.
    - La secci√≥n `[tool.uv.sources]` indica que ambos m√≥dulos deben resolverse desde el mismo workspace.
</Explanation>

Esto permite que `uv` reconozca `core` y `app` como proyectos conectados y que puedan **interactuar entre s√≠** sin necesidad de publicar o instalar paquetes manualmente.

## ‚öôÔ∏è Paso 3: Definir el m√≥dulo `core`

Ahora vamos a crear el primer subm√≥dulo del proyecto: `core`. Este m√≥dulo contendr√° la l√≥gica de negocio reutilizable. Primero definimos su archivo `pyproject.toml` con los metadatos b√°sicos:

```toml showLineNumbers title="core/pyproject.toml"
[project]
name = "core"
version = "0.1.0"
description = "Business logic for the echo app"
requires-python = ">=3.10"
```

Luego escribimos una funci√≥n simple que servir√° como punto de partida para probar el consumo desde el m√≥dulo `app`.

```python showLineNumbers title="core/echo_core/echo.py"
def echo(message: str) -> str:
    return message
```

<Explanation>
    Este m√≥dulo est√° dise√±ado para ser completamente independiente de la aplicaci√≥n que lo consuma. En proyectos bien estructurados, **la l√≥gica de negocio deber√≠a residir en m√≥dulos reutilizables** como este, facilitando su prueba, mantenimiento y posible uso desde diferentes interfaces o entornos.
</Explanation>


## üöÄ Paso 4: Crear el m√≥dulo `app` que consume `core`

Ahora definiremos el m√≥dulo `app`, que actuar√° como punto de entrada de nuestra aplicaci√≥n. Este m√≥dulo importar√° la funci√≥n `echo` definida en `core` y la usar√° para imprimir los argumentos recibidos desde la l√≠nea de comandos.

Primero, definimos su archivo `pyproject.toml` indicando que `core` es una dependencia local:

```toml showLineNumbers title="app/pyproject.toml"
[project]
name = "app"
version = "0.1.0"
description = "Application for the echo app that consumes the core library"
requires-python = ">=3.10"
dependencies = ["core"]
```

Luego escribimos el archivo `main.py`, que tomar√° los argumentos de la terminal y los procesar√° con `echo`.

```python showLineNumbers title="app/echo_app/main.py"
from echo_core import echo


def main(args: list[str]):
    for arg in args:
        print(echo(arg))


if __name__ == "__main__":
    import sys

    main(sys.argv[1:])
```

<Explanation>
    Este archivo define el comportamiento de la aplicaci√≥n.  
    - Importa la funci√≥n `echo` desde el m√≥dulo `core`, gracias a que `core` est√° declarado como dependencia.
    - Toma los argumentos que recibe el script desde la terminal (usando `sys.argv[1:]`) y los pasa uno a uno a `echo()`, imprimiendo el resultado.
</Explanation>

Esta es la primera vez que vemos c√≥mo conectar los m√≥dulos entre s√≠, lo que valida la organizaci√≥n en **capas separadas y reutilizables**.

## üß™ Paso 5: Ejecutar la aplicaci√≥n

Ahora que la aplicaci√≥n `app` depende correctamente de `core` y tiene definido un punto de entrada (`main.py`), podemos ejecutarla directamente desde la ra√≠z del proyecto usando `uv`.

```bash title="Desde la ra√≠z del proyecto"
uv run app/echo_app/main.py Butcher Hughie Kimiko Frenchie M.M.
```

Esto imprimir√°:

```text
Butcher
Hughie
Kimiko
Frenchie
M.M.
```

<Explanation>
    Cada argumento que pasamos se interpreta como una cadena y se env√≠a a la funci√≥n `echo()` definida en `core`. El resultado es que la aplicaci√≥n act√∫a como un **eco de nombres**: toma lo que le das y lo devuelve tal cual, usando una l√≥gica desacoplada en el m√≥dulo central.

    Este patr√≥n demuestra c√≥mo separar responsabilidades:  
    - `core` se encarga de la **l√≥gica de negocio** (qu√© hacer con el mensaje),
    - `app` se encarga de la **interfaz de entrada y salida** (c√≥mo recibir datos y mostrar resultados).
</Explanation>

## üéØ Conclusiones

En esta lecci√≥n dimos un paso importante hacia la estructuraci√≥n de proyectos Python m√°s complejos y profesionales. Aprendimos a crear un **workspace multi-m√≥dulo con `uv`**, dividiendo la l√≥gica en dos capas independientes: un m√≥dulo `core` con la funcionalidad reutilizable, y un m√≥dulo `app` que act√∫a como punto de entrada y la consume.

Gracias a esta separaci√≥n, comenzamos a trabajar con un enfoque **modular, escalable y f√°cil de mantener**, que refleja buenas pr√°cticas en el dise√±o de bibliotecas y aplicaciones.

### üîë Puntos clave

- `uv` permite declarar un workspace con m√∫ltiples m√≥dulos, facilitando la colaboraci√≥n entre ellos.
- Separar la l√≥gica de negocio (`core`) de la l√≥gica de aplicaci√≥n (`app`) mejora la claridad y reutilizaci√≥n.
- Cada m√≥dulo tiene su propio `pyproject.toml`, lo que permite gestionar dependencias de forma independiente.
- `uv run` permite ejecutar cualquier archivo dentro del entorno virtual sin necesidad de activarlo manualmente.
- La estructura de carpetas y paquetes es esencial para que los m√≥dulos sean importables entre s√≠.

### üß∞ ¬øQu√© nos llevamos?

Con esta lecci√≥n pasamos de un proyecto plano a una **arquitectura modular basada en workspaces**, donde cada componente cumple un rol bien definido.

Este cambio no solo mejora la organizaci√≥n del c√≥digo, sino que **abre la puerta a funcionalidades m√°s avanzadas**: desde pruebas por m√≥dulo y publicaci√≥n de bibliotecas, hasta automatizaci√≥n de tareas, integraci√≥n continua y empaquetado profesional.

A partir de ahora, nuestro proyecto est√° listo para escalar ‚Äîsin perder claridad, reutilizabilidad ni mantenibilidad.

<References />
