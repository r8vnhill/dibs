---
title: Estructurando un proyecto modular con uv
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/GithubRepoLink";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />
<GitHubRepoLink repo={"echo-app-py-uv"} user={"r8vnhill"} />

En la lecci√≥n anterior dimos nuestros primeros pasos con `uv`, creando un proyecto simple en Python y ejecutando un *Hello, World!* en un entorno virtual aislado.

Ahora llevaremos esa base un paso m√°s all√°: **estructuraremos el proyecto en m√∫ltiples m√≥dulos**, separando la l√≥gica de negocios en una biblioteca (`core`) y la l√≥gica de ejecuci√≥n en una aplicaci√≥n (`app`) que la consume. Este enfoque modular no solo facilita la organizaci√≥n del c√≥digo, sino que tambi√©n habilita una evoluci√≥n m√°s sostenible y profesional del proyecto.

En esta lecci√≥n aprender√°s a:

- Declarar m√∫ltiples m√≥dulos en un workspace de `uv`.
- Crear carpetas y archivos base para organizar los paquetes Python.
- Establecer dependencias locales entre m√≥dulos.
- Ejecutar una aplicaci√≥n que importa y utiliza c√≥digo de otro m√≥dulo.

Al finalizar, habr√°s transformado un script suelto en un proyecto con **estructura escalable y responsabilidad bien delimitada**, tal como se esperar√≠a en un entorno de desarrollo profesional.

## üèóÔ∏è Estructura esperada del proyecto

Nuestro objetivo es organizar el repositorio en dos m√≥dulos independientes: una biblioteca llamada `core` con la l√≥gica de negocios, y una aplicaci√≥n llamada `app` que consume esa biblioteca.

La estructura final ser√° la siguiente:

```mermaid
graph
    subgraph Root [üìÅ echo-app-py-uv]
        direction LR

        A1[üìÑ pyproject.toml]

        subgraph Core [üìÅ core]
            direction TB
            B1[üìÑ pyproject.toml]
            subgraph EchoCore [üìÅ echo_core]
                B2[üìÑ __init__.py]
            end
        end

        subgraph App [üìÅ app]
            direction TB
            C1[üìÑ pyproject.toml]
            subgraph EchoApp [üìÅ echo_app]
                C2[üìÑ __init__.py]
                C3[üìÑ main.py]
            end
        end
    end

    A1 -->|workspace| B1
    A1 -->|workspace| C1
    C3 -->|importa| EchoCore
```

:::info Explicaci√≥n de la estructura

Esta estructura representa un proyecto Python **multi-m√≥dulo** organizado con `uv` como workspace. Est√° compuesta por:

- `pyproject.toml` en la ra√≠z: define el proyecto principal y declara los m√≥dulos `core` y `app` como miembros del workspace.
- `core/`: contiene la l√≥gica de negocios del proyecto. Dentro:
    - `echo_core/`: paquete Python que implementa la biblioteca.
    - `__init__.py`: habilita `echo_core` como m√≥dulo importable.
- `app/`: contiene la aplicaci√≥n que consume `core`. Dentro:
    - `echo_app/`: paquete Python de la aplicaci√≥n.
    - `main.py`: punto de entrada.
    - `__init__.py`: habilita `echo_app` como m√≥dulo.

Esta estructura modular permite mantener una **clara separaci√≥n entre l√≥gica de negocio y l√≥gica de aplicaci√≥n**, facilitando la escalabilidad, el testeo independiente de componentes y la reutilizaci√≥n en otros proyectos.

:::

:::tip ¬øY el `main.py` anterior?

Puedes eliminar el archivo `main.py` que creaste en la lecci√≥n anterior, o guardarlo como recuerdo.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell title="En PowerShell"
        'core', 'app' | ForEach-Object {
            $name = $_
            $modulePath = ".\$name"
            $packagePath = "$modulePath\echo_$name"

            # Crear carpeta del m√≥dulo y del paquete
            New-Item -ItemType Directory -Path $packagePath -Force | Out-Null
            New-Item -ItemType File -Path "$packagePath\__init__.py" -Force | Out-Null

            # Crear pyproject.toml
            New-Item -ItemType File -Path "$modulePath\pyproject.toml" -Force | Out-Null

            # Crear main.py solo en app
            if ($name -eq 'app') {
                New-Item -ItemType File -Path "$packagePath\main.py" -Force | Out-Null
            }
        }
        ```

        <Explanation>
            Este bloque crea dos m√≥dulos: `core` y `app`, cada uno con una subcarpeta `echo_core` o `echo_app` que act√∫a como paquete Python.

            - Crea las carpetas del m√≥dulo (`core/`, `app/`) y sus respectivos paquetes (`echo_core/`, `echo_app/`).
            - Genera un archivo `__init__.py` en cada paquete, para marcarlo como m√≥dulo importable.
            - Crea un archivo `pyproject.toml` vac√≠o en cada m√≥dulo, que luego ser√° completado manualmente.
            - Si el m√≥dulo es `app`, se crea adem√°s un `main.py` como punto de entrada para la aplicaci√≥n.

            Esta estructura permite definir una biblioteca reutilizable (`core`) y una aplicaci√≥n que la consume (`app`), siguiendo buenas pr√°cticas de separaci√≥n de responsabilidades.
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell title="En PowerShell"
        'core', 'app' | % {
            $pkg = "echo_$_"
            md $_, "$_/$pkg" -f > $null
            ni "$_/$pkg/__init__.py", "$_/$pkg/pyproject.toml" -f > $null
            if ($_ -eq 'app') {
                ni "$_/$pkg/main.py" -f > $null
            }
        }
        ```

        <Explanation>
            Este script compacto:

            - Crea dos m√≥dulos: `core` y `app`.
            - Dentro de cada m√≥dulo, genera un paquete Python (`echo_core` o `echo_app`) con `__init__.py`.
            - Agrega un `pyproject.toml` vac√≠o en cada m√≥dulo.
            - En el m√≥dulo `app`, tambi√©n crea `main.py` como punto de entrada.
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash title="En tu terminal"
        for module in core app; do
            pkg="echo_$module"
            mkdir -p "$module/$pkg"
            : > "$module/pyproject.toml" "$module/$pkg/__init__.py"
            [[ $module == app ]] && : > "$module/$pkg/main.py"
        done
        ```

        <Explanation>
            Este script:

            - Crea dos m√≥dulos: `core` y `app`.
            - Dentro de cada uno, genera un paquete Python (`echo_core` o `echo_app`) con `__init__.py`.
            - Agrega un `pyproject.toml` vac√≠o por m√≥dulo.
            - En el m√≥dulo `app`, tambi√©n crea `main.py` como punto de entrada.
        </Explanation>
    </TabItem>
</BoxedTabs>

## ‚öôÔ∏è Paso 2: Declarar los m√≥dulos en el `pyproject.toml`

Para que `uv` reconozca que estamos trabajando en un proyecto con m√∫ltiples m√≥dulos, necesitamos declarar los subproyectos en el archivo `pyproject.toml` ra√≠z. Esto permitir√° que las dependencias entre m√≥dulos se resuelvan de forma local, sin necesidad de instalar ni publicar paquetes.

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```toml showLineNumbers title="pyproject.toml"
        [tool.uv.workspace]
        members = ["core", "app"]

        [tool.uv.sources]
        core = { workspace = true }
        app  = { workspace = true }
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```toml showLineNumbers
        [project]
        name = "echo-app-py-uv"
        version = "0.1.0"
        description = "Base project for the echo app"
        readme = "README.md"
        requires-python = ">=3.10"
        dependencies = []

        [tool.uv.workspace]
        members = ["core", "app"]

        [tool.uv.sources]
        core = { workspace = true }
        app  = { workspace = true }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este bloque declara que el proyecto ra√≠z es un workspace con dos m√≥dulos: `core` y `app`.  
    - La secci√≥n `[tool.uv.workspace]` enumera las carpetas que conforman el workspace.
    - La secci√≥n `[tool.uv.sources]` indica que ambos m√≥dulos deben resolverse desde el mismo workspace.
</Explanation>

Esto permite que `uv` reconozca `core` y `app` como proyectos conectados y que puedan **interactuar entre s√≠** sin necesidad de publicar o instalar paquetes manualmente.

## ‚öôÔ∏è Paso 3: Definir el m√≥dulo `core`

Ahora vamos a crear el primer subm√≥dulo del proyecto: `core`. Este m√≥dulo contendr√° la l√≥gica de negocio reutilizable. Primero definimos su archivo `pyproject.toml` con los metadatos b√°sicos:

```toml showLineNumbers title="core/pyproject.toml"
[project]
name = "core"
version = "0.1.0"
description = "Business logic for the echo app"
requires-python = ">=3.10"
```

Luego escribimos una funci√≥n simple que servir√° como punto de partida para probar el consumo desde el m√≥dulo `app`.

```python showLineNumbers title="core/echo_core/echo.py"
def echo(message: str) -> str:
    return message
```

<Explanation>
    Este m√≥dulo est√° dise√±ado para ser completamente independiente de la aplicaci√≥n que lo consuma. En proyectos bien estructurados, **la l√≥gica de negocio deber√≠a residir en m√≥dulos reutilizables** como este, facilitando su prueba, mantenimiento y posible uso desde diferentes interfaces o entornos.
</Explanation>


## üöÄ Paso 4: Crear el m√≥dulo `app` que consume `core`

Ahora definiremos el m√≥dulo `app`, que actuar√° como punto de entrada de nuestra aplicaci√≥n. Este m√≥dulo importar√° la funci√≥n `echo` definida en `core` y la usar√° para imprimir los argumentos recibidos desde la l√≠nea de comandos.

Primero, definimos su archivo `pyproject.toml` indicando que `core` es una dependencia local:

```toml showLineNumbers title="app/pyproject.toml"
[project]
name = "app"
version = "0.1.0"
description = "Application for the echo app that consumes the core library"
requires-python = ">=3.10"
dependencies = ["core"]
```

Luego escribimos el archivo `main.py`, que tomar√° los argumentos de la terminal y los procesar√° con `echo`.

```python showLineNumbers title="app/echo_app/main.py"
from echo_core import echo


def main(args: list[str]):
    for arg in args:
        print(echo(arg))


if __name__ == "__main__":
    import sys

    main(sys.argv[1:])
```

<Explanation>
    Este archivo define el comportamiento de la aplicaci√≥n.  
    - Importa la funci√≥n `echo` desde el m√≥dulo `core`, gracias a que `core` est√° declarado como dependencia.
    - Toma los argumentos que recibe el script desde la terminal (usando `sys.argv[1:]`) y los pasa uno a uno a `echo()`, imprimiendo el resultado.
</Explanation>

Esta es la primera vez que vemos c√≥mo conectar los m√≥dulos entre s√≠, lo que valida la organizaci√≥n en **capas separadas y reutilizables**.

## üß™ Paso 5: Ejecutar la aplicaci√≥n

Ahora que la aplicaci√≥n `app` depende correctamente de `core` y tiene definido un punto de entrada (`main.py`), podemos ejecutarla directamente desde la ra√≠z del proyecto usando `uv`.

```bash title="Desde la ra√≠z del proyecto"
uv run app/echo_app/main.py Butcher Hughie Kimiko Frenchie M.M.
```

Esto imprimir√°:

```text
Butcher
Hughie
Kimiko
Frenchie
M.M.
```

<Explanation>
    Cada argumento que pasamos se interpreta como una cadena y se env√≠a a la funci√≥n `echo()` definida en `core`. El resultado es que la aplicaci√≥n act√∫a como un **eco de nombres**: toma lo que le das y lo devuelve tal cual, usando una l√≥gica desacoplada en el m√≥dulo central.

    Este patr√≥n demuestra c√≥mo separar responsabilidades:  
    - `core` se encarga de la **l√≥gica de negocio** (qu√© hacer con el mensaje),
    - `app` se encarga de la **interfaz de entrada y salida** (c√≥mo recibir datos y mostrar resultados).
</Explanation>

## üéØ Conclusiones

En esta lecci√≥n dimos un paso importante hacia la estructuraci√≥n de proyectos Python m√°s complejos y profesionales. Aprendimos a crear un **workspace multi-m√≥dulo con `uv`**, dividiendo la l√≥gica en dos capas independientes: un m√≥dulo `core` con la funcionalidad reutilizable, y un m√≥dulo `app` que act√∫a como punto de entrada y la consume.

Gracias a esta separaci√≥n, comenzamos a trabajar con un enfoque **modular, escalable y f√°cil de mantener**, que refleja buenas pr√°cticas en el dise√±o de bibliotecas y aplicaciones.

### üîë Puntos clave

- `uv` permite declarar un workspace con m√∫ltiples m√≥dulos, facilitando la colaboraci√≥n entre ellos.
- Separar la l√≥gica de negocio (`core`) de la l√≥gica de aplicaci√≥n (`app`) mejora la claridad y reutilizaci√≥n.
- Cada m√≥dulo tiene su propio `pyproject.toml`, lo que permite gestionar dependencias de forma independiente.
- `uv run` permite ejecutar cualquier archivo dentro del entorno virtual sin necesidad de activarlo manualmente.
- La estructura de carpetas y paquetes es esencial para que los m√≥dulos sean importables entre s√≠.

### üß∞ ¬øQu√© nos llevamos?

Con esta lecci√≥n pasamos de un proyecto plano a una **arquitectura modular basada en workspaces**, donde cada componente cumple un rol bien definido.

Este cambio no solo mejora la organizaci√≥n del c√≥digo, sino que **abre la puerta a funcionalidades m√°s avanzadas**: desde pruebas por m√≥dulo y publicaci√≥n de bibliotecas, hasta automatizaci√≥n de tareas, integraci√≥n continua y empaquetado profesional.

A partir de ahora, nuestro proyecto est√° listo para escalar ‚Äîsin perder claridad, reutilizabilidad ni mantenibilidad.

## üìñ Referencias

### üî• Recomendadas

- [üåê "Using workspaces"](https://docs.astral.sh/uv/concepts/projects/workspaces/) de **la documentaci√≥n oficial de _uv_**: Explica c√≥mo organizar m√∫ltiples m√≥dulos en un solo repositorio usando `uv workspaces`, compartiendo un lockfile y gestionando dependencias entre paquetes de forma local. Es relevante porque sustenta la estructura modular adoptada en esta lecci√≥n, permitiendo que `core` y `app` interact√∫en sin necesidad de publicar paquetes ni activar entornos separados.
    
{/* ### üîπ Adicionales */}
