---
title: Estructurando un proyecto modular en Haskell con Cabal
---

import ReadingTime from '@site/src/components/ReadingTime'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import ScriptSetup from '@site/src/components/ScriptSetup'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="echo-app-cabal" />

En esta lecci√≥n aprender√°s a estructurar un proyecto en **Haskell** con m√∫ltiples m√≥dulos usando **Cabal**, la herramienta oficial del ecosistema. Veremos c√≥mo separar la l√≥gica principal en una biblioteca reutilizable, c√≥mo escribir un ejecutable que la consuma, y c√≥mo preparar el terreno para incorporar pruebas automatizadas m√°s adelante.

Este enfoque modular cobra especial relevancia si vienes del mundo de las bibliotecas en Kotlin o Scala, donde separar `lib` y `app` es una pr√°ctica com√∫n. En Haskell, esa misma separaci√≥n tambi√©n es posible (y recomendable), ya que permite escribir c√≥digo m√°s mantenible, reutilizable y preparado para escalar.

A lo largo del camino:

- Construiremos un proyecto llamado `echo-app-cabal` con una estructura clara y bien organizada.
- Implementaremos una funci√≥n sencilla para imprimir mensajes.
- Veremos c√≥mo pasar argumentos desde la terminal para probar su reutilizaci√≥n.
- Y ajustaremos el archivo `.cabal` para conectar todos los componentes de forma expl√≠cita.

Como siempre en este curso, no solo veremos el *c√≥mo*, sino tambi√©n el *por qu√©*. Entender la intenci√≥n detr√°s de cada decisi√≥n de dise√±o es lo que diferencia a quien simplemente usa herramientas de quien sabe cu√°ndo y c√≥mo aplicarlas con criterio.

Âàù„ÇÅÔºÅ

## üß± Estructura esperada del proyecto

Antes de modificar el archivo `.cabal`, es importante visualizar c√≥mo estar√° organizado nuestro proyecto. Lo estructuraremos en tres componentes principales:

- Una **biblioteca** (`src-lib/`) que contendr√° la l√≥gica reutilizable.
- Una **aplicaci√≥n** (`app/`) que actuar√° como ejecutable principal.
- Un m√≥dulo de **pruebas** (`test/`) que verificar√° el comportamiento de la biblioteca.

```mermaid
graph TD
    subgraph Root[üìÅ echo-app-cabal]
        direction LR

        CabalFile[üìÑ echo-app-cabal.cabal]

        subgraph App[üìÅ app]
            MainApp[üìÑ Main.hs]
        end

        subgraph Lib[üìÅ src-lib]
            EchoLib[üìÑ Echo.hs]
        end

        subgraph Test[üìÅ test]
            MainTest[üìÑ Main.hs]
        end

        MainApp -->|importa| EchoLib
        MainTest -->|importa| EchoLib
        CabalFile -->|library| Lib
        CabalFile -->|executable| App
        CabalFile -->|test-suite| Test
    end
```

:::info Explicaci√≥n de la estructura del proyecto

Esta estructura separa claramente las responsabilidades:

- `src-lib/` contiene la l√≥gica del programa y se declara como una biblioteca dentro del archivo `.cabal`.
- `app/` contiene el punto de entrada del ejecutable (`Main.hs`), que depende expl√≠citamente de la biblioteca.
- `test/` contiene las pruebas del proyecto, reutilizando tambi√©n la l√≥gica definida en la biblioteca.
- El archivo `echo-app-cabal.cabal` es el coraz√≥n del proyecto: declara los m√≥dulos, dependencias y configuraciones de compilaci√≥n para cada componente.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        <ScriptSetup moduleName="Initialize-CabalModules" repo="echo-app-cabal" />

        <details>
            <summary>
                Script de inicializaci√≥n
            </summary>
            
            ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
            function Initialize-CabalModules {
                [CmdletBinding(SupportsShouldProcess)]
                param (
                    [Alias('app', 'executables', 'apps')]
                    [ValidateNotNullOrEmpty()]
                    [string[]]$AppFiles = @('Main.hs'),

                    [Alias('lib', 'modules', 'libs')]
                    [ValidateNotNullOrEmpty()]
                    [string[]]$LibFiles = @('Lib.hs'),

                    [Alias('test', 'tests')]
                    [ValidateNotNullOrEmpty()]
                    [string[]]$TestFiles = @('Main.hs'),

                    [Alias('f')]
                    [switch]$Force,

                    [Alias('ni', 'noPrompt')]
                    [switch]$NoInteractive
                )

                begin {
                    Write-Host "`nüöÄ Initializing Haskell modules...`n" -ForegroundColor Cyan
                }

                process {
                    if ($PSCmdlet.ShouldProcess('Initialize Haskell files', 'Creating Haskell files')) {
                        $params = @{
                            Verbose       = $VerbosePreference
                            WhatIf        = $WhatIfPreference
                            Force         = $Force
                            NoInteractive = $NoInteractive
                        }

                        Initialize-FilesInDirectory -Directory 'app' `
                            -Files $AppFiles `
                            -Confirm:$false `
                            @params
                        Initialize-FilesInDirectory -Directory 'src-lib' `
                            -Files $LibFiles  `
                            -Confirm:$false `
                            @params
                        Initialize-FilesInDirectory -Directory 'test' `
                            -Files $TestFiles `
                            -Confirm:$false `
                            @params
                    }
                }

                end {
                    if ($PSCmdlet.ShouldProcess('Haskell files', 'Final confirmation')) {
                        Write-Host "`n‚úÖ Haskell files created successfully." -ForegroundColor Green
                    }
                    if ($WhatIfPreference) {
                        Write-Host "`n‚ÑπÔ∏è WhatIf: No files were created." -ForegroundColor Yellow
                    }
                }
            }
            ```

            <Explanation>
                La funci√≥n `Initialize-CabalModules` es el punto de entrada para generar la estructura inicial de archivos de un proyecto Haskell basado en Cabal. Est√° pensada para automatizar la creaci√≥n de los archivos t√≠picos de una aplicaci√≥n modular: ejecutables (`app`), biblioteca (`src-lib`) y pruebas (`test`).

                #### ¬øQu√© hace esta funci√≥n?

                - Declara par√°metros para recibir listas de archivos a crear en cada directorio, con valores por defecto (`Main.hs` o `Lib.hs`).
                - Usa `ShouldProcess` para soportar los flags `-WhatIf` y `-Confirm`, integr√°ndose con flujos interactivos o de simulaci√≥n.
                - Usa aliases convenientes como `-lib`, `-apps` o `-ni` para facilitar su uso desde la terminal.
                - Pasa los par√°metros comunes a `Initialize-FilesInDirectory`, que es responsable de crear cada archivo Haskell.
                - Al final del proceso, imprime un mensaje de √©xito o un recordatorio si se ejecut√≥ con `-WhatIf`.

                Esta funci√≥n es una forma segura, reutilizable y flexible de generar la estructura base de un proyecto, permitiendo personalizaci√≥n con poco esfuerzo.
            </Explanation>
        
            <details>
                <summary>
                    Funciones auxiliares
                </summary>

                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:Initialize-FilesInDirectory {
                    [CmdletBinding(SupportsShouldProcess)]
                    param (
                        [Parameter(Mandatory)][string]$Directory,
                        [Parameter(Mandatory)][string[]]$Files,
                        [switch]$Force,
                        [switch]$NoInteractive
                    )
                    foreach ($file in $Files) {
                        $filePath = Join-Path -Path $Directory -ChildPath $file

                        if ($PSCmdlet.ShouldProcess($filePath, 'Create Haskell file')) {
                            New-HaskellFile -FileName $filePath `
                                -Force:$Force `
                                -NoInteractive:$NoInteractive `
                                -Verbose:$VerbosePreference `
                                -WhatIf:$WhatIfPreference `
                                -Confirm:$false
                        }
                    }
                }
                ```

                <Explanation>
                    La funci√≥n `Initialize-FilesInDirectory` se encarga de crear m√∫ltiples archivos Haskell dentro de un directorio espec√≠fico. Recibe:

                    - Un nombre de directorio (`$Directory`) donde crear los archivos.
                    - Una lista de nombres de archivo (`$Files`), como `"Main.hs"` o `"Lib.hs"`.
                    - Dos modificadores opcionales: `-Force` para sobrescribir archivos existentes sin preguntar, y `-NoInteractive` para evitar solicitudes de confirmaci√≥n en caso de conflicto.

                    Por cada archivo:
                    - Se construye la ruta completa con `Join-Path`.
                    - Se eval√∫a si deber√≠a proceder la operaci√≥n con `ShouldProcess`, lo cual respeta los flags `-WhatIf` y `-Confirm`.
                    - Se invoca `New-HaskellFile`, que crea el archivo con el encabezado de m√≥dulo correspondiente, manejando la l√≥gica de existencia, sobrescritura y confirmaci√≥n.

                    Este patr√≥n modular permite que la inicializaci√≥n de archivos sea clara, reutilizable y segura para flujos interactivos y automatizados.
                </Explanation>

                
                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:Initialize-FilesInDirectory {
                    [CmdletBinding(SupportsShouldProcess)]
                    param (
                        [Parameter(Mandatory)][string]$Directory,
                        [Parameter(Mandatory)][string[]]$Files,
                        [switch]$Force,
                        [switch]$NoInteractive
                    )
                    foreach ($file in $Files) {
                        $filePath = Join-Path -Path $Directory -ChildPath $file

                        if ($PSCmdlet.ShouldProcess($filePath, 'Create Haskell file')) {
                            New-HaskellFile -FileName $filePath `
                                -Force:$Force `
                                -NoInteractive:$NoInteractive `
                                -Verbose:$VerbosePreference `
                                -WhatIf:$WhatIfPreference `
                                -Confirm:$false
                        }
                    }
                }
                ```

                <Explanation>
                    La funci√≥n `Initialize-FilesInDirectory` automatiza la creaci√≥n de varios archivos en una carpeta espec√≠fica.

                    - Recorre una lista de nombres de archivo (`$Files`) y los concatena con el nombre del directorio (`$Directory`) usando `Join-Path`.
                    - Antes de crear cada archivo, eval√∫a si la operaci√≥n debe ejecutarse con `ShouldProcess`, lo que habilita soporte para los flags `-WhatIf` y `-Confirm`.
                    - Llama a `New-HaskellFile` con los par√°metros adecuados, incluyendo:
                        - `-Force` para sobrescribir sin preguntar.
                        - `-NoInteractive` para evitar confirmaciones manuales.
                        - `-Verbose`, `-WhatIf` y `-Confirm` para respetar las preferencias del usuario.

                    Esta funci√≥n sirve como un puente entre el usuario y la l√≥gica de creaci√≥n de archivos, permitiendo ejecutar m√∫ltiples inicializaciones de forma controlada y segura.
                </Explanation>

                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:New-HaskellFile {
                    [CmdletBinding(SupportsShouldProcess)]
                    param (
                        [Parameter(Mandatory, Position = 0, ValueFromPipeline)]
                        [ValidateNotNullOrEmpty()]
                        [string]$FileName,

                        [switch]$Force,
                        [switch]$NoInteractive
                    )

                    process {
                        # Required: PowerShell 7.0 or later
                        $finalName = $FileName.EndsWith('.hs') ? $FileName : "$FileName.hs"
                        $fullPath = Resolve-FullPath $finalName
                        $directory = Split-Path $fullPath -Parent

                        if (-not (Test-ShouldOverwrite -Path $fullPath `
                                    -Force:$Force `
                                    -NoInteractive:$NoInteractive)) {
                            Write-Host "‚è≠Ô∏è Skipped: $fullPath" -ForegroundColor Gray
                            return
                        }

                        if ($PSCmdlet.ShouldProcess($fullPath, 'Create Haskell file')) {
                            try {
                                New-DirectoryIfMissing $directory
                                Write-ModuleHeader $fullPath
                                Write-Verbose "‚úÖ Created file: $fullPath"
                            } catch {
                                Write-Error "‚ùå Failed to create file '$fullPath': $_"
                            }
                        }
                    }
                }
                ```

                <Explanation>
                    La funci√≥n `New-HaskellFile` crea un archivo de m√≥dulo `.hs` de forma segura, evitando sobrescrituras accidentales y admitiendo ejecuci√≥n interactiva o automatizada.

                    - **Normaliza el nombre**: Si el nombre no termina en `.hs`, lo agrega autom√°ticamente.
                    - **Resuelve la ruta**: Usa `Resolve-FullPath` para obtener la ruta absoluta del archivo.
                    - **Verifica sobrescritura**: Usa `Test-ShouldOverwrite` para decidir si debe continuar, seg√∫n la existencia del archivo y los flags `-Force` o `-NoInteractive`.
                    - **Crea la carpeta si es necesario**: Llama a `New-DirectoryIfMissing`.
                    - **Genera el contenido base del archivo**: Escribe un encabezado de m√≥dulo con `Write-ModuleHeader`.
                    - **Soporta `-WhatIf` y `-Confirm`**: Gracias a `ShouldProcess`, permite simular acciones o confirmar antes de ejecutarlas.

                    Este enfoque modular mejora la legibilidad, mantiene el control en manos del usuario, y facilita integrar esta funci√≥n en scripts m√°s grandes para inicializar proyectos Haskell.
                </Explanation>
        
                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:Test-ShouldOverwrite(
                    [string]$Path,
                    [switch]$Force,
                    [switch]$NoInteractive
                ) {
                    if (-not (Test-Path $Path) -or $Force) { return $true }
                    if ($NoInteractive) {
                        Write-Host "‚ö†Ô∏è File already exists: $Path. Use -Force to overwrite." `
                            -ForegroundColor DarkYellow
                        return $false
                    }

                    $answer = Read-Host "‚ö†Ô∏è File '$Path' exists. Overwrite? (y/N)"
                    return $answer -eq 'y' -or $answer -eq 'Y'
                }
                ```

                <Explanation>
                    La funci√≥n `Test-ShouldOverwrite` decide si se debe sobrescribir un archivo existente, controlando de forma flexible tanto flujos autom√°ticos como interactivos.

                    - Si el archivo no existe o se pas√≥ `-Force`, devuelve `true`, permitiendo la creaci√≥n o sobrescritura sin preguntar.
                    - Si se pas√≥ `-NoInteractive`, se evita la pregunta y se emite un mensaje de advertencia, devolviendo `false`.
                    - En otros casos, se solicita confirmaci√≥n manual con `Read-Host`, devolviendo `true` solo si se responde "y" o "Y".

                    Esta funci√≥n es √∫til para scripts que generan archivos, como m√≥dulos de Haskell, y que deben ser cuidadosos al sobrescribir contenido ya existente. Tambi√©n permite que los scripts funcionen bien tanto en entornos automatizados como en sesiones interactivas.
                </Explanation>
        
                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:Write-ModuleHeader([string]$Path) {
                    $module = [IO.Path]::GetFileNameWithoutExtension($Path)
                    $header = "module $module where`n"
                    Set-Content -Path $Path `
                        -Value $header `
                        -Force `
                        -Encoding UTF8 `
                        -Confirm:$false `
                        -WhatIf:$WhatIfPreference
                }
                ```

                <Explanation>
                    La funci√≥n `Write-ModuleHeader` escribe una cabecera b√°sica de m√≥dulo Haskell en un archivo dado.

                    - Primero, se extrae el nombre del m√≥dulo a partir del nombre del archivo usando `[IO.Path]::GetFileNameWithoutExtension`.  
                    Por ejemplo, para `Echo.hs`, se obtiene `Echo`.
                    - Luego, se construye una l√≠nea de cabecera del estilo `module Echo where` y se guarda como contenido del archivo usando `Set-Content`.
                    - Los flags:
                        - `-Force`: crea o sobreescribe el archivo si ya existe.
                        - `-Encoding UTF8`: asegura una codificaci√≥n est√°ndar.
                        - `-Confirm:$false` y `-WhatIf:$WhatIfPreference`: respetan los modos de ejecuci√≥n y simulaci√≥n del script.

                    Esta funci√≥n se usa para inicializar r√°pidamente archivos `.hs` vac√≠os con una declaraci√≥n v√°lida de m√≥dulo, algo necesario para que GHC o Cabal los reconozcan correctamente.
                </Explanation>
                    
                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:New-DirectoryIfMissing([string]$Path) {
                    if ($Path -and -not (Test-Path $Path)) {
                        New-Item -ItemType Directory `
                            -Path $Path `
                            -Force `
                            -Confirm:$false `
                            -WhatIf:$WhatIfPreference | Out-Null
                        Write-Verbose "‚úÖ Created directory: $Path"
                    }
                }
                ```

                <Explanation>
                    La funci√≥n `New-DirectoryIfMissing` se asegura de que un directorio exista. Si la ruta especificada no existe a√∫n, lo crea de manera silenciosa y segura:

                    - `Test-Path $Path` verifica si ya existe el directorio.
                    - Si no existe, se invoca `New-Item` para crearlo con:
                    - `-Force` para evitar errores si parte de la ruta ya existe.
                    - `-Confirm:$false` para omitir confirmaciones.
                    - `-WhatIf:$WhatIfPreference` para respetar los modos simulados.

                    Esto permite que el script sea idempotente y compatible con `-WhatIf` y `-Verbose`, evitando errores innecesarios si los directorios ya existen o est√°n por crearse m√°s adelante.
                </Explanation>

                ```powershell showLineNumbers title="Initialize-CabalModules.psm1"
                function Script:Resolve-FullPath([string]$Path) {
                    $resolved = Resolve-Path -Path $Path -ErrorAction SilentlyContinue
                    return $resolved ? $resolved.Path : $Path
                }
                ```

                <Explanation>
                    La funci√≥n `Resolve-FullPath` intenta obtener la ruta absoluta de un archivo o directorio. Si no puede resolverla (por ejemplo, si el archivo a√∫n no existe), devuelve la ruta original sin producir errores.

                    Esto asegura que las rutas que usamos m√°s adelante en el script sean siempre v√°lidas, ya sea que apunten a archivos existentes o que vayan a crearse m√°s adelante.

                    Se utiliza el operador ternario (`? :`) introducido en PowerShell 7.0+, lo que permite expresar la l√≥gica condicional de forma m√°s concisa.
                </Explanation>
            </details>   
        </details>

        ```powershell showLineNumbers title="Establece tu paquete (desde la terminal)"
        Initialize-CabalModules `
            -LibFiles 'Echo.hs' `
            -NoInteractive `
            -Verbose
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        {/* <Bash /> */}
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        {/* <Bash /> */}
    </TabItem>
</BoxedTabs>

## üß™ Paso 1: Crear un m√≥dulo de biblioteca

Comenzamos implementando la l√≥gica reutilizable en un m√≥dulo llamado `Echo`. Este m√≥dulo definir√° una funci√≥n `echoMessage` que imprimir√° un mensaje en la terminal.

```haskell title="src-lib/Echo.hs"
module Echo (echoMessage) where

echoMessage :: String -> String
echoMessage msg = msg
```

<Explanation>
    En este paso definimos un **m√≥dulo de biblioteca** en `src-lib/Echo.hs`. 

    - Usamos `module Echo (echoMessage) where` para declarar el nombre del m√≥dulo y exportar expl√≠citamente la funci√≥n `echoMessage`.
    - La funci√≥n tiene el tipo `String -> String`, lo que indica que recibe un mensaje de texto y devuelve el mismo mensaje como resultado.
    
    Este dise√±o modular nos permite importar `Echo` desde otros componentes del proyecto, como la aplicaci√≥n principal o las pruebas. Es un patr√≥n com√∫n en Haskell para escribir c√≥digo reutilizable y testable.
</Explanation>

## üöÄ Paso 2: Usar la biblioteca desde el ejecutable

Ya que nuestra funci√≥n `echoMessage` est√° definida como parte de un m√≥dulo de biblioteca, podemos usarla desde el ejecutable para procesar argumentos de l√≠nea de comandos.

```haskell title="app/Main.hs" showLineNumbers
module Main where

import Echo (echoMessage)
import System.Environment (getArgs)

main :: IO ()
main = getArgs >>= mapM_ (putStrLn . echoMessage)
```

<Explanation>
    En este paso creamos el punto de entrada principal del programa (`Main.hs`), que act√∫a como ejecutable.

    - Usamos `getArgs` para obtener los argumentos pasados por la terminal.
    - Aplicamos `echoMessage` a cada uno usando `mapM_`, que ejecuta una acci√≥n (`putStrLn`) sobre cada elemento de la lista, descartando el resultado.
    - La expresi√≥n `(putStrLn . echoMessage)` aplica la funci√≥n `echoMessage` a cada argumento y luego imprime el resultado.
</Explanation>

Esta forma es idiom√°tica en Haskell, compacta y expresiva, y muestra c√≥mo una biblioteca puede ser reutilizada desde un m√≥dulo ejecutable.
## ‚öôÔ∏è Paso 3: Ajustar el archivo `.cabal`

Ahora configuraremos el archivo `echo-app-cabal.cabal` para que el ejecutable y la suite de pruebas puedan reutilizar la biblioteca definida en `src-lib`.

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```haskell showLineNumbers title="echo-app-cabal.cabal"
        -- Nombre del proyecto
        name:               echo-app-cabal

        -- Configuraci√≥n de la biblioteca
        library
            exposed-modules:  Echo
            hs-source-dirs:   src-lib

        -- Ejecutable que usa la biblioteca
        executable echo-app-cabal
            main-is:          Main.hs
            hs-source-dirs:   app
            build-depends:    echo-app-cabal

        -- Suite de pruebas que tambi√©n depende de la biblioteca
        test-suite echo-app-cabal-test
            main-is:          Main.hs
            hs-source-dirs:   test
            type:             exitcode-stdio-1.0
            build-depends:    echo-app-cabal
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```haskell showLineNumbers title="echo-app-cabal.cabal"
        cabal-version:      3.0
        name:               echo-app-cabal
        version:            0.1.0.0
        homepage:           https://dibs.pages.dev
        license:            BSD-2-Clause
        license-file:       LICENSE
        author:             r8vnhill
        maintainer:         reachme@ravenhill.cl
        build-type:         Simple
        extra-doc-files:    CHANGELOG.md

        common warnings
            ghc-options:      -Wall

        library
            import:           warnings
            exposed-modules:  Echo
            build-depends:    base ^>=4.17.2.1
            hs-source-dirs:   src-lib
            default-language: GHC2021

        executable echo-app-cabal
            import:           warnings
            main-is:          Main.hs
            hs-source-dirs:   app
            build-depends:
            base ^>=4.17.2.1,
            echo-app-cabal
            default-language: GHC2021

        test-suite echo-app-cabal-test
            import:           warnings
            main-is:          Main.hs
            hs-source-dirs:   test
            type:             exitcode-stdio-1.0
            build-depends:
            base ^>=4.17.2.1,
            echo-app-cabal
            default-language: GHC2021
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    El archivo `.cabal` describe c√≥mo se construyen y conectan los distintos componentes del proyecto:

    - En la secci√≥n `library`, declaramos que el m√≥dulo `Echo` estar√° disponible para otros componentes, y especificamos que su c√≥digo fuente vive en `src-lib/`.
    - En `executable`, indicamos que `Main.hs` es el punto de entrada de la app, que est√° en `app/`, y que este m√≥dulo depende de la biblioteca del proyecto.
    - En `test-suite`, seguimos una estructura similar para habilitar pruebas que tambi√©n pueden usar el c√≥digo de la biblioteca.
    - Usamos `import: warnings` para aplicar opciones comunes como `-Wall` a todos los componentes, favoreciendo advertencias √∫tiles durante el desarrollo.
</Explanation>

Esta configuraci√≥n modular refleja buenas pr√°cticas de dise√±o en Haskell: separar responsabilidades, promover la reutilizaci√≥n y preparar el terreno para escalar el proyecto con facilidad.

## ‚ñ∂Ô∏è Paso 4: Ejecutar el proyecto

Con la biblioteca, el ejecutable y la configuraci√≥n listos, ya podemos compilar y lanzar el programa desde la ra√≠z del proyecto.

Ejecuta el siguiente comando:

```bash showLineNumbers title=""
cabal run echo-app-cabal -- "Hi Barbie!" "Hi Ken!" "Do you guys ever think about dying?"
```

La salida deber√≠a ser algo como:

```plaintext
Hi Barbie!
Hi Ken!
Do you guys ever think about dying?
```

<Explanation>
    Usamos `cabal run` seguido del nombre del ejecutable (`echo-app-cabal`) y los argumentos que queremos pasar entre comillas.  
    Estos argumentos son capturados por la funci√≥n `getArgs` en `Main.hs`, lo que permite que el programa procese entradas din√°micas desde la l√≠nea de comandos.

    Luego, cada argumento se transforma con la funci√≥n `echoMessage` definida en la biblioteca y se imprime por separado, gracias al uso de `mapM_`.
</Explanation>

üëâ Este paso confirma que el ejecutable est√° correctamente conectado a la biblioteca y que puede recibir entradas externas, lo que lo hace m√°s interactivo y reutilizable.

## üéØ Conclusiones

Dividir un proyecto Haskell en m√∫ltiples m√≥dulos no es solo una cuesti√≥n de orden: es una forma de expresar con claridad qu√© partes del c√≥digo son reutilizables, cu√°les se ejecutan como aplicaci√≥n y cu√°les prueban su correcto funcionamiento. Esta separaci√≥n de responsabilidades es clave al dise√±ar bibliotecas, y en esta lecci√≥n dimos nuestros primeros pasos en esa direcci√≥n.

Aprendimos a usar `cabal init` para crear un proyecto bien estructurado, a definir una biblioteca simple con una funci√≥n exportada, y a configurar el ejecutable para que la consuma. Tambi√©n comprendimos c√≥mo ajustar el archivo `.cabal` para reflejar estas relaciones y c√≥mo ejecutar el programa con argumentos reales desde la terminal.

Este ejercicio no solo nos ense√±√≥ herramientas, sino tambi√©n una forma de pensar: **crear software reutilizable, modular y preparado para crecer**.

### üîë Puntos clave

- Crear un proyecto con `cabal init` permite estructurar desde el inicio la biblioteca, el ejecutable y las pruebas.
- Definir m√≥dulos separados facilita la reutilizaci√≥n y el mantenimiento del c√≥digo.
- El archivo `.cabal` act√∫a como contrato entre los componentes: describe qu√© se construye, desde d√≥nde y con qu√© dependencias.
- La funci√≥n `getArgs` permite capturar argumentos desde la terminal, y `forM_` es una forma idiom√°tica de recorrerlos.
- Tanto la app como los tests pueden importar l√≥gica com√∫n desde la biblioteca.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n nos mostr√≥ que un proyecto no comienza cuando escribimos c√≥digo, sino cuando tomamos decisiones sobre su estructura.  
Separar la l√≥gica reutilizable en una biblioteca, definir un ejecutable claro y configurar correctamente los archivos del proyecto es lo que transforma un conjunto de archivos en una base s√≥lida para construir software real.

Pero tambi√©n nos llevamos algo m√°s sutil: que **la forma en que organizamos nuestro c√≥digo influye en c√≥mo pensamos nuestros programas**.  
Cuando estructuramos bien, podemos escribir menos y lograr m√°s. Podemos componer, reutilizar y probar.  
Y cuando eso ocurre, lo que estamos creando no es solo un programa... es una biblioteca que puede vivir m√°s all√° del proyecto original.

## üìñ Referencias

### üî• Recomendadas

- üåê Structure of a Haskell project‚ÄîHaskellWiki. (s.¬†f.). Recuperado 5 de abril de 2025, de https://wiki.haskell.org/Structure_of_a_Haskell_project

{/* ### üîπ Adicionales */}
