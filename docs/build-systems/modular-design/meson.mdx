---
title: Modularizando tu proyecto C++ con Meson
---

import GitHubRepoLink from "@site/src/components/git/GithubRepoLink";
import Explanation from "@site/src/components/admonitions/Explanation";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Glossary from '@site/src/components/admonitions/Glossary'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'
import Sh from '@site/src/components/mdx/build-systems/modular-design/meson/sh.mdx'
import CleanupSh from '@site/src/components/mdx/build-systems/modular-design/meson/cleanup-sh.mdx'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="echo-app-cpp-meson" />

:::danger TODO

- [ ] A√±adir introducci√≥n

:::

## üèóÔ∏è Estructura esperada del proyecto

```mermaid
graph TD
```

:::danger TODO

- [ ] A√±adir un diagrama de flujo de la estructura del proyecto.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="src/scripts/ps1/CreateProjectStructure.ps1"
        @{
            App = @("src/app/main.cpp", "src/app/meson.build")
            Core = @("src/core/echo.cpp", "src/core/echo.hpp", "src/core/meson.build")
        }.GetEnumerator() | ForEach-Object {
            $module = $_.Key
            $files = $_.Value

            Write-Host "üìÅ Creating structure for module: $module" -ForegroundColor Cyan

            foreach ($file in $files) {
                $dir = Split-Path $file -Parent
                if (-not (Test-Path $dir)) {
                    New-Item -Path $dir -ItemType Directory -Force | Out-Null
                }
                New-Item -Path $file -ItemType File -Force | Out-Null
                Write-Host "‚úÖ $file" -ForegroundColor Green
            }
        }

        Write-Host "üü¢ Project initialized successfully." -ForegroundColor Green
        ```

        <Explanation>
            Este script de PowerShell automatiza la creaci√≥n de una estructura de carpetas y archivos m√≠nima para un proyecto modular en C++ usando **Meson** como sistema de construcci√≥n.

            - Define un diccionario con dos m√≥dulos: `App` y `Core`, cada uno asociado a los archivos que necesita.
            - Por cada archivo:
                - Crea la carpeta contenedora si no existe (por ejemplo, `src/app/` o `src/core/`).
                - Crea un archivo vac√≠o (`main.cpp`, `echo.cpp`, `meson.build`, etc.) en la ubicaci√≥n indicada.
                - Muestra en consola un mensaje de confirmaci√≥n (`‚úÖ`) por cada archivo creado.
        </Explanation>
        
        Puedes crear el archivo `CreateProjectStructure.ps1` y ejecutarlo desde PowerShell para crear la estructura de carpetas y archivos autom√°ticamente.

        ```powershell
        .\scripts\ps1\CreateProjectStructure.ps1
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <Sh />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <Sh />
    </TabItem>
</BoxedTabs>

::::tip Limpieza

Puedes borrar los archivos creados en la lecci√≥n pasada o guardarlos como recuerdo.

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="src/scripts/ps1/CleanupProject.ps1"
        'src\main.cpp', 'src\meson.build' | Remove-Item -Force -Verbose
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <CleanupSh />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <CleanupSh />
    </TabItem>
</BoxedTabs>

::::

## üßæ Paso 2: Declarar el archivo ra√≠z `meson.build`

En este archivo indicamos a Meson que estamos creando un proyecto en C++, especificamos su versi√≥n, y declaramos qu√© subdirectorios contienen c√≥digo que debe ser compilado.

```python showLineNumbers title="meson.build"
project('echo-app', 'cpp', version: '0.2.0')  # Nombre, lenguaje y versi√≥n del proyecto

subdir('src/core')  # Biblioteca reutilizable
subdir('src/app')   # Ejecutable principal
```

<Explanation>
    Este archivo es el punto de entrada del sistema de construcci√≥n de Meson. Declara el proyecto y registra los subdirectorios que contienen sus propios archivos `meson.build`. As√≠, Meson podr√° compilar correctamente tanto la biblioteca (`core`) como la aplicaci√≥n (`app`).
</Explanation>


## üß© Paso 3: Implementar la biblioteca `core`

En este paso definimos la biblioteca `core`, que encapsula una funci√≥n simple `echo`. Para ello, configuramos el archivo `meson.build` del m√≥dulo y escribimos su implementaci√≥n.

```python showLineNumbers title="src/core/meson.build"
core_sources = files('echo.cpp')

core_lib = static_library(
    'core',
    core_sources,
    include_directories: include_directories('.'),
    cpp_args: ['-std=c++23'],
)
```

<Explanation>
    Este archivo configura la compilaci√≥n del m√≥dulo `core` como una biblioteca est√°tica. 

    - `static_library('core', ...)` indica que se generar√° una `.a` o `.lib` con ese nombre.
    - Se incluyen los archivos fuente del m√≥dulo (`echo.cpp`) y el directorio actual como ruta de inclusi√≥n (`.`), donde est√° el archivo `echo.hpp`.
    - Se fuerza el est√°ndar `c++23` para habilitar caracter√≠sticas modernas del lenguaje.

    Esto permite que otros m√≥dulos, como `app`, puedan vincularse contra `core` y reutilizar sus funciones.
</Explanation>

### ‚úçÔ∏è Implementaci√≥n de `echo`

Ahora escribimos la funci√≥n `echo`, que devuelve una copia del mensaje recibido. Usamos `std::string_view` para mayor eficiencia en el paso de argumentos.

```cpp showLineNumbers title="src/core/echo.hpp"
#pragma once

#include <string>
#include <string_view>

[[nodiscard]] std::string echo(std::string_view message);
```

```cpp showLineNumbers title="src/core/echo.cpp"
#include "echo.hpp"

std::string echo(std::string_view message) {
    return {message.begin(), message.end()};
}
```

<Explanation>
    - En `echo.hpp`, definimos la interfaz p√∫blica de la biblioteca.  
      Usamos `std::string_view` como entrada para aceptar cadenas sin copiar, y `[[nodiscard]]` para evitar que se ignore el resultado de la funci√≥n.
    
    - En `echo.cpp`, implementamos `echo` devolviendo una copia expl√≠cita del contenido usando rangos. Esto funciona igual que `std::string(message)` pero es m√°s expl√≠cito en su conversi√≥n.

    Esta biblioteca es m√≠nima pero funcional. Ilustra c√≥mo separar la l√≥gica de negocio (`core`) del ejecutable principal (`app`), siguiendo una estructura modular mantenible.
</Explanation>

## üöÄ M√≥dulo `app`: ejecutable

```python showLineNumbers title="src/app/meson.build"
app_sources = files('main.cpp')
executable('app', app_sources,
    dependencies: [],
    link_with: core_lib,
    include_directories: include_directories('..')
)
```

C√≥digo principal:

```cpp showLineNumbers title="src/app/main.cpp"
#include <iostream>
#include "core/echo.hpp"

int main() {
    std::cout << echo("Hello from Meson!") << std::endl;
    return 0;
}
```

## üî® Compilaci√≥n

Desde la ra√≠z del proyecto:

```bash
meson setup build
meson compile -C build
```

Y ejecuta el binario:

```bash
./build/src/app/app
```

```plaintext
Echo: Hello from Meson!
```

<Explanation>
El ejecutable `app` se compila en `build/src/app/app` y enlaza con la biblioteca `core`. Gracias a la configuraci√≥n modular, puedes mantener `core` como una unidad reutilizable o independiente.
</Explanation>
