---
title: Estructurando Proyectos Multi-M√≥dulo con Swift
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/GithubRepoLink";
import ReadingTime from '@site/src/components/ReadingTime';
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime/>
<GitHubRepoLink repo={"echo-app-swift"} user={"r8vnhill"} />

En esta lecci√≥n vamos a dar un paso m√°s all√° del t√≠pico archivo `main.swift`: aprender√°s a **estructurar un proyecto Swift en m√∫ltiples m√≥dulos** usando [Swift Package Manager (SwiftPM)](https://www.swift.org/package-manager/), la herramienta oficial para construir, distribuir y organizar c√≥digo en Swift.

Dividiremos el proyecto en tres partes:  
- Un ejecutable (`App`) que act√∫a como punto de entrada,  
- Una biblioteca (`Lib`) que contiene la l√≥gica reutilizable,  
- Y un conjunto de pruebas (`LibTests`) que valida esa l√≥gica.

Este enfoque modular no solo mejora la organizaci√≥n del c√≥digo, sino que sienta las bases para proyectos m√°s escalables, testeables y f√°ciles de mantener ‚Äî como los que se esperan en entornos profesionales.

:::tip ¬øPor qu√© importa?

Dise√±ar un proyecto en m√≥dulos bien definidos te permite **trabajar en capas**, **reutilizar l√≥gica** en m√∫ltiples contextos, y **acelerar los ciclos de desarrollo y prueba**.

:::

Al terminar esta lecci√≥n, estar√°s en condiciones de construir tus propias bibliotecas Swift, integrarlas en aplicaciones y ejecutar proyectos bien estructurados desde la terminal.

Let's-a go!

## üèóÔ∏è Estructura esperada del proyecto

SwiftPM impone una convenci√≥n estricta de carpetas para que los m√≥dulos (targets) funcionen correctamente.
A continuaci√≥n se muestra la estructura completa que debe seguir el proyecto `EchoAppSwift` para que compile correctamente y mantenga una separaci√≥n clara entre ejecutable, biblioteca y pruebas:

```mermaid
graph TD
    subgraph Root [üìÅ EchoAppSwift]
        direction LR

        Package[üìÑ Package.swift]

        subgraph Sources [üìÅ Sources]
            direction TB

            subgraph App [üìÅ App]
                Main[üìÑ main.swift]
            end

            subgraph Lib [üìÅ Lib]
                Echo[üìÑ Echo.swift]
            end
        end

        subgraph Tests [üìÅ Tests]
            direction TB

            subgraph LibTests [üìÅ LibTests]
                EchoTests[üìÑ EchoTests.swift]
            end
        end
    end

    Package -->|declara| App
    Package -->|declara| Lib
    Package -->|declara| LibTests
    Main -->|import| Echo
    EchoTests -->|testea| Echo
```

:::info Explicaci√≥n de la estructura del proyecto

Este diagrama muestra c√≥mo organizar un proyecto modular en Swift utilizando **Swift Package Manager (SwiftPM)**, respetando sus convenciones:

- **`Package.swift`**: Archivo central de configuraci√≥n donde se declaran los m√≥dulos (`App`, `Lib`, `LibTests`) y sus relaciones.
- **`Sources/App/`**: Contiene el ejecutable principal. SwiftPM buscar√° aqu√≠ un archivo `main.swift` como punto de entrada del programa.
- **`Sources/Lib/`**: M√≥dulo de biblioteca reutilizable. Puede ser importado por `App` o cualquier otro m√≥dulo.
- **`Tests/LibTests/`**: M√≥dulo de pruebas unitarias para `Lib`. SwiftPM asocia autom√°ticamente esta carpeta con el target `LibTests`.

üìå Los nombres de las carpetas dentro de `Sources/` y `Tests/` deben coincidir **exactamente** con los nombres de los targets definidos en `Package.swift`.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
  <TabItem value="Windows" label="Windows">
        ```powershell title="En PowerShell"
        'App', 'Lib' | ForEach-Object {
            $target = "Sources/$_"
            New-Item $target -ItemType Directory -Force | Out-Null

            switch ($_) {
                'App' {
                    New-Item "$target/main.swift" `
                        -ItemType File -Force | Out-Null
                }
                'Lib' {
                    $echo = 'Echo'
                    New-Item "$target/$echo.swift", `
                        "Tests/${echo}Tests.swift" `
                        -ItemType File -Force | Out-Null
                }
            }
        }
        ```

        <Explanation>
            Este script inicializa la estructura de un proyecto Swift con dos m√≥dulos:

            - **`Sources/App/`**: contiene el archivo `main.swift` como punto de entrada para la aplicaci√≥n.
            - **`Sources/Lib/`**: define la biblioteca reutilizable en `Echo.swift`.
            - **`Tests/`**: contiene el archivo `EchoTests.swift` para pruebas automatizadas de la biblioteca.
            - **`| Out-Null`** se usa para suprimir la salida de la consola al crear directorios y archivos.

            El uso de `switch` permite generar diferentes archivos seg√∫n el m√≥dulo, y las rutas se construyen din√°micamente para mantener el c√≥digo claro y compacto.
        </Explanation>
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell title="En PowerShell"
            'App', 'Lib' | % {
                $src = "Sources/$_"
                md $src -f > $null

                switch ($_) {
                    'App' { ni "$src/main.swift" -f > $null }
                    'Lib' { ni "$src/Echo.swift", "Tests/EchoTests.swift" -f > $null }
                }
            }
            ```

            <Explanation>
                Este bloque configura la estructura inicial de un proyecto Swift dividido en dos m√≥dulos:

                - Crea los directorios `Sources/App` y `Sources/Lib`.
                - En `App`, genera el archivo `main.swift`, punto de entrada de la aplicaci√≥n.
                - En `Lib`, crea `Echo.swift` (l√≥gica reutilizable) y `EchoTests.swift` dentro de `Tests` para futuras pruebas.

                El uso de `> $null` en cada comando suprime la salida innecesaria en la consola, manteniendo el script limpio y silencioso.
            </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash title="En tu terminal (Linux/macOS)"
        mkdir -p Tests  # Asegura que la carpeta de pruebas exista
        for module in App Lib; do
            src="Sources"
            mkdir -p "$src/$module"  # Crea la carpeta del m√≥dulo

            case "$module" in
                App)
                    touch "$src/$module/main.swift"  # Archivo principal de la app
                    ;;
                Lib)
                    touch "$src/$module/Echo.swift"  # L√≥gica compartida (biblioteca)
                    touch "Tests/EchoTests.swift"    # Archivo de pruebas para la biblioteca
                    ;;
            esac
        done
        ```

        <Explanation>
            Este script configura un proyecto Swift modular:

            - Crea los directorios `Sources/App` y `Sources/Lib`, donde vivir√°n los archivos fuente.
            - Si el m√≥dulo es `App`, genera `main.swift`, el punto de entrada de la aplicaci√≥n.
            - Si el m√≥dulo es `Lib`, crea `Echo.swift` para la l√≥gica reutilizable y `EchoTests.swift` dentro de `Tests` para escribir pruebas m√°s adelante.

            El uso de `case` mejora la claridad respecto a m√∫ltiples condiciones, facilitando la escalabilidad del script si se agregan m√°s m√≥dulos en el futuro.
        </Explanation>
    </TabItem>
</BoxedTabs>

## üß© Paso 2: Declarar m√≥dulos y productos

Vamos a definir la configuraci√≥n del proyecto en `Package.swift`. Aqu√≠ declaramos:

- Un ejecutable llamado `App`, que actuar√° como punto de entrada.
- Una biblioteca llamada `Lib`, que contendr√° la l√≥gica reutilizable.
- Un conjunto de pruebas unitarias llamado `LibTests`.

```swift showLineNumbers title="Package.swift"
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "echo-app-swift",
    products: [
        .executable(name: "App", targets: ["App"]),   // Ejecutable principal
        .library(name: "Lib", targets: ["Lib"])       // Biblioteca compartida
    ],
    targets: [
        .target(name: "Lib"),                         // L√≥gica reutilizable
        .executableTarget(
            name: "App",
            dependencies: ["Lib"]                     // App depende de Lib
        ),
        .testTarget(
            name: "LibTests",
            dependencies: ["Lib"]                     // Pruebas para la biblioteca
        )
    ]
)
```

<Explanation>
    Este archivo configura el proyecto como un **paquete de Swift multiplataforma** con una estructura modular.

    - `App` ser√° el ejecutable que se puede lanzar desde consola.
    - `Lib` es la biblioteca donde colocamos la l√≥gica de negocio (como la funci√≥n `echo`).
    - `LibTests` es un m√≥dulo de pruebas para verificar el comportamiento de `Lib`.

    Al declarar estas relaciones, el compilador entiende c√≥mo construir cada componente y c√≥mo se relacionan entre s√≠.
</Explanation>

## üß™ Paso 3: Implementar la l√≥gica reutilizable

Vamos a definir una funci√≥n `echo` dentro de la biblioteca `Lib`. Esta funci√≥n ser√° p√∫blica para que el m√≥dulo `App` pueda usarla.

```swift showLineNumbers title="Sources/Lib/Echo.swift"
public func echo(_ message: String) -> String {
    return message
}
```

<Explanation>
    En este paso declaramos una funci√≥n p√∫blica `echo`, que recibe un mensaje y lo devuelve sin cambios.

    - Usamos `public` para que otros m√≥dulos ‚Äîcomo `App`‚Äî puedan acceder a esta funci√≥n.
    - La funci√≥n encapsula una responsabilidad simple, pero servir√° como ejemplo para entender c√≥mo se comparte l√≥gica entre m√≥dulos.

    Este archivo representa la **unidad m√≠nima de l√≥gica de negocio** dentro de la biblioteca `Lib`.
</Explanation>

## üöÄ Paso 4: Crear el punto de entrada de la aplicaci√≥n

Ahora implementamos la funci√≥n principal de la aplicaci√≥n en el m√≥dulo `App`, que utilizar√° la funci√≥n `echo` de la biblioteca `Lib`.

```swift showLineNumbers title="Sources/App/main.swift"
import Lib

func main() {
    // Ignora el primer argumento (nombre del ejecutable)
    let args = CommandLine.arguments.dropFirst()
    for arg in args {
        print(echo(arg))
    }
}

main()
```

<Explanation>
    Este archivo define el punto de entrada del programa:

    - `import Lib` habilita el uso de funciones p√∫blicas del m√≥dulo `Lib`, como `echo`.
    - `CommandLine.arguments` captura los argumentos pasados por terminal.
    - `dropFirst()` elimina el primer argumento, que es el nombre del binario ejecutado.
    - `print(echo(arg))` imprime cada argumento utilizando la funci√≥n definida en la biblioteca.

    Esta estructura demuestra c√≥mo separar la **l√≥gica de aplicaci√≥n (App)** de la **l√≥gica de negocio (Lib)**, siguiendo buenas pr√°cticas de dise√±o modular.
</Explanation>

## ‚ñ∂Ô∏è Paso 5: Ejecutar la aplicaci√≥n

Una vez que has definido los m√≥dulos y escrito el c√≥digo, puedes ejecutar la aplicaci√≥n directamente desde la terminal con:

```bash title="En tu terminal"
swift run App Kanna Kenji Friend
```

```plaintext title="Salida esperada"
Kanna
Kenji
Friend
```

<Explanation>
    Este comando compila el proyecto (si es necesario) y ejecuta el m√≥dulo `App` con los argumentos `Kanna`, `Kenji` y `Friend`.
</Explanation>

Cada argumento se imprime en una nueva l√≠nea. Esto demuestra que:

- `App` puede consumir funciones p√∫blicas de `Lib`.
- El programa responde correctamente a entradas din√°micas.
- La separaci√≥n entre biblioteca y aplicaci√≥n funciona de forma efectiva.

‚úÖ ¬°Tu primer programa modular en Swift est√° en marcha!

## üéØ Conclusiones

En esta lecci√≥n aprendiste a estructurar un proyecto en Swift utilizando una arquitectura modular basada en **Swift Package Manager (SwiftPM)**.

Partiste desde cero y construiste una estructura que separa claramente la **l√≥gica de aplicaci√≥n** (m√≥dulo `App`) de la **l√≥gica reutilizable** (m√≥dulo `Lib`). Adem√°s, sentaste las bases para un desarrollo profesional al incluir un m√≥dulo de pruebas (`LibTests`), aun cuando todav√≠a no hayas escrito los tests.

Esta separaci√≥n no solo mejora la organizaci√≥n del proyecto, sino que te prepara para escalarlo, reutilizar c√≥digo entre proyectos, y aplicar buenas pr√°cticas como pruebas unitarias e integraci√≥n continua.

### üîë Puntos clave

- SwiftPM permite definir ejecutables, bibliotecas y pruebas dentro de un mismo proyecto, usando una convenci√≥n clara de carpetas.
- El archivo `Package.swift` es el punto central para declarar m√≥dulos y sus relaciones.
- `App` act√∫a como punto de entrada y puede depender de bibliotecas como `Lib`.
- `Lib` contiene la l√≥gica reutilizable, y su visibilidad se controla con el modificador `public`.
- `LibTests` permite probar la biblioteca de forma aislada.
- La separaci√≥n modular mejora la escalabilidad, el mantenimiento y la testeabilidad del proyecto.

### üß∞ ¬øQu√© nos llevamos?

Con esta lecci√≥n pasaste de tener un √∫nico archivo Swift a trabajar con una **estructura profesional y escalable**, donde cada m√≥dulo cumple un rol bien definido.

Aprendiste a:

- Respetar las convenciones de SwiftPM.
- Dise√±ar una arquitectura basada en separaci√≥n de responsabilidades.
- Compartir funcionalidad entre m√≥dulos mediante `import`.
- Ejecutar un programa con argumentos desde la l√≠nea de comandos.

Este enfoque modular ser√° la base para futuras lecciones en las que exploraremos pruebas, documentaci√≥n, empaquetado y automatizaci√≥n. **Ya est√°s pensando como quien construye software, no solo como quien lo escribe.**

## üìñ Referencias

### üî• Recomendadas

- [üåê "Package Manager"](https://www.swift.org/documentation/package-manager/) de **la documentaci√≥n oficial de Swift**: Explica los fundamentos de **Swift Package Manager (SwiftPM)**, incluyendo c√≥mo definir m√≥dulos (`targets`), productos (`products`) y dependencias. La lecci√≥n usa precisamente estos conceptos para estructurar el proyecto en m√≥dulos (`App`, `Lib`, `LibTests`) y compartir l√≥gica mediante `import`. Esta lectura es clave para entender c√≥mo SwiftPM organiza, compila y vincula proyectos modulares de manera autom√°tica y escalable.

### üîπ Adicionales

- [üì∞ "Modular Project Structure with Swift Package Manager (SPM)"](https://santoshbotre01.medium.com/modular-project-structure-with-swift-package-manager-spm-c81fb62c8619) de **Santosh Botre**: Explica c√≥mo estructurar aplicaciones iOS en m√∫ltiples m√≥dulos usando **Swift Package Manager** para lograr escalabilidad, reutilizaci√≥n y aislamiento. Presenta un enfoque pr√°ctico para dividir el c√≥digo en paquetes locales (como `Network`, `Logger`, `Login`, etc.) y vincularlos al proyecto. Es relevante para esta lecci√≥n porque ilustra los beneficios y el proceso de migrar de un dise√±o monol√≠tico a una arquitectura modular realista con SwiftPM.
