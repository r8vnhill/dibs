---
title: Configuraciones b√°sicas de proyectos multi-m√≥dulo en Swift
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/GithubRepoLink";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>
<GitHubRepoLink repo={"echo-app-swift"} user={"r8vnhill"} />

En lecciones anteriores aprendiste c√≥mo estructurar un proyecto multi-m√≥dulo utilizando **Gradle**. Ahora aplicaremos esos mismos principios en un entorno diferente: **Swift**.

Swift Package Manager (SwiftPM) es la herramienta oficial para gestionar dependencias, construir proyectos y organizar c√≥digo en m√≥dulos dentro del ecosistema Swift. A diferencia de Gradle, SwiftPM favorece una estructura de carpetas muy estricta basada en convenciones, lo que simplifica muchas decisiones pero tambi√©n limita algunas opciones de personalizaci√≥n.

En esta lecci√≥n aprender√°s a:

- Declarar m√∫ltiples m√≥dulos en `Package.swift`.
- Establecer relaciones de dependencia entre ellos.
- Comprender c√≥mo SwiftPM estructura el c√≥digo en carpetas y archivos.
- Preparar una base s√≥lida para bibliotecas modulares escritas en Swift.

Aunque los ejemplos que ver√°s aqu√≠ son simples, reproducen una estructura t√≠pica de proyectos reales ‚Äîy escalables‚Äî que te servir√° tanto para crear **bibliotecas reutilizables** como para organizar aplicaciones Swift complejas desde el inicio.

## üì¶ Declarar m√∫ltiples m√≥dulos

En SwiftPM, los m√≥dulos se organizan como **targets** dentro de un archivo `Package.swift`.  
Para que otros paquetes o ejecutables puedan usar esos m√≥dulos, tambi√©n se deben declarar como **productos**.

```swift showLineNumbers title="Package.swift"
// swift-tools-version: 6.0
import PackageDescription

let package = Package(
    name: "echo-app-swift",
    products: [
        .executable(name: "App", targets: ["App"]),
        .library(name: "Lib", targets: ["Lib"])
    ],
    targets: [
        .target(name: "Lib"),
        .executableTarget(
            name: "App",
            dependencies: ["Lib"]
        ),
        .testTarget(
            name: "LibTests",
            dependencies: ["Lib"]
        )
    ]
)
```

<Explanation>
    - **`products`**: Definen los artefactos que el paquete expone p√∫blicamente. En este caso, una **librer√≠a** (`Lib`) y un **ejecutable** (`App`).
    - **`targets`**: Representan los m√≥dulos reales que se compilan. Cada uno puede ser una librer√≠a, un ejecutable o un conjunto de tests.
    - `App` declara una dependencia interna sobre `Lib`, lo que le permite importar y usar su funcionalidad.
    - `LibTests` depende tambi√©n de `Lib`, siguiendo el patr√≥n com√∫n de "testear la biblioteca de forma aislada".
</Explanation>

## üß± Estructura de un proyecto multi-m√≥dulo en Swift

Al igual que en Gradle, Swift Package Manager (**SwiftPM**) permite organizar un proyecto en m√∫ltiples **m√≥dulos reutilizables**, llamados *targets*. Esta estructura facilita el desarrollo independiente, la reutilizaci√≥n y la escalabilidad del c√≥digo.

Un proyecto b√°sico puede organizarse as√≠:

```mermaid
graph LR
    subgraph echo-app-swift [üìÅ echo-app-swift]
        Package["üìÑ Package.swift"]

        subgraph sources [üìÅ Sources]
            subgraph App [üìÅ App]
                Main["üìÑ main.swift"]
            end
            subgraph Lib [üìÅ Lib]
                Echo["üìÑ Echo.swift"]
            end
        end

        subgraph tests [üìÅ Tests]
            subgraph LibTests [üìÅ LibTests]
                EchoTests["üìÑ EchoTests.swift"]
            end
        end
    end

    Package --> sources
    Package --> tests

    App --> Lib
    LibTests --> Lib
```

:::info Descripci√≥n de la estructura del proyecto

- **`Package.swift`**: Archivo de configuraci√≥n del proyecto, donde se declaran los m√≥dulos (targets) y productos.
- **`Sources/App`**: M√≥dulo ejecutable principal. Contiene la entrada del programa (`main.swift`) y depende de la biblioteca `Lib`.
- **`Sources/Lib`**: M√≥dulo de biblioteca reutilizable. Puede incluir l√≥gica compartida entre m√∫ltiples aplicaciones o tests.
- **`Tests/LibTests`**: M√≥dulo de pruebas para la biblioteca `Lib`.

Este patr√≥n de separaci√≥n es est√°ndar en SwiftPM y ayuda a mantener el c√≥digo organizado y f√°cil de escalar.
:::

:::tip ¬øY el `main.swift` anterior?

Si previamente creaste un archivo `Sources/main.swift` fuera de un m√≥dulo, puedes eliminarlo.  
Ahora que el m√≥dulo ejecutable se llama `App`, todo el c√≥digo de entrada debe ubicarse dentro de `Sources/App/main.swift`.
:::

## üéØ Conclusiones

En esta lecci√≥n aprendiste c√≥mo estructurar un proyecto Swift utilizando m√∫ltiples m√≥dulos (*targets*) con Swift Package Manager (SwiftPM), siguiendo principios similares a los vistos en Gradle.

Esta organizaci√≥n es clave para proyectos **escalables, reutilizables y mantenibles**, especialmente cuando desarrollas bibliotecas de software que deben estar bien separadas de las aplicaciones que las consumen.

### üîë Puntos clave

- **SwiftPM organiza el proyecto a trav√©s de `Package.swift`**, donde defines productos (`library`, `executable`) y m√≥dulos (`target`, `testTarget`).
- **Cada target representa un m√≥dulo de c√≥digo** que puede compilarse, testearse e integrarse de manera independiente.
- **Las dependencias entre m√≥dulos se declaran expl√≠citamente**, por ejemplo, haciendo que el ejecutable `App` dependa de la biblioteca `Lib`.
- **La estructura de carpetas sigue convenciones estrictas**, como `Sources/` y `Tests/`, lo cual mejora la claridad y la interoperabilidad del proyecto.

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° de los detalles sint√°cticos y t√©cnicos, esta lecci√≥n te da una herramienta conceptual poderosa: **la modularidad como principio de dise√±o**.

Aprender a organizar un proyecto en m√∫ltiples m√≥dulos no es solo una cuesti√≥n de estilo o limpieza, sino una decisi√≥n estrat√©gica que facilita el crecimiento, la prueba, la colaboraci√≥n y la reutilizaci√≥n del c√≥digo. SwiftPM, con su enfoque expl√≠cito y su estructura basada en convenciones, nos obliga a pensar de forma clara en **qu√© hace cada parte del sistema y c√≥mo se relaciona con las dem√°s**.

Al aplicar esta estructura desde los primeros pasos de tu proyecto, te est√°s preparando no solo para escribir buen c√≥digo hoy, sino para mantenerlo y escalarlo ma√±ana.

## üìñ Referencias

### üî• Recomendadas

- üåê Apple Inc. (s.¬†f.). Package Manager. Swift.Org. Recuperado 4 de abril de 2025, de https://www.swift.org/documentation/package-manager/

{/* ### üîπ Adicionales */}
