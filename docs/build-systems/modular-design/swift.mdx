---
title: Estructurando Proyectos Multi-M√≥dulo con Swift
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/GithubRepoLink";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>
<GitHubRepoLink repo={"echo-app-swift"} user={"r8vnhill"} />

## üèóÔ∏è Estructura esperada del proyecto

SwiftPM impone una convenci√≥n estricta de carpetas para que los m√≥dulos (targets) funcionen correctamente.
A continuaci√≥n se muestra la estructura completa que debe seguir el proyecto `EchoAppSwift` para que compile correctamente y mantenga una separaci√≥n clara entre ejecutable, biblioteca y pruebas:

```mermaid
graph TD
    subgraph Root [üìÅ EchoAppSwift]
        direction LR

        Package[üìÑ Package.swift]

        subgraph Sources [üìÅ Sources]
            direction TB

            subgraph App [üìÅ App]
                Main[üìÑ main.swift]
            end

            subgraph Lib [üìÅ Lib]
                Echo[üìÑ Echo.swift]
            end
        end

        subgraph Tests [üìÅ Tests]
            direction TB

            subgraph LibTests [üìÅ LibTests]
                EchoTests[üìÑ EchoTests.swift]
            end
        end
    end

    Package -->|declara| App
    Package -->|declara| Lib
    Package -->|declara| LibTests
    Main -->|import| Echo
    EchoTests -->|testea| Echo
```

:::info Explicaci√≥n de la estructura del proyecto

Este diagrama muestra c√≥mo organizar un proyecto modular en Swift utilizando **Swift Package Manager (SwiftPM)**, respetando sus convenciones:

- **`Package.swift`**: Archivo central de configuraci√≥n donde se declaran los m√≥dulos (`App`, `Lib`, `LibTests`) y sus relaciones.
- **`Sources/App/`**: Contiene el ejecutable principal. SwiftPM buscar√° aqu√≠ un archivo `main.swift` como punto de entrada del programa.
- **`Sources/Lib/`**: M√≥dulo de biblioteca reutilizable. Puede ser importado por `App` o cualquier otro m√≥dulo.
- **`Tests/LibTests/`**: M√≥dulo de pruebas unitarias para `Lib`. SwiftPM asocia autom√°ticamente esta carpeta con el target `LibTests`.

üìå Los nombres de las carpetas dentro de `Sources/` y `Tests/` deben coincidir **exactamente** con los nombres de los targets definidos en `Package.swift`.

:::

## üì¶ Declarar m√∫ltiples m√≥dulos

En Swift, todos los proyectos gestionados con SwiftPM se definen a trav√©s de un archivo llamado `Package.swift`.
Este archivo act√∫a como el punto central de configuraci√≥n: en √©l se declaran los m√≥dulos (llamados **targets**), los productos que se generan, sus dependencias internas y externas, y la versi√≥n m√≠nima de herramientas requeridas para compilar el proyecto.

A continuaci√≥n, un ejemplo completo que define una aplicaci√≥n modular simple con una biblioteca y sus pruebas:

```swift showLineNumbers title="Declaraci√≥n de m√≥dulos y productos (Package.swift)"
// swift-tools-version: 6.0
import PackageDescription

let package = Package(
    name: "echo-app-swift",
    products: [
        .executable(name: "App", targets: ["App"]),
        .library(name: "Lib", targets: ["Lib"])
    ],
    targets: [
        .target(name: "Lib"),
        .executableTarget(
            name: "App",
            dependencies: ["Lib"]
        ),
        .testTarget(
            name: "LibTests",
            dependencies: ["Lib"]
        )
    ]
)
```

<Explanation>
    Este archivo est√° compuesto por varias secciones clave:

    - **`// swift-tools-version: 6.0`**:
        Esta l√≠nea debe estar al inicio del archivo. Indica la versi√≥n m√≠nima del `Swift Package Manager` requerida para interpretar correctamente la sintaxis y las capacidades usadas en el paquete.
    - **`import PackageDescription`**
        Importa la API necesaria para construir la definici√≥n del paquete. Es obligatorio para usar `Package`, `Target`, `Product`, etc.
    - **`name`**:
        Define el nombre del paquete. Tambi√©n ser√° el nombre de la carpeta ra√≠z del proyecto.
    - **`products`**:
        Declara los artefactos que este paquete expone p√∫blicamente.
        En este caso:
        - Un ejecutable llamado **`App`**, construido a partir del target `App`.
        - Una biblioteca llamada **`Lib`**, expuesta a partir del target `Lib`.
    - **`targets`**:
        Representan las unidades internas que SwiftPM compila.
        - `.target(name: "Lib")`: Un m√≥dulo de biblioteca con c√≥digo reutilizable.
        - `.executableTarget(name: "App", dependencies: ["Lib"])`: Un ejecutable que **importa** y **usa** la biblioteca `Lib`.
        - `.testTarget(name: "LibTests", dependencies: ["Lib"])`: Un conjunto de pruebas unitarias que tambi√©n depende de `Lib`, permitiendo testearla de forma aislada.

    Esta estructura modular facilita la separaci√≥n de responsabilidades entre componentes del sistema, como:

    - **`Lib`** ‚Üí l√≥gica reutilizable
    - **`App`** ‚Üí entrada principal de la aplicaci√≥n
    - **`LibTests`** ‚Üí validaci√≥n de la biblioteca
</Explanation>

## üß± Estructura de un proyecto multi-m√≥dulo en Swift

Al igual que en Gradle, **Swift Package Manager (SwiftPM)** permite organizar el proyecto en m√∫ltiples **m√≥dulos reutilizables**, llamados *targets*.  
Esta organizaci√≥n mejora la mantenibilidad, facilita el desarrollo modular y permite escalar el c√≥digo sin perder claridad.

En SwiftPM, la estructura de carpetas **no es arbitraria**: debe seguir convenciones estrictas para que los targets funcionen correctamente.  
Un proyecto b√°sico multi-m√≥dulo puede organizarse as√≠:

```mermaid
graph LR
    subgraph echo-app-swift [üìÅ echo-app-swift]
        Package["üìÑ Package.swift"]

        subgraph sources [üìÅ Sources]
            subgraph App [üìÅ App]
                Main["üìÑ main.swift"]
            end
            subgraph Lib [üìÅ Lib]
                Echo["üìÑ Echo.swift"]
            end
        end

        subgraph tests [üìÅ Tests]
            subgraph LibTests [üìÅ LibTests]
                EchoTests["üìÑ EchoTests.swift"]
            end
        end
    end

    Package --> sources
    Package --> tests

    App --> Lib
    LibTests --> Lib
```

:::info Descripci√≥n de la estructura del proyecto

- **`Package.swift`**: Archivo central de configuraci√≥n. Define los m√≥dulos (*targets*) y productos del proyecto.
- **`Sources/App/`**: Contiene el c√≥digo del ejecutable principal (`App`). El archivo `main.swift` es el punto de entrada del programa.
- **`Sources/Lib/`**: Contiene el c√≥digo de una biblioteca reutilizable. Puede ser usada por otros targets, como `App` o `LibTests`.
- **`Tests/LibTests/`**: Contiene las pruebas del m√≥dulo `Lib`.  
  SwiftPM busca autom√°ticamente archivos de test en carpetas llamadas `Tests/<TargetName>Tests`.

üìå Los nombres de las carpetas dentro de `Sources/` y `Tests/` **deben coincidir exactamente** con los nombres de los targets declarados en `Package.swift`.

:::

:::tip ¬øY el `main.swift` anterior?

Si creaste un archivo `Sources/main.swift` antes de definir m√≥dulos, puedes eliminarlo.  
Ahora que el ejecutable se llama `App`, su punto de entrada debe estar en `Sources/App/main.swift`.

:::

## üéØ Conclusiones

En esta lecci√≥n aprendiste c√≥mo estructurar un proyecto Swift utilizando m√∫ltiples m√≥dulos (*targets*) con Swift Package Manager (SwiftPM), siguiendo principios similares a los vistos en Gradle.

Esta organizaci√≥n es clave para proyectos **escalables, reutilizables y mantenibles**, especialmente cuando desarrollas bibliotecas de software que deben estar bien separadas de las aplicaciones que las consumen.

### üîë Puntos clave

- **SwiftPM organiza el proyecto a trav√©s de `Package.swift`**, donde defines productos (`library`, `executable`) y m√≥dulos (`target`, `testTarget`).
- **Cada target representa un m√≥dulo de c√≥digo** que puede compilarse, testearse e integrarse de manera independiente.
- **Las dependencias entre m√≥dulos se declaran expl√≠citamente**, por ejemplo, haciendo que el ejecutable `App` dependa de la biblioteca `Lib`.
- **La estructura de carpetas sigue convenciones estrictas**, como `Sources/` y `Tests/`, lo cual mejora la claridad y la interoperabilidad del proyecto.

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° de los detalles sint√°cticos y t√©cnicos, esta lecci√≥n te da una herramienta conceptual poderosa: **la modularidad como principio de dise√±o**.

Aprender a organizar un proyecto en m√∫ltiples m√≥dulos no es solo una cuesti√≥n de estilo o limpieza, sino una decisi√≥n estrat√©gica que facilita el crecimiento, la prueba, la colaboraci√≥n y la reutilizaci√≥n del c√≥digo. SwiftPM, con su enfoque expl√≠cito y su estructura basada en convenciones, nos obliga a pensar de forma clara en **qu√© hace cada parte del sistema y c√≥mo se relaciona con las dem√°s**.

Al aplicar esta estructura desde los primeros pasos de tu proyecto, te est√°s preparando no solo para escribir buen c√≥digo hoy, sino para mantenerlo y escalarlo ma√±ana.

## üìñ Referencias

### üî• Recomendadas

- üåê Apple Inc. (s.¬†f.). Package Manager. Swift.Org. Recuperado 4 de abril de 2025, de https://www.swift.org/documentation/package-manager/

{/* ### üîπ Adicionales */}
