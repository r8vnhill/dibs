---
title: Estructurando Proyectos Multi-M√≥dulo con PDM
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import AnimatedCodeExample from '@site/src/components/animations/AnimatedCode'

<ReadingTime />

## üèóÔ∏è Estructura esperada del proyecto

Vamos a crear un proyecto con la siguiente estructura:

```mermaid
graph
    subgraph Root [üìÅ echo-app-pdm/]
        subgraph Lib [üìÅ core/echo_lib]
            direction LR
            I1[__init__.py]
        end
        
        subgraph App [üìÅ app/echo_app]
            direction LR
            I2[__init__.py]
            main.py
        end
        
        PyProject[üìù pyproject.toml]
    end

    main.py -->|depende de| I1
    PyProject -->|define| Lib
    PyProject -->|define| App
```

:::info Explicaci√≥n de la estructura

Este diagrama representa la organizaci√≥n del proyecto con dos m√≥dulos separados (`lib` y `app`), siguiendo un patr√≥n com√∫n en el desarrollo de bibliotecas y aplicaciones:

- **`lib/echo_lib/`** contiene la l√≥gica reutilizable, que en este caso est√° en `echo.py`. Es nuestro m√≥dulo de biblioteca.
- **`app/echo_app/`** contiene el punto de entrada principal de la aplicaci√≥n, `main.py`, que **depende** del m√≥dulo `lib`.
- **`pyproject.toml`** es el archivo central de configuraci√≥n del proyecto. Define metadatos, dependencias, scripts y cualquier otro aspecto relacionado con la construcci√≥n del proyecto.
- La flecha `main.py --> echo.py` indica que el c√≥digo de la app **importa** o **usa** funciones o clases definidas en la biblioteca.
- Las flechas desde `pyproject.toml` muestran que este archivo **define y configura** ambos m√≥dulos dentro del mismo proyecto PDM.

Este dise√±o facilita la separaci√≥n de responsabilidades: puedes desarrollar, probar y documentar la l√≥gica de `lib` por separado, mientras que `app` act√∫a como consumidor de esa l√≥gica, permitiendo una evoluci√≥n m√°s limpia del proyecto.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        'core\echo_core', 'app\echo_app' | ForEach-Object {
            $dir = $_
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
            New-Item -ItemType File -Path "$dir\__init__.py" -Force | Out-Null

            if ($dir -eq 'app\echo_app') {
                New-Item -ItemType File -Path "$dir\main.py" -Force | Out-Null
            }
        }
        ```

        <Explanation>
            Este bloque de PowerShell crea dos m√≥dulos separados dentro del proyecto:

            - `core\echo_core`: representa el m√≥dulo reutilizable de la biblioteca.
            - `app\echo_app`: representa la aplicaci√≥n que depende de `core`.

            Para cada m√≥dulo se crean:
            - La carpeta correspondiente (si no existe).
            - Un archivo `__init__.py` que marca el directorio como paquete de Python.

            Adem√°s, si el m√≥dulo es `app\echo_app`, tambi√©n se crea un archivo `main.py` vac√≠o, que actuar√° como punto de entrada de la aplicaci√≥n.

            El operador `| Out-Null` se utiliza para **suprimir la salida que normalmente mostrar√≠an los comandos `New-Item`**. Esto hace que el script se ejecute de forma silenciosa, sin imprimir mensajes innecesarios en la consola, lo cual es √∫til para mantener el entorno limpio especialmente al automatizar la creaci√≥n de estructura de carpetas.
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell
        'core\echo_core', 'app\echo_app' | % {
            md $_ -f >$null
            ni "$_\__init__.py" -f >$null
            if ($_ -eq 'app\echo_app') {
                ni "$_\main.py" -f >$null
            }
        }
        ```

        <Explanation>
            Este bloque de PowerShell inicializa la estructura del proyecto:

            - Crea dos directorios: `core\echo_core` y `app\echo_app`.
            - En cada uno, agrega un archivo `__init__.py` para marcarlo como paquete de Python.
            - En el m√≥dulo `app\echo_app`, tambi√©n crea un archivo `main.py` como punto de entrada para la aplicaci√≥n.

            El uso de alias (`md` para `New-Item -ItemType Directory` y `ni` para `New-Item`) y la redirecci√≥n de salida a `$null` permite que el comando sea breve y silencioso.
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        for dir in core/echo_core app/echo_app; do
            mkdir -p "$dir"
            : > "$dir/__init__.py"
            if [[ "$dir" == "app/echo_app" ]]; then
                : > "$dir/main.py"
            fi
        done
        ```

        <Explanation>
            {/* ¬øQu√© acabamos de hacer? */}
        </Explanation>
    </TabItem>
</BoxedTabs>

Luego crea un archivo de entrada para la app:

```bash
touch app/echo_app/main.py
```

## üß† Paso 2: Implementar una funci√≥n en lib

Edita `lib/echo_lib/__init__.py` y agrega una funci√≥n reutilizable:

```python
def shout(message: str) -> str:
    return message.upper() + "!!"
```

## üöÄ Paso 3: Consumir lib desde app

Edita `app/echo_app/main.py` con el siguiente contenido:

```python
from lib.echo_lib import shout

def main():
    print(shout("lib and app are working"))

if __name__ == "__main__":
    main()
```

## üîç Paso 4: Asegurar que lib est√© en el path

Para que Python pueda encontrar el m√≥dulo `lib`, debes agregarlo al `PYTHONPATH` cuando ejecutes tu script:

```bash
PYTHONPATH=./ app/echo_app/main.py
```

Pero si est√°s usando PDM, es mejor definirlo como script en `pyproject.toml`:

```toml
[tool.pdm.scripts]
run-app = { cmd = "python app/echo_app/main.py", env = { PYTHONPATH = "." } }
```

Ahora puedes ejecutar:

```bash
pdm run run-app
```

Y deber√≠as ver:

```text
LIB AND APP ARE WORKING!!
```

<Explanation>
  La variable de entorno `PYTHONPATH` le indica a Python d√≥nde buscar m√≥dulos al hacer imports.  
  En este caso, apuntamos a la ra√≠z del proyecto (`.`) para que Python pueda resolver correctamente `lib.echo_lib`.
</Explanation>

## üîÅ Alternativa: mover lib a `src/lib` (opcional)

Si prefieres seguir el patr√≥n `src/`, puedes mover `lib/` a `src/lib/` y ajustar `PYTHONPATH=./src` en el script.  
Ambos enfoques son v√°lidos; lo importante es que haya una **separaci√≥n clara entre la l√≥gica de biblioteca y la l√≥gica de aplicaci√≥n**.

## üß™ Verificar

Tambi√©n puedes probar manualmente desde la consola:

```bash
PYTHONPATH=. python app/echo_app/main.py
```

O ejecutar desde PDM:

```bash
pdm run run-app
```

Ambos comandos deber√≠an ejecutar correctamente la aplicaci√≥n y mostrar el resultado del uso de `lib`.

## üéØ Conclusiones

Separar `lib` y `app` desde el comienzo mejora la **organizaci√≥n**, **reutilizaci√≥n** y **mantenibilidad** de tu proyecto.

### üîë Puntos clave

- `lib` contiene l√≥gica gen√©rica reutilizable.
- `app` act√∫a como cliente de `lib`.
- Con `PYTHONPATH=.` se permite importar m√≥dulos entre carpetas sin empaquetar a√∫n.
- PDM permite definir scripts reutilizables para facilitar la ejecuci√≥n.

En pr√≥ximas lecciones podr√°s convertir `lib` en un **paquete instalable** e incluso publicarlo, si lo deseas.

## üìñ Referencias

- [Import system ‚Äî Python Docs](https://docs.python.org/3/reference/import.html)
- [PDM - Defining scripts](https://pdm-project.org/latest/usage/scripts/)
