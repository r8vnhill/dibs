---
title: Estructurando Proyectos Multi-M√≥dulo con PDM
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />

## üèóÔ∏è Estructura esperada del proyecto

Vamos a crear un proyecto con la siguiente estructura:

```mermaid
graph
    subgraph Root [üìÅ echo-app-pdm/]
        subgraph Lib [üìÅ core/echo_lib]
            direction LR
            I1[__init__.py]
        end
        
        subgraph App [üìÅ app/echo_app]
            direction LR
            I2[__init__.py]
            main.py
        end
        
        PyProject[üìù pyproject.toml]
    end

    main.py -->|depende de| I1
    PyProject -->|define| Lib
    PyProject -->|define| App
```

:::info Explicaci√≥n de la estructura

Este diagrama representa la organizaci√≥n del proyecto con dos m√≥dulos separados (`lib` y `app`), siguiendo un patr√≥n com√∫n en el desarrollo de bibliotecas y aplicaciones:

- **`lib/echo_lib/`** contiene la l√≥gica reutilizable, que en este caso est√° en `echo.py`. Es nuestro m√≥dulo de biblioteca.
- **`app/echo_app/`** contiene el punto de entrada principal de la aplicaci√≥n, `main.py`, que **depende** del m√≥dulo `lib`.
- **`pyproject.toml`** es el archivo central de configuraci√≥n del proyecto. Define metadatos, dependencias, scripts y cualquier otro aspecto relacionado con la construcci√≥n del proyecto.
- La flecha `main.py --> echo.py` indica que el c√≥digo de la app **importa** o **usa** funciones o clases definidas en la biblioteca.
- Las flechas desde `pyproject.toml` muestran que este archivo **define y configura** ambos m√≥dulos dentro del mismo proyecto PDM.

Este dise√±o facilita la separaci√≥n de responsabilidades: puedes desarrollar, probar y documentar la l√≥gica de `lib` por separado, mientras que `app` act√∫a como consumidor de esa l√≥gica, permitiendo una evoluci√≥n m√°s limpia del proyecto.

:::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell title="En PowerShell"
        'core\echo_core', 'app\echo_app' | ForEach-Object {
            $dir = $_
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
            New-Item -ItemType File -Path "$dir\__init__.py" -Force | Out-Null

            if ($dir -eq 'app\echo_app') {
                New-Item -ItemType File -Path "$dir\main.py" -Force | Out-Null
            }
        }
        ```

        <Explanation>
            Este bloque de PowerShell crea dos m√≥dulos separados dentro del proyecto:

            - `core\echo_core`: representa el m√≥dulo reutilizable de la biblioteca.
            - `app\echo_app`: representa la aplicaci√≥n que depende de `core`.

            Para cada m√≥dulo se crean:
            - La carpeta correspondiente (si no existe).
            - Un archivo `__init__.py` que marca el directorio como paquete de Python.

            Adem√°s, si el m√≥dulo es `app\echo_app`, tambi√©n se crea un archivo `main.py` vac√≠o, que actuar√° como punto de entrada de la aplicaci√≥n.

            El operador `| Out-Null` se utiliza para **suprimir la salida que normalmente mostrar√≠an los comandos `New-Item`**. Esto hace que el script se ejecute de forma silenciosa, sin imprimir mensajes innecesarios en la consola, lo cual es √∫til para mantener el entorno limpio especialmente al automatizar la creaci√≥n de estructura de carpetas.
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell title="En PowerShell"
        'core\echo_core', 'app\echo_app' | % {
            md $_ -f >$null
            ni "$_\__init__.py" -f >$null
            if ($_ -eq 'app\echo_app') {
                ni "$_\main.py" -f >$null
            }
        }
        ```

        <Explanation>
            Este bloque de PowerShell inicializa la estructura del proyecto:

            - Crea dos directorios: `core\echo_core` y `app\echo_app`.
            - En cada uno, agrega un archivo `__init__.py` para marcarlo como paquete de Python.
            - En el m√≥dulo `app\echo_app`, tambi√©n crea un archivo `main.py` como punto de entrada para la aplicaci√≥n.

            El uso de alias (`md` para `New-Item -ItemType Directory` y `ni` para `New-Item`) y la redirecci√≥n de salida a `$null` permite que el comando sea breve y silencioso.
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash title="En tu terminal"
        for dir in core/echo_core app/echo_app; do
            mkdir -p "$dir"
            : > "$dir/__init__.py"
            if [[ "$dir" == "app/echo_app" ]]; then
                : > "$dir/main.py"
            fi
        done
        ```

        <Explanation>
            Este bloque de Bash crea la estructura inicial de un proyecto Python con dos m√≥dulos separados:

            - `core/echo_core`: contiene la l√≥gica reutilizable de la biblioteca.
            - `app/echo_app`: contiene la aplicaci√≥n que consume esa l√≥gica.

            Para cada m√≥dulo se realizan dos acciones:
            - Se crea el directorio si no existe (`mkdir -p`).
            - Se crea un archivo `__init__.py`, necesario para que Python reconozca la carpeta como un paquete.

            Adem√°s, si el m√≥dulo es `app/echo_app`, se crea un archivo `main.py` vac√≠o, que actuar√° como punto de entrada de la aplicaci√≥n.

            La instrucci√≥n `: > archivo` es una forma idiom√°tica y muy eficiente en Bash para **crear un archivo vac√≠o** (o vaciarlo si ya existe), sin depender de `touch`. Es especialmente √∫til para scripts automatizados y portables.
        </Explanation>
    </TabItem>
</BoxedTabs>

## üß† Paso 2: Implementar una funci√≥n en core

Edita `core/echo_core/__init__.py` y agrega una funci√≥n reutilizable:

Una buena sugerencia para ese bloque ser√≠a:

```python showLineNumbers title="Funci√≥n de eco definida en el m√≥dulo core (core/echo_core/__init__.py)"
def echo(message: str) -> str:
    return message
``` 

Este t√≠tulo indica claramente la ubicaci√≥n del archivo y refuerza que se est√° trabajando dentro del m√≥dulo `core`. ¬øQuieres que siga ese formato para los dem√°s bloques tambi√©n (`app/echo_app/main.py`, por ejemplo)?

Luego, modifica el archivo `pyproject.toml` para declarar el m√≥dulo `core/echo_core` como un paquete editable dentro del proyecto.  
Agrega esta secci√≥n al final del archivo:

```toml showLineNumbers title="Declaraci√≥n del m√≥dulo core como dependencia editable (pyproject.toml)"
[tool.pdm.dev-dependencies]
core = { path = "core", develop = true }
```

Y ejecuta en terminal:

```bash title="En tu terminal"
pdm install
```

<Explanation>
    Esta funci√≥n `echo` recibe un mensaje como argumento y simplemente lo devuelve sin modificarlo.  
    Aunque su implementaci√≥n es trivial, cumple un prop√≥sito importante: act√∫a como **punto de partida** para probar que la biblioteca `core` puede ser importada y utilizada correctamente desde el m√≥dulo `app`.

    Adem√°s, al declarar `core` como un paquete editable en `pyproject.toml`, permitimos que su c√≥digo pueda ser importado directamente desde el entorno gestionado por PDM, sin necesidad de modificar rutas manualmente.  
    Esto facilita el desarrollo iterativo y la separaci√≥n clara entre l√≥gica de biblioteca (`core`) y l√≥gica de aplicaci√≥n (`app`).
</Explanation>

## üß™ Paso 3: Usar la funci√≥n del m√≥dulo core desde app

Edita `app/echo_app/main.py` y escribe un peque√±o script que utilice la funci√≥n `echo` definida en el m√≥dulo `core`.

```python showLineNumbers title="Uso de la funci√≥n echo desde app (app/echo_app/main.py)"
from echo_core import echo

def main():
    message = "¬°Hola desde app usando core!"
    print(echo(message))

if __name__ == "__main__":
    main()
```

<Explanation>
    Este archivo `main.py` define una funci√≥n principal que importa la funci√≥n `echo` desde el paquete `core`, la invoca con un mensaje de prueba y muestra el resultado por consola.

    Este paso valida que:
    - La estructura multi-m√≥dulo funciona correctamente.
    - `core` fue registrado como paquete editable en el entorno de PDM.
    - Puedes desarrollar y ejecutar la app sin modificar manualmente variables de entorno como `PYTHONPATH`.

    Adem√°s, el uso del patr√≥n `if __name__ == "__main__"` asegura que el c√≥digo solo se ejecute cuando `main.py` sea ejecutado directamente, no al ser importado desde otro m√≥dulo.
</Explanation>

### ‚ñ∂Ô∏è Ejecutar el programa

Puedes ejecutar el m√≥dulo directamente desde terminal usando:

```bash title="En tu terminal"
pdm run python app/echo_app/main.py
```

<Explanation>
    El comando `pdm run` asegura que el script se ejecute dentro del entorno virtual gestionado por PDM, respetando la configuraci√≥n del proyecto.

    Si todo est√° bien configurado, deber√≠as ver en consola:

    ```text
    ¬°Hola desde app usando core!
    ```
</Explanation>

## üöÄ Paso 3: Consumir lib desde app

Edita `app/echo_app/main.py` con el siguiente contenido:

```python
from lib.echo_lib import shout

def main():
    print(shout("lib and app are working"))

if __name__ == "__main__":
    main()
```

## üîç Paso 4: Asegurar que lib est√© en el path

Para que Python pueda encontrar el m√≥dulo `lib`, debes agregarlo al `PYTHONPATH` cuando ejecutes tu script:

```bash
PYTHONPATH=./ app/echo_app/main.py
```

Pero si est√°s usando PDM, es mejor definirlo como script en `pyproject.toml`:

```toml
[tool.pdm.scripts]
run-app = { cmd = "python app/echo_app/main.py", env = { PYTHONPATH = "." } }
```

Ahora puedes ejecutar:

```bash
pdm run run-app
```

Y deber√≠as ver:

```text
LIB AND APP ARE WORKING!!
```

<Explanation>
  La variable de entorno `PYTHONPATH` le indica a Python d√≥nde buscar m√≥dulos al hacer imports.  
  En este caso, apuntamos a la ra√≠z del proyecto (`.`) para que Python pueda resolver correctamente `lib.echo_lib`.
</Explanation>

## üîÅ Alternativa: mover lib a `src/lib` (opcional)

Si prefieres seguir el patr√≥n `src/`, puedes mover `lib/` a `src/lib/` y ajustar `PYTHONPATH=./src` en el script.  
Ambos enfoques son v√°lidos; lo importante es que haya una **separaci√≥n clara entre la l√≥gica de biblioteca y la l√≥gica de aplicaci√≥n**.

## üß™ Verificar

Tambi√©n puedes probar manualmente desde la consola:

```bash
PYTHONPATH=. python app/echo_app/main.py
```

O ejecutar desde PDM:

```bash
pdm run run-app
```

Ambos comandos deber√≠an ejecutar correctamente la aplicaci√≥n y mostrar el resultado del uso de `lib`.

## üéØ Conclusiones

Separar `lib` y `app` desde el comienzo mejora la **organizaci√≥n**, **reutilizaci√≥n** y **mantenibilidad** de tu proyecto.

### üîë Puntos clave

- `lib` contiene l√≥gica gen√©rica reutilizable.
- `app` act√∫a como cliente de `lib`.
- Con `PYTHONPATH=.` se permite importar m√≥dulos entre carpetas sin empaquetar a√∫n.
- PDM permite definir scripts reutilizables para facilitar la ejecuci√≥n.

En pr√≥ximas lecciones podr√°s convertir `lib` en un **paquete instalable** e incluso publicarlo, si lo deseas.

## üìñ Referencias

- [Import system ‚Äî Python Docs](https://docs.python.org/3/reference/import.html)
- [PDM - Defining scripts](https://pdm-project.org/latest/usage/scripts/)
