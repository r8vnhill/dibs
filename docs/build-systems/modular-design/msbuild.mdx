---
title: "Modularizando tu proyecto en C# con MSBuild"
---
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';
import RemoveEchoAppCsprojBashCode from '@site/src/components/mdx/build-systems/modular-design/msbuild/RemoveEchoAppCsprojBashCode';
import RemoveEchoAppCsprojPsCode from '@site/src/components/mdx/build-systems/modular-design/msbuild/RemoveEchoAppCsprojPsCode';
import InitializeCSharpSolutionBashCode from '@site/src/components/mdx/build-systems/modular-design/msbuild/InitializeCSharpSolutionBash';
import InitializeCSharpSolutionPsCode from '@site/src/components/mdx/build-systems/modular-design/msbuild/InitializeCSharpSolutionPsCode';
import Explanation from '@site/src/components/admonitions/Explanation';
import ReadingTime from '@site/src/components/reading-time/ReadingTime';
import GitHubRepo from '@site/src/components/git/GitHubRepo';
import GitLabRepo from '@site/src/components/git/GitLabRepo';
import RepoLinks from '@site/src/components/git/RepoLinks';
import ReferenceList from '@site/src/components/references/ReferenceList';
import WebPage from '@site/src/components/references/WebPage';

<ReadingTime />
<RepoLinks children={[
    <GitLabRepo repo="echo-app-csharp" user="r8vnhill" />,
    <GitHubRepo repo="echo-app-csharp" user="r8vnhill" />
]} />

C# permite organizar proyectos en soluciones modulares, lo que facilita la reutilizaci√≥n de c√≥digo, la separaci√≥n de responsabilidades y el mantenimiento a largo plazo. En lugar de mantener toda la l√≥gica en una √∫nica aplicaci√≥n, es preferible separar funcionalidades en bibliotecas que puedan ser utilizadas desde distintos proyectos.

En esta lecci√≥n, aprender√°s a crear una soluci√≥n en C# con **MSBuild** que contenga dos proyectos:

- Una **biblioteca reutilizable** llamada `EchoLib`.
- Una **aplicaci√≥n de consola** llamada `EchoApp` que utiliza dicha biblioteca.

Usaremos herramientas de l√≠nea de comandos multiplataforma para automatizar la creaci√≥n, referencia y ejecuci√≥n de los proyectos, sentando as√≠ las bases para dise√±ar aplicaciones limpias y modulares en el ecosistema .NET.

## üèóÔ∏è Estructura esperada del proyecto

Esta es la estructura t√≠pica de una soluci√≥n modular en C# utilizando MSBuild. Incluye dos proyectos: una biblioteca reutilizable (`EchoLib`) y una aplicaci√≥n de consola (`EchoApp`) que consume esa biblioteca. Todo est√° organizado bajo una √∫nica soluci√≥n (`.sln`).

```mermaid
graph TD
    subgraph Root [üìÅ EchoAppCSharp]
        direction TB

        Sln[üìÑ EchoAppCsharp.sln]

        subgraph Lib [üìÅ EchoLib]
            direction TB

            LibProject[üìÑ EchoLib.csproj]
            LibCode[üìÑ Echo.cs]
        end

        subgraph App [üìÅ EchoApp]
            direction TB

            AppProject[üìÑ EchoApp.csproj]
            AppCode[üìÑ Program.cs]
        end
    end

    Sln -->|declara| Lib
    Sln -->|declara| App
    AppProject -->|referencia| LibProject
    AppCode -->|utiliza| LibCode
```

:::info Explicaci√≥n de la estructura

- `EchoAppCsharp.sln`: Archivo de soluci√≥n que act√∫a como punto de entrada para abrir toda la estructura del proyecto en Visual Studio o cualquier editor compatible.
- `EchoLib/`: Contiene una biblioteca reutilizable con utilidades (en este caso, la clase `Echo`).
- `EchoApp/`: Contiene la aplicaci√≥n de consola que consume `EchoLib`.
- `EchoApp.csproj` ‚Üí `EchoLib.csproj`: Se establece como una referencia de proyecto, permitiendo reutilizar c√≥digo sin compilar por separado.

:::

:::tip ¬øY el proyecto anterior?

Puedes eliminar el proyecto `EchoAppCSharp` que creamos en la lecci√≥n anterior, ya que ahora vamos a crear una soluci√≥n modular con dos proyectos: una biblioteca y una aplicaci√≥n que la utiliza.

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        <RemoveEchoAppCsprojPsCode />
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <RemoveEchoAppCsprojBashCode title="scripts/macos/remove_echo_app_csproj.sh" />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <RemoveEchoAppCsprojBashCode title="scripts/linux/remove_echo_app_csproj.sh" />
    </TabItem>
</BoxedTabs>

:::

## üõ†Ô∏è Paso 1: Crear soluci√≥n base en C#

En esta secci√≥n automatizaremos la creaci√≥n de una soluci√≥n C# que contiene dos proyectos: una biblioteca (`EchoLib`) y una aplicaci√≥n de consola (`EchoApp`) que depende de ella.  
Puedes usar los siguientes scripts seg√∫n tu sistema operativo:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        <InitializeCSharpSolutionPsCode />
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <InitializeCSharpSolutionBashCode title="scripts/macos/initialize_csharp_solution.sh" />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <InitializeCSharpSolutionBashCode title="scripts/linux/initialize_csharp_solution.sh" />
    </TabItem>
</BoxedTabs>

### üß© Entendiendo la soluci√≥n

El archivo de soluci√≥n (`.sln`) de Visual Studio organiza m√∫ltiples proyectos en un mismo entorno de trabajo. En este archivo, se definen los proyectos que componen la soluci√≥n, sus configuraciones de compilaci√≥n y otras propiedades relevantes.

```plaintext showLineNumbers title="EchoAppCsharp.sln"
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
Project("{...}") = "EchoLib", "EchoLib\EchoLib.csproj", "{...}"
EndProject
Project("{...}") = "EchoApp", "EchoApp\EchoApp.csproj", "{...}"
EndProject
Global
    GlobalSection(SolutionConfigurationPlatforms) = preSolution
        Debug|Any CPU = Debug|Any CPU
        Release|Any CPU = Release|Any CPU
    EndGlobalSection
    GlobalSection(ProjectConfigurationPlatforms) = postSolution
        {...}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {...}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {...}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {...}.Release|Any CPU.Build.0 = Release|Any CPU
    EndGlobalSection
    GlobalSection(SolutionProperties) = preSolution
        HideSolutionNode = FALSE
    EndGlobalSection
EndGlobal
```

<Explanation>
    - `Project("{...}") = "Nombre", "Ruta", "{GUID}"`: Define un proyecto incluido en la soluci√≥n, indicando su nombre, ubicaci√≥n y un identificador √∫nico.
    - `SolutionConfigurationPlatforms`: Lista las combinaciones de configuraci√≥n y plataforma disponibles (como `Debug|Any CPU`).
    - `ProjectConfigurationPlatforms`: Establece c√≥mo debe compilarse cada proyecto bajo cada configuraci√≥n definida globalmente.
    - `SolutionProperties`: Define propiedades generales de la soluci√≥n, como si se debe ocultar el nodo ra√≠z en el explorador de soluciones de Visual Studio.
</Explanation>

### üß± Entendiendo los proyectos

Cada proyecto en una soluci√≥n de .NET est√° definido por un archivo `.csproj` en formato XML. Este archivo contiene metadatos y configuraciones necesarias para compilar, empaquetar y ejecutar el proyecto. A continuaci√≥n, se muestra c√≥mo est√°n definidos los dos proyectos de esta soluci√≥n: una biblioteca (`EchoLib`) y una aplicaci√≥n de consola (`EchoApp`).

```xml showLineNumbers title="EchoLib\EchoLib.csproj"
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>
```

Este archivo define un proyecto de biblioteca de clases:
- `TargetFramework`: Especifica que el proyecto se compila para .NET 9.
- `ImplicitUsings`: Habilita la inclusi√≥n autom√°tica de espacios de nombres comunes.
- `Nullable`: Activa las anotaciones y advertencias para referencias anulables.

```xml showLineNumbers title="EchoApp\EchoApp.csproj"
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\EchoLib\EchoLib.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>
```

Este archivo describe una aplicaci√≥n de consola que referencia la biblioteca `EchoLib`:
- `ProjectReference`: Establece una dependencia directa a otro proyecto del mismo repositorio, lo que permite reutilizar su c√≥digo sin necesidad de compilarlo por separado.
- `OutputType`: Indica que este proyecto genera un ejecutable.
- Las dem√°s propiedades son similares a las de la biblioteca.

## üîÅ Paso 2: Crear una biblioteca reutilizable

Creamos una clase est√°tica `Echo` dentro del proyecto `EchoLib`. Esta biblioteca est√° pensada para agrupar utilidades relacionadas con cadenas de texto. Por ahora, define un √∫nico m√©todo `Repeat`, que simplemente retorna la cadena entregada como entrada.

```csharp showLineNumbers title="EchoLib/Echo.cs"
namespace EchoLib;

public static class Echo {
    public static string Repeat(string input) => input;
}
```

<Explanation>
    - `namespace EchoLib;`: Define el espacio de nombres de la biblioteca. Agrupar tipos bajo un mismo namespace ayuda a mantener el c√≥digo organizado y evita conflictos.
    - `public static class Echo`: Se declara como est√°tica porque la clase no necesita ser instanciada y solo contiene utilidades.
    - `Repeat(string input)`: Por ahora, este m√©todo simplemente devuelve el valor original.
</Explanation>

## üß™ Paso 3: Ejecutar con argumentos

Este programa toma argumentos desde la l√≠nea de comandos, repite cada uno usando la funci√≥n `Echo.Repeat`, y los imprime en pantalla. Es una forma simple de probar la conexi√≥n entre el proyecto de consola y la biblioteca.

```csharp showLineNumbers title="EchoApp/Program.cs"
using EchoLib;

namespace EchoApp;

internal static class Program {
    private static void Main(string[] args) {
        foreach (var arg in args) Console.WriteLine(Echo.Repeat(arg));
    }
}
```

<Explanation>
    - `args`: arreglo de cadenas que contiene los argumentos recibidos al ejecutar el programa.
    - `Echo.Repeat(arg)`: utiliza la funci√≥n de la biblioteca para procesar cada argumento.
    - `foreach`: itera sobre cada argumento y lo imprime por separado.
</Explanation>

### üöÄ Ejecutar la aplicaci√≥n

Para ejecutar la aplicaci√≥n, utiliza el siguiente comando en la terminal:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="En PowerShell"
        dotnet run --project EchoApp -- `
            "Is this the end of the beginning", `
            "or the beginning of the end?"
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        ```bash showLineNumbers title="En la terminal"
        dotnet run --project EchoApp -- \
            "Is this the end of the beginning" \
            "or the beginning of the end?"
        ```
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        ```bash showLineNumbers title="En la terminal"
        dotnet run --project EchoApp -- \
            "Is this the end of the beginning" \
            "or the beginning of the end?"
        ```
    </TabItem>
</BoxedTabs>

Esto imprimir√°:

```plaintext
Is this the end of the beginning
or the beginning of the end?
```

<Explanation>
    - `dotnet run --project EchoApp --`: Ejecuta el proyecto `EchoApp`, pasando los argumentos despu√©s del `--`.
    - Las barras invertidas (`\`) o backticks (`` ` ``) permiten dividir argumentos en varias l√≠neas, seg√∫n el sistema operativo.
</Explanation>

## üéØ Conclusiones

En esta lecci√≥n construimos una soluci√≥n C# modular compuesta por una biblioteca reutilizable y una aplicaci√≥n de consola. Aprendimos a usar `dotnet` para crear, organizar y vincular proyectos dentro de una misma soluci√≥n, y entendimos c√≥mo aprovechar los archivos `.sln` y `.csproj` para configurar cada componente. Esta estructura no solo mejora la organizaci√≥n del c√≥digo, sino que tambi√©n facilita su mantenimiento y evoluci√≥n.

### üîë Puntos clave

- Las soluciones (`.sln`) permiten agrupar m√∫ltiples proyectos de forma coherente.
- Las bibliotecas (`classlib`) son ideales para encapsular l√≥gica reutilizable.
- Las referencias de proyecto (`ProjectReference`) eliminan la necesidad de compilar y distribuir dependencias por separado.
- Ejecutar aplicaciones con argumentos permite probar funcionalidades directamente desde la l√≠nea de comandos.

### üß∞ ¬øQu√© nos llevamos?

Dividir tu proyecto en m√≥dulos desde el inicio promueve buenas pr√°cticas como la separaci√≥n de responsabilidades, la reutilizaci√≥n de c√≥digo y la mantenibilidad a largo plazo. Esta estructura es especialmente √∫til cuando tu c√≥digo crece o cuando quieres compartir bibliotecas entre diferentes aplicaciones. En lugar de tener una gran aplicaci√≥n monol√≠tica, pensar en t√©rminos de bibliotecas te permite dise√±ar sistemas m√°s limpios, extensibles y testeables.

Esta lecci√≥n sienta las bases para continuar explorando herramientas del ecosistema .NET como pruebas automatizadas, empaquetado de bibliotecas y publicaci√≥n en NuGet.

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
    <WebPage 
        title=<code>dotnet sln</code>
        url="https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-sln"
        location="Microsoft Learn"
    >
        Este recurso documenta el comando <code>dotnet sln</code>, que permite crear, listar, agregar, eliminar y migrar proyectos dentro de archivos de soluci√≥n (<code>.sln</code> o <code>.slnx</code>) en proyectos .NET. Explica c√≥mo generar una soluci√≥n con <code>dotnet new sln</code>, c√≥mo organizar proyectos mediante carpetas virtuales con <code>--solution-folder</code>, y c√≥mo utilizar patrones (<code>globbing</code>) para agregar o quitar m√∫ltiples proyectos a la vez. Tambi√©n cubre la conversi√≥n de <code>.sln</code> a <code>.slnx</code> y proporciona ejemplos pr√°cticos multiplataforma para automatizar la organizaci√≥n modular de soluciones.
    </WebPage>
]}  />
