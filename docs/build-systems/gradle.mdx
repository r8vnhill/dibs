---
title: Build Systems
---

import ReadingTime from '../../src/components/ReadingTime';
import Definition from '../../src/components/Definition';

<ReadingTime/>

### Creando un Proyecto Básico con Gradle

Para empezar a trabajar con **Gradle**, lo primero que necesitas es crear un proyecto. A continuación te mostramos los pasos básicos para configurar un nuevo proyecto utilizando Gradle. En este ejemplo, configuraremos un proyecto utilizando el DSL de Kotlin para la definición de scripts.

#### Paso 1: Crear el Directorio del Proyecto

Comienza creando un nuevo directorio para tu proyecto y luego accede a él:

```bash
mkdir gradle-basics
cd gradle-basics || exit
```

#### Paso 2: Inicializar el Proyecto con Gradle

Utiliza el comando `gradle init` para inicializar la estructura del proyecto. Este comando te guiará a través de algunas opciones básicas para configurar tu proyecto. A medida que sigas las indicaciones, verás varias opciones para seleccionar el tipo de proyecto que deseas crear:

```bash
gradle init
```

#### Paso 3: Selección de Opciones de Inicialización

A continuación, Gradle te pedirá que elijas el tipo de proyecto que quieres generar. Para este ejemplo, seleccionaremos la opción **Basic (build structure only)**, que genera la estructura básica de un proyecto sin ninguna lógica de aplicación específica.

```text
Select type of build to generate:
  1: Application
  2: Library
  3: Gradle plugin
  # highlight-next-line
  4: Basic (build structure only)
Enter selection (default: Application) [1..4]
> 4
```

#### Paso 4: Nombre del Proyecto

Gradle te pedirá un nombre para el proyecto. Puedes presionar Enter para usar el nombre por defecto, que será el nombre de la carpeta en la que te encuentras (en este caso, `gradle-basics`):

```text
Project name (default: gradle-basics):
```

#### Paso 5: Selección del Script DSL

El siguiente paso es elegir el lenguaje de script que quieres usar para los archivos de configuración de Gradle. En este curso, utilizaremos **Kotlin**, así que selecciona la opción 1:

```text
Select build script DSL:
  # highlight-next-line
  1: Kotlin
  2: Groovy
Enter selection (default: Kotlin) [1..2]
> 1
```

#### Paso 6: APIs y Comportamientos Nuevos

Gradle puede preguntarte si quieres generar el proyecto utilizando nuevas APIs y comportamientos que podrían cambiar en próximas versiones. Para mayor estabilidad, selecciona **no** (esto es recomendado si prefieres usar APIs más estables):

```
Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no]
> no
```

#### Estructura del Proyecto Generado

Una vez que completes los pasos anteriores, Gradle generará una estructura básica de proyecto como la siguiente:

```text title="./gradle-basics/"
├── .gitattributes
├── .gitignore
├── build.gradle.kts        # Archivo de configuración de Gradle en Kotlin DSL
├── gradlew                 # Wrapper de Gradle (ejecutable en Unix)
├── gradlew.bat             # Wrapper de Gradle (ejecutable en Windows)
├── settings.gradle.kts     # Archivo de configuración de ajustes del proyecto
├── .gradle                 # Carpeta con archivos temporales de Gradle
└── gradle
    ├── libs.versions.toml      # Archivo de versiones de dependencias
    └── wrapper
        ├── gradle-wrapper.jar          # Archivo jar del wrapper de Gradle
        └── gradle-wrapper.properties   # Archivo de propiedades del wrapper
```

#### Explicación de los Archivos Generados

- **`build.gradle.kts`**: Es el archivo principal donde configurarás las dependencias, tareas y plugins de tu proyecto usando Kotlin DSL.
- **`gradlew` y `gradlew.bat`**: Son los archivos ejecutables del wrapper de Gradle. Estos permiten ejecutar Gradle sin necesidad de que esté instalado globalmente en el sistema. Es recomendable usar el wrapper en lugar de la instalación global de Gradle para garantizar que todxs lxs desarrolladorxs usen la misma versión.
- **`settings.gradle.kts`**: Archivo de configuración de ajustes del proyecto. Aquí puedes definir el nombre del proyecto y otros módulos si tu proyecto tiene múltiples subproyectos.
- **`gradle-wrapper.jar`** y **`gradle-wrapper.properties`**: Archivos generados por el wrapper de Gradle. Aseguran que todos los desarrolladores usen la misma versión de Gradle en el proyecto.

:::info
Puedes actualizar la versión del wrapper de Gradle que está en el archivo de propiedades (`gradle-wrapper.properties`) con el comando:

```text
./gradlew wrapper --gradle-version=latest # Actualiza a la última versión de Gradle
./gradlew wrapper --gradle-version=8.9.0  # Actualiza a una versión específica de Gradle
```
:::

#### Ejecutando Tareas en Gradle

Una vez que el proyecto está configurado, puedes ejecutar comandos básicos de Gradle, como por ejemplo:

```bash
./gradlew build     # Compila el proyecto
./gradlew tasks     # Muestra todas las tareas disponibles
```

Este flujo de trabajo te proporciona una base sólida para empezar a trabajar con Gradle en tus proyectos Kotlin, permitiéndote manejar dependencias, automatizar tareas y compilar tu código de manera eficiente.

### `settings.gradle.kts`

El archivo `settings.gradle.kts` es esencial para configurar y gestionar los ajustes globales de un proyecto **Gradle**,
permitiendo definir aspectos como el nombre del proyecto y su estructura de módulos. Este archivo se evalúa al comienzo de la ejecución de Gradle, estableciendo el entorno para el resto del proceso de construcción.

#### Propósito Principal

1. **Definir el nombre del proyecto**: Esto es especialmente útil cuando el nombre de la carpeta del proyecto no coincide con el nombre deseado del proyecto en Gradle.
2. **Configurar proyectos multi-módulo**: Para proyectos más complejos, puedes declarar varios módulos o subproyectos en este archivo, permitiendo que Gradle gestione todos los componentes de manera centralizada.

En el caso de nuestro proyecto comenzaríamos con un archivo `settings.gradle.kts` simple como este:

```kotlin title="settings.gradle.kts"
rootProject.name = "gradle-basics"
```

#### Proyectos Multi-Módulo

En proyectos grandes, gestionar todo en un único módulo puede volverse ineficiente y difícil de mantener. Esto es especialmente relevante cuando trabajamos en **bibliotecas de software**, donde lxs usuarixs podrían necesitar solo una parte específica de la funcionalidad ofrecida por nuestra biblioteca.

Para resolver este problema, la mayoría de los sistemas de construcción (build systems) permiten crear **proyectos multi-módulo**. Un proyecto multi-módulo divide el código en componentes más pequeños y manejables, lo que facilita la reutilización y mejora la modularidad. Además, permite que diferentes partes del proyecto se desarrollen y se mantengan de manera independiente.

Aunque en este curso las tareas serán lo suficientemente sencillas como para no necesitar múltiples módulos, utilizaremos una estructura multi-módulo para **practicar** y familiarizarnos con este patrón común en la creación de bibliotecas.

##### Definir un Proyecto Multi-Módulo

A continuación, te mostramos cómo configurar un proyecto Gradle multi-módulo en el archivo `settings.gradle.kts`. Este archivo define el nombre del proyecto raíz y los módulos que lo componen:

```kotlin title="settings.gradle.kts"
rootProject.name = "gradle-basics"

include(
    ":app",
    ":lib"
)
```

En este ejemplo, hemos definido dos módulos:
- **`app`**: Actúa como el módulo de la aplicación principal.
- **`lib`**: Es el módulo donde colocaremos la funcionalidad que queremos reutilizar, como nuestras bibliotecas de software.

#### ¿Por qué usar Proyectos Multi-Módulo?

1. **Modularidad**: Cada módulo puede contener una parte específica de la funcionalidad, lo que facilita el desarrollo independiente de cada uno.
2. **Reutilización**: Los módulos se pueden compartir entre diferentes proyectos. Por ejemplo, puedes reutilizar el módulo `lib` en otros proyectos sin necesidad de copiar el código.
3. **Mantenimiento**: Al dividir el proyecto en módulos, es más fácil detectar y solucionar problemas, ya que el código está mejor organizado.
4. **Optimización**: Gradle solo recompilará los módulos que hayan sido modificados, lo que reduce el tiempo de compilación en proyectos grandes.

#### Aplicación en el Curso

En este curso, aunque los ejemplos serán sencillos, nos enfocaremos principalmente en crear módulos como **`lib`**, ya que el objetivo principal es desarrollar **bibliotecas de software**. Aun así, la estructura multi-módulo te permitirá practicar cómo organizar un proyecto real en el que:
- La biblioteca (módulo `lib`) encapsula las funcionalidades.
- El módulo de aplicación (`app`) consume las bibliotecas desarrolladas.

<Definition title="Dependencias">
    Las **dependencias** son componentes externos o bibliotecas que tu proyecto necesita para compilarse y ejecutarse
    correctamente. Estas dependencias pueden incluir desde bibliotecas de terceros hasta herramientas internas que
    extienden la funcionalidad de tu código. En lugar de manejar manualmente las dependencias y sus versiones, los
    sistemas de construcción modernos automatizan este proceso.
</Definition>

#### Gestión de Dependencias en Sistemas de Construcción

**Gradle**, como muchos otros sistemas de construcción, automatiza la descarga e integración de las dependencias, ya sea desde repositorios remotos como **Maven Central** o **JCenter**, o desde repositorios locales. Sin embargo, Gradle no es el único sistema que ofrece esta funcionalidad. Otros sistemas de construcción que también gestionan dependencias incluyen:
Algunos ejemplos de sistemas de construcción que descargan y gestionan dependencias son: **Maven**, **npm**, **SBT**, **Cargo**.

En las próximas secciones, profundizaremos en cómo agregar y manejar dependencias en Gradle, que es una habilidad
esencial para desarrollar proyectos más complejos.

### `libs.versions.toml`

Aunque no es obligatorio, es una **buena práctica** centralizar las versiones de las dependencias de un proyecto utilizando un archivo `.toml`. Este enfoque garantiza consistencia en las versiones utilizadas en todo el proyecto, evitando problemas de incompatibilidad y facilitando el mantenimiento.

El archivo `libs.versions.toml` se organiza en cuatro secciones principales:

- **Versions**: Especifica las versiones de las dependencias, permitiendo su reutilización en las secciones de bibliotecas y plugins.
- **Libraries**: Define las bibliotecas necesarias para el proyecto, asociándolas con las versiones especificadas en la sección de versiones.
- **Bundles**: Agrupa varias bibliotecas bajo un mismo nombre, facilitando la inclusión de conjuntos de dependencias relacionadas.
- **Plugins**: Configura los plugins del proyecto, también vinculados a las versiones centralizadas.

Este enfoque te ayuda a tener un control centralizado sobre las versiones, evitando la repetición de versiones en múltiples archivos y garantizando que todas las dependencias y componentes utilicen las mismas versiones.

#### Ejemplo de archivo `libs.versions.toml`:

```toml title="gradle/libs.versions.toml"
[versions]
kotlin = "2.0.20"
echo = "1.0.0" # Versión de nuestro proyecto

[libraries]
kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
```

En este ejemplo:

- La sección `[versions]` define las versiones que serán utilizadas en las dependencias. En este caso, se especifica la versión de Kotlin y una versión para nuestro proyecto (`echo`).
- En la sección `[libraries]`, definimos la biblioteca `kotlin-gradle-plugin` y vinculamos su versión a la referencia `kotlin` especificada anteriormente en la sección `[versions]`.

Al usar esta estructura, cualquier actualización futura de la versión de Kotlin solo requiere modificar el archivo `libs.versions.toml` en un único lugar, manteniendo la consistencia en todo el proyecto.

### Convention Plugins

En proyectos con múltiples módulos, es común y recomendable tener un módulo dedicado a proporcionar configuraciones compartidas que puedan ser reutilizadas por otros módulos. A este tipo de módulo se le conoce como **convention plugins** o también como el patrón **buildSrc**. Estos plugins permiten centralizar configuraciones comunes, facilitando la consistencia y simplificando el mantenimiento del proyecto.

Más adelante exploraremos los plugins con mayor profundidad, pero aquí comenzamos con la configuración básica.

### Configuración de un Convention Plugin

Lo primero que debemos hacer es definir un módulo que siempre se cargue antes que los demás módulos del proyecto. Esto se configura en el archivo `settings.gradle.kts`, asegurando que el módulo de plugins esté disponible para todos los demás módulos.

```kotlin title="settings.gradle.kts"
/* ... */
pluginManagement {
    includeBuild("convention-plugins") // Incluye el módulo de configuración de plugins
    repositories {
        mavenCentral()        // Repositorio Maven Central
        gradlePluginPortal()  // Portal de plugins de Gradle
    }
}
```

### ¿Qué es lo que estamos haciendo aquí?

1. **pluginManagement**: Esta sección configura la gestión de los plugins en Gradle. Es el lugar donde se puede incluir configuraciones adicionales para gestionar cómo y desde dónde se descargan los plugins.

2. **includeBuild("convention-plugins")**: Aquí estamos incluyendo el módulo llamado `convention-plugins`. Este módulo albergará las configuraciones comunes que serán aplicadas en los demás módulos. Siempre se cargará antes de los demás módulos para garantizar que todas las configuraciones estén disponibles desde el principio.

3. **repositories**: Dentro de esta sección definimos los repositorios de donde se obtendrán los plugins. En este caso, estamos usando dos repositorios:
- `mavenCentral()`: El repositorio central de Maven, donde se encuentran numerosas dependencias y plugins.
- `gradlePluginPortal()`: El repositorio oficial de Gradle para la gestión de plugins.

### Configuración de Repositorios

En Gradle, los **repositorios** especifican de dónde obtener las dependencias necesarias para compilar y ejecutar el proyecto.

```kotlin
repositories {
    mavenCentral()
    google()
    maven {
        url = uri("https://your.company.com/maven")
        credentials {
            username = System.getenv("MAVEN_USERNAME") ?: "defaultUser"
            password = System.getenv("MAVEN_PASSWORD") ?: "defaultPassword"
        }
    }
    flatDir {
        dirs("lib")
    }
}
```

### Dependencias

Las **dependencias** son componentes externos que tu proyecto necesita para funcionar. Gradle las gestiona automáticamente y las descarga de repositorios configurados.

```kotlin
dependencies {
    implementation(kotlin("reflect"))
    testImplementation("group:name:version")
    implementation(group = "group", name = "name", version = "version")
}
```

### `settings.gradle`

El archivo `settings.gradle.kts` se utiliza para configurar y gestionar los ajustes de configuración de un proyecto Gradle. Este archivo define la estructura de módulos del proyecto y puede incluir configuraciones adicionales para la gestión de plugins.

```kotlin title="settings.gradle.kts"
// El nombre del proyecto raíz
rootProject.name = "echo-kt"

// Incluye los subproyectos del proyecto raíz
include(
    ":echoLib",
    ":echoApp",
)
```

A continuación, un ejemplo más completo que incluye la configuración de la gestión de plugins:

```kotlin title="settings.gradle.kts"
rootProject.name = "echo-kt"

pluginManagement { // Configuración de gestión de plugins
    includeBuild("convention-plugins") // Incluye un archivo de configuración de plugins
    repositories {  // Repositorios de plugins
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {    // Gestión de resolución de dependencias
    repositories {
        maven { // Repositorio Maven
            url = uri("https://maven.pkg.github.com/r8vnhill/strait-jakt")
            credentials {
                username = System.getenv("GITHUB_USER")
                password = System.getenv("GITHUB_TOKEN")
            }
        }
        mavenCentral()  // Repositorio Maven Central
        mavenLocal()    // Repositorio local
    }
}

plugins {   // Plugins del proyecto
    id("org.gradle.toolchains.foojay-resolver-convention") version "0.8.0"
}

include(    // Incluye subproyectos
    ":echoLib",
    ":echoApp"
)
```

### Convention Plugins

Los **convention plugins** son una forma de definir y compartir configuraciones y convenciones comunes en un proyecto Gradle. Estos plugins permiten estandarizar la configuración y estructura de los proyectos, facilitando la colaboración y la reutilización de código.
Por ahora, solo necesitas entender que los **convention plugins** son una forma de estandarizar la configuración de proyectos Gradle.

```kotlin title="convention-plugins/settings.gradle.kts"
rootProject.name = "convention-plugins"

pluginManagement {
   repositories {
      mavenCentral()
      gradlePluginPortal()
   }
}

dependencyResolutionManagement {
   repositories {
      mavenCentral()
      gradlePluginPortal()
   }
   versionCatalogs {
      create("libs") {
         from(files("../gradle/libs.versions.toml"))    // Carga las versiones desde un archivo toml
      }
   }
}
```

En este ejemplo, el archivo `settings.gradle.kts` define un **version catalog** llamado `libs` que carga las versiones de las dependencias desde un archivo `libs.versions.toml` ubicado en el directorio `gradle` del proyecto.

```kotlin title="convention-plugins/build.gradle.kts"
plugins {
   `kotlin-dsl`
}

dependencies {
   implementation(libs.kotlin.gradle.plugin)
}
```

En el archivo `build.gradle.kts`, se utiliza el **version catalog** `libs` para obtener la versión del plugin de Kotlin. Esto permite centralizar y estandarizar la gestión de versiones en el proyecto.

```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
plugins {
   kotlin("jvm")
}
```

Aquí, el archivo `jvm.conventions.gradle.kts` define las convenciones para proyectos JVM, como la configuración del plugin de Kotlin para JVM y la configuración de las opciones de compilación.
En este caso, el archivo sólo establece el plugin de Kotlin para proyectos JVM.

### `build.gradle.kts`

El archivo `build.gradle.kts` es el script principal de Gradle que define las tareas y configuraciones de construcción del proyecto. En este archivo se especifican las dependencias, plugins, tareas personalizadas y otros ajustes necesarios para compilar y ejecutar el proyecto.

```kotlin title="build.gradle.kts"
plugins {
    id("jvm.conventions")
    alias(libs.plugins.detekt)
}

// Configura el grupo y la versión para todos los proyectos
allprojects {
    group = "echo-kt"
    version = libs.versions.build.systems
}

// Define el repositorio de Maven Central como fuente para las dependencias de los subproyectos
subprojects {
    repositories {
        mavenCentral()
    }
}
```

```kotlin title="subproject1/build.gradle.kts"
plugins {
    id("jvm.conventions")
}

dependencies {
    implementation(kotlin("reflect"))
    implementation(libs.kotlinx.datetime)
    testImplementation(libs.kotest.assertions.core)
    testImplementation(libs.kotest.framework.datatest)
    testImplementation(libs.kotest.framework.engine)
    testImplementation(libs.kotest.property)
    testImplementation(libs.kotest.runner.junit5)
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(17)
}
```

## Construyendo el Proyecto

```bash
./gradlew :subproject1:build
./gradlew build
```

## Comparaciones con Otros Lenguajes

### En otros lenguajes, el concepto de sistemas de construcción y dependencias también es central:

- **Maven (Java)**: Es uno de los sistemas de construcción más populares en el ecosistema Java. Utiliza un archivo `pom.xml` para definir dependencias y configuraciones del proyecto.

```xml title="pom.xml"
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.3.0.RELEASE</version>
</dependency>
```

- **NPM (JavaScript)**: En JavaScript, se usa NPM (Node Package Manager) para gestionar dependencias y scripts de construcción.

```json title="package.json"
{
    "name": "my-app",
    "version": "1.0.0",
    "scripts": {
        "build": "webpack",
        "test": "jest"
    },
    "dependencies": {
        "react": "^16.13.1",
        "webpack": "^4.43.0"
    }
}
```

- **CMake (C++)**: Para proyectos en C++, CMake es una herramienta de construcción común que permite la generación de scripts de compilación.

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject VERSION 1.0)

add_executable(MyExecutable main.cpp)
target_link_libraries(MyExecutable PUBLIC MyLibrary)
```
