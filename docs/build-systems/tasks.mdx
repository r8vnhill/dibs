---
title: Tareas
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Definition from "../../src/components/Definition";
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime/>

Un escenario común es la necesidad de ejecutar tareas específicas durante el proceso de compilación, pruebas o
empaquetado de un proyecto. Algunos ejemplos de tareas comunes incluyen la ejecución de pruebas, la generación de
documentación y la verificación de calidad de código, entre otras.

<Definition title="Tareas">
    Unidad de trabajo que Gradle puede ejecutar. Puede representar cualquier cosa, desde compilar código, ejecutar
    pruebas, generar documentación, hasta desplegar una aplicación. Las tareas se definen en algún archivo
    `*.gradle.kts` y pueden ser tan simples o complejas como sea necesario, dependiendo del propósito que deban
    cumplir.
</Definition>

## Tareas Predefinidas

Gradle proporciona un conjunto de tareas predefinidas que se pueden ejecutar en cualquier proyecto. Por ejemplo
`build`, `clean`, `assemble`, `check`, entre otras. Estas tareas son comunes en la mayoría de los proyectos y se
pueden ejecutar directamente desde la línea de comandos.

### Tarea `build`

La tarea `build` es una de las tareas más comunes en Gradle. Se encarga de compilar el código fuente, ejecutar las
pruebas y empaquetar la aplicación en un formato específico. Al ejecutar `./gradlew build`, Gradle realizará todas las
tareas necesarias para construir el proyecto.

### Tarea `clean`

La tarea `clean` se utiliza para limpiar el directorio de salida del proyecto, eliminando los archivos generados durante
el proceso de compilación. Al ejecutar `./gradlew clean`, Gradle eliminará los archivos compilados y otros artefactos
generados, dejando el proyecto en un estado limpio.

### Tarea `assemble`

La tarea `assemble` se encarga de compilar y empaquetar la aplicación en un formato específico, sin ejecutar las
pruebas. Esta tarea es útil cuando solo se necesita generar el artefacto final sin realizar las pruebas. Al ejecutar
`./gradlew assemble`, Gradle generará el artefacto de salida sin ejecutar las pruebas.

### Tarea `check`

La tarea `check` se utiliza para ejecutar las pruebas y verificar la calidad del código. Esta tarea incluye la ejecución
de pruebas unitarias, pruebas de integración, análisis estático de código, entre otras verificaciones. Al ejecutar
`./gradlew check`, Gradle ejecutará todas las pruebas y verificaciones de calidad de código definidas en el proyecto.

### Configuración de Tareas por Defecto

Además de las mencionadas, Gradle también define tareas por defecto que pueden ser configuradas para personalizar su
comportamiento. Por ejemplo, la tarea `test` se encarga de ejecutar las pruebas unitarias y puede ser configurada para
declarar el motor de pruebas a utilizar, los informes a generar, entre otros aspectos.

```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
tasks.test {
    useJUnitPlatform()
    testLogging {
        events("passed", "skipped", "failed")
        showStandardStreams = true
    }
}
```

## Creación de Tareas Personalizadas

Gradle no solo te permite usar tareas predefinidas, sino que también te brinda la flexibilidad de definir tareas
personalizadas para realizar acciones específicas dentro de tu proyecto. Estas tareas pueden variar en complejidad,
desde operaciones sencillas hasta flujos de trabajo más elaborados, y se definen fácilmente en los archivos
`build.gradle.kts` o en otros archivos `*.gradle.kts` dentro del proyecto.


Para definir las tareas que utilizaremos, podemos hacerlo en el módulo `convention-plugins`, dentro de un archivo
`playground.gradle.kts`. Ahora podemos crear una tarea personalizada, utilizamos la función `tasks.register`, donde
especificamos el nombre de la tarea y las acciones que queremos ejecutar. A continuación te mostramos un ejemplo
básico:

```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
tasks.register("greet") {
    group = "Playground"
    description = "Prints a greeting message"
    println("Hello, Gradle!")
}
```

Con esto, podemos ir al archivo `build.gradle.kts` en el módulo principal y aplicar el plugin que contiene la tarea
personalizada.

```kotlin title="build.gradle.kts"
plugins {
    id("jvm.conventions")
    id("playground")
}
```

Ahora podemos ejecutar la tarea `greet` con el comando `./gradlew greet` y veremos el mensaje impreso en la consola.

### Acciones en Gradle

Las acciones en Gradle son bloques de código que puedes agregar a una tarea para definir comportamientos que deben
ejecutarse en momentos específicos durante el ciclo de vida de esa tarea. Existen dos tipos principales de acciones:

- **`doFirst`**: Agrega una acción que se ejecutará **al inicio** de la tarea, antes de cualquier otra acción
configurada. Se usa cuando necesitas realizar preparaciones o configuraciones previas, como inicializaciones,
antes de la ejecución principal de la tarea.

- **`doLast`**: Agrega una acción que se ejecutará **al final** de la tarea, después de todas las demás acciones
configuradas. Se usa para realizar operaciones finales, como validaciones, limpieza, o cualquier acción que deba
ocurrir después de que la tarea haya completado su ejecución principal.

### Ejemplo: Calculando la secuencia de Fibonacci

Para ilustrar cómo funcionan estas acciones, veamos un ejemplo en el que creamos una tarea personalizada que calcula
la secuencia de Fibonacci hasta el décimo número. No sé qué caso de uso tendría esto, pero este ejemplo nos permite
explorar cómo definir y estructurar tareas personalizadas con `doFirst` y `doLast`.

La secuencia de Fibonacci es una serie en la que cada número es la suma de los dos números anteriores. La fórmula para
calcularla es la siguiente:

$$
F_0 = 0
$$
$$
F_1 = 1
$$
$$
F_n = F_{n-1} + F_{n-2}
$$

Usando esta relación, podemos definir una tarea en Gradle que calcule y muestre los primeros 10 números de la
secuencia de Fibonacci:

```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
tasks.register("fib") {
    group = "Playground"
    description = "Calculates the Fibonacci sequence up to the 10th number"

    var first = 0
    var second = 1

    doFirst {
        for (i in 1..10) {
            print("$first ")
            second += first
            first = second - first
        }
    }

    doLast {
        println("\nThe 10th Fibonacci number is: $first")
    }
}
```

### ¿Qué está sucediendo aquí?

1. **`doFirst`**: Este bloque se ejecuta primero. Aquí, estamos imprimiendo los primeros 10 números de la secuencia de
Fibonacci. En cada iteración, calculamos el siguiente número sumando los dos anteriores y actualizamos las
variables `first` y `second`.

2. **`doLast`**: Después de que `doFirst` termina, este bloque se ejecuta al final de la tarea. Imprimimos el décimo
número de la secuencia, que se encuentra en la variable `first` al finalizar el bucle.

### Resultado

Cuando ejecutas esta tarea, verás una salida similar a la siguiente:

```plaintext
> Task :fib
0 1 1 2 3 5 8 13 21 34
The 10th Fibonacci number is: 55
```

### ¿Por qué usar `doFirst` y `doLast`?

- **`doFirst`** es útil cuando necesitas preparar algo antes de que la lógica principal de la tarea se ejecute, como inicializar variables o configurar el entorno.

- **`doLast`** es ideal para operaciones finales, como limpiar recursos o imprimir resultados después de que la tarea haya completado sus operaciones principales.

Con esta estructura, puedes crear tareas altamente personalizadas que ejecuten acciones en puntos específicos de su ciclo de vida, lo que te da un control más fino sobre cómo y cuándo ocurren las distintas operaciones dentro de tu proyecto Gradle.

:::tip Ejercicio
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        ¿Qué sucede si intercambias las acciones `doFirst` y `doLast` en la tarea `fib`? ¿Cómo afecta esto el resultado?
    </TabItem>
    <TabItem value="Solución" label="Solución">
        Al intercambiar las acciones `doFirst` y `doLast`, el resultado de la tarea `fib` cambiará. En este caso, la
        secuencia de Fibonacci se imprimirá al final de la ejecución de la tarea, y el décimo número se mostrará
        antes de los primeros 10 números. Esto se debe a que `doLast` se ejecuta después de `doFirst`, por lo que
        el cálculo de la secuencia se realizará primero y luego se imprimirá el décimo número al final.
    </TabItem>
</Tabs>
:::

:::tip Ejercicio
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        ¿Qué imprime lo siguiente?

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
tasks.register("advancedTask")
    doFirst
        println("First action - Preparation Step 1")
    }
    doFirst
        println("First action - Preparation Step 2")
    }
    doLast
        println("Last action - Cleanup Step 1")
    }
    doLast
        println("Last action - Cleanup Step 2")
    }
}
```
    </TabItem>
    <TabItem value="Solución" label="Solución">
        Al ejecutar la tarea `advancedTask`, verás la siguiente salida:
```plaintext
> Task :advancedTask
First action - Preparation Step 2
First action - Preparation Step 1
Last action - Cleanup Step 1
Last action - Cleanup Step 2
```
    </TabItem>
</Tabs>
:::

### Dependencias entre Tareas

En proyectos Gradle, es común que ciertas tareas dependan de otras para asegurarse de que se ejecuten en el orden
correcto. Esto se puede lograr utilizando el método `dependsOn`, que permite definir que una tarea específica debe
ejecutarse antes de otra.

Supongamos que queremos una tarea que imprima un mensaje antes de ejecutar la tarea `fib`. Para lograrlo, podemos
definir una nueva tarea `message` y luego establecer que la tarea `fib` dependa de `message`.

```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
tasks.register("message") {
    doFirst {
        println("Calculating the Fibonacci sequence...")
    }
}

tasks.named("fib") {
    dependsOn("message")
}
```

En este ejemplo:
- **`message`**: Una tarea que imprime un mensaje indicando que está a punto de calcularse la secuencia de Fibonacci.
- **`dependsOn`**: Establece que la tarea `fib` depende de `message`, lo que significa que Gradle ejecutará primero
  `message` antes de continuar con `fib`.

Cuando ejecutas la tarea `fib`, el resultado en la consola será algo como esto:

```plaintext
> Task :message
Calculating the Fibonacci sequence...

> Task :fib
0 1 1 2 3 5 8 13 21 34
The 10th Fibonacci number is: 55
```

### Ejemplo Práctico: Contar el Tamaño del Proyecto Compilado

Un ejercicio interesante es crear una tarea personalizada en Gradle que calcule el tamaño de los archivos compilados
del proyecto. Esto puede ser útil para monitorear el tamaño del proyecto después de la compilación. 

Además, haremos que esta tarea dependa de `compileKotlin`, asegurándonos de que se compile el código antes de contar el
tamaño de los archivos.

:::tip Ejercicio
<Tabs>
    <TabItem value="Ejercicio" label="Ejercicio">
        Crea una tarea en Gradle que calcule el tamaño de los archivos compilados de tu proyecto.

        - La tarea debe acceder a los archivos compilados de Kotlin ubicados en
            `app/build/classes/kotlin/main`.
          Para esto, puedes utilizar `fileTree("ruta").files` para obtener los archivos.
        - Puedes calcular el tamaño de un archivo utilizando el método `length()`.
        - Incluye un grupo y descripción para la tarea.
        - Asegúrate de que la tarea dependa de `compileKotlin`.
    </TabItem>
    <TabItem value="Solución" label="Solución">
```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
tasks.register("countCompiledSize") {
    group = "build"
    description = "Count the size of the compiled classes"
    dependsOn("compileKotlin")
    
    doLast {
        val files = fileTree("app/build/classes/kotlin/main").files +
                    fileTree("lib/build/classes/kotlin/main").files
        var size = 0L
        for (file in files) {
            size += file.length()
        }
        println("The total size of the compiled classes is $size bytes")
    }
}
```
    </TabItem>
</Tabs>
:::

