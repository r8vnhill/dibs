---
title: Estructurando un Proyecto en Haskell con M√∫ltiples M√≥dulos
---

import ReadingTime from '@site/src/components/ReadingTime'
import GitHubRepoLink from '@site/src/components/GithubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="echo-app-cabal" />

En esta lecci√≥n aprender√°s a estructurar un proyecto en **Haskell** con m√∫ltiples m√≥dulos usando **Cabal**, la herramienta oficial del ecosistema. Veremos c√≥mo separar la l√≥gica principal en una biblioteca reutilizable, c√≥mo escribir un ejecutable que la consuma, y c√≥mo preparar el terreno para agregar pruebas automatizadas m√°s adelante.

Este enfoque modular es especialmente importante si vienes del mundo de las bibliotecas en Kotlin o Scala, donde separar `lib` y `app` es una pr√°ctica com√∫n. En Haskell, esa separaci√≥n tambi√©n es posible (y deseable), y nos permite escribir c√≥digo m√°s mantenible, reutilizable y listo para crecer.

A lo largo del camino:

- Construiremos un proyecto llamado `echo-app-cabal` con una estructura clara y bien definida.
- Implementaremos una funci√≥n simple para imprimir mensajes.
- Veremos c√≥mo pasar argumentos desde la terminal para probar su reutilizaci√≥n.
- Y ajustaremos el archivo `.cabal` para conectar todo de forma expl√≠cita.

Como siempre en este curso, no solo veremos el *c√≥mo*, sino tambi√©n el *por qu√©*. Porque entender la intenci√≥n detr√°s de las decisiones de dise√±o es lo que te convierte en alguien que no solo usa herramientas, sino que sabe cu√°ndo y c√≥mo usarlas.

Âàù„ÇÅÔºÅ

## üß± Estructura esperada

```mermaid
graph LR
  A[üìÅ echo-app-cabal]

  subgraph B[üìÅ app]
    B1[üìÑ Main.hs]
  end

  subgraph C[üìÅ src-lib]
    C1[üìÑ Echo.hs]
  end

  subgraph D[üìÅ test]
    D1[üìÑ Main.hs]
  end

  A --> B
  A --> C
  A --> D
  A --> E[üìÑ echo-app-cabal.cabal]

  B --> C
  D --> C
```

:::info Explicaci√≥n de la estructura del proyecto

Este diagrama representa la estructura resultante tras ejecutar `cabal init` con soporte para biblioteca, ejecutable y pruebas.

- **üìÅ `echo-app-cabal/`**: Carpeta ra√≠z del proyecto. Contiene el archivo de configuraci√≥n y las carpetas de c√≥digo.
    - **üìÑ `echo-app-cabal.cabal`**: Archivo central de configuraci√≥n. Define los targets (`library`, `executable`, `test-suite`), las dependencias, opciones de compilaci√≥n y metadatos del paquete.
- **üìÅ `src-lib/`**: Contiene el c√≥digo fuente de la biblioteca.  
  - **üìÑ `Echo.hs`**: Define funciones reutilizables que se pueden importar desde otras partes del proyecto.
- **üìÅ `app/`**: Contiene el ejecutable principal de la aplicaci√≥n.  
  - **üìÑ `Main.hs`**: M√≥dulo de entrada con la funci√≥n `main`. Importa y utiliza funciones definidas en `src-lib`.
- **üìÅ `test/`**: Contiene la suite de pruebas del proyecto.  
  - **üìÑ `Main.hs`**: Punto de entrada de las pruebas. Tambi√©n importa la biblioteca (`src-lib`) para verificar su comportamiento.

Las flechas del diagrama indican **relaciones de dependencia**:
- El ejecutable (`app/Main.hs`) **usa** c√≥digo de la biblioteca (`src-lib/Echo.hs`).
- Las pruebas (`test/Main.hs`) tambi√©n **dependen** de la biblioteca para poder verificar su funcionalidad.

Esta separaci√≥n permite una arquitectura modular, donde la l√≥gica central reside en la biblioteca (`src-lib`), y tanto la aplicaci√≥n como las pruebas la consumen de forma independiente.  
Esto favorece la reutilizaci√≥n de c√≥digo, facilita el testing, y prepara el terreno para publicar la biblioteca en el futuro.

:::

## üß™ Paso 1: Crear un m√≥dulo de biblioteca

Primero definiremos una peque√±a biblioteca que nos permita imprimir mensajes con un formato determinado.  
Vamos a crear el archivo `src-lib/Echo.hs` con el siguiente contenido:

```haskell title="src-lib/Echo.hs"
module Echo (echoMessage) where

echoMessage :: String -> IO ()
echoMessage msg = do
    putStrLn msg
```

<Explanation>
    En este paso creamos un **m√≥dulo llamado `Echo`** que define una funci√≥n p√∫blica `echoMessage`.  
    Esta funci√≥n toma un texto (`String`) y lo imprime por pantalla (`IO ()`).  
    El archivo est√° ubicado dentro del directorio `src-lib/`, que configuramos como origen de la biblioteca durante el `cabal init`.

    - `module Echo (echoMessage) where`: declara el nombre del m√≥dulo y exporta la funci√≥n `echoMessage`.
    - `echoMessage :: String -> IO ()`: especifica que la funci√≥n recibe un texto y produce una acci√≥n de entrada/salida.
    - `putStrLn msg`: imprime el mensaje en la consola.
</Explanation>

**Por ahora comenzamos con una versi√≥n simple**, pero en pasos posteriores le agregaremos m√°s funcionalidades √∫tiles, como imprimir la hora actual junto al mensaje.  
Esto nos permitir√° reutilizar `echoMessage` tanto en la aplicaci√≥n principal como en otros contextos del proyecto.

## üöÄ Paso 2: Usar la biblioteca desde el ejecutable

Ahora que tenemos una funci√≥n `echoMessage` en nuestra biblioteca, vamos a usarla desde el ejecutable.  
Edita el archivo `app/Main.hs` para que reciba argumentos desde la l√≠nea de comandos y los imprima uno por uno con nuestra funci√≥n:

```haskell title="app/Main.hs" showLineNumbers
module Main where

import Echo (echoMessage)
import System.Environment (getArgs)
import Control.Monad (forM_)

main :: IO ()
main = do
    messages <- getArgs
    forM_ messages $ \msg -> 
        echoMessage msg
```

<Explanation>
    En este paso creamos el **punto de entrada de la aplicaci√≥n**, donde conectamos el ejecutable con la biblioteca `Echo`.

    - `getArgs`: obtiene los argumentos pasados al programa desde la l√≠nea de comandos.
    - `forM_ messages $ \msg -> ...`: recorre cada argumento (`msg`) y lo pasa a `echoMessage` para imprimirlo.
    - `echoMessage msg`: delega en la biblioteca la l√≥gica de impresi√≥n.

    Este dise√±o ya nos permite probar la reutilizaci√≥n del m√≥dulo `Echo`, y sienta las bases para seguir extendi√©ndolo.  
</Explanation>

<details>
    <summary>‚ÑπÔ∏è ¬øQu√© es <code>forM_</code> y por qu√© usamos <code>Control.Monad</code>?</summary>

    En Haskell, `forM_` es una funci√≥n de la librer√≠a `Control.Monad` que permite recorrer una lista realizando acciones de tipo `IO`, **sin acumular los resultados**.

    ```haskell
    forM_ :: Monad m => [a] -> (a -> m b) -> m ()
    ```

    Es equivalente a `mapM_`, pero con los argumentos en orden m√°s natural: primero la lista, luego la acci√≥n.

    Usamos `forM_` en lugar de un bucle tradicional porque Haskell no tiene bucles imperativos como `for` o `while`.  
    En su lugar, usamos funciones de orden superior como `mapM_`, `forM_` o recursi√≥n expl√≠cita para recorrer listas y realizar efectos colaterales.

    Importamos `Control.Monad` porque ah√≠ se definen estas funciones mon√°dicas √∫tiles para trabajar con efectos como `IO`, listas, `Maybe`, etc.
</details>

## ‚öôÔ∏è Paso 3: Ajustar el archivo `.cabal`

A continuaci√≥n, ajustaremos el archivo `echo-app-cabal.cabal` para que el ejecutable y la suite de pruebas puedan acceder a la biblioteca definida en `src-lib`.

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
    ```haskell showLineNumbers title="echo-app-cabal.cabal"
    -- Nombre del proyecto
    name:               echo-app-cabal

    -- Configuraci√≥n de la biblioteca
    library
      exposed-modules:  Echo
      hs-source-dirs:   src-lib

    -- Ejecutable que usa la biblioteca
    executable echo-app-cabal
      main-is:          Main.hs
      hs-source-dirs:   app
      build-depends:
        echo-app-cabal

    -- Suite de pruebas que tambi√©n depende de la biblioteca
    test-suite echo-app-cabal-test
      hs-source-dirs:   test
      main-is:          Main.hs
      build-depends:
        echo-app-cabal
    ```
  </TabItem>

  <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
    ```haskell showLineNumbers title="echo-app-cabal.cabal"
    cabal-version:      3.0
    name:               echo-app-cabal
    version:            0.1.0.0
    homepage:           https://dibs.pages.dev
    license:            BSD-2-Clause
    license-file:       LICENSE
    author:             r8vnhill
    maintainer:         reachme@ravenhill.cl
    build-type:         Simple
    extra-doc-files:    CHANGELOG.md

    common warnings
      ghc-options: -Wall

    library
      import:           warnings
      exposed-modules:  Echo
      build-depends:    base ^>=4.17.2.1
      hs-source-dirs:   src-lib
      default-language: GHC2021

    executable echo-app-cabal
      import:           warnings
      main-is:          Main.hs
      build-depends:
        base ^>=4.17.2.1,
        echo-app-cabal
      hs-source-dirs:   app
      default-language: GHC2021

    test-suite echo-app-cabal-test
      import:           warnings
      default-language: GHC2021
      type:             exitcode-stdio-1.0
      hs-source-dirs:   test
      main-is:          Main.hs
      build-depends:
        base ^>=4.17.2.1,
        echo-app-cabal
    ```
  </TabItem>
</BoxedTabs>

<Explanation>
    El archivo `.cabal` define c√≥mo se construyen los distintos componentes del proyecto:

    - En la secci√≥n `library`, declaramos el m√≥dulo `Echo` como expuesto y lo ubicamos en `src-lib/`.
    - En el bloque `executable`, indicamos que `Main.hs` es el punto de entrada y que este ejecutable depende de la biblioteca `echo-app-cabal` (s√≠, el mismo nombre del proyecto).
    - En `test-suite`, hacemos lo mismo: configuramos el punto de entrada y declaramos la dependencia hacia la biblioteca.

    De esta forma, tanto el ejecutable como la suite de pruebas pueden importar y reutilizar c√≥digo desde el m√≥dulo `Echo`.
</Explanation>

## ‚ñ∂Ô∏è Paso 4: Ejecutar el proyecto

Con la biblioteca, el ejecutable y la configuraci√≥n listos, ahora podemos compilar y ejecutar el programa desde la ra√≠z del proyecto.

Ejecuta el siguiente comando:

```bash
cabal run echo-app-cabal -- "Hi Barbie!" "Hi Ken!" "Do you guys ever think about dying?"
```

La salida ser√° algo como:

```plaintext
Hi Barbie!
Hi Ken!
Do you guys ever think about dying?
```

<Explanation>
    Usamos `cabal run` seguido del nombre del ejecutable (`echo-app-cabal`) y una serie de argumentos entre comillas.  
    Estos argumentos se transforman en una lista de `String` que `getArgs` recibe en `Main.hs`.

    Luego, cada uno se imprime l√≠nea por l√≠nea mediante `forM_`, usando la funci√≥n `echoMessage` de nuestra biblioteca.

</Explanation>

üëâ Este paso comprueba que **el ejecutable est√° correctamente conectado a la biblioteca** y que **puede recibir entradas din√°micas desde la l√≠nea de comandos**, lo que lo hace mucho m√°s flexible y √∫til.

## üéØ Conclusiones

Dividir un proyecto Haskell en m√∫ltiples m√≥dulos no es solo una cuesti√≥n de orden: es una forma de expresar con claridad qu√© partes del c√≥digo son reutilizables, cu√°les se ejecutan como aplicaci√≥n y cu√°les prueban su correcto funcionamiento. Esta separaci√≥n de responsabilidades es clave al dise√±ar bibliotecas, y en esta lecci√≥n dimos nuestros primeros pasos en esa direcci√≥n.

Aprendimos a usar `cabal init` para crear un proyecto bien estructurado, a definir una biblioteca simple con una funci√≥n exportada, y a configurar el ejecutable para que la consuma. Tambi√©n comprendimos c√≥mo ajustar el archivo `.cabal` para reflejar estas relaciones y c√≥mo ejecutar el programa con argumentos reales desde la terminal.

Este ejercicio no solo nos ense√±√≥ herramientas, sino tambi√©n una forma de pensar: **crear software reutilizable, modular y preparado para crecer**.

### üîë Puntos clave

- Crear un proyecto con `cabal init` permite estructurar desde el inicio la biblioteca, el ejecutable y las pruebas.
- Definir m√≥dulos separados facilita la reutilizaci√≥n y el mantenimiento del c√≥digo.
- El archivo `.cabal` act√∫a como contrato entre los componentes: describe qu√© se construye, desde d√≥nde y con qu√© dependencias.
- La funci√≥n `getArgs` permite capturar argumentos desde la terminal, y `forM_` es una forma idiom√°tica de recorrerlos.
- Tanto la app como los tests pueden importar l√≥gica com√∫n desde la biblioteca.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n nos mostr√≥ que un proyecto no comienza cuando escribimos c√≥digo, sino cuando tomamos decisiones sobre su estructura.  
Separar la l√≥gica reutilizable en una biblioteca, definir un ejecutable claro y configurar correctamente los archivos del proyecto es lo que transforma un conjunto de archivos en una base s√≥lida para construir software real.

Pero tambi√©n nos llevamos algo m√°s sutil: que **la forma en que organizamos nuestro c√≥digo influye en c√≥mo pensamos nuestros programas**.  
Cuando estructuramos bien, podemos escribir menos y lograr m√°s. Podemos componer, reutilizar y probar.  
Y cuando eso ocurre, lo que estamos creando no es solo un programa... es una biblioteca que puede vivir m√°s all√° del proyecto original.

## üìñ Referencias

### üî• Recomendadas

- üåê Structure of a Haskell project‚ÄîHaskellWiki. (s.¬†f.). Recuperado 5 de abril de 2025, de https://wiki.haskell.org/Structure_of_a_Haskell_project

{/* ### üîπ Adicionales */}
