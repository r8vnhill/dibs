---
title: Convention plugins
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="echo-app-kt" />

En proyectos con m√∫ltiples m√≥dulos, es com√∫n y recomendable contar con un m√≥dulo dedicado a centralizar configuraciones compartidas que puedan ser reutilizadas por el resto del proyecto. En el contexto de **Gradle**, a este tipo de m√≥dulo se le conoce como un **convention plugin**, y tambi√©n se asocia con el patr√≥n conocido como **`buildSrc`**.

Estos plugins permiten consolidar configuraciones comunes, lo que mejora la consistencia entre m√≥dulos y simplifica el mantenimiento general del proyecto.

M√°s adelante profundizaremos en el uso de plugins personalizados dentro del ecosistema Gradle. Por ahora, comenzaremos con una configuraci√≥n b√°sica.

## üß© Configuraci√≥n de un Convention Plugin

Lo primero que debemos hacer es definir un m√≥dulo que se cargue **antes que los dem√°s**. Esto se configura en el archivo `settings.gradle.kts`, asegurando que el m√≥dulo de plugins est√© disponible para el resto del proyecto desde el inicio.

```kotlin showLineNumbers title="settings.gradle.kts"
// ...
pluginManagement {
    includeBuild("convention-plugins")
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}
```

<Explanation>
    - **[2‚Äì8]**: Esta secci√≥n configura la gesti√≥n de plugins en Gradle. Aqu√≠ es posible personalizar c√≥mo se resuelven y desde d√≥nde se descargan.
    - **[3]**: Se incluye el m√≥dulo `convention-plugins` como un *build externo* (`includeBuild`). Este m√≥dulo contendr√° las configuraciones comunes que ser√°n aplicadas autom√°ticamente en el resto del proyecto. Al estar declarado aqu√≠, se garantiza que se cargue antes que los dem√°s m√≥dulos.
    - **[4‚Äì7]**: Se definen los repositorios desde los cuales se obtendr√°n los plugins:
        - **[5]**: `mavenCentral()`: Repositorio central de Maven, ampliamente utilizado para dependencias y plugins.
        - **[6]**: `gradlePluginPortal()`: Repositorio oficial de Gradle para plugins.
</Explanation>

## üóÇÔ∏è Configuraci√≥n de Convention Plugins

El siguiente paso es crear la estructura de directorios necesaria para definir nuestros *convention plugins*. Estos plugins encapsulan configuraciones comunes que podr√°n ser reutilizadas en otros m√≥dulos del proyecto. 

En este ejemplo, omitiremos el directorio de pruebas, ya que este tipo de m√≥dulo no suele requerir c√≥digo testeable: su prop√≥sito es √∫nicamente configurar comportamientos comunes.

### üèóÔ∏è Crear la Estructura de Directorios

Primero, crea el directorio donde ubicaremos el c√≥digo fuente del plugin de convenciones:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        New-Item -Path "convention-plugins\src\main\kotlin" `
            -ItemType "Directory" `
            -Force
        ```

        <Explanation>  
            Este comando crea el directorio `convention-plugins\src\main\kotlin`, incluyendo todas las carpetas intermedias si no existen. El par√°metro `-ItemType "Directory"` indica que se debe crear un directorio, y `-Force` asegura que no falle si alguna parte del path ya existe. La barra invertida invertida (`` ` ``) al final de cada l√≠nea permite dividir el comando en varias l√≠neas para mayor legibilidad.  
        </Explanation>
    </TabItem>
    <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
        ```powershell
        md "convention-plugins\src\main\kotlin" -f
        ```

        <Explanation>  
            Este comando utiliza el alias `md` (abreviatura de `mkdir`) para crear el directorio `convention-plugins\src\main\kotlin`, incluyendo cualquier carpeta intermedia que no exista. El par√°metro `-f` (de *force*) evita errores si el directorio ya existe. Esta es una forma m√°s corta y com√∫nmente usada en PowerShell para crear directorios.  
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        mkdir -p convention-plugins/src/main/kotlin
        ```

        <Explanation>  
            Este comando crea el directorio `convention-plugins/src/main/kotlin` y, gracias al par√°metro `-p`, tambi√©n crea autom√°ticamente cualquier directorio intermedio que no exista. Es una forma segura y habitual de crear estructuras de carpetas en sistemas basados en Unix (Linux y macOS), sin generar errores si los directorios ya existen.  
        </Explanation>
    </TabItem>
</BoxedTabs>

### ‚öôÔ∏è Configuraci√≥n de `settings.gradle.kts`

Dentro de la carpeta principal `convention-plugins`, debemos crear el archivo `settings.gradle.kts`. Este archivo configura el nombre del proyecto, la gesti√≥n de plugins y la resoluci√≥n de dependencias para este m√≥dulo.

```kotlin showLineNumbers title="convention-plugins/settings.gradle.kts"
rootProject.name = "convention-plugins"

// Gesti√≥n de plugins y definici√≥n de repositorios para su descarga
pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

// Configuraci√≥n para la resoluci√≥n de dependencias
@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    // Definici√≥n de un cat√°logo centralizado de versiones de dependencias
    versionCatalogs {
        create("libs") {
            from(files("../gradle/libs.versions.toml"))
        }
    }
}
```

<Explanation>
    Este archivo `settings.gradle.kts` define la configuraci√≥n principal del m√≥dulo `convention-plugins`. En la l√≠nea 1 se establece el nombre del proyecto, necesario para que Gradle lo identifique correctamente como un build independiente.

    La secci√≥n `pluginManagement` (l√≠neas 4‚Äì9) indica desde qu√© repositorios deben descargarse los plugins utilizados en este m√≥dulo. Aqu√≠ se usan `mavenCentral()` y `gradlePluginPortal()`, que cubren la mayor√≠a de los plugins comunes en proyectos Java y Kotlin.

    La secci√≥n `dependencyResolutionManagement` (l√≠neas 12‚Äì25) configura c√≥mo se resolver√°n las dependencias declaradas en los archivos `build.gradle.kts` del m√≥dulo. Se especifican los mismos repositorios, y adem√°s se declara un cat√°logo de versiones (`versionCatalogs`) en la l√≠nea 20, apuntando al archivo `libs.versions.toml` ubicado fuera del m√≥dulo. Este cat√°logo permite mantener versiones centralizadas y consistentes en todos los m√≥dulos del proyecto.

    :::note `@Suppress("UnstableApiUsage")`

    Se incluye la anotaci√≥n `@Suppress("UnstableApiUsage")` porque la propiedad `repositories` dentro de `dependencyResolutionManagement` se considera **inestable** en las versiones actuales de Gradle, y su uso genera un warning en compilaciones con Kotlin DSL.

    :::
</Explanation>

<details>
    <summary>¬øPor qu√© aparece el warning sobre "UnstableApiUsage"?</summary>

    En el archivo `settings.gradle.kts` del m√≥dulo `convention-plugins`, se utiliza la anotaci√≥n `@Suppress("UnstableApiUsage")` antes de la configuraci√≥n de `dependencyResolutionManagement`. Esto se debe a que, en las versiones actuales de Gradle, al invocar `repositories` dentro de `dependencyResolutionManagement`, se genera una advertencia indicando que la funci√≥n est√° marcada como inestable con la anotaci√≥n `@Incubating`.

    La anotaci√≥n `@Incubating` en Gradle se√±ala que una caracter√≠stica o API est√° en fase de incubaci√≥n, lo que significa que a√∫n est√° en desarrollo y podr√≠a sufrir cambios en futuras versiones. Aunque estas funcionalidades son utilizables, es importante ser consciente de su estado y de la posibilidad de modificaciones. Para suprimir las advertencias relacionadas con el uso de APIs inestables, se emplea `@Suppress("UnstableApiUsage")`, lo que permite mantener el c√≥digo limpio y sin advertencias innecesarias.

    Es recomendable revisar peri√≥dicamente la documentaci√≥n oficial de Gradle para estar al tanto del estado de las APIs utilizadas y ajustar el c√≥digo en consecuencia a medida que evolucionan hacia versiones estables.
</details>

## üìë Cat√°logo de Versiones

Aunque no es obligatorio, es una **buena pr√°ctica** centralizar las versiones de las dependencias de un proyecto utilizando un archivo `.toml`. Este enfoque garantiza consistencia en las versiones utilizadas en todo el proyecto, evitando problemas de incompatibilidad y facilitando el mantenimiento.

El cat√°logo de versiones se organiza en cuatro secciones principales:

- **Versions**: Especifica las versiones de las dependencias, permitiendo su reutilizaci√≥n en las secciones de bibliotecas y plugins.
- **Libraries**: Define las bibliotecas necesarias para el proyecto, asoci√°ndolas con las versiones especificadas en la secci√≥n de versiones.
- **Bundles**: Agrupa varias bibliotecas bajo un mismo nombre, facilitando la inclusi√≥n de conjuntos de dependencias relacionadas.
- **Plugins**: Configura los plugins del proyecto, tambi√©n vinculados a las versiones centralizadas.

Este enfoque te ayuda a tener un control centralizado sobre las versiones, evitando la repetici√≥n de versiones en m√∫ltiples archivos y garantizando que todas las dependencias y componentes utilicen las mismas versiones.

### Ejemplo de archivo `libs.versions.toml`:

Definiremos un cat√°logo de versiones en un archivo `libs.versions.toml` para centralizar las versiones de las dependencias de nuestro proyecto:

```toml title="gradle/libs.versions.toml" showLines
[versions]
kotlin = "2.1.10"
echo = "1.0.0" # Versi√≥n de nuestro proyecto

[libraries]
kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
```

<Explanation>
    - La secci√≥n `[versions]` define las versiones que ser√°n utilizadas en las dependencias. En este caso, se especifica la versi√≥n de Kotlin y una versi√≥n para nuestro proyecto (`echo`).
    - En la secci√≥n `[libraries]`, definimos la biblioteca `kotlin-gradle-plugin` y vinculamos su versi√≥n a la referencia `kotlin` especificada anteriormente en la secci√≥n `[versions]`.
</Explanation>

:::note Nombre `libs.versions.toml`

El nombre `libs.versions.toml` es solo una convenci√≥n y puedes elegir cualquier nombre que refleje su prop√≥sito,
incluso dividirlo en varios archivos si es necesario. En este curso utilizaremos esta convenci√≥n de nombre, ya que es
com√∫n en la comunidad de Gradle.

:::

Al usar esta estructura, cualquier actualizaci√≥n futura de la versi√≥n de Kotlin solo requiere modificar el archivo
`libs.versions.toml` en un √∫nico lugar, manteniendo la consistencia en todo el proyecto.

### üõ†Ô∏è Crear el archivo de construcci√≥n

Dentro de la carpeta `convention-plugins`, crea un archivo de construcci√≥n llamado `build.gradle.kts`. Este archivo define c√≥mo se compila y configura el m√≥dulo de plugins de convenci√≥n.

```kotlin showLineNumbers title="convention-plugins/build.gradle.kts"
plugins {
    `kotlin-dsl`
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    implementation(libs.kotlin.gradle.plugin)
}
```

<Explanation>
    Para que los plugins de convenci√≥n escritos con Kotlin DSL sean detectados correctamente por Gradle, es necesario aplicar el plugin `kotlin-dsl`.

    - **[2]** `` `kotlin-dsl` ``: Se aplica el plugin usando *backticks* debido a que el nombre contiene un guion, lo que lo hace inv√°lido como identificador normal en Kotlin. Este plugin habilita la escritura de scripts en Kotlin y permite que los plugins precompilados sean descubiertos autom√°ticamente por el sistema de compilaci√≥n.
    - **[5‚Äì8]** `repositories`: Especifica de d√≥nde se obtendr√°n las dependencias y plugins necesarios. Se utilizan `mavenCentral()` y `gradlePluginPortal()` por su amplio soporte.
    - **[11]** `implementation(libs.kotlin.gradle.plugin)`: Agrega el plugin de Kotlin para Gradle como dependencia. Esta l√≠nea asume que el proyecto utiliza un cat√°logo de versiones (`libs.versions.toml`), lo cual permite gestionar versiones de forma centralizada y coherente.
</Explanation>

<details>
    <summary>
        Backticks en el nombramiento de variables y funciones
    </summary>

    En Kotlin, los *backticks* (`` `...` ``) permiten declarar identificadores que normalmente no ser√≠an v√°lidos, como aquellos que contienen guiones (`-`) o espacios.

    Esto es especialmente √∫til en archivos `build.gradle.kts`, donde algunos plugins tienen nombres con guiones. Por ejemplo:

    ```kotlin
    plugins {
        `kotlin-dsl` // v√°lido gracias a los backticks
    }
    ```

    Sin los *backticks*, `kotlin-dsl` no ser√≠a un identificador v√°lido porque contiene un guion (`-`).

    :::info ¬øPor qu√© se usan?

    Este mecanismo existe principalmente por compatibilidad con **Groovy**, el lenguaje original usado por Gradle. En Groovy, los nombres de plugins como `kotlin-dsl` se declaraban como cadenas:

    ```groovy
    plugins {
        id "kotlin-dsl"
    }
    ```

    Para mantener una sintaxis similar en Kotlin DSL, se permite el uso de backticks alrededor del nombre. As√≠, la migraci√≥n y la legibilidad entre ambos DSLs es m√°s natural.

    :::

    :::tip Buenas pr√°cticas

    - **√ösalos solo cuando sea necesario**: Los *backticks* deben reservarse para nombres que no ser√≠an v√°lidos como identificadores normales.
    - **Evita abusar de nombres arbitrarios**: Aunque Kotlin permite cualquier texto entre backticks, como `` `some weird name` ``, eso puede volver tu c√≥digo menos mantenible.
    - **Prefiere nombres v√°lidos sin backticks** si es posible, para aprovechar el soporte completo de autocompletado y verificaci√≥n est√°tica.

    :::
</details>

## üß™ Mi Primer Plugin

<Definition title="Plugin" id="plugin-def">
    Un **plugin** es un componente de software que extiende o modifica la funcionalidad de un sistema existente.  
    En el contexto de Gradle, un plugin es un conjunto de tareas, configuraciones y comportamientos que se pueden aplicar a un proyecto para automatizar su construcci√≥n y administraci√≥n.
</Definition>

Gradle permite definir plugins de distintas formas. Una de las m√°s utilizadas es mediante **plugins de convenci√≥n**, que encapsulan configuraciones comunes aplicadas autom√°ticamente a todos los subproyectos de un proyecto.

En esta secci√≥n, crearemos un plugin de convenci√≥n b√°sico para proyectos basados en la JVM. Comenzaremos con una configuraci√≥n m√≠nima y la iremos expandiendo en las siguientes secciones.

### ‚ú® Creando el Plugin

Primero, vamos a crear el archivo que contendr√° nuestro plugin. Dentro de la carpeta `convention-plugins/src/main/kotlin`, crea un archivo llamado `jvm.conventions.gradle.kts` con el siguiente contenido:

```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
plugins {
    kotlin("jvm")
}

kotlin {
    jvmToolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
```

<Explanation>
    Este archivo define un **plugin de convenci√≥n** que aplica autom√°ticamente el plugin `kotlin("jvm")` y configura la versi√≥n del compilador de Java a trav√©s del bloque `jvmToolchain`.

    - **[2]**: Aplica el plugin de Kotlin para la JVM. Al estar definido en un archivo de convenci√≥n, se aplicar√° de forma impl√≠cita a todos los m√≥dulos que utilicen este plugin.
    - **[5‚Äì9]**: Configura la herramienta de compilaci√≥n (`jvmToolchain`) para usar Java 21 como versi√≥n del lenguaje. Esto garantiza que todos los proyectos que usen este plugin compilen con la misma versi√≥n de Java, asegurando compatibilidad y consistencia.
</Explanation>

#### ‚ùì ¬øPor qu√© no especificamos la versi√≥n del plugin?

Aunque es com√∫n declarar el plugin con una versi√≥n expl√≠cita, como en el siguiente ejemplo:

```kotlin showLineNumbers
plugins {
    kotlin("jvm") version "2.1.20"
}
```

en este caso **no es necesario**, ya que hemos centralizado la gesti√≥n de versiones mediante el archivo `libs.versions.toml`. Esta estrategia asegura que todas las dependencias y plugins de Kotlin utilicen la misma versi√≥n, facilitando su actualizaci√≥n y manteniendo coherencia en todo el proyecto.

### üì¶ Usando el Plugin

Una vez creado nuestro plugin de convenciones, podemos aplicarlo en los subproyectos donde queramos que se utilicen esas configuraciones comunes. En este ejemplo, lo aplicaremos en dos subproyectos: `app` y `lib`.

Primero, necesitamos crear las carpetas correspondientes para cada subproyecto. Puedes hacerlo con los siguientes comandos seg√∫n tu sistema operativo:

<BoxedTabs>
    <TabItem value="Windows" label="Windows">
        ```powershell
        "src\main\kotlin" | ForEach-Object { 
            "app\$_", "lib\$_" | ForEach-Object { 
                New-Item -Path $_ -ItemType "Directory" -Force 
            }
        }
        ```

        <Explanation>
            Este fragmento utiliza dos bucles `ForEach-Object` anidados para crear de forma concisa los directorios `app\src\main\kotlin` y `lib\src\main\kotlin`.

            - En el primer pipeline (`"src\main\kotlin"`), se define el segmento de ruta com√∫n que ser√° a√±adido a cada m√≥dulo.
            - En el segundo pipeline (`"app\$_", "lib\$_"`), se generan las rutas completas para ambos subproyectos combinando los nombres de los m√≥dulos (`app`, `lib`) con la ruta com√∫n.
            - `New-Item` crea los directorios y el par√°metro `-Force` asegura que no se generen errores si alguno ya existe.

            Este patr√≥n permite mantener el c√≥digo limpio y f√°cilmente extensible en caso de que se agreguen m√°s m√≥dulos o rutas.
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell
        "src\main\kotlin" | % { "app\$_", "lib\$_" | % { md $_ -f } }
        ```
        
        <Explanation>
            Este comando usa una forma abreviada y funcional de crear m√∫ltiples directorios en PowerShell utilizando el alias `%` para `ForEach-Object`.

            - `"src\main\kotlin"` es la ruta com√∫n que se desea agregar a los m√≥dulos `app` y `lib`.
            - En el primer `%`, se toma ese valor (`$_`) y se construyen dos rutas: `"app\$_"` y `"lib\$_"`, es decir, `app\src\main\kotlin` y `lib\src\main\kotlin`.
            - El segundo `%` recorre esas rutas y ejecuta `md` (alias de `mkdir`) con el par√°metro `-f` (alias de `-Force`), que crea los directorios y no lanza error si ya existen.

            Es una forma compacta y efectiva de crear varias rutas en un solo comando.
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        printf "%s\n" app lib | xargs -I{} mkdir -pv "{}/src/main/kotlin"
        ```

        <Explanation>
            Este comando crea las carpetas `app/src/main/kotlin` y `lib/src/main/kotlin` de forma compacta y funcional:

            - `printf "%s\n" app lib` imprime cada nombre de m√≥dulo (`app` y `lib`) en una l√≠nea separada.
            - `xargs -I{}` toma cada l√≠nea y reemplaza `{}` en el comando `mkdir -pv "{}/src/main/kotlin"`.
            - `mkdir -p` crea todos los directorios intermedios si no existen.
            - `-v` (verbose) muestra en consola qu√© directorios se est√°n creando.

            Esto asegura que se creen correctamente dos rutas independientes, evitando el error com√∫n de que se cree una carpeta llamada `"app lib"` si se usa `echo` sin separaci√≥n de l√≠neas.

            :::warning Nota

            Si no se imprime nada en consola, es porque las carpetas ya exist√≠an. En ese caso, `mkdir -p` no realiza ninguna acci√≥n y suprime cualquier salida, incluso con `-v`.

            :::
        </Explanation>

    </TabItem>
</BoxedTabs>


#### En el subproyecto `app`:

```kotlin showLineNumbers title="app/build.gradle.kts"
plugins {
    id("jvm.conventions")
}
```

#### En el subproyecto `lib`:

```kotlin showLineNumbers title="lib/build.gradle.kts"
plugins {
    id("jvm.conventions")
}
```

<Explanation>
    Al aplicar el plugin `jvm.conventions` en los subproyectos `app` y `lib`, aseguramos que ambos compartan una base com√∫n de configuraciones para proyectos basados en la JVM. En su forma actual, este plugin aplica autom√°ticamente el plugin de Kotlin para JVM y configura la versi√≥n del compilador.

    A medida que el plugin crezca, podremos extenderlo con reglas, convenciones y dependencias adicionales que se aplicar√°n de forma coherente en todos los subproyectos, facilitando el mantenimiento y promoviendo la consistencia del proyecto.
</Explanation>

## üîç Verificar que el Plugin se Aplica Correctamente

Una vez aplicado el plugin en los subproyectos, puedes verificar que las configuraciones se hayan aplicado correctamente utilizando algunos comandos de Gradle:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        .\gradlew --quiet app:dependencies | Select-String "kotlin"
        ```

        <Explanation>
            Este comando permite verificar si el plugin `kotlin("jvm")` fue aplicado correctamente en el subproyecto `app`.

            - `.\gradlew app:dependencies` imprime el √°rbol de dependencias del subproyecto.
            - `--quiet` reduce el ruido en la salida, omitiendo mensajes como `"Task :convention-plugins:checkKotlinGradlePluginConfigurationErrors SKIPPED"`.
            - `| Select-String "kotlin"` filtra la salida mostrando solo las l√≠neas relacionadas con Kotlin, lo que permite confirmar si las dependencias del compilador y est√°ndar de Kotlin est√°n presentes.

            Esto es √∫til para validar que el plugin de convenciones est√° funcionando correctamente.

            :::note Nota

            Como se us√≥ la opci√≥n `--quiet`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

            :::
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell
        .\gradlew -q app:dependencies | sls "kotlin"
        ```

        <Explanation>
            Este comando compacto verifica si el plugin `kotlin("jvm")` fue aplicado correctamente en el subproyecto `app`:

            - `.\gradlew -q app:dependencies` imprime las dependencias de forma silenciosa, omitiendo mensajes irrelevantes.
            - `sls "kotlin"` es un alias de `Select-String` y filtra la salida para mostrar solo las l√≠neas que contienen la palabra `kotlin`.

            Esto permite confirmar r√°pidamente que las dependencias de Kotlin est√°n presentes sin ruido adicional.

            :::note Nota

            Como se us√≥ la opci√≥n `-q`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

            :::
        </Explanation>
    </TabItem>
    <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            ./gradlew --quiet app:dependencies | grep kotlin
            ```

            <Explanation>
                Este comando permite verificar si el plugin `kotlin("jvm")` fue aplicado correctamente al subproyecto `app`:

                - `./gradlew --quiet app:dependencies` ejecuta la tarea que imprime el √°rbol de dependencias del subproyecto, y la opci√≥n `--quiet` reduce la salida omitiendo tareas informativas y mensajes innecesarios.
                - `| grep kotlin` filtra la salida para mostrar √∫nicamente las l√≠neas que contienen la palabra `kotlin`, facilitando la identificaci√≥n de dependencias del compilador, est√°ndar u otras herramientas de Kotlin.

                Este comando es √∫til para confirmar que el plugin de convenciones est√° funcionando como se espera.

                :::note Nota

                Al usar la opci√≥n `--quiet`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

                :::
            </Explanation>
    </TabItem>
</BoxedTabs>

Si la salida del comando muestra dependencias relacionadas con Kotlin, significa que el plugin se aplic√≥ correctamente y que las configuraciones comunes est√°n siendo compartidas entre los subproyectos.
En caso contrario, es probable que el plugin no se haya aplicado correctamente, por lo que conviene revisar los pasos anteriores.

### üß± Estructura Final del Proyecto

Despu√©s de ejecutar el comando de construcci√≥n, tu proyecto deber√≠a tener una estructura de directorios similar a la
siguiente:

```mermaid
%% title: ./echo
graph LR
    A["üìÅ ./echo"]
    A --> A1["üìÅ .gradle"]
    A --> A2["üìÅ app"]
    A2 --> A2a["üìÅ src"]
    A2a --> A2a1["üìÅ main"]
    A2a1 --> A2a1k["üìÅ kotlin"]
    A2a --> A2a2["üìÅ test"]
    A2a2 --> A2a2k["üìÅ kotlin"]

    A --> A3["üìÅ convention-plugins"]
    A3 --> A3a["üìÅ .gradle"]
    A3 --> A3b["üìÅ build"]
    A3b --> A3b1["üìÅ classes"]
    A3b1 --> A3b1j["üìÅ java"]
    A3b1j --> A3b1jm["üìÅ main"]
    A3b1j --> A3b1jt["üìÅ test"]
    A3b --> A3b2["üìÅ resources"]
    A3b2 --> A3b2m["üìÅ main"]
    A3b2 --> A3b2t["üìÅ test"]
    A3 --> A3c["üìÅ src"]
    A3c --> A3c1["üìÅ main"]
    A3c1 --> A3c1k["üìÅ kotlin"]

    A --> A4["üìÅ gradle"]
    A4 --> A4w["üìÅ wrapper"]

    A --> A5["üìÅ lib"]
    A5 --> A5s["üìÅ src"]
    A5s --> A5sm["üìÅ main"]
    A5sm --> A5smk["üìÅ kotlin"]
    A5s --> A5st["üìÅ test"]
    A5st --> A5stk["üìÅ kotlin"]

```

## üéØ Conclusiones

En esta lecci√≥n aprendimos a crear y aplicar un **plugin de convenciones** en un proyecto Gradle con m√∫ltiples m√≥dulos. Exploramos c√≥mo encapsular configuraciones comunes dentro de un m√≥dulo especializado, reutilizable y f√°cilmente mantenible.

Este enfoque no solo promueve la coherencia entre los subproyectos, sino que tambi√©n reduce la repetici√≥n, centraliza las decisiones de configuraci√≥n y facilita el crecimiento del proyecto a medida que evoluciona.

### üîë Puntos clave

- Un **plugin de convenci√≥n** encapsula comportamientos, dependencias y configuraciones comunes que pueden aplicarse autom√°ticamente en m√∫ltiples m√≥dulos.
- La instrucci√≥n `includeBuild("convention-plugins")` permite que el m√≥dulo est√© disponible desde el inicio del proceso de construcci√≥n.
- La combinaci√≥n de convenciones con un **cat√°logo de versiones (`libs.versions.toml`)** ayuda a mantener dependencias actualizadas, coherentes y f√°ciles de gestionar.
- Gradle detecta autom√°ticamente los plugins definidos en archivos como `jvm.conventions.gradle.kts` si se respeta la convenci√≥n de nombres.
- Verificar la aplicaci√≥n del plugin asegura que el comportamiento esperado se est√© aplicando en cada subproyecto.

### üß∞ ¬øQu√© nos llevamos?

Adoptar plugins de convenci√≥n desde las primeras etapas de un proyecto no es solo una cuesti√≥n de orden: es una decisi√≥n estrat√©gica. Esta pr√°ctica convierte decisiones repetitivas en configuraciones autom√°ticas, alivia la carga cognitiva de cada subm√≥dulo, y favorece una arquitectura escalable y profesional.

A medida que el proyecto crezca, contar con una base s√≥lida y coherente en su configuraci√≥n har√° una gran diferencia, tanto para quienes lo mantienen como para quienes se incorporen m√°s adelante.

## üìñ Referencias

### üî• Recomendadas

- üåê Sharing build logic between subprojects Sample. (s.¬†f.). Recuperado 27 de marzo de 2025, de https://docs.gradle.org/current/samples/sample_convention_plugins.html

### üîπ Adicionales

- üìö Build script essentials. (2014). En B. Muschko & H. Dockter, Gradle in action (pp. 75‚Äì104). Manning.
