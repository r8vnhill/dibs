---
title: Convention Plugins
---



import References from "../../src/components/ReferencesComponent";
import Definition from "../../src/components/Definition";
import ReadingTime from "../../src/components/ReadingTime";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<ReadingTime/>

En proyectos con múltiples módulos, es común y recomendable tener un módulo dedicado a proporcionar configuraciones
compartidas que puedan ser reutilizadas por otros módulos. A este tipo de módulo se le conoce como **convention
plugins** o también como el patrón **buildSrc**. Estos plugins permiten centralizar configuraciones comunes,
facilitando la consistencia y simplificando el mantenimiento del proyecto.

Más adelante exploraremos los plugins con mayor profundidad, pero aquí comenzamos con la configuración básica.

## Configuración de un Convention Plugin

Lo primero que debemos hacer es definir un módulo que siempre se cargue antes que los demás módulos del proyecto. Esto
se configura en el archivo `settings.gradle.kts`, asegurando que el módulo de plugins esté disponible para todos los
demás módulos.

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin title="settings.gradle.kts"
        pluginManagement {
            includeBuild("convention-plugins") // Incluye el módulo de configuración de plugins
            repositories {
                mavenCentral()        // Repositorio Maven Central
                gradlePluginPortal()  // Portal de plugins de Gradle
            }
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy title="settings.gradle"
        pluginManagement {
            includeBuild 'convention-plugins' // Incluye el módulo de configuración de plugins
            repositories {
                mavenCentral()        // Repositorio Maven Central
                gradlePluginPortal()  // Portal de plugins de Gradle
            }
        }
        ```
    </TabItem>
</Tabs>

### ¿Qué es lo que estamos haciendo aquí?

1. **pluginManagement**: Esta sección configura la gestión de los plugins en Gradle. Es el lugar donde se puede incluir
configuraciones adicionales para gestionar cómo y desde dónde se descargan los plugins.

2. **includeBuild("convention-plugins")**: Aquí estamos incluyendo el módulo llamado `convention-plugins`. Este módulo
albergará las configuraciones comunes que serán aplicadas en los demás módulos. Siempre se cargará antes de los
demás módulos para garantizar que todas las configuraciones estén disponibles desde el principio.

3. **repositories**: Dentro de esta sección definimos los repositorios de donde se obtendrán los plugins. En este caso,
estamos usando dos repositorios:
 - `mavenCentral()`: El repositorio central de Maven, donde se encuentran numerosas dependencias y plugins.
 - `gradlePluginPortal()`: El repositorio oficial de Gradle para la gestión de plugins.

## Configuración de Convention Plugins

El siguiente paso es crear la estructura de directorios necesaria para los convention plugins. Estos plugins definirán
configuraciones comunes que otros módulos del proyecto podrán utilizar. En este caso, omitiremos el directorio de
pruebas, ya que no es necesario para este tipo de módulos.

### Crear la Estructura de Directorios

Primero, crea el directorio donde colocaremos el código del plugin de convenciones:

```bash
mkdir -p convention-plugins/src/main/kotlin
```

### Configuración del `settings.gradle.kts`

Dentro de la carpeta principal `convention-plugins`, debemos crear el archivo `settings.gradle.kts`. Este archivo se
encarga de configurar el nombre del proyecto, la gestión de plugins y la resolución de dependencias para todo el módulo
de convention plugins.

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin title="convention-plugins/settings.gradle.kts"
        rootProject.name = "convention-plugins"

        // Gestión de plugins y definición de repositorios para su descarga
        pluginManagement {
            repositories {
                mavenCentral()
                gradlePluginPortal()
            }
        }

        // Configuración para la resolución de dependencias
        @Suppress("UnstableApiUsage")
        dependencyResolutionManagement {
            repositories {
                mavenCentral()
                gradlePluginPortal()
            }

            // Definición de un catálogo centralizado de versiones de dependencias
            versionCatalogs {
                create("libs") {
                    from(files("../gradle/libs.versions.toml"))
                }
            }
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy title="convention-plugins/settings.gradle"
        rootProject.name = 'convention-plugins'

        // Gestión de plugins y definición de repositorios para su descarga
        pluginManagement {
            repositories {
                mavenCentral()
                gradlePluginPortal()
            }
        }

        // Configuración para la resolución de dependencias
        dependencyResolutionManagement {
            repositories {
                mavenCentral()
                gradlePluginPortal()
            }

            // Definición de un catálogo centralizado de versiones de dependencias
            versionCatalogs {
                libs {
                    from(files("../gradle/libs.versions.toml"))
                }
            }
        }
        ```
    </TabItem>
</Tabs>

### ¿Qué estamos haciendo aquí?

1. **`rootProject.name = "convention-plugins"`**: Aquí definimos el nombre del proyecto principal como
`convention-plugins`. Esto es importante para identificar y organizar correctamente el módulo dentro del entorno
Gradle.

2. **`pluginManagement`**: Esta sección configura los repositorios desde los cuales se descargarán los plugins que el
    proyecto necesita. Se utilizan los repositorios más comunes:
    - **`mavenCentral()`**: Uno de los repositorios más grandes para librerías y plugins Java y Kotlin.
    - **`gradlePluginPortal()`**: Repositorio especializado en plugins para Gradle.

3. **`dependencyResolutionManagement`**: Configuramos cómo se gestionará la resolución de dependencias en todo el
    proyecto:
    - **`repositoriesMode = RepositoriesMode.PREFER_SETTINGS`**: Esto asegura que las configuraciones de los
        repositorios en `settings.gradle.kts` tengan prioridad sobre las configuraciones en archivos `build.gradle.kts`
        de los subproyectos.
    - **Repositorios de dependencias**: Similar a la sección de gestión de plugins, se configuran los repositorios
        desde los cuales se descargarán las dependencias del proyecto, como `mavenCentral()` y `gradlePluginPortal()`.

4. **`versionCatalogs`**: Utilizamos un catálogo de versiones centralizado que se define en el archivo
    `libs.versions.toml`, ubicado fuera de la carpeta de `convention-plugins`. Este archivo externo permite gestionar
    versiones de dependencias de manera centralizada y reutilizable, lo que facilita la actualización de versiones en
    todos los módulos del proyecto de manera consistente.

## Mi Primer Plugin

<Definition title="Plugin" id="plugin-def">
    Un **plugin** es un componente de software que extiende o modifica la funcionalidad de un sistema existente. En el
    contexto de Gradle, un plugin es un conjunto de tareas, configuraciones y comportamientos específicos que se pueden
    aplicar a un proyecto para automatizar su construcción y administración.
</Definition>

Existen varias formas de crear plugins en Gradle. Una de ellas es mediante la definición de **convenciones**, que son
configuraciones comunes aplicadas a todos los subproyectos de un proyecto. En esta sección, crearemos un plugin que
establece convenciones para proyectos basados en la JVM. Mantendremos este plugin simple para comenzar, y lo
expandiremos gradualmente en las siguientes secciones.

### Creando el Plugin

Primero, vamos a crear el archivo para nuestro plugin. Dentro de la carpeta `convention-plugins/src/main/kotlin`, crea
un archivo llamado `jvm.conventions.gradle.kts` con el siguiente contenido:

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
        plugins {
            kotlin("jvm")
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy title="convention-plugins/src/main/kotlin/jvm.conventions.gradle"
        plugins {
            id 'org.jetbrains.kotlin.jvm'
        }
        ```
    </TabItem>
</Tabs>

Este archivo define las convenciones para proyectos basados en la JVM, específicamente aplicando el plugin de Kotlin
para JVM. Por ahora, simplemente estamos configurando el plugin de Kotlin, lo que permite la compilación de código
Kotlin para la JVM.

#### ¿Por qué no especificamos la versión del plugin?

Aunque es común ver el plugin configurado con una versión explícita, como se muestra a continuación:

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin
        plugins {
            kotlin("jvm") version "2.0.20"
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy
        plugins {
            id 'org.jetbrains.kotlin.jvm' version '2.0.20'
        }
        ```
    </TabItem>
</Tabs>

En este caso, no es necesario especificar la versión directamente, ya que hemos centralizado la gestión de versiones
utilizando el archivo `libs.versions.toml`. Esto asegura que todas las dependencias y plugins de Kotlin usen la misma
versión definida en ese archivo, facilitando su actualización en todo el proyecto.

### Usando el Plugin

Una vez que hemos creado nuestro plugin, necesitamos aplicarlo en los subproyectos donde queremos que se apliquen las
convenciones definidas. En este ejemplo, aplicaremos el plugin a los subproyectos `app` y `lib`.

#### En el subproyecto `app`:

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin title="app/build.gradle.kts"
        plugins {
            id("jvm.conventions")
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy title="app/build.gradle"
        plugins {
            id 'jvm.conventions'
        }
        ```
    </TabItem>
</Tabs>

#### En el subproyecto `lib`:

<Tabs>
    <TabItem value="Kotlin DSL" label="Kotlin DSL">
        ```kotlin title="lib/build.gradle.kts"
        plugins {
            id("jvm.conventions")
        }
        ```
    </TabItem>
    <TabItem value="Groovy DSL" label="Groovy DSL">
        ```groovy title="lib/build.gradle"
        plugins {
            id 'jvm.conventions'
        }
        ```
    </TabItem>
</Tabs>

### ¿Qué estamos logrando con esto?

Al aplicar el plugin `jvm.conventions` en los subproyectos `app` y `lib`, estamos asegurando que ambos proyectos sigan
las mismas configuraciones y convenciones definidas para proyectos JVM. Esto incluye la aplicación automática del plugin
de Kotlin para JVM en cada subproyecto. A medida que expandamos el plugin, podremos agregar más configuraciones y reglas
que se aplicarán de manera consistente en todos los subproyectos.

## Integrando Todo

Ahora que hemos creado y aplicado el plugin, lo que nos queda es construir el proyecto y asegurarnos de que las
convenciones definidas en el plugin se apliquen correctamente a todos los subproyectos.

Para construir el proyecto completo, ejecuta el siguiente comando desde la raíz del proyecto:

```bash
./gradlew build
```

Este comando ejecutará todas las tareas necesarias, incluyendo la compilación del código y la generación de los
artefactos (como archivos `.jar`) para cada uno de los subproyectos.

### Estructura Final del Proyecto

Después de ejecutar el comando de construcción, tu proyecto debería tener una estructura de directorios similar a la
siguiente:

```text
echo-app
├───.gradle                 // Directorio de archivos internos de Gradle
├───app                     // Subproyecto 'app'
│   ├───build               // Archivos generados por la compilación
│   │   ├───libs            // Artefactos (JARs) generados
│   │   └───tmp             // Archivos temporales utilizados durante la construcción
│   │       └───jar         // Archivos temporales para la tarea de empaquetado en JAR
│   └───src                 // Código fuente del subproyecto 'app'
│       ├───main            // Código principal de la aplicación
│       │   └───kotlin      // Código en Kotlin
│       └───test            // Código de pruebas
│           └───kotlin      // Pruebas en Kotlin
├───convention-plugins      // Módulo de los plugins de convención
│   ├───build               // Archivos generados para los plugins
│   └───src                 // Código fuente de los plugins de convención
│       └───main
│           └───kotlin      // Código en Kotlin para los plugins
├───gradle                  // Configuración del wrapper de Gradle
│   └───wrapper             // Archivos del Gradle wrapper
└───lib                     // Subproyecto 'lib'
    ├───build               // Archivos generados por la compilación del subproyecto 'lib'
    │   ├───libs            // Artefactos (JARs) generados
    │   └───tmp             // Archivos temporales para la construcción
    │       └───jar         // Archivos temporales para la tarea de empaquetado en JAR
    └───src                 // Código fuente del subproyecto 'lib'
        ├───main            // Código principal de la librería
        │   └───kotlin      // Código en Kotlin
        └───test            // Código de pruebas
            └───kotlin      // Pruebas en Kotlin
```

### ¿Qué hemos logrado?

Con este comando, hemos realizado las siguientes acciones:
- **Compilación del código**: Se ha compilado el código de los subproyectos `app` y `lib`, aplicando las convenciones de
compilación definidas en nuestro plugin `jvm.conventions`.
- **Generación de artefactos**: Para cada subproyecto, se han generado los archivos `.jar` en el directorio
`build/libs`.
- **Aplicación de convenciones**: El plugin `jvm.conventions` ha asegurado que ambos subproyectos sigan las mismas
reglas y configuraciones para la compilación en la JVM, centralizando la gestión y facilitando el mantenimiento a
medida que el proyecto crezca.

<References references={[
    {
        accessedDate: '9 de septiembre de 2024',
        siteOrAuthor: 'Gradle',
        title: 'Sharing dependency versions between projects',
        type: 'web',
        url: 'https://docs.gradle.org/current/userguide/platforms.html'
    },
    {
        accessedDate: '9 de septiembre de 2024',
        siteOrAuthor: 'Gradle',
        title: 'Composite Builds',
        type: 'web',
        url: 'https://docs.gradle.org/current/userguide/composite_builds.html'
    },
    {
        title: "Build Script Essentials",
        bookTitle: "Gradle in Action",
        pages: "75–104",
        location: "Shelter Island, NY",
        publisher: "Manning",
        year: "2014",
        type: "book",
        author: 'Muschko, Benjamin and Dockter, Hans',
    },
]}
/>
