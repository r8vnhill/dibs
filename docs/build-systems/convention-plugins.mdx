---
title: Convention plugins
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="echo-app-kt" />

En proyectos con m√∫ltiples m√≥dulos, es com√∫n y recomendable contar con un m√≥dulo dedicado a centralizar configuraciones compartidas que puedan ser reutilizadas por el resto del proyecto. En el contexto de **Gradle**, a este tipo de m√≥dulo se le conoce como un **convention plugin**, y tambi√©n se asocia con el patr√≥n conocido como **`buildSrc`**.

Estos plugins permiten consolidar configuraciones comunes, lo que mejora la consistencia entre m√≥dulos y simplifica el mantenimiento general del proyecto.

M√°s adelante profundizaremos en el uso de plugins personalizados dentro del ecosistema Gradle. Por ahora, comenzaremos con una configuraci√≥n b√°sica.

## üß© Configuraci√≥n de un Convention Plugin

Lo primero que debemos hacer es definir un m√≥dulo que se cargue **antes que los dem√°s**. Esto se configura en el archivo `settings.gradle.kts`, asegurando que el m√≥dulo de plugins est√© disponible para el resto del proyecto desde el inicio.

```kotlin showLineNumbers title="settings.gradle.kts"
// ...
pluginManagement {
    includeBuild("convention-plugins")
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}
```

<Explanation>
    - **[2‚Äì8]**: Esta secci√≥n configura la gesti√≥n de plugins en Gradle. Aqu√≠ es posible personalizar c√≥mo se resuelven y desde d√≥nde se descargan.
    - **[3]**: Se incluye el m√≥dulo `convention-plugins` como un *build externo* (`includeBuild`). Este m√≥dulo contendr√° las configuraciones comunes que ser√°n aplicadas autom√°ticamente en el resto del proyecto. Al estar declarado aqu√≠, se garantiza que se cargue antes que los dem√°s m√≥dulos.
    - **[4‚Äì7]**: Se definen los repositorios desde los cuales se obtendr√°n los plugins:
        - **[5]**: `mavenCentral()`: Repositorio central de Maven, ampliamente utilizado para dependencias y plugins.
        - **[6]**: `gradlePluginPortal()`: Repositorio oficial de Gradle para plugins.
</Explanation>

## üóÇÔ∏è Configuraci√≥n de Convention Plugins

El siguiente paso es crear la estructura de directorios necesaria para definir nuestros *convention plugins*. Estos plugins encapsulan configuraciones comunes que podr√°n ser reutilizadas en otros m√≥dulos del proyecto. 

En este ejemplo, omitiremos el directorio de pruebas, ya que este tipo de m√≥dulo no suele requerir c√≥digo testeable: su prop√≥sito es √∫nicamente configurar comportamientos comunes.

### üèóÔ∏è Crear la Estructura de Directorios

Primero, crea el directorio donde ubicaremos el c√≥digo fuente del plugin de convenciones:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        New-Item -Path "convention-plugins\src\main\kotlin" `
            -ItemType "Directory" `
            -Force
        ```

        <Explanation>  
            Este comando crea el directorio `convention-plugins\src\main\kotlin`, incluyendo todas las carpetas intermedias si no existen. El par√°metro `-ItemType "Directory"` indica que se debe crear un directorio, y `-Force` asegura que no falle si alguna parte del path ya existe. La barra invertida invertida (`` ` ``) al final de cada l√≠nea permite dividir el comando en varias l√≠neas para mayor legibilidad.  
        </Explanation>
    </TabItem>
    <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
        ```powershell
        md "convention-plugins\src\main\kotlin" -f
        ```

        <Explanation>  
            Este comando utiliza el alias `md` (abreviatura de `mkdir`) para crear el directorio `convention-plugins\src\main\kotlin`, incluyendo cualquier carpeta intermedia que no exista. El par√°metro `-f` (de *force*) evita errores si el directorio ya existe. Esta es una forma m√°s corta y com√∫nmente usada en PowerShell para crear directorios.  
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        mkdir -p convention-plugins/src/main/kotlin
        ```

        <Explanation>  
            Este comando crea el directorio `convention-plugins/src/main/kotlin` y, gracias al par√°metro `-p`, tambi√©n crea autom√°ticamente cualquier directorio intermedio que no exista. Es una forma segura y habitual de crear estructuras de carpetas en sistemas basados en Unix (Linux y macOS), sin generar errores si los directorios ya existen.  
        </Explanation>
    </TabItem>
</BoxedTabs>

### ‚öôÔ∏è Configuraci√≥n de `settings.gradle.kts`

Dentro de la carpeta principal `convention-plugins`, debemos crear el archivo `settings.gradle.kts`. Este archivo configura el nombre del proyecto, la gesti√≥n de plugins y la resoluci√≥n de dependencias para este m√≥dulo.

```kotlin showLineNumbers title="convention-plugins/settings.gradle.kts"
rootProject.name = "convention-plugins"

// Gesti√≥n de plugins y definici√≥n de repositorios para su descarga
pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

// Configuraci√≥n para la resoluci√≥n de dependencias
@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    // Definici√≥n de un cat√°logo centralizado de versiones de dependencias
    versionCatalogs {
        create("libs") {
            from(files("../gradle/libs.versions.toml"))
        }
    }
}
```

<Explanation>
    Este archivo `settings.gradle.kts` define la configuraci√≥n principal del m√≥dulo `convention-plugins`. En la l√≠nea 1 se establece el nombre del proyecto, necesario para que Gradle lo identifique correctamente como un build independiente.

    La secci√≥n `pluginManagement` (l√≠neas 4‚Äì9) indica desde qu√© repositorios deben descargarse los plugins utilizados en este m√≥dulo. Aqu√≠ se usan `mavenCentral()` y `gradlePluginPortal()`, que cubren la mayor√≠a de los plugins comunes en proyectos Java y Kotlin.

    La secci√≥n `dependencyResolutionManagement` (l√≠neas 12‚Äì25) configura c√≥mo se resolver√°n las dependencias declaradas en los archivos `build.gradle.kts` del m√≥dulo. Se especifican los mismos repositorios, y adem√°s se declara un cat√°logo de versiones (`versionCatalogs`) en la l√≠nea 20, apuntando al archivo `libs.versions.toml` ubicado fuera del m√≥dulo. Este cat√°logo permite mantener versiones centralizadas y consistentes en todos los m√≥dulos del proyecto.

    :::note `@Suppress("UnstableApiUsage")`

    Se incluye la anotaci√≥n `@Suppress("UnstableApiUsage")` porque la propiedad `repositories` dentro de `dependencyResolutionManagement` se considera **inestable** en las versiones actuales de Gradle, y su uso genera un warning en compilaciones con Kotlin DSL.

    :::
</Explanation>

<details>
    <summary>¬øPor qu√© aparece el warning sobre "UnstableApiUsage"?</summary>

    En el archivo `settings.gradle.kts` del m√≥dulo `convention-plugins`, se utiliza la anotaci√≥n `@Suppress("UnstableApiUsage")` antes de la configuraci√≥n de `dependencyResolutionManagement`. Esto se debe a que, en las versiones actuales de Gradle, al invocar `repositories` dentro de `dependencyResolutionManagement`, se genera una advertencia indicando que la funci√≥n est√° marcada como inestable con la anotaci√≥n `@Incubating`.

    La anotaci√≥n `@Incubating` en Gradle se√±ala que una caracter√≠stica o API est√° en fase de incubaci√≥n, lo que significa que a√∫n est√° en desarrollo y podr√≠a sufrir cambios en futuras versiones. Aunque estas funcionalidades son utilizables, es importante ser consciente de su estado y de la posibilidad de modificaciones. Para suprimir las advertencias relacionadas con el uso de APIs inestables, se emplea `@Suppress("UnstableApiUsage")`, lo que permite mantener el c√≥digo limpio y sin advertencias innecesarias.

    Es recomendable revisar peri√≥dicamente la documentaci√≥n oficial de Gradle para estar al tanto del estado de las APIs utilizadas y ajustar el c√≥digo en consecuencia a medida que evolucionan hacia versiones estables.
</details>

Tu secci√≥n est√° muy bien enfocada, pero puede beneficiarse de una redacci√≥n un poco m√°s fluida, una explicaci√≥n clara del prop√≥sito del archivo, y una descripci√≥n de por qu√© se usa `kotlin-dsl` y `libs.kotlin.gradle.plugin`.

### üõ†Ô∏è Crear el archivo de construcci√≥n

Dentro de la carpeta `convention-plugins`, crea un archivo de construcci√≥n llamado `build.gradle.kts`. Este archivo define c√≥mo se compilar√° y configurar√° el m√≥dulo de plugins de convenci√≥n.

A continuaci√≥n, el contenido b√°sico para iniciar el m√≥dulo:

```kotlin showLineNumbers title="convention-plugins/build.gradle.kts"
plugins {
    `kotlin-dsl`
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    implementation(libs.kotlin.gradle.plugin)
}
```

<Explanation>
    Este archivo `build.gradle.kts` define c√≥mo se construye el m√≥dulo `convention-plugins`:

    - **[2]** `kotlin-dsl`: Aplica el plugin de Kotlin DSL, necesario para escribir scripts de Gradle en Kotlin y habilitar autocompletado y validaci√≥n est√°tica dentro de los archivos `.gradle.kts`.
    - **[5‚Äì8]** `repositories`: Declara los repositorios desde los cuales se resolver√°n los plugins y dependencias que se utilicen en este m√≥dulo. Se incluyen `mavenCentral()` y `gradlePluginPortal()` por compatibilidad y disponibilidad.
    - **[11]** `implementation(libs.kotlin.gradle.plugin)`: Agrega como dependencia el plugin de Gradle para Kotlin. Esta l√≠nea asume que el proyecto est√° utilizando un cat√°logo de versiones (`libs.versions.toml`) donde se encuentra declarada `kotlin.gradle.plugin`, lo cual permite mantener las versiones de dependencias centralizadas y consistentes.
</Explanation>

Tu secci√≥n est√° muy bien estructurada y clara. Solo har√≠a **peque√±as mejoras de estilo y fluidez** para que la redacci√≥n sea m√°s natural y did√°ctica, especialmente al introducir el concepto de convenciones y la progresi√≥n del ejemplo.

## üß™ Mi Primer Plugin

<Definition title="Plugin" id="plugin-def">
    Un **plugin** es un componente de software que extiende o modifica la funcionalidad de un sistema existente.  
    En el contexto de Gradle, un plugin es un conjunto de tareas, configuraciones y comportamientos que se pueden aplicar a un proyecto para automatizar su construcci√≥n y administraci√≥n.
</Definition>

Gradle permite definir plugins de distintas formas. Una de las m√°s utilizadas es mediante **plugins de convenci√≥n**, que encapsulan configuraciones comunes aplicadas autom√°ticamente a todos los subproyectos de un proyecto.

En esta secci√≥n, crearemos un plugin de convenci√≥n b√°sico para proyectos basados en la JVM. Comenzaremos con una configuraci√≥n m√≠nima y la iremos expandiendo en las siguientes secciones.

### ‚ú® Creando el Plugin

Primero, vamos a crear el archivo que contendr√° nuestro plugin. Dentro de la carpeta `convention-plugins/src/main/kotlin`, crea un archivo llamado `jvm.conventions.gradle.kts` con el siguiente contenido:

```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/jvm.conventions.gradle.kts"
plugins {
    kotlin("jvm")
}

kotlin {
    jvmToolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
```

<Explanation>
    Este archivo define un **plugin de convenci√≥n** que aplica autom√°ticamente el plugin `kotlin("jvm")` y configura la versi√≥n del compilador de Java a trav√©s del bloque `jvmToolchain`.

    - **[2]**: Aplica el plugin de Kotlin para la JVM. Al estar definido en un archivo de convenci√≥n, se aplicar√° de forma impl√≠cita a todos los m√≥dulos que utilicen este plugin.
    - **[5‚Äì9]**: Configura la herramienta de compilaci√≥n (`jvmToolchain`) para usar Java 21 como versi√≥n del lenguaje. Esto garantiza que todos los proyectos que usen este plugin compilen con la misma versi√≥n de Java, asegurando compatibilidad y consistencia.
</Explanation>

#### ‚ùì ¬øPor qu√© no especificamos la versi√≥n del plugin?

Aunque es com√∫n declarar el plugin con una versi√≥n expl√≠cita, como en el siguiente ejemplo:

```kotlin showLineNumbers
plugins {
    kotlin("jvm") version "2.1.20"
}
```

en este caso **no es necesario**, ya que hemos centralizado la gesti√≥n de versiones mediante el archivo `libs.versions.toml`. Esta estrategia asegura que todas las dependencias y plugins de Kotlin utilicen la misma versi√≥n, facilitando su actualizaci√≥n y manteniendo coherencia en todo el proyecto.

### üì¶ Usando el Plugin

Una vez creado nuestro plugin de convenciones, podemos aplicarlo en los subproyectos donde queramos que se utilicen esas configuraciones comunes. En este ejemplo, lo aplicaremos en dos subproyectos: `app` y `lib`.

Primero, necesitamos crear las carpetas correspondientes para cada subproyecto. Puedes hacerlo con los siguientes comandos seg√∫n tu sistema operativo:

<BoxedTabs>
    <TabItem value="Windows" label="Windows">
        ```powershell
        "src\main\kotlin" | ForEach-Object { 
            "app\$_", "lib\$_" | ForEach-Object { 
                New-Item -Path $_ -ItemType "Directory" -Force 
            }
        }
        ```

        <Explanation>
            Este fragmento utiliza dos bucles `ForEach-Object` anidados para crear de forma concisa los directorios `app\src\main\kotlin` y `lib\src\main\kotlin`.

            - En el primer pipeline (`"src\main\kotlin"`), se define el segmento de ruta com√∫n que ser√° a√±adido a cada m√≥dulo.
            - En el segundo pipeline (`"app\$_", "lib\$_"`), se generan las rutas completas para ambos subproyectos combinando los nombres de los m√≥dulos (`app`, `lib`) con la ruta com√∫n.
            - `New-Item` crea los directorios y el par√°metro `-Force` asegura que no se generen errores si alguno ya existe.

            Este patr√≥n permite mantener el c√≥digo limpio y f√°cilmente extensible en caso de que se agreguen m√°s m√≥dulos o rutas.
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell
        "src\main\kotlin" | % { "app\$_", "lib\$_" | % { md $_ -f } }
        ```
        
        <Explanation>
            Este comando usa una forma abreviada y funcional de crear m√∫ltiples directorios en PowerShell utilizando el alias `%` para `ForEach-Object`.

            - `"src\main\kotlin"` es la ruta com√∫n que se desea agregar a los m√≥dulos `app` y `lib`.
            - En el primer `%`, se toma ese valor (`$_`) y se construyen dos rutas: `"app\$_"` y `"lib\$_"`, es decir, `app\src\main\kotlin` y `lib\src\main\kotlin`.
            - El segundo `%` recorre esas rutas y ejecuta `md` (alias de `mkdir`) con el par√°metro `-f` (alias de `-Force`), que crea los directorios y no lanza error si ya existen.

            Es una forma compacta y efectiva de crear varias rutas en un solo comando.
        </Explanation>
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        printf "%s\n" app lib | xargs -I{} mkdir -pv "{}/src/main/kotlin"
        ```

        <Explanation>
            Este comando crea las carpetas `app/src/main/kotlin` y `lib/src/main/kotlin` de forma compacta y funcional:

            - `printf "%s\n" app lib` imprime cada nombre de m√≥dulo (`app` y `lib`) en una l√≠nea separada.
            - `xargs -I{}` toma cada l√≠nea y reemplaza `{}` en el comando `mkdir -pv "{}/src/main/kotlin"`.
            - `mkdir -p` crea todos los directorios intermedios si no existen.
            - `-v` (verbose) muestra en consola qu√© directorios se est√°n creando.

            Esto asegura que se creen correctamente dos rutas independientes, evitando el error com√∫n de que se cree una carpeta llamada `"app lib"` si se usa `echo` sin separaci√≥n de l√≠neas.

            :::warning Nota

            Si no se imprime nada en consola, es porque las carpetas ya exist√≠an. En ese caso, `mkdir -p` no realiza ninguna acci√≥n y suprime cualquier salida, incluso con `-v`.

            :::
        </Explanation>

    </TabItem>
</BoxedTabs>


#### En el subproyecto `app`:

```kotlin showLineNumbers title="app/build.gradle.kts"
plugins {
    id("jvm.conventions")
}
```

#### En el subproyecto `lib`:

```kotlin showLineNumbers title="lib/build.gradle.kts"
plugins {
    id("jvm.conventions")
}
```

<Explanation>
    Al aplicar el plugin `jvm.conventions` en los subproyectos `app` y `lib`, aseguramos que ambos compartan una base com√∫n de configuraciones para proyectos basados en la JVM. En su forma actual, este plugin aplica autom√°ticamente el plugin de Kotlin para JVM y configura la versi√≥n del compilador.

    A medida que el plugin crezca, podremos extenderlo con reglas, convenciones y dependencias adicionales que se aplicar√°n de forma coherente en todos los subproyectos, facilitando el mantenimiento y promoviendo la consistencia del proyecto.
</Explanation>

## üîç Verificar que el Plugin se Aplica Correctamente

Una vez aplicado el plugin en los subproyectos, puedes verificar que las configuraciones se hayan aplicado correctamente utilizando algunos comandos de Gradle:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        .\gradlew --quiet app:dependencies | Select-String "kotlin"
        ```

        <Explanation>
            Este comando permite verificar si el plugin `kotlin("jvm")` fue aplicado correctamente en el subproyecto `app`.

            - `.\gradlew app:dependencies` imprime el √°rbol de dependencias del subproyecto.
            - `--quiet` reduce el ruido en la salida, omitiendo mensajes como `"Task :convention-plugins:checkKotlinGradlePluginConfigurationErrors SKIPPED"`.
            - `| Select-String "kotlin"` filtra la salida mostrando solo las l√≠neas relacionadas con Kotlin, lo que permite confirmar si las dependencias del compilador y est√°ndar de Kotlin est√°n presentes.

            Esto es √∫til para validar que el plugin de convenciones est√° funcionando correctamente.

            :::note Nota

            Como se us√≥ la opci√≥n `--quiet`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

            :::
        </Explanation>
    </TabItem>
    <TabItem value="Windows (corto)" label="Windows (corto)">
        ```powershell
        .\gradlew -q app:dependencies | sls "kotlin"
        ```

        <Explanation>
            Este comando compacto verifica si el plugin `kotlin("jvm")` fue aplicado correctamente en el subproyecto `app`:

            - `.\gradlew -q app:dependencies` imprime las dependencias de forma silenciosa, omitiendo mensajes irrelevantes.
            - `sls "kotlin"` es un alias de `Select-String` y filtra la salida para mostrar solo las l√≠neas que contienen la palabra `kotlin`.

            Esto permite confirmar r√°pidamente que las dependencias de Kotlin est√°n presentes sin ruido adicional.

            :::note Nota

            Como se us√≥ la opci√≥n `-q`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

            :::
        </Explanation>
    </TabItem>
    <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            ./gradlew --quiet app:dependencies | grep kotlin
            ```

            <Explanation>
                Este comando permite verificar si el plugin `kotlin("jvm")` fue aplicado correctamente al subproyecto `app`:

                - `./gradlew --quiet app:dependencies` ejecuta la tarea que imprime el √°rbol de dependencias del subproyecto, y la opci√≥n `--quiet` reduce la salida omitiendo tareas informativas y mensajes innecesarios.
                - `| grep kotlin` filtra la salida para mostrar √∫nicamente las l√≠neas que contienen la palabra `kotlin`, facilitando la identificaci√≥n de dependencias del compilador, est√°ndar u otras herramientas de Kotlin.

                Este comando es √∫til para confirmar que el plugin de convenciones est√° funcionando como se espera.

                :::note Nota

                Al usar la opci√≥n `--quiet`, no se mostrar√°n mensajes durante la ejecuci√≥n del comando, a menos que haya errores o advertencias. Por eso, podr√≠a parecer que no ocurre nada, pero en realidad se est√° filtrando la salida para mostrar solo las dependencias relacionadas con Kotlin. ¬°Paciencia y confianza! üòâ

                :::
            </Explanation>
    </TabItem>
</BoxedTabs>

Si la salida del comando muestra dependencias relacionadas con Kotlin, significa que el plugin se aplic√≥ correctamente y que las configuraciones comunes est√°n siendo compartidas entre los subproyectos.
En caso contrario, es probable que el plugin no se haya aplicado correctamente, por lo que conviene revisar los pasos anteriores.

### üß± Estructura Final del Proyecto

Despu√©s de ejecutar el comando de construcci√≥n, tu proyecto deber√≠a tener una estructura de directorios similar a la
siguiente:

```mermaid
%% title: ./echo
graph LR
    A["üìÅ ./echo"]
    A --> A1["üìÅ .gradle"]
    A --> A2["üìÅ app"]
    A2 --> A2a["üìÅ src"]
    A2a --> A2a1["üìÅ main"]
    A2a1 --> A2a1k["üìÅ kotlin"]
    A2a --> A2a2["üìÅ test"]
    A2a2 --> A2a2k["üìÅ kotlin"]

    A --> A3["üìÅ convention-plugins"]
    A3 --> A3a["üìÅ .gradle"]
    A3 --> A3b["üìÅ build"]
    A3b --> A3b1["üìÅ classes"]
    A3b1 --> A3b1j["üìÅ java"]
    A3b1j --> A3b1jm["üìÅ main"]
    A3b1j --> A3b1jt["üìÅ test"]
    A3b --> A3b2["üìÅ resources"]
    A3b2 --> A3b2m["üìÅ main"]
    A3b2 --> A3b2t["üìÅ test"]
    A3 --> A3c["üìÅ src"]
    A3c --> A3c1["üìÅ main"]
    A3c1 --> A3c1k["üìÅ kotlin"]

    A --> A4["üìÅ gradle"]
    A4 --> A4w["üìÅ wrapper"]

    A --> A5["üìÅ lib"]
    A5 --> A5s["üìÅ src"]
    A5s --> A5sm["üìÅ main"]
    A5sm --> A5smk["üìÅ kotlin"]
    A5s --> A5st["üìÅ test"]
    A5st --> A5stk["üìÅ kotlin"]

```

## üéØ Conclusiones

A lo largo de esta secci√≥n, exploramos c√≥mo crear un plugin de convenciones en Gradle para proyectos multi-m√≥dulo. Vimos c√≥mo configurar un m√≥dulo especial dedicado a definir reglas comunes, c√≥mo estructurar sus carpetas y archivos, y c√≥mo aplicarlo f√°cilmente en los subproyectos.

Este enfoque permite mantener la coherencia en el uso de herramientas como Kotlin, JDK, y librer√≠as compartidas, al tiempo que reduce el esfuerzo de mantenimiento y mejora la escalabilidad del proyecto.

### üîë Puntos clave

- Un **convention plugin** permite encapsular y reutilizar configuraciones comunes entre m√≥dulos.
- Gradle permite incluir estos plugins mediante `includeBuild`, asegurando que se carguen antes que el resto del proyecto.
- Utilizar un **cat√°logo de versiones centralizado** (`libs.versions.toml`) simplifica la gesti√≥n de dependencias.
- La estructura de carpetas debe seguir el layout est√°ndar de `src/main/kotlin`, incluso para los plugins.
- Es posible verificar la aplicaci√≥n de configuraciones con herramientas como `dependencies`, `grep`, o `Select-String`.

### üß∞ ¬øQu√© nos llevamos?

El uso de plugins de convenci√≥n es una herramienta poderosa para mejorar la mantenibilidad de proyectos con m√∫ltiples m√≥dulos. Nos permite encapsular buenas pr√°cticas, aplicar configuraciones consistentes de forma autom√°tica, y reducir la duplicaci√≥n de c√≥digo entre subproyectos.

Adoptar este enfoque desde las primeras etapas de un proyecto contribuye a mantener un entorno de desarrollo m√°s ordenado, coherente y f√°cil de evolucionar.

## üìñ Referencias

### üî• Recomendadas

- üåê Sharing build logic between subprojects Sample. (s.¬†f.). Recuperado 27 de marzo de 2025, de https://docs.gradle.org/current/samples/sample_convention_plugins.html
