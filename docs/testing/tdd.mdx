---
title: TDD by Example
---
import GithubRepoLink from "../../src/components/GithubRepoLink";
import Definition from "../../src/components/Definition";
import ReadingTime from "../../src/components/ReadingTime";

<ReadingTime/>
<GithubRepoLink repo="example-based-testing" user="r8vnhill"/>

<br/>
## Características básicas

Supongamos que estamos diseñando un juego llamado *Bucket Monsters* (o *Bakémon*), similar a Pokémon, donde podemos tener diferentes criaturas con distintas características. Comenzaremos con un requisito básico: todos los *Bakémon* deben tener un nombre.

### Paso 1: Escribir una prueba que falle

Un enfoque útil para estructurar el desarrollo es definir primero la interfaz. Esto ayuda a visualizar los casos de prueba que necesitamos escribir.

Primero, creamos una interfaz para nuestros *Bakémon*:

```kotlin title="test-basics/src/main/kotlin/cl/ravenhill/bakemon/Bakemon.kt"
package cl.ravenhill.bakemon

interface Bakemon {
    val name: String
}
```

Ahora, escribimos un test para validar la característica del nombre:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
package cl.ravenhill.bakemon

import io.kotest.core.spec.style.FreeSpec

class BakemonTest : FreeSpec({
    "A Bakémon" - {
        "should have a name" { }
    }
})
```

Si corremos este test, **pasaría**, pero aquí es donde detectamos un problema: ¡el test no está implementado! Es crucial que una prueba falle inicialmente para asegurar que estamos probando la lógica correctamente.

Ahora, implementemos un test más completo para asegurar que falle antes de escribir la funcionalidad.

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
package cl.ravenhill.bakemon

import io.kotest.core.spec.style.FreeSpec
import io.kotest.matchers.shouldBe

private const val BAKEMON_NAME = "Bigachu"

class BakemonTest : FreeSpec({
    "A Bakémon" - {
        "should have a name" {
            val bigachu: Bakemon = TODO()
            bigachu.name shouldBe BAKEMON_NAME
        }
    }
})
```

Si corremos este test ahora, **fallará**, que es justo lo que esperamos. El test está correctamente diseñado para capturar el comportamiento que queremos implementar más adelante.

### Paso 2: Hacer que la prueba pase

Lo primero que debemos hacer es eliminar el `TODO()`. No podemos testear directamente la interfaz, ya que no podemos crear instancias de ella. En lugar de crear de inmediato una jerarquía completa de subtipos de *Bakémon*, utilizaremos un **objeto anónimo** para prototipar la implementación de la interfaz de manera rápida y eficiente.

<Definition title="Objeto Anónimo">
    Un **objeto anónimo** es una expresión que permite crear una instancia de una interfaz o clase sin darle un nombre explícito. Es una forma útil de implementar interfaces de manera provisional y directa.

    **Ejemplo:**
    ```kotlin
    object : MouseAdapter() { /* ... */ }
    ```
    - No pueden contener métodos abstractos.
    - Su ciclo de vida está vinculado al contexto donde se crea: cuando el contexto desaparece, también lo hace el objeto anónimo.
</Definition>

Veamos cómo lo implementamos en el código de prueba:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
class BakemonTest : FreeSpec({
    "A Bakémon" - {
        "should have a name" {
            val bigachu: Bakemon = object : Bakemon {
                override val name: String = BAKEMON_NAME
            }
            bigachu.name shouldBe BAKEMON_NAME
        }
    }
})
```

Aquí creamos un objeto anónimo que implementa la interfaz `Bakemon` y, mediante el uso de `override`, asignamos el nombre `"Bigachu"`. Esto nos permite pasar la prueba sin necesidad de definir toda la jerarquía de clases todavía, asegurando que nuestro test verifique correctamente la funcionalidad básica.

### Paso 3: Refactorización

El siguiente paso es transformar el **objeto anónimo** en una **clase nombrada**, lo que hará nuestro código más reutilizable y escalable. Dado que la funcionalidad del nombre es común a todos los *Bakémon*, podemos aprovechar una **clase abstracta** que defina esta propiedad común. Esto nos permitirá implementar más adelante las características específicas de cada tipo de *Bakémon*.

#### Creación de la clase abstracta

Primero, creamos la clase `AbstractBakemon`, que implementa la interfaz `Bakemon` y define la propiedad común `name`:

```kotlin title="test-basics/src/main/kotlin/cl/ravenhill/bakemon/AbstractBakemon.kt"
package cl.ravenhill.bakemon

abstract class AbstractBakemon : Bakemon {
    override val name = "Bigachu"
}
```

#### Actualización de la prueba

A continuación, modificamos nuestro test para utilizar la nueva clase abstracta en lugar del objeto anónimo:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
class BakemonTest : FreeSpec({
    "A Bakémon" - {
        "should have a name" {
            val bigachu: Bakemon = object : AbstractBakemon() {}
            bigachu.name shouldBe BAKEMON_NAME
        }
    }
})
```

En este punto, nuestro test sigue funcionando, pero el valor `"Bigachu"` está codificado en la clase abstracta. Queremos hacer esta clase más flexible para que otros *Bakémon* puedan tener nombres diferentes. Para lograrlo, modificamos la clase abstracta para recibir el nombre como un parámetro:

```kotlin title="test-basics/src/main/kotlin/cl/ravenhill/bakemon/AbstractBakemon.kt"
abstract class AbstractBakemon(override val name: String) : Bakemon
```

#### Refactorización del test

Finalmente, actualizamos nuestro test para usar esta nueva versión de `AbstractBakemon`, pasando el nombre como argumento:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
class BakemonTest : FreeSpec({
    "A Bakémon" - {
        "should have a name" {
            val bigachu: Bakemon = object : AbstractBakemon(BAKEMON_NAME) {}
            bigachu.name shouldBe BAKEMON_NAME
        }
    }
})
```

### ¿Qué hemos hecho?

1. Hemos refactorizado el objeto anónimo para crear una **clase abstracta** `AbstractBakemon`, facilitando la implementación de futuras clases específicas de *Bakémon*.
2. Permitimos que el nombre sea un **parámetro**, lo que proporciona mayor flexibilidad y reutilización de la clase abstracta.
3. Actualizamos el test para reflejar estos cambios, manteniendo su propósito original.

Este patrón es fundamental para estructurar bien una biblioteca, permitiendo extender funcionalidades de manera ordenada.

## Combate en Bakémon

Vamos a implementar el sistema de **combate** entre *Bakémon*. En esta primera versión, no consideraremos las ventajas o desventajas de los tipos, solo nos enfocaremos en la mecánica de **puntos de salud**. Esto nos permitirá avanzar con las bases del combate, para luego añadir más complejidad en futuras iteraciones.

### Paso 1: Escribir una prueba que falle

Como siempre, comenzamos siguiendo el enfoque **Test-Driven Development (TDD)**. Escribiremos una prueba que valide que todos los *Bakémon* tienen un atributo de **puntos de salud**.

1. Primero, añadimos la nueva propiedad a la interfaz `Bakemon`:

    ```kotlin title="test-basics/src/main/kotlin/cl/ravenhill/bakemon/Bakemon.kt"
    interface Bakemon {
        val name: String
        val healthPoints: Int
    }
    ```

2. A continuación, escribimos un test que verifique la existencia de esta nueva propiedad en los *Bakémon*:

    ```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
    // ...
    private const val BAKEMON_HEALTH = 100

    class BakemonTest : FreeSpec({
        "A Bakémon" - {
            "should have a name" {
                val bigachu: Bakemon = createBakemon()
                bigachu.name shouldBe BAKEMON_NAME
            }

            "should have health points" {
                val bigachu: Bakemon = createBakemon()
                bigachu.healthPoints shouldBe BAKEMON_HEALTH
            }
        }
    })

    private fun createBakemon(): Bakemon = object : AbstractBakemon(BAKEMON_NAME) {
        override val healthPoints: Int = TODO()
    }
    ```

### Paso 2: Hacer que la prueba pase

El siguiente paso en nuestro enfoque **TDD** es hacer que la prueba falle y luego implementarla correctamente. Para esto, necesitamos definir la propiedad `healthPoints` en nuestra clase de *Bakémon*.

Para esto, basta con completar la implementación del método `createBakemon`:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
private fun createBakemon(): Bakemon = object : AbstractBakemon(BAKEMON_NAME) {
    override val healthPoints: Int = BAKEMON_HEALTH
}
```

### Paso 3: Refactorización

Para mejorar nuestro código, comenzamos modificando la **clase abstracta** `AbstractBakemon` para incluir la propiedad `healthPoints`:

```kotlin title="test-basics/src/main/kotlin/cl/ravenhill/bakemon/AbstractBakemon.kt"
abstract class AbstractBakemon(
    override val name: String,
    override val healthPoints: Int
) : Bakemon
```

Y actualizamos la función `createBakemon` para reflejar esta mejora:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
private fun createBakemon(): Bakemon = object : AbstractBakemon(BAKEMON_NAME, BAKEMON_HEALTH) {}
```

Hasta este punto, el código es más claro, pero seguimos repitiendo la creación del *Bakémon* en cada test individual. Podemos refactorizar esto para mejorar la reutilización del código.

### Uso de Hooks: `beforeTest` y `afterTest`

Kotest permite ejecutar código antes y después de cada caso de prueba, lo que facilita la preparación de objetos comunes para varios tests. Esto se logra con los **hooks** `beforeTest` y `afterTest`, que ayudan a evitar la repetición innecesaria.

Ejemplo simple de hooks:

```kotlin
class HooksTest : FreeSpec({
    beforeTest {
        println("Before test")
    }

    afterTest { (test, result) ->
        println("Finished spec with result $result")
    }
})
```

Ahora, aplicamos este patrón para crear el *Bakémon* una sola vez antes de cada test:

```kotlin title="test-basics/src/test/kotlin/cl/ravenhill/bakemon/BakemonTest.kt"
class BakemonTest : FreeSpec({
    lateinit var bigachu: Bakemon  // Variable compartida entre tests

    beforeTest {
        bigachu = createBakemon()  // Inicialización común para todos los tests
    }

    "A Bakémon" - {
        "should have a name" {
            bigachu.name shouldBe BAKEMON_NAME
        }

        "should have health points" {
            bigachu.healthPoints shouldBe BAKEMON_HEALTH
        }
    }
})
```

## ¿Qué logramos en esta lección?

En esta lección, hemos cubierto los fundamentos de **Test-Driven Development (TDD)** utilizando un enfoque por ejemplo, específicamente en el contexto de un juego llamado *Bucket Monsters* o *Bakémon*. Al seguir los pasos de **TDD**, logramos lo siguiente:

1. **Escribir pruebas fallidas**: Iniciamos escribiendo casos de prueba que no pasan, ayudándonos a identificar la funcionalidad que necesitamos implementar.
2. **Prototipado rápido con objetos anónimos**: Usamos objetos anónimos para crear implementaciones rápidas y temporales de nuestra interfaz `Bakemon`, facilitando la verificación de funcionalidades sin crear clases completas.
3. **Refactorización hacia clases abstractas**: Refactorizamos el código para transformar el objeto anónimo en una clase abstracta (`AbstractBakemon`), permitiendo la reutilización de código y la extensión de funcionalidades.
4. **Uso de lifecycle hooks (`beforeTest`)**: Introducimos hooks para inicializar nuestros objetos antes de cada prueba, evitando duplicación de código.

### Lo que sigue
En la próxima lección, exploraremos cómo **testear excepciones** dentro de nuestros tests, aplicando el mismo enfoque de **TDD** para validar escenarios donde las funciones pueden fallar o arrojar errores. Esto nos permitirá profundizar en la robustez y manejo de errores en nuestros tests.