---
title: Data-Driven Testing en JUnit
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

JUnit 5 proporciona soporte para pruebas parametrizadas a través de su módulo `junit-jupiter-params`. Este enfoque es ligeramente diferente de Kotest en términos de configuración y sintaxis, pero ofrece las mismas capacidades fundamentales: ejecutar la misma prueba con diferentes conjuntos de datos.

### Ejemplo en JUnit 5

Imaginemos que queremos realizar las mismas validaciones de contraseñas que hicimos con Kotest. Con JUnit 5, podemos utilizar la anotación `@ParameterizedTest` para definir la prueba y `@CsvSource` para proporcionar los datos de prueba.

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class PasswordValidatorTest {

    @ParameterizedTest
    @CsvSource({
        "'P@ssw0rd', true",
        "'P@ssw0r', false",
        "'p@ssw0rd', false",
        "'P@SSW0RD', false",
        "'P@ssword', false",
        "'Password1', false"
    })
    void testIsValidPassword(String password, boolean expected) {
        boolean result = PasswordValidator.isValid(password);
        assertEquals(expected, result);
    }
}
```

## Diferencias Clave

### 1. **Sintaxis**

- En **Kotest**, las pruebas con datos se definen usando `withData`, que permite definir una tabla de datos o listas y realizar múltiples verificaciones en un solo bloque de prueba. Esto facilita anidar pruebas y organizar casos de prueba complejos.
- En **JUnit 5**, se usa `@ParameterizedTest` junto con `@CsvSource` o `@MethodSource` para definir los casos de prueba. Este enfoque es más explícito en términos de anotaciones y puede ser más fácil de entender para quienes ya están familiarizados con JUnit.

### 2. **Manejo de Errores**

- **Kotest** permite continuar ejecutando todas las pruebas, incluso si alguna falla, proporcionando un reporte completo de los errores al final. Además, las herramientas de Kotest son más expresivas, ofreciendo mensajes de error claros.
- En **JUnit 5**, si un caso de prueba falla, ese caso es reportado individualmente. Sin embargo, el manejo de errores en JUnit puede resultar más básico en comparación con Kotest, que tiene soporte nativo para `shouldBe` y otras funciones de validación más concisas.

### 3. **Anidamiento de Pruebas**

- **Kotest** sobresale en el anidamiento de `withData`. Esto permite probar múltiples combinaciones de datos sin tener que duplicar la lógica de las pruebas. En el caso de políticas de validación complejas, el anidamiento es muy útil.

- En **JUnit 5**, el anidamiento no es tan flexible como en Kotest. Para casos simples de pruebas con datos, JUnit funciona bien, pero para combinaciones más complejas de datos de prueba, es necesario usar otros enfoques más manuales, como `@MethodSource` con bucles anidados.

### `@MethodSource`
