---
title: Data-Driven Testing
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink repo="data-driven-testing-kt" user="r8vnhill"/>
<RepoClone repoName="data-driven-testing-kt"/>
<ModuleSetup module='ddt' task='setupDdtModule'>
    ```kotlin showLineNumbers   
    val baseName = "ddt"
    val baseDir = rootProject.file(baseName)
    val printError: (String) -> Unit = System.err::println

    tasks.register("setupDdtModule") {
        group = "setup"
        description = "Creates the base module and files for the Data-Driven Testing project"

        doLast {
            createModule()
            createBuildFile()
        }
    }

    fun createModule() = when {
        baseDir.exists() -> printError("The base directory already exists")
        baseDir.mkdirs() -> println("The base directory was created successfully")
        else -> printError("The base directory could not be created")
    }

    fun createBuildFile() = baseDir.resolve("build.gradle.kts").run {
        if (exists()) printError("The build file already exists")
        else writeText("// Intentionally left blank\n")
    }
    ```
</ModuleSetup>

En el desarrollo de **bibliotecas de software**, es fundamental asegurar que nuestras funciones y métodos funcionen correctamente con una variedad de entradas. Esto garantiza que otrxs desarrolladorxs puedan confiar en nuestra biblioteca para manejar casos diversos sin errores.

Sin embargo, escribir pruebas unitarias para cada posible entrada puede volverse tedioso y propenso a errores. Aquí es donde las **Pruebas basadas en datos** (Data-Driven Testing, DDT) entran en juego.

En esta lección, exploraremos cómo implementar **Data-Driven Testing** utilizando **Kotest** en Kotlin, para mejorar la eficiencia y la calidad de nuestras pruebas.

## ¿Qué es el Data-Driven Testing?

El **Data-Driven Testing** es una técnica que separa los datos de prueba (entradas y salidas esperadas) de la lógica de prueba. En lugar de escribir una prueba individual para cada caso, podemos escribir una sola prueba que se ejecuta múltiples veces con diferentes datos.

## Caso de Estudio: Biblioteca de Validación de Contraseñas

Supongamos que estamos desarrollando una biblioteca de software para validar contraseñas según ciertas políticas de seguridad. Nuestra función `isValidPassword` debe verificar si una contraseña cumple con los siguientes criterios:

- **Longitud mínima**: Al menos 8 caracteres.
- **Contiene números**: Debe incluir al menos un dígito.
- **Contiene letras mayúsculas y minúsculas**: Debe incluir ambas.
- **Contiene caracteres especiales**: Debe incluir al menos un carácter especial (e.g., `!@#\$%^&*`).

Queremos asegurarnos de que nuestra función se comporte correctamente con una variedad de contraseñas válidas e inválidas.

### Especificación BDD

Podemos expresar los criterios de validación de contraseñas utilizando una especificación BDD:

```kotlin showLineNumbers
"Given a password" - {
    "when validating it" - {
        "then it should return true for a strong password" {}
        "then it should return false for a weak password" - {
            "if it has less than 8 characters" {}
            "if it has no uppercase letter" {}
            "if it has no lowercase letter" {}
            "if it has no digits" {}
            "if it has no special characters" {}
        }
    }
}
```

### Implementación de las pruebas


### Implementación de la Función de Validación

```kotlin showLineNumbers title="src/main/kotlin/com/github/tu_usuario/validator/PasswordValidator.kt"
package com.github.tu_usuario.validator

object PasswordValidator {

    private val specialChars = "!@#\$%^&*"

    fun isValidPassword(password: String): Boolean {
        if (password.length < 8) return false
        if (!password.any { it.isDigit() }) return false
        if (!password.any { it.isLowerCase() }) return false
        if (!password.any { it.isUpperCase() }) return false
        if (!password.any { it in specialChars }) return false
        return true
    }
}
```

### Implementación Manual de Pruebas

#### Paso 1: Crear el Módulo de Pruebas

<details>
    <summary>
        Crear el módulo <code>password-validator</code> y configurar el entorno de pruebas.
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            mkdir -p 'password-validator\src\test\kotlin'
            '// Intentionally left blank' > 'password-validator\build.gradle.kts'
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            mkdir -p password-validator/src/test/kotlin
            echo "// Intentionally left blank" > password-validator/build.gradle.kts
            ```
        </TabItem>
    </BoxedTabs>

    Asegúrate de agregar el módulo al archivo `settings.gradle.kts`:

    ```kotlin showLineNumbers title="settings.gradle.kts"
    include(":password-validator")
    ```
</details>

#### Paso 2: Escribir Pruebas Manualmente

Creamos una prueba para validar contraseñas individuales:

```kotlin showLineNumbers title="password-validator/src/test/kotlin/com/github/tu_usuario/validator/PasswordValidatorTest.kt"
package com.github.tu_usuario.validator

import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class PasswordValidatorTest : StringSpec({

    "should return true for valid password" {
        val password = "Password1!"
        PasswordValidator.isValidPassword(password) shouldBe true
    }

    "should return false for password without digits" {
        val password = "Password!"
        PasswordValidator.isValidPassword(password) shouldBe false
    }

    // Más pruebas individuales...
})
```

Como puedes ver, escribir una prueba para cada caso puede volverse repetitivo.

### Implementación de Data-Driven Testing Manualmente

Podemos mejorar nuestras pruebas iterando sobre una lista de contraseñas:

```kotlin showLineNumbers title="password-validator/src/test/kotlin/com/github/tu_usuario/validator/PasswordValidatorTest.kt"
package com.github.tu_usuario.validator

import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class PasswordValidatorTest : StringSpec({

    "should validate passwords correctly" {
        val testCases = listOf(
            "Password1!" to true,
            "password1!" to false, // Sin mayúsculas
            "PASSWORD1!" to false, // Sin minúsculas
            "Password!" to false,  // Sin dígitos
            "Password1" to false,  // Sin caracteres especiales
            "Pass1!" to false,     // Menos de 8 caracteres
        )

        testCases.forEach { (password, expected) ->
            PasswordValidator.isValidPassword(password) shouldBe expected
        }
    }
})
```

### Implementación con Kotest y `withData`

Kotest proporciona funciones como `forAll` y `withData` para simplificar aún más nuestras pruebas.

#### Paso 1: Agregar la Dependencia de Kotest DataTest

En tu archivo `build.gradle.kts`, agrega:

```kotlin showLineNumbers title="password-validator/build.gradle.kts"
dependencies {
    testImplementation("io.kotest:kotest-runner-junit5:5.9.1")
    testImplementation("io.kotest:kotest-framework-datatest:5.9.1")
}
```

#### Paso 2: Reescribir las Pruebas con `withData`

```kotlin showLineNumbers title="password-validator/src/test/kotlin/com/github/tu_usuario/validator/PasswordValidatorTest.kt"
package com.github.tu_usuario.validator

import io.kotest.core.spec.style.StringSpec
import io.kotest.datatest.withData
import io.kotest.matchers.shouldBe

class PasswordValidatorTest : StringSpec({

    "should validate passwords correctly" {
        withData(
            "Password1!" to true,
            "password1!" to false,
            "PASSWORD1!" to false,
            "Password!" to false,
            "Password1" to false,
            "Pass1!" to false,
        ) { (password, expected) ->
            PasswordValidator.isValidPassword(password) shouldBe expected
        }
    }
})
```

<Explanation>
- **Uso de `withData`**: Simplifica la iteración sobre los casos de prueba.
- **Desestructuración**: Utilizamos `(password, expected)` para extraer los valores del par.
- **Legibilidad**: El código es más limpio y fácil de mantener.
</Explanation>

### Ampliando las Pruebas con `withData` Anidados

Supongamos que queremos probar múltiples políticas de validación, como diferentes longitudes mínimas o conjuntos de caracteres especiales.

#### Paso 1: Modificar la Función para Aceptar Parámetros

```kotlin showLineNumbers title="src/main/kotlin/com/github/tu_usuario/validator/PasswordValidator.kt"
package com.github.tu_usuario.validator

object PasswordValidator {

    fun isValidPassword(
        password: String,
        minLength: Int = 8,
        requireDigit: Boolean = true,
        requireLowerCase: Boolean = true,
        requireUpperCase: Boolean = true,
        requireSpecialChar: Boolean = true,
        specialChars: String = "!@#\$%^&*"
    ): Boolean {
        if (password.length < minLength) return false
        if (requireDigit && !password.any { it.isDigit() }) return false
        if (requireLowerCase && !password.any { it.isLowerCase() }) return false
        if (requireUpperCase && !password.any { it.isUpperCase() }) return false
        if (requireSpecialChar && !password.any { it in specialChars }) return false
        return true
    }
}
```

#### Paso 2: Escribir Pruebas con `withData` Anidados

```kotlin showLineNumbers title="password-validator/src/test/kotlin/com/github/tu_usuario/validator/PasswordValidatorTest.kt"
package com.github.tu_usuario.validator

import io.kotest.core.spec.style.StringSpec
import io.kotest.datatest.withData
import io.kotest.matchers.shouldBe

class PasswordValidatorTest : StringSpec({

    "should validate passwords with different policies" {
        val passwords = listOf(
            "Password1!",
            "password1!",
            "PASSWORD1!",
            "Password!",
            "Password1",
            "Pass1!"
        )

        val minLengths = listOf(6, 8, 10)
        val requireDigits = listOf(true, false)
        val requireSpecialChars = listOf(true, false)

        withData(passwords) { password ->
            withData(minLengths) { minLength ->
                withData(requireDigits) { requireDigit ->
                    withData(requireSpecialChars) { requireSpecialChar ->
                        val isValid = PasswordValidator.isValidPassword(
                            password,
                            minLength = minLength,
                            requireDigit = requireDigit,
                            requireSpecialChar = requireSpecialChar
                        )
                        // Realiza las aserciones necesarias o imprime los resultados
                    }
                }
            }
        }
    }
})
```

<Explanation>
- **`withData` Anidados**: Generan combinaciones de los datos proporcionados.
- **Flexibilidad**: Podemos probar múltiples configuraciones de políticas de validación.
- **Cobertura Amplia**: Aseguramos que nuestra función maneja correctamente diferentes escenarios.
</Explanation>

## Consideraciones y Buenas Prácticas

- **Organiza tus datos**: Si los conjuntos de datos son grandes, considera externalizarlos o estructurarlos mejor.
- **Nombra tus pruebas**: Kotest permite nombrar cada caso, lo que facilita identificar fallos.
- **Evita la complejidad excesiva**: Anidar muchos `withData` puede hacer que las pruebas sean difíciles de seguir.

## ¿Qué aprendimos?

En esta lección, exploramos cómo implementar **Data-Driven Testing** en el contexto del desarrollo de una **biblioteca de validación de contraseñas**. Aprendimos a:

- **Implementar DDT manualmente**: Usando bucles para iterar sobre casos de prueba.
- **Utilizar Kotest para DDT**: Simplificando nuestras pruebas con `withData` y `withData` anidados.
- **Mejorar la eficiencia**: Reduciendo la duplicación de código y facilitando el mantenimiento.
- **Aplicar buenas prácticas**: Organizando nuestros datos y pruebas para mayor claridad.

## Ejercicio

<Exercise title="Validar Números de Teléfono">
    Implementa una función `isValidPhoneNumber` que valide números de teléfono según las siguientes reglas:

    - Debe tener exactamente 10 dígitos.
    - Solo puede contener números.
    - No puede contener espacios ni caracteres especiales.

    Escribe pruebas utilizando **Data-Driven Testing** con Kotest para validar múltiples casos de números de teléfono válidos e inválidos.

    <Solution>
        ```kotlin showLineNumbers title="src/main/kotlin/com/github/tu_usuario/validator/PhoneNumberValidator.kt"
        package com.github.tu_usuario.validator

        object PhoneNumberValidator {

            fun isValidPhoneNumber(phoneNumber: String): Boolean {
                return phoneNumber.matches(Regex("^\\d{10}\$"))
            }
        }
        ```

        ```kotlin showLineNumbers title="src/test/kotlin/com/github/tu_usuario/validator/PhoneNumberValidatorTest.kt"
        package com.github.tu_usuario.validator

        import io.kotest.core.spec.style.StringSpec
        import io.kotest.datatest.withData
        import io.kotest.matchers.shouldBe

        class PhoneNumberValidatorTest : StringSpec({

            "should validate phone numbers correctly" {
                withData(
                    "1234567890" to true,
                    "0987654321" to true,
                    "12345" to false,
                    "12345678901" to false,
                    "123456789a" to false,
                    "123 456 7890" to false,
                    "123-456-7890" to false
                ) { (phoneNumber, expected) ->
                    PhoneNumberValidator.isValidPhoneNumber(phoneNumber) shouldBe expected
                }
            }
        })
        ```
    </Solution>
</Exercise>

---

<References references={[
    {
        publisher: "Manning Publications",
        pages: "177-200",
        type: "book",
        title: "Testing Kotlin code",
        author: "John Doe",
        year: "2020",
        bookTitle: "Kotlin in Action",
    },
    {
        title: "Kotest Documentation",
        url: "https://kotest.io/docs/framework/datatest.html",
        type: "web",
        accessed: "2023-10",
    },
]}/>

<References references={[
    {
        publisher: "Addison-Wesley",
        pages: "277–345",
        type: "book",
        title: "18. Test Strategy Patterns",
        author: "Gerard Meszaros",
        year: "2007",
        bookTitle: "xUnit test patterns: refactoring test code",
    },
]}/>