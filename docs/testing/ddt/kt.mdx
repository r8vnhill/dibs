---
title: Data-Driven Testing
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink repo="data-driven-testing-kt" user="r8vnhill"/>
<RepoClone repoName="data-driven-testing-kt"/>
<ModuleSetup module='ddt' task='setupDdtModule'>
    ```kotlin showLineNumbers   
    val baseName = "ddt"
    val baseDir = rootProject.file(baseName)
    val printError: (String) -> Unit = System.err::println

    tasks.register("setupDdtModule") {
        group = "setup"
        description = "Creates the base module and files for the Data-Driven Testing project"

        doLast {
            createModule()
            createBuildFile()
        }
    }

    fun createModule() = when {
        baseDir.exists() -> printError("The base directory already exists")
        baseDir.mkdirs() -> println("The base directory was created successfully")
        else -> printError("The base directory could not be created")
    }

    fun createBuildFile() = baseDir.resolve("build.gradle.kts").run {
        if (exists()) printError("The build file already exists")
        else writeText("// Intentionally left blank\n")
    }
    ```
</ModuleSetup>

En el desarrollo de **bibliotecas de software**, es fundamental asegurar que nuestras funciones y métodos funcionen correctamente con una variedad de entradas. Esto garantiza que otrxs desarrolladorxs puedan confiar en nuestra biblioteca para manejar casos diversos sin errores.

Sin embargo, escribir pruebas unitarias para cada posible entrada puede volverse tedioso y propenso a errores. Aquí es donde las **pruebas basadas en datos** (Data-Driven Testing, DDT), **pruebas parametrizadas** o **pruebas de tabla** (table-driven testing) pueden ser útiles. Estas técnicas permiten ejecutar una prueba con múltiples conjuntos de datos, lo que facilita la validación de diferentes escenarios con un solo caso de prueba.

En esta lección, exploraremos cómo implementar **Data-Driven Testing** utilizando **Kotest** en Kotlin, para mejorar la eficiencia y la calidad de nuestras pruebas.

## ¿Qué es el Data-Driven Testing?

El **Data-Driven Testing** es una técnica que separa los datos de prueba (entradas y salidas esperadas) de la lógica de prueba. En lugar de escribir una prueba individual para cada caso, podemos escribir una sola prueba que se ejecuta múltiples veces con diferentes datos.

## Caso de Estudio: Biblioteca de Validación de Contraseñas

Supongamos que estamos desarrollando una biblioteca de software para validar contraseñas según ciertas políticas de seguridad. Nuestra función `isValidPassword` debe verificar si una contraseña cumple con los siguientes criterios:

- **Longitud mínima**: Al menos 8 caracteres.
- **Contiene números**: Debe incluir al menos un dígito.
- **Contiene letras mayúsculas y minúsculas**: Debe incluir ambas.
- **Contiene caracteres especiales**: Debe incluir al menos un carácter especial (e.g., `!@#\$%^&*`).

Queremos asegurarnos de que nuestra función se comporte correctamente con una variedad de contraseñas válidas e inválidas.

### Especificación BDD

Podemos expresar los criterios de validación de contraseñas utilizando una especificación BDD:

```kotlin showLineNumbers
"Given a password" - {
    "when validating it" - {
        "then it should return true for a strong password" {}
        "then it should return false for a weak password" - {
            "if it has less than 8 characters" {}
            "if it has no uppercase letter" {}
            "if it has no lowercase letter" {}
            "if it has no digits" {}
            "if it has no special characters" {}
        }
    }
}
```

### Implementación de las pruebas

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        isValid("P@ssw0rd").shouldBeTrue()
        isValid("P@ssw0r").shouldBeFalse()
        isValid("p@ssw0rd").shouldBeFalse()
        isValid("P@SSW0RD").shouldBeFalse()
        isValid("P@ssword").shouldBeFalse()
        isValid("Password1").shouldBeFalse()
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="ddt/src/test/kotlin/com/github/username/validator/PasswordValidatorTest.kt"
        package com.github.username.validator

        import com.github.username.validator.PasswordValidator.isValid
        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.booleans.shouldBeFalse
        import io.kotest.matchers.booleans.shouldBeTrue

        class PasswordValidatorTest : FreeSpec({
            "Given a password" - {
                "when validating it" - {
                    "then it should return true for a strong password" {
                        isValid("P@ssw0rd").shouldBeTrue()
                    }
                    "then it should return false for a weak password" - {
                        "if it has less than 8 characters" {
                            isValid("P@ssw0r").shouldBeFalse()
                        }
                        "if it has no uppercase letter" {
                            isValid("p@ssw0rd").shouldBeFalse()
                        }
                        "if it has no lowercase letter" {
                            isValid("P@SSW0RD").shouldBeFalse()
                        }
                        "if it has no digits" {
                            isValid("P@ssword").shouldBeFalse()
                        }
                        "if it has no special characters" {
                            isValid("Password1").shouldBeFalse()
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

### Implementación de la Función de Validación

```kotlin showLineNumbers title="ddt/src/main/kotlin/com/github/username/validator/PasswordValidator.kt"
package com.github.username.validator

object PasswordValidator {

    private const val SPECIAL_CHARACTERS = "!@#$%^&*()-+"

    fun isValid(password: String) = 
        password.length >= 8 &&
            password.any { it.isDigit() } &&
            password.any { it.isLowerCase() } &&
            password.any { it.isUpperCase() } &&
            password.any { it in SPECIAL_CHARACTERS }
}
```

## El problema con nuestras pruebas

Aunque nuestras pruebas actuales son claras y concisas, su estructura se vuelve repetitiva y difícil de mantener a medida que aumentamos los casos de prueba. Cada prueba individual introduce redundancia en la lógica y el código, lo que complica su escalabilidad. Aquí es donde DDT ofrece una solución eficiente, permitiendo que un solo conjunto de pruebas cubra múltiples escenarios de manera organizada y sin duplicación innecesaria.

## Implementación manual de DDT

La implementación manual de DDT es sencilla y flexible, lo que permite crear pruebas reutilizables para distintos conjuntos de datos. Este enfoque ayuda a simplificar los casos de prueba, especialmente cuando múltiples entradas deben ser validadas de la misma manera. Después de ver este ejemplo manual, compararemos el enfoque con la solución más elegante proporcionada por Kotest, que facilita la implementación de DDT.

Crearemos una prueba para validar contraseñas individuales:

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        val testCases = listOf(
            "P@ssw0rd" to true,
            "P@ssw0r" to false,
            "p@ssw0rd" to false,
            "P@SSW0RD" to false,
            "P@ssword" to false,
            "Password1" to false
        )
        testCases.forEach { (password, expected) ->
            isValid(password) shouldBe expected
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers
        package com.github.usernamevalidator

        import com.github.usernamevalidator.PasswordValidator.isValid
        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.booleans.shouldBeFalse
        import io.kotest.matchers.booleans.shouldBeTrue
        import io.kotest.matchers.shouldBe

        class PasswordValidatorTest : FreeSpec({
            "Given a password" - {
                "when validating it" - {
                    "then it should return true if it is strong and false if it is weak" {
                        val testCases = listOf(
                            "P@ssw0rd" to true,
                            "P@ssw0r" to false,
                            "p@ssw0rd" to false,
                            "P@SSW0RD" to false,
                            "P@ssword" to false,
                            "Password1" to false
                        )
                        testCases.forEach { (password, expected) ->
                            isValid(password) shouldBe expected
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Lista de Casos de Prueba**: Almacenamos los casos de prueba en una lista de pares `(password, expected)`. Este patrón es común en DDT.
    - **Iteración sobre los Casos**: Usamos `forEach` para ejecutar la función de validación para cada caso y verificar el resultado.
</Explanation>

## Implementación con Kotest y `withData`

Kotest ofrece una forma más elegante y concisa de implementar DDT a través de la función `withData`. Esta función permite definir una tabla de datos y ejecutar una lógica de prueba para cada valor, mejorando la legibilidad del código y la organización de los casos de prueba. A diferencia de la implementación manual, `withData` sigue ejecutando todos los casos de prueba incluso si uno de ellos falla, lo que genera un reporte más completo con todos los fallos.

### Paso 1: Agregar la Dependencia de Kotest DataTest

Primero, debemos agregar la dependencia de **Kotest DataTest** en nuestro catálogo de versiones.

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```toml showLineNumbers
        [libraries]
        kotest-datatest = { module = "io.kotest:kotest-framework-datatest", version.ref = "kotest" }

        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest"]
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```toml showLineNumbers
        [versions]
        kotlin = "2.0.21"
        data-driven-testing = "1.0.0"
        detekt = "1.23.7"
        kotest = "5.9.1"

        [libraries]
        kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
        detekt-formatting = { module = "io.gitlab.arturbosch.detekt:detekt-formatting", version.ref = "detekt" }
        kotest-runner-junit5 = { module = "io.kotest:kotest-runner-junit5", version.ref = "kotest" }
        kotest-datatest = { module = "io.kotest:kotest-framework-datatest", version.ref = "kotest" }

        [plugins]
        detekt = { id = "io.gitlab.arturbosch.detekt", version.ref = "detekt" }

        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest"]
        ```
    </TabItem>
</BoxedTabs>

El uso de **bundles** nos permite agrupar varias dependencias relacionadas, como las herramientas de Kotest, para simplificar la gestión de dependencias. Esto evita modificaciones dispersas en los archivos de configuración y facilita la actualización o incorporación de nuevas dependencias de forma centralizada.

### Paso 2: Reescribir las Pruebas con `withData`

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        withData(
            "P@ssw0rd" to true,
            "P@ssw0r" to false,
            "p@ssw0rd" to false,
            "P@SSW0RD" to false,
            "P@ssword" to false,
            "Password1" to false
        ) { (password, expected) ->
            isValid(password) shouldBe expected
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers
        package com.github.username.validator

        import com.github.username.validator.PasswordValidator.isValid
        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.datatest.withData
        import io.kotest.matchers.booleans.shouldBeFalse
        import io.kotest.matchers.booleans.shouldBeTrue
        import io.kotest.matchers.shouldBe

        class PasswordValidatorTest : FreeSpec({
            "Given a password" - {
                "when validating it" - {
                    "then it should return true if it is strong and false if it is weak" - {
                        withData(
                            "P@ssw0rd" to true,
                            "P@ssw0r" to false,
                            "p@ssw0rd" to false,
                            "P@SSW0RD" to false,
                            "P@ssword" to false,
                            "Password1" to false
                        ) { (password, expected) ->
                            isValid(password) shouldBe expected
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Utilizamos `withData` para definir una tabla de datos con los casos de prueba y ejecutar la lógica de prueba para cada valor. Esto simplifica la estructura de las pruebas y mejora la legibilidad del código.
</Explanation>

## Ampliando las Pruebas con `withData` Anidados

Para validar múltiples políticas de contraseñas (como longitudes mínimas y conjuntos de caracteres especiales), podemos usar **`withData` anidados** en Kotest, lo que permite probar combinaciones de casos sin duplicar lógica de prueba.

### Paso 1: Modificar la Función para Aceptar Parámetros

```kotlin showLineNumbers title="src/main/kotlin/com/github/tu_usuario/validator/PasswordValidator.kt"
package com.github.tu_usuario.validator

object PasswordValidator {

    private const val SPECIAL_CHARACTERS = "!@#$%^&*()-+"

    fun isValid(
        password: String,
        minLength: Int = 8,
        requireDigit: Boolean = true,
        requireLowerCase: Boolean = true,
        requireUpperCase: Boolean = true,
        requireSpecialChar: Boolean = true
    ) = password.length >= minLength &&
            (!requireDigit || password.any { it.isDigit() }) &&
            (!requireLowerCase || password.any { it.isLowerCase() }) &&
            (!requireUpperCase || password.any { it.isUpperCase() }) &&
            (!requireSpecialChar || password.any { it in SPECIAL_CHARACTERS })
}
```

:::warning **Número de Parámetros**

Este diseño tiene un **problema** de demasiados parámetros, lo que puede reducir la legibilidad y hacer que el código sea más difícil de mantener. Siguiendo los principios de **código limpio**, debemos limitar el número de parámetros a tres como máximo. Una alternativa sería usar un **objeto de configuración** o el **builder pattern** para encapsular las opciones de validación.

Para no desviarnos del objetivo principal de la lección, mantendremos la función como está por simplicidad.

:::

#### Paso 2: Escribir Pruebas con `withData` Anidados

```kotlin showLineNumbers title="password-validator/src/test/kotlin/com/github/tu_usuario/validator/PasswordValidatorTest.kt"
package com.github.tu_usuario.validator

import io.kotest.core.spec.style.StringSpec
import io.kotest.datatest.withData
import io.kotest.matchers.shouldBe

class PasswordValidatorTest : StringSpec({

    "should validate passwords with different policies" {
        val passwords = listOf(
            "Password1!",
            "password1!",
            "PASSWORD1!",
            "Password!",
            "Password1",
            "Pass1!"
        )

        val minLengths = listOf(6, 8, 10)
        val requireDigits = listOf(true, false)
        val requireSpecialChars = listOf(true, false)

        withData(passwords) { password ->
            withData(minLengths) { minLength ->
                withData(requireDigits) { requireDigit ->
                    withData(requireSpecialChars) { requireSpecialChar ->
                        val isValid = PasswordValidator.isValidPassword(
                            password,
                            minLength = minLength,
                            requireDigit = requireDigit,
                            requireSpecialChar = requireSpecialChar
                        )
                        // Realiza las aserciones necesarias o imprime los resultados
                    }
                }
            }
        }
    }
})
```

<Explanation>
- **`withData` Anidados**: Generan combinaciones de los datos proporcionados.
- **Flexibilidad**: Podemos probar múltiples configuraciones de políticas de validación.
- **Cobertura Amplia**: Aseguramos que nuestra función maneja correctamente diferentes escenarios.
</Explanation>

## Consideraciones y Buenas Prácticas

- **Organiza tus datos**: Si los conjuntos de datos son grandes, considera externalizarlos o estructurarlos mejor.
- **Nombra tus pruebas**: Kotest permite nombrar cada caso, lo que facilita identificar fallos.
- **Evita la complejidad excesiva**: Anidar muchos `withData` puede hacer que las pruebas sean difíciles de seguir.

## ¿Qué aprendimos?

En esta lección, exploramos cómo implementar **Data-Driven Testing** en el contexto del desarrollo de una **biblioteca de validación de contraseñas**. Aprendimos a:

- **Implementar DDT manualmente**: Usando bucles para iterar sobre casos de prueba.
- **Utilizar Kotest para DDT**: Simplificando nuestras pruebas con `withData` y `withData` anidados.
- **Mejorar la eficiencia**: Reduciendo la duplicación de código y facilitando el mantenimiento.
- **Aplicar buenas prácticas**: Organizando nuestros datos y pruebas para mayor claridad.

## Ejercicio

<Exercise title="Validar Números de Teléfono">
    Implementa una función `isValidPhoneNumber` que valide números de teléfono según las siguientes reglas:

    - Debe tener exactamente 10 dígitos.
    - Solo puede contener números.
    - No puede contener espacios ni caracteres especiales.

    Escribe pruebas utilizando **Data-Driven Testing** con Kotest para validar múltiples casos de números de teléfono válidos e inválidos.

    <Solution>
        ```kotlin showLineNumbers title="src/main/kotlin/com/github/tu_usuario/validator/PhoneNumberValidator.kt"
        package com.github.tu_usuario.validator

        object PhoneNumberValidator {

            fun isValidPhoneNumber(phoneNumber: String): Boolean {
                return phoneNumber.matches(Regex("^\\d{10}\$"))
            }
        }
        ```

        ```kotlin showLineNumbers title="src/test/kotlin/com/github/tu_usuario/validator/PhoneNumberValidatorTest.kt"
        package com.github.tu_usuario.validator

        import io.kotest.core.spec.style.StringSpec
        import io.kotest.datatest.withData
        import io.kotest.matchers.shouldBe

        class PhoneNumberValidatorTest : StringSpec({

            "should validate phone numbers correctly" {
                withData(
                    "1234567890" to true,
                    "0987654321" to true,
                    "12345" to false,
                    "12345678901" to false,
                    "123456789a" to false,
                    "123 456 7890" to false,
                    "123-456-7890" to false
                ) { (phoneNumber, expected) ->
                    PhoneNumberValidator.isValidPhoneNumber(phoneNumber) shouldBe expected
                }
            }
        })
        ```
    </Solution>
</Exercise>

---

<References references={[
    {
        publisher: "Manning Publications",
        pages: "177-200",
        type: "book",
        title: "Testing Kotlin code",
        author: "John Doe",
        year: "2020",
        bookTitle: "Kotlin in Action",
    },
    {
        title: "Kotest Documentation",
        url: "https://kotest.io/docs/framework/datatest.html",
        type: "web",
        accessed: "2023-10",
    },
]}/>

<References references={[
    {
        publisher: "Addison-Wesley",
        pages: "277–345",
        type: "book",
        title: "18. Test Strategy Patterns",
        author: "Gerard Meszaros",
        year: "2007",
        bookTitle: "xUnit test patterns: refactoring test code",
    },
]}/>