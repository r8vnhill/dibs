---
title: Data-Driven Testing en otros frameworks
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import DdtJunit from "./ddt-junit.mdx"

## .NET: NUnit

En **C#**, el framework de pruebas **NUnit** proporciona soporte robusto para **Data-Driven Testing (DDT)** mediante el uso de atributos como `[TestCase]` y `[TestCaseSource]`. Al igual que en **Kotest** y **JUnit 5**, NUnit permite ejecutar múltiples casos de prueba con diferentes conjuntos de datos sin duplicar código, mejorando la reutilización y el mantenimiento de las pruebas.

### Ejemplo en NUnit con `[TestCase]`

En este ejemplo, utilizamos el atributo `[TestCase]` para probar diferentes valores de entrada en un solo método de prueba:

```csharp
using NUnit.Framework;
using System;

[TestFixture]
public class BakemonTest
{
    [TestCase("Bigachu", -100)]
    [TestCase("Psygoose", -1)]
    [TestCase("Bigachu", 101)]
    [TestCase("Psygoose", 1000)]
    public void TestInvalidHealthPoints(string name, int invalidHp)
    {
        Bakemon bakemon = new Bakemon(name, 100);
        Assert.Throws<ArgumentException>(() => bakemon.SetCurrentHealthPoints(invalidHp));
    }
}
```

### Ejemplo en NUnit con `[TestCaseSource]`

Para casos más complejos o cuando los datos de prueba se obtienen dinámicamente, se puede utilizar `[TestCaseSource]`:

```csharp
using NUnit.Framework;
using System;
using System.Collections;

[TestFixture]
public class BakemonTest
{
    static IEnumerable TestCases
    {
        get
        {
            yield return new TestCaseData("Bigachu", -100);
            yield return new TestCaseData("Psygoose", -1);
            yield return new TestCaseData("Bigachu", 101);
            yield return new TestCaseData("Psygoose", 1000);
        }
    }

    [Test, TestCaseSource(nameof(TestCases))]
    public void TestInvalidHealthPoints(string name, int invalidHp)
    {
        Bakemon bakemon = new Bakemon(name, 100);
        Assert.Throws<ArgumentException>(() => bakemon.SetCurrentHealthPoints(invalidHp));
    }
}
```

### Similitudes entre Kotest y NUnit

1. **Data-Driven Testing**: Ambos frameworks permiten ejecutar el mismo test con diferentes conjuntos de datos, utilizando técnicas de DDT.
2. **Reutilización del Código**: La lógica del test permanece constante, mientras que los datos de entrada varían, evitando la duplicación de código.
3. **Manejo de Múltiples Casos**: Permiten probar una amplia gama de escenarios de manera eficiente, mejorando el mantenimiento y la escalabilidad de las pruebas.

### Diferencias entre Kotest y NUnit

1. **Sintaxis**:
 - **Kotest**: Utiliza funciones como `withData` para una sintaxis más declarativa y fluida.
 - **NUnit**: Utiliza atributos como `[TestCase]` y `[TestCaseSource]`, lo que puede parecer más estructurado y menos flexible en comparación con Kotest.
2. **Flexibilidad en la Fuente de Datos**:
 - **Kotest**: Permite una mayor flexibilidad al combinar diferentes conjuntos de datos de manera anidada.
 - **NUnit**: Requiere el uso de múltiples atributos o métodos fuente (`TestCaseSource`) para combinar datos complejos.
3. **Estilo de Pruebas**:
 - **Kotest**: Ofrece múltiples estilos de especificación (BDD, FreeSpec, etc.), permitiendo una mayor personalización en la estructura de las pruebas.
 - **NUnit**: Sigue una estructura más tradicional basada en métodos de prueba dentro de clases de prueba.

### Ejemplo en NUnit con múltiples parámetros usando `[TestCaseSource]`

```csharp
using NUnit.Framework;
using System;
using System.Collections;

[TestFixture]
public class BakemonTest
{
    static IEnumerable TestCases
    {
        get
        {
            yield return new TestCaseData("Bigachu", -100);
            yield return new TestCaseData("Psygoose", -1);
            yield return new TestCaseData("Bigachu", 101);
            yield return new TestCaseData("Psygoose", 1000);
        }
    }

    [Test, TestCaseSource(nameof(TestCases))]
    public void TestInvalidHealthPoints(string name, int invalidHp)
    {
        Bakemon bakemon = new Bakemon(name, 100);
        Assert.Throws<ArgumentException>(() => bakemon.SetCurrentHealthPoints(invalidHp));
    }
}
```

### Comparación Final

| **Aspecto**                | **Kotest**                                           | **NUnit**                                                |
|----------------------------|------------------------------------------------------|----------------------------------------------------------|
| **Data-Driven Testing**    | `withData`                                           | `[ParameterizedTest]` + `[TestCase]`, `[TestCaseSource]` |
| **Combinación de Valores** | Fácil con `withData`                                 | Requiere múltiples atributos o `TestCaseSource`          |
| **Sintaxis**               | Declarativa y fluida                                 | Basada en atributos y métodos                            |
| **Estilo de Pruebas**      | Soporte para múltiples estilos (BDD, FreeSpec, etc.) | Tradicional, basado en métodos de prueba                 |

---

<DdtJunit />

---

## Python: PyTest

En **PyTest**, el **Data-Driven Testing (DDT)** se implementa utilizando la función `@pytest.mark.parametrize`, que permite definir un conjunto de valores de entrada para ejecutar un test repetidamente. Al igual que en **Kotest**, esta técnica permite evitar la duplicación de código al probar múltiples entradas con la misma lógica de prueba.

### Ejemplo en PyTest con `@pytest.mark.parametrize`

En este ejemplo, utilizamos `@pytest.mark.parametrize` para probar diferentes valores de entrada:

```python
import pytest

def test_invalid_health_points():
    @pytest.mark.parametrize("invalid_hp", [-100, -1, 101, 1000])
    def inner_test(invalid_hp):
        bakemon = Bakemon("Bigachu", 100)
        with pytest.raises(ValueError):
            bakemon.set_current_health_points(invalid_hp)
```

### Similitudes entre Kotest y PyTest

1. **Data-Driven Testing**: Ambos frameworks permiten pasar diferentes valores de entrada y ejecutar el mismo test con cada valor.
2. **Reutilización del código**: En ambos frameworks, la lógica de prueba permanece constante, mientras que los datos de entrada cambian.
3. **Manejo de múltiples casos**: Tanto Kotest como PyTest permiten probar múltiples escenarios de manera eficiente, mejorando el mantenimiento y la escalabilidad de las pruebas.

### Diferencias entre Kotest y PyTest

1. **Sintaxis**: Kotest utiliza la función `withData` para lograr una sintaxis fluida y declarativa, mientras que PyTest depende de la anotación `@pytest.mark.parametrize`, que sigue un enfoque más tradicional basado en decoradores.
2. **Combinación de valores**: Kotest facilita la combinación de múltiples conjuntos de datos con `withData` anidado, mientras que en PyTest se pueden usar múltiples parámetros en `@pytest.mark.parametrize` para combinar entradas.

### Ejemplo en PyTest con múltiples parámetros

En PyTest, también podemos usar múltiples parámetros en `@pytest.mark.parametrize` para probar diferentes combinaciones de valores:

```python
import pytest

@pytest.mark.parametrize("name, invalid_hp", [
    ("Bigachu", -100),
    ("Psygoose", -1),
    ("Bigachu", 101),
    ("Psygoose", 1000)
])
def test_invalid_health_points(name, invalid_hp):
    bakemon = Bakemon(name, 100)
    with pytest.raises(ValueError):
        bakemon.set_current_health_points(invalid_hp)
```

### Comparación final

| Aspecto                    | Kotest                                               | PyTest                                              |
|----------------------------|------------------------------------------------------|-----------------------------------------------------|
| **Data-Driven Testing**    | `withData`                                           | `@pytest.mark.parametrize`                          |
| **Combinación de Valores** | Fácil con `withData`                                 | Soportado con múltiples parámetros en `parametrize` |
| **Sintaxis**               | Declarativa y fluida                                 | Decoradores con anotaciones                         |
| **Estilo de pruebas**      | Soporte para múltiples estilos (BDD, FreeSpec, etc.) | Enfoque tradicional de pruebas                      |
