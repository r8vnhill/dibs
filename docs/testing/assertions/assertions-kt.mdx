---
title: Aserciones
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import CodeBlock from '@theme/CodeBlock'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'

<ReadingTime />
<GithubRepoLink repo={"assertions-kt"} user={"r8vnhill"}/>
<ModuleSetup module='assertions' task='setupAssertionsModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupAssertionsModule") {
        description = "Creates the base module and files for the assertions lesson"
        module.set("assertions")

        doLast {
            createFiles(
                "calculator",
                test to "CalculatorTest.kt",
                main to "Calculator.kt",
            )
            createFiles(
                "assertions",
                test to "assertTrue.kt",
                test to "assertIsOrdered.kt",
            )
        }
    }
    ```
</ModuleSetup>

Las **aserciones** son instrucciones que verifican si una condici√≥n espec√≠fica es verdadera en un punto particular del c√≥digo. Si la condici√≥n es falsa, la aserci√≥n falla y se lanza una excepci√≥n, interrumpiendo la ejecuci√≥n del programa o prueba. Los frameworks de testing capturan estas excepciones para generar reportes detallados de los resultados.

:::info Nota did√°ctica

Esta lecci√≥n tiene fines did√°cticos y busca ilustrar c√≥mo funcionan las aserciones.
En la pr√°ctica, en lugar de implementar nuestras propias aserciones, utilizamos **matchers**, que permiten escribir pruebas m√°s expresivas y estructuradas.  
En lecciones futuras, exploraremos el uso de **matchers** y c√≥mo facilitan la validaci√≥n en los tests.

:::

## üìå Implementaci√≥n manual

Por ejemplo, consideremos una prueba escrita manualmente:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        "Given a calculator" - {
            "when adding 1 and 2" - {
                "should return 3" {
                    Calculator.add(1, 2).takeIf { it == 3 } 
                        ?: throw AssertionError("1 + 2 should be 3")
                }
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator
        
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3 (manual)" {
                        Calculator.add(1, 2).takeIf { it == 3 } 
                            ?: throw AssertionError("1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este c√≥digo, verificamos si `Calculator.add(1, 2)` es igual a `3`. Si no lo es, lanzamos una excepci√≥n `AssertionError` con un mensaje descriptivo; de lo contrario, imprimimos `"Test passed"`.
</Explanation>

Supongamos ahora que tenemos la siguiente implementaci√≥n err√≥nea de ``Calculator``:

```kotlin title="assert/src/main/kotlin/com/github/username/calculator/Calculator.kt"
package com.github.username.calculator

object Calculator {
    fun add(a: Int, b: Int): Int = a - b
}
```

En este caso, si ejecutamos el test obtendremos la siguiente salida:

```plaintext
java.lang.AssertionError: 1 + 2 should be 3
	at com.github.username.assertions.CalculatorTest$1$1.invokeSuspend(CalculatorTest.kt:8)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at io.kotest.core.spec.style.scopes.FreeSpecRootScope$invoke$1.invokeSuspend(FreeSpecRootScope.kt:26)
	...
Caused by: java.lang.AssertionError: 1 + 2 should be 3
	at com.github.username.assertions.CalculatorTest$1$1.invokeSuspend(CalculatorTest.kt:8)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at io.kotest.core.spec.style.scopes.FreeSpecRootScope$invoke$1.invokeSuspend(FreeSpecRootScope.kt:26)
	...
```

Sin embargo, podemos simplificar y mejorar este test utilizando las aserciones que ofrece el framework:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin
        Calculator.add(1, 2).takeIf { it == 3 }
            ?: fail("1 + 2 should be 3")
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator

        import io.kotest.assertions.fail
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3"  - {
                        Calculator.add(1, 2).takeIf { it == 3 }
                            ?: fail("1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Aqu√≠, en lugar de lanzar una excepci√≥n manualmente, utilizamos la funci√≥n `fail` proporcionada por el framework, que marca la prueba como fallida y proporciona el mensaje de error correspondiente. Esto tambi√©n ayudar√° al framework a generar un informe detallado de la prueba.
</Explanation>

## üõ†Ô∏è Implementaci√≥n de Aserciones Personalizadas

Supongamos ahora que queremos implementar nuestras propias funciones de aserci√≥n personalizadas para simplificar la escritura de pruebas. Por ejemplo, podemos crear una funci√≥n `assertTrue` que verifique si una condici√≥n es verdadera y lance una excepci√≥n si no lo es.

```kotlin title="assert/src/test/kotlin/com/github/username/assertions/assertTrue.kt"
package com.github.username.assertions

import io.kotest.assertions.fail

fun assertTrue(
    condition: Boolean,
    message: String = "Condition is not true"
) {
    if (!condition) {
        fail(message)
    }
}
```

<Explanation>
    La funci√≥n `assertTrue` toma dos par√°metros:

    - `condition`: la condici√≥n que se debe cumplir.
    - `message`: el mensaje de error que se mostrar√° si la condici√≥n no se cumple.

    Si la condici√≥n no se cumple, se lanza una excepci√≥n `AssertionError` con el mensaje especificado.
</Explanation>

### üî• Ejemplo de uso en tu prueba

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        assertTrue(Calculator.add(1, 2) == 3, "1 + 2 should be 3")
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator

        import com.github.username.assertions.assertTrue
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3"  - {
                        assertTrue(Calculator.add(1, 2) == 3, "1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, utilizamos la funci√≥n `assertTrue` para verificar si `Calculator.add(1, 2)` es igual a `3`. Si la condici√≥n no se cumple, se lanza una excepci√≥n con el mensaje `"1 + 2 should be 3"`.
</Explanation>

## ‚öñÔ∏è Beneficios y limitaciones

<ProCons>
    <Pros>
        - **Claridad y Reusabilidad**: Las aserciones personalizadas mejoran la legibilidad del c√≥digo de pruebas y permiten reutilizar las mismas aserciones en diferentes casos, reduciendo duplicaciones.
        - **Mensajes de error personalizados**: Permite proporcionar mensajes de error m√°s claros y espec√≠ficos, lo que facilita la identificaci√≥n de fallos en las pruebas.
        - **Abstracci√≥n de complejidad**: Las aserciones personalizadas ocultan detalles complejos de validaci√≥n, dejando las pruebas m√°s concisas y f√°ciles de mantener.
        - **Integraci√≥n con frameworks**: Al crear aserciones personalizadas, se puede integrar f√°cilmente con frameworks de testing como Kotest, aprovechando su capacidad de generar informes detallados.
    </Pros>
    <Cons>
        - **Mayor mantenimiento**: Si las aserciones personalizadas no est√°n bien dise√±adas o documentadas, pueden ser dif√≠ciles de mantener y propensas a errores si los requisitos cambian.
        - **Sobrecarga inicial**: Crear aserciones personalizadas desde cero puede llevar m√°s tiempo y esfuerzo inicialmente, comparado con el uso de aserciones predefinidas de los frameworks.
    </Cons>
</ProCons>

<Exercise title={"Verificar si una lista est√° ordenada"}>
    Crea una aserci√≥n ``assertIsOrdered: (List<Int>, Boolean) -> Unit`` que verifique si una lista de enteros est√° ordenada de forma ascendente.
    - Si el segundo par√°metro es ``true``, la lista debe estar ordenada de forma estrictamente ascendente (sin elementos repetidos).
    - Si el segundo par√°metro es ``false``, la lista puede contener elementos repetidos.

    <Solution>
        ```kotlin showLineNumbers
        fun assertIsOrdered(list: List<Int>, isStrictlyOrdered: Boolean) {
            if (isStrictlyOrdered) {
                for (i in 0..<list.size - 1) {
                    if (list[i] >= list[i + 1]) {
                        fail("List is not strictly ordered")
                    }
                }
            } else {
                for (i in 0..<list.size - 1) {
                    if (list[i] > list[i + 1]) {
                        fail("List is not ordered")
                    }
                }
            }
        }
        ```
    </Solution>

    <Solution title='(Alternativa)'>
        ```kotlin showLineNumbers
        fun assertIsOrdered(list: List<Int>, isStrictlyOrdered: Boolean) {
            val comparator = if (isStrictlyOrdered) { a: Int, b: Int -> a < b }
                            else { a: Int, b: Int -> a <= b }
            list.zipWithNext().all { (a, b) -> comparator(a, b) } || 
                fail("List is not ordered")
        }
        ```

        :::info Explicaci√≥n de la soluci√≥n alternativa

        - Utilizamos `zipWithNext` para obtener pares consecutivos de elementos en la lista.
        - Utilizamos una lambda para verificar si cada par cumple con la condici√≥n de orden.
        - Si la condici√≥n no se cumple, lanzamos una excepci√≥n con el mensaje correspondiente.

        :::
    </Solution>
</Exercise>

## üéØ Conclusiones

Las **aserciones** son una herramienta fundamental en el desarrollo de software, especialmente en la escritura de pruebas unitarias. A lo largo de esta lecci√≥n, exploramos su implementaci√≥n manual, el uso de frameworks de testing como **Kotest**, y la creaci√≥n de **aserciones personalizadas** para mejorar la claridad y reusabilidad del c√≥digo de pruebas.

### üîë Puntos clave

1. **Aserciones como mecanismo de validaci√≥n**  
   - Permiten verificar que una condici√≥n se cumple en un punto espec√≠fico del c√≥digo.  
   - Si la condici√≥n es falsa, la ejecuci√≥n se detiene con un mensaje de error, facilitando la detecci√≥n de fallos.  
2. **Implementaci√≥n manual vs. uso de frameworks**  
   - Aunque es posible escribir aserciones manualmente, los frameworks de testing como **Kotest** ofrecen herramientas m√°s expresivas y f√°ciles de usar.  
   - M√©todos como `fail` mejoran la integraci√≥n con los reportes de pruebas, facilitando el diagn√≥stico de errores.  
3. **Aserciones personalizadas**  
   - Permiten encapsular verificaciones repetitivas en funciones reutilizables.  
   - Mejoran la claridad de los tests y hacen que los mensajes de error sean m√°s comprensibles.  
   - Deben mantenerse bien documentadas para evitar confusi√≥n en el equipo de desarrollo.  
4. **Beneficios y limitaciones**  
   - **Beneficios**: Mayor legibilidad, reusabilidad y personalizaci√≥n en los mensajes de error.  
   - **Limitaciones**: Pueden introducir sobrecarga inicial y aumentar la complejidad de mantenimiento si no se dise√±an correctamente.  
5. **Ejercicio pr√°ctico**  
   - Dise√±amos una aserci√≥n `assertIsOrdered` para verificar si una lista est√° ordenada, explorando distintas estrategias de implementaci√≥n.  

### ‚úÖ Reflexi√≥n final

Las aserciones no solo ayudan a detectar errores en el c√≥digo, sino que tambi√©n mejoran la **seguridad y confianza** en su ejecuci√≥n. Un buen conjunto de aserciones bien dise√±adas facilita la depuraci√≥n, reduce el tiempo de mantenimiento y hace que las pruebas sean m√°s comprensibles.  

Al integrar **aserciones personalizadas** y aprovechar las funcionalidades de los frameworks de testing, es posible escribir c√≥digo de prueba m√°s limpio, expresivo y mantenible.

### üöÄ Hacia pruebas m√°s expresivas

En esta lecci√≥n hemos implementado **aserciones manuales y personalizadas** para comprender su funcionamiento.  
Sin embargo, en la pr√°ctica, no es necesario escribir nuestras propias aserciones, ya que los **frameworks de pruebas** ofrecen herramientas m√°s expresivas y flexibles.  

En lecciones futuras exploraremos el uso de **matchers**, que permiten escribir pruebas m√°s declarativas, mejorando la legibilidad y la mantenibilidad del c√≥digo de test.

<References references={[
    {
        title: "xUnit Patterns",
        bookTitle: "Test-driven development: By example",
        publisher: "Addison-Wesley",
        year: "2003",
        author: "K. Beck",
        type: "book",
    },
]} additionalReferences={[
    {
        accessedDate: '31 de julio de 2024',
        siteOrAuthor: 'Wikipedia',
        title: 'Assertion (Software Development)',
        type: 'web',
        url: 'https://en.wikipedia.org/w/index.php?title=Assertion_(software_development)&oldid=1237703007',
    },
    {
        accessedDate: '31 de julio de 2024',
        siteOrAuthor: 'Wikipedia',
        title: 'Test assertion',
        type: 'web',
        url: 'https://en.wikipedia.org/w/index.php?title=Test_assertion&oldid=1110777862',
    },
]}/>
