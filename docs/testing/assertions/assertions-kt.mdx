---
title: Aserciones
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import CodeBlock from '@theme/CodeBlock'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'

<ReadingTime />
<GithubRepoLink repo={"assertions-kt"} user={"r8vnhill"}/>
<ModuleSetup module='assertions' task='setupAssertionsModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupAssertionsModule") {
        description = "Creates the base module and files for the assertions lesson"
        module.set("assertions")

        doLast {
            createFiles(
                "calculator",
                test to "CalculatorTest.kt",
                main to "Calculator.kt",
            )
            createFiles(
                "assertions",
                test to "assertTrue.kt",
                test to "assertIsOrdered.kt",
            )
        }
    }
    ```
</ModuleSetup>

En esta lecci√≥n aprender√°s c√≥mo implementar aserciones manuales y personalizadas, entendiendo c√≥mo se comportan y c√≥mo integrarlas con frameworks como Kotest. Esto sienta las bases para usar matchers m√°s expresivos en lecciones futuras.

## üß™ ¬øPor qu√© necesitamos aserciones?

Al desarrollar bibliotecas o aplicaciones, una parte esencial del proceso es **verificar que nuestro c√≥digo haga lo que esperamos**. Las **aserciones** son una de las herramientas m√°s directas para lograr esto: son expresiones booleanas que validan condiciones cr√≠ticas en tiempo de ejecuci√≥n. Si la condici√≥n es verdadera, el programa contin√∫a. Si es falsa, se lanza una excepci√≥n que interrumpe la ejecuci√≥n y se√±ala que **algo se desvi√≥ del comportamiento esperado**.

Esto convierte a las aserciones en una t√©cnica valiosa dentro del testing funcional: permiten validar los invariantes del sistema, detectar errores al instante y reducir el tiempo necesario para depurar o corregir fallos.

## ‚úÖ Beneficios clave del uso de aserciones

### 1. Detecci√≥n temprana de errores

Las aserciones permiten capturar **errores peque√±os y sutiles** que podr√≠an pasar desapercibidos con otros m√©todos. Esto mejora la robustez del sistema y reduce el riesgo de propagar fallos a etapas m√°s avanzadas del desarrollo.

### 2. Falla inmediata = feedback inmediato

En especial con **aserciones duras (hard assertions)**, la ejecuci√≥n se detiene justo en el punto donde algo falla. Esto facilita un **ciclo de retroalimentaci√≥n r√°pido**: no se contin√∫a evaluando condiciones irrelevantes una vez que algo cr√≠tico falla, permitiendo al equipo enfocarse directamente en el problema.

### 3. Verificaci√≥n de garant√≠as internas

Las aserciones tambi√©n sirven como **contratos internos** dentro del c√≥digo, ayudando a documentar y reforzar que ciertos bloques de l√≥gica deben producir resultados correctos. Esto fortalece la **autoconfianza del software** al garantizar que sus partes clave se comportan de forma fiable.

## üîç ¬øC√≥mo se clasifican las aserciones?

<details>
  <summary>
    Tipos de aserciones y `assertSoftly`
  </summary>

  Las aserciones pueden clasificarse seg√∫n su comportamiento al validar condiciones:

  - **Aserciones simples**: Verifican una √∫nica condici√≥n. Si falla, el test se interrumpe inmediatamente. √ötiles para validar entradas, salidas o invariantes simples.

  - **Aserciones compuestas**: Agrupan varias condiciones en una misma evaluaci√≥n. Todas deben cumplirse para que la prueba pase, permitiendo validar estructuras m√°s complejas o m√∫ltiples propiedades al mismo tiempo.

  - **Aserciones suaves (soft assertions)**: No interrumpen la ejecuci√≥n tras el primer fallo. En lugar de eso, acumulan los errores y los reportan al final. Son ideales cuando se quiere tener una **visi√≥n completa del estado del sistema**, incluso si algunas partes fallan.

  En Kotest, el mecanismo para realizar aserciones suaves es `assertSoftly`, que agrupa varias verificaciones sin detener la ejecuci√≥n ante la primera falla:

  ```kotlin showLineNumbers
  assertSoftly {
      person.name shouldBe "Alice"
      person.age shouldBe 30
      person.email shouldContain "@"
  }
  ```

  Si una o m√°s condiciones fallan, el framework mostrar√° todas las fallas juntas, facilitando el diagn√≥stico de errores sin necesidad de ejecutar m√∫ltiples veces.

</details>

:::info Nota did√°ctica

Esta lecci√≥n tiene fines did√°cticos y busca ilustrar c√≥mo funcionan las aserciones.  
En la pr√°ctica, en lugar de implementar nuestras propias aserciones, utilizamos **matchers**, que permiten escribir pruebas m√°s expresivas y estructuradas.  
En lecciones futuras, exploraremos el uso de matchers y c√≥mo facilitan la validaci√≥n en los tests.

:::


## üìå Implementaci√≥n manual

Por ejemplo, consideremos una prueba escrita manualmente:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        "Given a calculator" - {
            "when adding 1 and 2" - {
                "should return 3" {
                    Calculator.add(1, 2).takeIf { it == 3 } 
                        ?: throw AssertionError("1 + 2 should be 3")
                }
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator
        
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3 (manual)" {
                        Calculator.add(1, 2).takeIf { it == 3 } 
                            ?: throw AssertionError("1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este c√≥digo, verificamos si `Calculator.add(1, 2)` es igual a `3`. Si no lo es, lanzamos una excepci√≥n `AssertionError` con un mensaje descriptivo; de lo contrario, imprimimos `"Test passed"`.
</Explanation>

Supongamos ahora que tenemos la siguiente implementaci√≥n err√≥nea de ``Calculator``:

```kotlin title="assert/src/main/kotlin/com/github/username/calculator/Calculator.kt"
package com.github.username.calculator

object Calculator {
    fun add(a: Int, b: Int): Int = a - b
}
```

En este caso, si ejecutamos el test obtendremos la siguiente salida:

```plaintext
java.lang.AssertionError: 1 + 2 should be 3
	at com.github.username.assertions.CalculatorTest$1$1.invokeSuspend(CalculatorTest.kt:8)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at io.kotest.core.spec.style.scopes.FreeSpecRootScope$invoke$1.invokeSuspend(FreeSpecRootScope.kt:26)
	...
Caused by: java.lang.AssertionError: 1 + 2 should be 3
	at com.github.username.assertions.CalculatorTest$1$1.invokeSuspend(CalculatorTest.kt:8)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at com.github.username.assertions.CalculatorTest$1$1.invoke(CalculatorTest.kt)
	at io.kotest.core.spec.style.scopes.FreeSpecRootScope$invoke$1.invokeSuspend(FreeSpecRootScope.kt:26)
	...
```

Sin embargo, podemos simplificar y mejorar este test utilizando las aserciones que ofrece el framework:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin
        Calculator.add(1, 2).takeIf { it == 3 }
            ?: fail("1 + 2 should be 3")
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator

        import io.kotest.assertions.fail
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3"  - {
                        Calculator.add(1, 2).takeIf { it == 3 }
                            ?: fail("1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Aqu√≠, en lugar de lanzar una excepci√≥n manualmente, utilizamos la funci√≥n `fail` proporcionada por el framework, que marca la prueba como fallida y proporciona el mensaje de error correspondiente. Esto tambi√©n ayudar√° al framework a generar un informe detallado de la prueba.
</Explanation>

## üõ†Ô∏è Implementaci√≥n de Aserciones Personalizadas

Supongamos ahora que queremos implementar nuestras propias funciones de aserci√≥n personalizadas para simplificar la escritura de pruebas. Por ejemplo, podemos crear una funci√≥n `assertTrue` que verifique si una condici√≥n es verdadera y lance una excepci√≥n si no lo es.

```kotlin title="assert/src/test/kotlin/com/github/username/assertions/assertTrue.kt"
package com.github.username.assertions

import io.kotest.assertions.fail

fun assertTrue(
    condition: Boolean,
    message: String = "Condition is not true"
) {
    if (!condition) {
        fail(message)
    }
}
```

<Explanation>
    La funci√≥n `assertTrue` toma dos par√°metros:

    - `condition`: la condici√≥n que se debe cumplir.
    - `message`: el mensaje de error que se mostrar√° si la condici√≥n no se cumple.

    Si la condici√≥n no se cumple, se lanza una excepci√≥n `AssertionError` con el mensaje especificado.
</Explanation>

### üî• Ejemplo de uso en tu prueba

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        assertTrue(Calculator.add(1, 2) == 3, "1 + 2 should be 3")
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="assert/src/test/kotlin/com/github/username/calculator/CalculatorTest.kt"
        package com.github.username.calculator

        import com.github.username.assertions.assertTrue
        import io.kotest.core.spec.style.FreeSpec

        class CalculatorTest : FreeSpec({
            "A calculator" - {
                "when adding 1 and 2" - {
                    "should return 3"  - {
                        assertTrue(Calculator.add(1, 2) == 3, "1 + 2 should be 3")
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, utilizamos la funci√≥n `assertTrue` para verificar si `Calculator.add(1, 2)` es igual a `3`. Si la condici√≥n no se cumple, se lanza una excepci√≥n con el mensaje `"1 + 2 should be 3"`.
</Explanation>

## ‚öñÔ∏è Beneficios y limitaciones

<ProCons>
    <Pros>
        - **Claridad y Reusabilidad**: Las aserciones personalizadas mejoran la legibilidad del c√≥digo de pruebas y permiten reutilizar las mismas aserciones en diferentes casos, reduciendo duplicaciones.
        - **Mensajes de error personalizados**: Permite proporcionar mensajes de error m√°s claros y espec√≠ficos, lo que facilita la identificaci√≥n de fallos en las pruebas.
        - **Abstracci√≥n de complejidad**: Las aserciones personalizadas ocultan detalles complejos de validaci√≥n, dejando las pruebas m√°s concisas y f√°ciles de mantener.
        - **Integraci√≥n con frameworks**: Al crear aserciones personalizadas, se puede integrar f√°cilmente con frameworks de testing como Kotest, aprovechando su capacidad de generar informes detallados.
    </Pros>
    <Cons>
        - **Mayor mantenimiento**: Si las aserciones personalizadas no est√°n bien dise√±adas o documentadas, pueden ser dif√≠ciles de mantener y propensas a errores si los requisitos cambian.
        - **Sobrecarga inicial**: Crear aserciones personalizadas desde cero puede llevar m√°s tiempo y esfuerzo inicialmente, comparado con el uso de aserciones predefinidas de los frameworks.
    </Cons>
</ProCons>

## üß† Buenas pr√°cticas

:::tip

- Reutiliza funciones de aserci√≥n en varios tests para evitar duplicaci√≥n.
- Incluye siempre mensajes de error descriptivos.
- Integra tus aserciones con el sistema del framework (como `fail()` en Kotest) para aprovechar sus reportes.

:::

## üî¢ Ejercicio: Verificar si una lista est√° ordenada

<Exercise>
    Sup√≥n que est√°s escribiendo una biblioteca que ordena rankings, y quieres asegurarte de que los resultados se ordenan correctamente antes de exponerlos a otrxs usuaries.

    Crea una aserci√≥n ``assertIsOrdered: (List<Int>, Boolean) -> Unit`` que verifique si una lista de enteros est√° ordenada de forma ascendente.
    - Si el segundo par√°metro es ``true``, la lista debe estar ordenada de forma estrictamente ascendente (sin elementos repetidos).
    - Si el segundo par√°metro es ``false``, la lista puede contener elementos repetidos.

    <Solution>
        <BoxedTabs>
            <TabItem label={"Implementaci√≥n iterativa"} value={"Implementaci√≥n iterativa"}>
                ```kotlin showLineNumbers
                fun assertIsOrdered(list: List<Int>, isStrictlyOrdered: Boolean) {
                    if (isStrictlyOrdered) {
                        for (i in 0..<list.size - 1) {
                            if (list[i] >= list[i + 1]) {
                                fail("List is not strictly ordered")
                            }
                        }
                    } else {
                        for (i in 0..<list.size - 1) {
                            if (list[i] > list[i + 1]) {
                                fail("List is not ordered")
                            }
                        }
                    }
                }
                ```
            </TabItem>
            <TabItem label={"Implementaci√≥n funcional"} value={"Implementaci√≥n funcional"}>
                ```kotlin showLineNumbers
                fun assertIsOrdered(list: List<Int>, isStrictlyOrdered: Boolean) {
                    val comparator = if (isStrictlyOrdered) { a: Int, b: Int -> a < b }
                                    else { a: Int, b: Int -> a <= b }
                    list.zipWithNext().all { (a, b) -> comparator(a, b) } || 
                        fail("List is not ordered")
                }
                ```

                <Explanation>
                    - `zipWithNext()` crea una lista de pares consecutivos: `[a1, a2, a3]` ‚Üí `[(a1, a2), (a2, a3)]`
                    - Luego usamos `all { (a, b) -> comparator(a, b) }` para verificar que todos los pares cumplen la relaci√≥n esperada (estricta o no estricta).
                    - Si la condici√≥n no se cumple, lanzamos una excepci√≥n con el mensaje correspondiente.
                </Explanation>
            </TabItem>
        </BoxedTabs>
    </Solution>
</Exercise>

## üéØ Conclusiones

A lo largo de esta lecci√≥n, exploramos el rol fundamental de las **aserciones** como mecanismo para validar el comportamiento del sistema en distintos puntos clave del c√≥digo. Comenzamos con implementaciones manuales para comprender su funcionamiento esencial y luego avanzamos hacia la creaci√≥n de funciones personalizadas que encapsulan l√≥gica reusable.

Aunque hoy en d√≠a los frameworks modernos favorecen el uso de **matchers** m√°s expresivos, comprender c√≥mo funcionan las aserciones b√°sicas nos permite:

- **Entender qu√© ocurre "bajo el cap√≥"** en una prueba fallida,
- **Dise√±ar validaciones adaptadas al dominio**, y
- **Construir herramientas propias** cuando las existentes no son suficientes.

### üîë Puntos clave

1. **Una aserci√≥n es una validaci√≥n que detiene la prueba si una condici√≥n no se cumple**.  
2. **Es posible implementar aserciones manualmente**, pero frameworks como Kotest ofrecen utilidades como `fail()` y `assertSoftly` para integrarse mejor con los reportes.  
3. **Las funciones de aserci√≥n personalizadas** aumentan la expresividad, reducen duplicaci√≥n y ayudan a expresar reglas del dominio.  
4. **Mensajes claros** facilitan la depuraci√≥n cuando una prueba falla.  
5. **Preparar funciones propias sienta las bases** para comprender herramientas m√°s potentes como matchers, validadores o DSLs de testing.

### üß∞ ¬øQu√© nos llevamos?

Aprender a escribir aserciones manuales nos obliga a **pensar con precisi√≥n** sobre qu√© se quiere validar, c√≥mo y por qu√©. En el contexto del desarrollo de bibliotecas, esto es clave: las pruebas dejan de ser simples chequeos y se convierten en **garant√≠as expl√≠citas** del contrato que estamos definiendo para quienes usar√°n nuestro c√≥digo.

Este conocimiento tambi√©n te prepara para transicionar a herramientas m√°s declarativas, como los *matchers*, que exploraremos en pr√≥ximas lecciones. As√≠, ganamos control y flexibilidad para construir pruebas que sean no solo correctas, sino tambi√©n **claras, mantenibles y alineadas con el prop√≥sito de la biblioteca**.

## üìñ Referencias

### üî• Recomendadas

üì∞ Tamas Cser. (2024, septiembre 5). What is Assertion Testing? Ensuring Quality and Accuracy. https://www.functionize.com/automated-testing/assertion

### üîπ Adicionales

üåê ¬øCu√°les son las pr√°cticas recomendadas para usar aserciones en las pruebas? (s.¬†f.). Recuperado 23 de marzo de 2025, de https://es.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es

{/* TODO: Bibliograf√≠as por revisar
## Fundamentos generales de las aserciones  
Es importante notar que las aserciones se deben usar para verificar **condiciones internas que siempre deber√≠an cumplirse** (invariantes de c√≥digo), y no para el manejo de errores externos; por ejemplo, no se recomienda usar `assert` para validar entradas de usuario, ya que su objetivo es marcar errores l√≥gicos del programador y puede deshabilitarse en producci√≥n ([Pruebas en Python | Aserciones | Fundamentos de Programaci√≥n | LabEx](https://labex.io/es/tutorials/python-python-testing-essentials-132735#:~:text=assert%20isinstance,un%20int)). Un uso extensivo de aserciones est√° asociado al enfoque de *Dise√±o por Contrato*, donde se especifican pre y post-condiciones mediante aserciones para garantizar la correcci√≥n del programa ([Pruebas en Python | Aserciones | Fundamentos de Programaci√≥n | LabEx](https://labex.io/es/tutorials/python-python-testing-essentials-132735#:~:text=Tambi%C3%A9n%20conocida%20como%20Dise%C3%B1o%20por,para%20los%20componentes%20del%20software)). *(Recursos: Art√≠culo colaborativo en LinkedIn, gratuito, introductorio ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=Las%20aserciones%20son%20instrucciones%20que,c%C3%B3mo%20escribirlas%20y%20c%C3%B3mo%20manejarlas)); Tutorial de LabEx sobre pruebas en Python, gratis, b√°sico/pr√°ctico ([Pruebas en Python | Aserciones | Fundamentos de Programaci√≥n | LabEx](https://labex.io/es/tutorials/python-python-testing-essentials-132735#:~:text=assert%20isinstance,un%20int)) ([Pruebas en Python | Aserciones | Fundamentos de Programaci√≥n | LabEx](https://labex.io/es/tutorials/python-python-testing-essentials-132735#:~:text=Tambi%C3%A9n%20conocida%20como%20Dise%C3%B1o%20por,para%20los%20componentes%20del%20software)).)*  

- **Importancia de las aserciones en pruebas automatizadas (ingl√©s)** ‚Äì Las aserciones son consideradas *‚Äúuna de las t√©cnicas automatizadas m√°s √∫tiles‚Äù* para chequear el comportamiento de un programa ([](https://www.idt.mdu.se/ecbs2023/pre-prints/paper_2356.pdf#:~:text=,rendered%20119%20papers%20on%20assertions)). Al incluir aserciones en las pruebas, √©stas **se ejecutan de forma autom√°tica** y verifican condiciones esperadas sin intervenci√≥n manual. Esto mejora la **precisi√≥n y rapidez de las pruebas** ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=Assertion%20is%20a%20key%20concept,including%20speeding%20up%20the%20testing)). En palabras de un art√≠culo t√©cnico reciente, *‚ÄúAssertion is a key concept in functional testing‚Äù*, ya que permiten declarar el resultado esperado de una prueba y hacerla fallar autom√°ticamente si el comportamiento real no coincide ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=Assertion%20is%20a%20key%20concept,including%20speeding%20up%20the%20testing)). Adem√°s, existen distintos tipos de aserciones: por ejemplo, las llamadas **aserciones simples** validan una sola condici√≥n booleana, mientras que **aserciones compuestas** pueden verificar m√∫ltiples condiciones a la vez; tambi√©n se distinguen **aserciones duras** (hard) de **aserciones blandas** (soft), donde las primeras detienen inmediatamente la ejecuci√≥n ante un fallo, mientras que las soft permiten continuar ejecutando otras verificaciones y reportar m√∫ltiples fallos a la vez ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=,even%20if%20some%20conditions%20fail)). *(Recursos: Blog t√©cnico de Functionize, gratuito, nivel introductorio-conceptual ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=Assertion%20is%20a%20key%20concept,including%20speeding%20up%20the%20testing)) ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=,even%20if%20some%20conditions%20fail)); Art√≠culo de investigaci√≥n ‚ÄúA Literature Survey of Assertions in Software Testing‚Äù (Taromirad & Runeson 2023), *open access*, avanzado y conceptual ([](https://www.idt.mdu.se/ecbs2023/pre-prints/paper_2356.pdf#:~:text=,rendered%20119%20papers%20on%20assertions)).)*  

## Dise√±o de aserciones personalizadas  
- **Necesidad de aserciones personalizadas y matchers (ingl√©s)** ‚Äì En escenarios complejos, las funciones de aserci√≥n b√°sicas (p. ej. `assertTrue`, `assertEquals`) pueden quedarse cortas o hacer las pruebas menos legibles. Un art√≠culo en InfoQ se√±ala que aunque *‚Äúescribir aserciones parece sencillo‚Äù*, comparar resultados con expectativas usando solo m√©todos b√°sicos puede *‚Äúensuciar nuestras pruebas con detalles de bajo nivel‚Äù* ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=Writing%20assertions%20for%20tests%20seems,test%20using%20such%20basic%20assertions)). Lo ideal es que las pruebas *‚Äúhablen el lenguaje del negocio‚Äù* y no queden ocultas tras log√≠ca repetitiva ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=The%20main%20issue%20is%20that,in%20the%20language%20of%20business)). Por ello, surgen **bibliotecas de matchers** y la posibilidad de implementar **aserciones personalizadas** que expresen mejor la intenci√≥n de la prueba ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=In%20this%20article%20I%20will,tests%20more%20readable%20and%20maintainable)). Frameworks como JUnit o TestNG permiten extender su conjunto de aserciones, y existen librer√≠as como **Hamcrest**, **AssertJ** o **Truth** que proveen un vocabulario m√°s rico de verificaciones ([Assert with Grace: Custom Assertions using AssertJ for Cleaner Code](https://eliasnogueira.com/assert-with-grace-custom-assertions-for-cleaner-code/#:~:text=)). Estas bibliotecas permiten cadenas de aserciones m√°s legibles (p. ej., `assertThat(item, isValid())`) e incluso crear nuevos m√©todos de aserci√≥n adaptados a tipos de dominio (por ejemplo, AssertJ facilita escribir una clase `PedidoAssert` con m√©todos como `tieneTotal(expected)` para un objeto `Pedido`). *(Recursos: Art√≠culo **‚ÄúCustom Assertions in Java Tests‚Äù** de InfoQ, gratuito, intermedio-conceptual con c√≥digo ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=Writing%20assertions%20for%20tests%20seems,test%20using%20such%20basic%20assertions)) ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=In%20this%20article%20I%20will,tests%20more%20readable%20and%20maintainable)); Blog de Elias Nogueira sobre aserciones personalizadas con AssertJ, gratuito, intermedio-pr√°ctico ([Assert with Grace: Custom Assertions using AssertJ for Cleaner Code](https://eliasnogueira.com/assert-with-grace-custom-assertions-for-cleaner-code/#:~:text=Because%20of%20this%2C%20new%20libraries,different%20aspects%20providing%20different%20features)).)*  

- **C√≥mo construir funciones de aserci√≥n propias (pr√°ctico)** ‚Äì Crear aserciones personalizadas suele implicar encapsular una condici√≥n y lanzar una excepci√≥n de fallo si no se cumple. Por ejemplo, en **JUnit (Java)** se puede escribir un m√©todo est√°tico que verifique una propiedad espec√≠fica y lance `AssertionError` o use internamente una aserci√≥n existente. En **MSTest (C#)**, una t√©cnica es extender la clase de aserciones mediante *m√©todos de extensi√≥n*: pasos t√≠picos son *‚Äú1. Escribir un m√©todo de extensi√≥n sobre la clase Assert, 2. Comparar los par√°metros *actual* y *expected*, 3. Lanzar una AssertFailedException si la comparaci√≥n falla‚Äù* ([How to create custom assertions in C# with MSTest - DEV Community](https://dev.to/canro91/how-to-create-custom-assertions-in-c-with-mstest-4831#:~:text=To%20write%20custom%20assertions%20with,MSTest)). El siguiente fragmento muestra una aserci√≥n personalizada `StringIsEmpty` en MSTest, que lanza una excepci√≥n con un mensaje claro si la cadena no est√° vac√≠a: 

  `public static void StringIsEmpty(this Assert assert, string actual) {  
      if (string.IsNullOrEmpty(actual)) return;  
      throw new AssertFailedException("Expected empty string but was " + actual);  
  }` ([How to create custom assertions in C# with MSTest - DEV Community](https://dev.to/canro91/how-to-create-custom-assertions-in-c-with-mstest-4831#:~:text=Here%2C%20we%27re%20creating%20a%20,method))

  Una vez definida, puede usarse en las pruebas como `Assert.That.StringIsEmpty(valorObtenido)` ([How to create custom assertions in C# with MSTest - DEV Community](https://dev.to/canro91/how-to-create-custom-assertions-in-c-with-mstest-4831#:~:text=Enter%20fullscreen%20mode%20Exit%20fullscreen,mode)). De forma an√°loga, en Kotest (Kotlin) es sencillo definir *matchers* propios implementando la interfaz `Matcher<T>`; estos matchers pueden combinar l√≥gica existente o ser completamente nuevos ([Assertions | Kotest](https://kotest.io/docs/assertions/assertions.html#:~:text=Custom%20Matchers)). La idea central es encapsular la verificaci√≥n para **reutilizarla en m√∫ltiples pruebas** y proporcionar **mensajes de fallo m√°s descriptivos**. *(Recursos: Tutorial *‚ÄúHow to create custom assertions in C# with MSTest‚Äù* ‚Äì blog DEV.to, gratuito, pr√°ctico con c√≥digo ([How to create custom assertions in C# with MSTest - DEV Community](https://dev.to/canro91/how-to-create-custom-assertions-in-c-with-mstest-4831#:~:text=To%20write%20custom%20assertions%20with,MSTest)) ([How to create custom assertions in C# with MSTest - DEV Community](https://dev.to/canro91/how-to-create-custom-assertions-in-c-with-mstest-4831#:~:text=,if%20%28string.IsNullOrEmpty%28actual%29%29%20return)); Documentaci√≥n oficial de Kotest sobre *Custom Matchers*, gratis, orientado a pr√°ctica en Kotlin ([Assertions | Kotest](https://kotest.io/docs/assertions/assertions.html#:~:text=Custom%20Matchers)).)*  

- **Ejemplos de aserciones custom y beneficios** ‚Äì Dise√±ar nuestras propias aserciones mejora la legibilidad de los tests. Por ejemplo, usando AssertJ en Java se puede escribir: `assertThat(person).hasName("Juan").hasAge(30)`, tras haber creado m√©todos `hasName` y `hasAge` dentro de una clase `PersonAssert`. Esto expresa claramente qu√© se verifica, en contraste con usar m√∫ltiples `assertEquals` separados. Las aserciones custom tambi√©n permiten **reutilizar l√≥gica de verificaci√≥n compleja** (p. ej., comparar la igualdad de dos gr√°ficos, verificar propiedades de un JSON, etc.) en una sola llamada. La documentaci√≥n de AssertJ muestra c√≥mo extender `AbstractAssert` para crear aserciones fluentes para tipos espec√≠ficos ([Assert with Grace: Custom Assertions using AssertJ for Cleaner Code](https://eliasnogueira.com/assert-with-grace-custom-assertions-for-cleaner-code/#:~:text=Because%20of%20this%2C%20new%20libraries,different%20aspects%20providing%20different%20features)). En resumen, invertir en escribir aserciones a medida puede hacer que los tests sean m√°s *‚Äúautoexplicativos y mantenibles‚Äù* ([Custom Assertions in Java Tests - InfoQ](https://www.infoq.com/articles/custom-assertions/#:~:text=The%20main%20issue%20is%20that,in%20the%20language%20of%20business)), al hablar en t√©rminos del problema de negocio en vez de detalles t√©cnicos. *(Recursos: Documentaci√≥n de AssertJ (open source) y ejemplo en blog de Elias Nogueira ([Assert with Grace: Custom Assertions using AssertJ for Cleaner Code](https://eliasnogueira.com/assert-with-grace-custom-assertions-for-cleaner-code/#:~:text=)); Cap√≠tulo sobre *matchers* en libro *‚ÄúPractical Unit Testing‚Äù* de T. Kaczanowski ‚Äì plantea casos donde asserts b√°sicos no son suficientes (recurso de pago, nivel intermedio).)*

## Integraci√≥n de aserciones con frameworks de prueba  
- **Aserciones en JUnit y TestNG (documentaci√≥n oficial)** ‚Äì La mayor√≠a de frameworks xUnit proveen una clase utilitaria con m√©todos est√°ticos para aserciones. En **JUnit 4** est√° la clase `org.junit.Assert` (en JUnit 5, `org.junit.jupiter.api.Assertions`). Sus m√©todos incluyen, por ejemplo, `assertTrue(condici√≥n)` ‚Äì que verifica que la condici√≥n booleana es verdadera (lanza `AssertionError` si no lo es) ([
Assert (JUnit API)
](https://junit.org/junit4/javadoc/4.13/org/junit/Assert.html#:~:text=assertTrue)) ‚Äì o `assertEquals(expected, actual)` ‚Äì que comprueba igualdad de valores. Tambi√©n se define `fail()` para marcar expl√≠citamente una prueba como fallida. Seg√∫n la documentaci√≥n, `Assert.fail()` *‚Äúfalla una prueba sin mensaje‚Äù* (solo lanza el error) ([
Assert (JUnit API)
](https://junit.org/junit4/javadoc/4.13/org/junit/Assert.html#:~:text=Asserts%20that%20a%20condition%20is,test%20with%20the%20given%20message)); esto se usa t√≠picamente dentro de ramas del test que no deber√≠an ejecutarse. Un ejemplo pr√°ctico en JUnit es verificar que un m√©todo lance excepci√≥n: se llama al m√©todo dentro de un bloque try, luego inmediatamente `fail("Should have thrown an exception")` si no se produjo la excepci√≥n, y en el catch se puede usar `assertTrue(true)` para indicar que se captur√≥ lo esperado ([JUnit Assert.fail() Method Example](https://www.javaguides.net/2018/08/junit-assertfail-method-example.html#:~:text=Let%27s%20write%20the%20JUnit%20test,list%29%C2%A0method)). En **TestNG**, el funcionamiento es similar; la clase `org.testng.Assert` proporciona m√©todos equivalentes (`Assert.assertTrue`, `Assert.assertEquals`, etc.). Una diferencia de dise√±o es el orden de par√°metros: TestNG los define en orden ‚Äúvalor actual, valor esperado‚Äù (considerado m√°s natural) ([org.testng/testng/7.3.0 : org/testng/Assert.java](https://code.yawk.at/org.testng/testng/7.3.0/org/testng/Assert.java#:~:text=Assertion%20tool%20class,message)), mientras JUnit tradicionalmente usa ‚Äúesperado, actual‚Äù. Por ejemplo, en TestNG se escribe `Assert.assertEquals(objActual, objEsperado)`. La sintaxis general es `Assert.metodo(actual, expected)` ([Guide To TestNG Assertions in Selenium Based Test Automation](https://www.pcloudy.com/blogs/guide-to-testng-assertions-in-selenium-based-test-automation/#:~:text=TestNG%20provides%20an%20Assert%20class,Assert)). *(Recursos: Javadoc de **JUnit 4** (referencia libre) ([
Assert (JUnit API)
](https://junit.org/junit4/javadoc/4.13/org/junit/Assert.html#:~:text=Asserts%20that%20a%20condition%20is,test%20with%20the%20given%20message)) ([
Assert (JUnit API)
](https://junit.org/junit4/javadoc/4.13/org/junit/Assert.html#:~:text=assertTrue)); Javadoc de **TestNG** (libre) ([org.testng/testng/7.3.0 : org/testng/Assert.java](https://code.yawk.at/org.testng/testng/7.3.0/org/testng/Assert.java#:~:text=Assertion%20tool%20class,message)); Tutorial JavaGuides con ejemplos de `fail()` en JUnit, gratuito, pr√°ctico ([JUnit Assert.fail() Method Example](https://www.javaguides.net/2018/08/junit-assertfail-method-example.html#:~:text=The%20fail,Assert%20class)) ([JUnit Assert.fail() Method Example](https://www.javaguides.net/2018/08/junit-assertfail-method-example.html#:~:text=Let%27s%20write%20the%20JUnit%20test,list%29%C2%A0method)).)*  

- **Uso de aserciones con frameworks espec√≠ficos** ‚Äì Cada framework de pruebas puede ofrecer *extras*. **Kotest (Kotlin)**, por ejemplo, introduce un estilo fluido: en lugar de m√©todos est√°ticos, emplea extensiones infix como `shouldBe` o `shouldContain`. Por ejemplo: `nombre shouldBe "sam"` comprueba que la variable `nombre` sea igual a "sam" ([Assertions | Kotest](https://kotest.io/docs/assertions/assertions.html#:~:text=Multitude%20of%20Matchers)). Estas construcciones se integran idiom√°ticamente al lenguaje (Kotlin) y permiten encadenar aserciones: p. ej. `"texto".shouldContain("tex").shouldBeLowerCase()` verifica dos propiedades de forma concisa ([Assertions | Kotest](https://kotest.io/docs/assertions/assertions.html#:~:text=For%20example%2C%20to%20assert%20that,function)). **JUnit 5** a√±adi√≥ m√©todos como `assertAll` para realizar m√∫ltiples aserciones agrupadas (reportando todas las fallas juntas) y `assertThrows` para simplificar la verificaci√≥n de excepciones esperadas. **TestNG** por su parte diferencia entre *Hard Asserts* y *Soft Asserts*: una *hard assert* (las tradicionales) interrumpe la prueba en el primer fallo, mientras que una *soft assert* acumula los errores y los reporta al final, permitiendo que el test contin√∫e ejecut√°ndose ([Guide To TestNG Assertions in Selenium Based Test Automation](https://www.pcloudy.com/blogs/guide-to-testng-assertions-in-selenium-based-test-automation/#:~:text=There%20are%20two%20types%20of,assertions%20in%20testng)) ([What is Assertion Testing? Ensuring Quality and Accuracy](https://www.functionize.com/automated-testing/assertion#:~:text=,even%20if%20some%20conditions%20fail)). En frameworks como **JUnit, NUnit, MSTest, etc.**, normalmente todas las aserciones son *hard* (a menos que se use una librer√≠a especial). Integrar aserciones en estos frameworks suele ser tan sencillo como importar est√°ticamente los m√©todos de aserci√≥n e invocarlos en el bloque de verificaci√≥n de cada caso de prueba. En todos los casos, **el resultado de la prueba** (pass/fail) **depende de las aserciones**: si alguna falla, el framework marca el test como fallido. *(Recursos: Documentaci√≥n de Kotest (sitio oficial, gratis) ([Assertions | Kotest](https://kotest.io/docs/assertions/assertions.html#:~:text=Multitude%20of%20Matchers)); Gu√≠a ‚ÄúTestNG Assertions‚Äù (Shivani Sinha, 2023) ‚Äì blog t√©cnico, gratis ([Guide To TestNG Assertions in Selenium Based Test Automation](https://www.pcloudy.com/blogs/guide-to-testng-assertions-in-selenium-based-test-automation/#:~:text=Irrespective%20of%20any%20programming%20language,case%20is%20passed%20or%20failed)) ([Guide To TestNG Assertions in Selenium Based Test Automation](https://www.pcloudy.com/blogs/guide-to-testng-assertions-in-selenium-based-test-automation/#:~:text=There%20are%20two%20types%20of,assertions%20in%20testng)); Documentaci√≥n JUnit 5 (open source); Blog de Microsoft/BrowserStack sobre aserciones en MSTest y NUnit, etc.)*  

- **Consideraciones de implementaci√≥n** ‚Äì Es importante escribir las aserciones de forma que aporten informaci√≥n √∫til. La mayor√≠a de frameworks permiten pasar un mensaje opcional: p. ej. `assertTrue(condici√≥n, "Mensaje de error")`. Si la condici√≥n falla, el mensaje aparecer√° en el reporte, facilitando diagnosticar el problema. Algunos frameworks (JUnit, NUnit) generan mensajes por defecto indicando el valor esperado y actual cuando se usa `assertEquals`, pero en otros casos conviene proporcionar un mensaje manual. Por ejemplo, en JUnit: `assertFalse(lista.isEmpty(), "La lista deber√≠a tener elementos")`. Tambi√©n es √∫til aprovechar las variantes especializadas (como `assertNotNull(obj)` en lugar de `assertTrue(obj != null)`), ya que expresan mejor la intenci√≥n y a veces dan mensajes m√°s claros. En JUnit 5, una mejora es que los mensajes de error pueden ser *lazy* (usando un `Supplier<String>`), de modo que no se calcula el texto del mensaje si la aserci√≥n pasa (optimizaci√≥n menor pero √∫til en muchas aserciones). En resumen, conocer las facilidades del framework (desde aserciones espec√≠ficas como `assertArrayEquals` hasta utilidades como `fail()`) permite integrar las aserciones de forma efectiva en la suite de pruebas. *(Recursos: Secci√≥n de *Assertions* en la **gu√≠a de JUnit 5** (gratuito, conceptual-pr√°ctico); Documentaci√≥n de **TestNG** sobre SoftAssert (web, gratuito); Ejemplos en **Blogs de Baeldung/HowToDoInJava** sobre aserciones en distintos frameworks.)*  

## Buenas pr√°cticas y patrones de dise√±o de aserciones  
- **Patrones estilo xUnit: AAA y ubicaci√≥n de aserciones** ‚Äì Una recomendaci√≥n ampliamente aceptada es estructurar las pruebas con el patr√≥n **Arrange-Act-Assert (AAA)**, donde la verificaci√≥n (*Assert*) viene al final. Es decir, primero se *prepara* el escenario y datos (Arrange), luego se *ejecuta* la funcionalidad a probar (Act) y finalmente se *verifican* los resultados (Assert). Esto mejora la legibilidad y garantiza que las aserciones se hagan *despu√©s* de ejercer el c√≥digo bajo prueba. Un consejo derivado de esto es **limitar cada prueba a un solo ‚ÄúAct‚Äù principal y su correspondiente verificaci√≥n**, evitando mezclar m√∫ltiples acciones en una misma prueba ([Assertion Roulette & Eager Test. Assertion Roulette is a test smell‚Ä¶ | by bytedev | Medium](https://bytedev.medium.com/assertion-roulette-eager-test-1481db0b744e#:~:text=Assertion%20Roulette%20can%20often%20be,is%20one%20%E2%80%9CAct%E2%80%9D%20per%20test)). Tener **una sola acci√≥n y resultado esperado por test** suele implicar una o pocas aserciones relacionadas; si una prueba est√° verificando muchos aspectos diferentes (m√∫ltiples ‚ÄúAct‚Äù), podr√≠a dividirse en varios tests. Algunos autores llaman a esto ‚Äúuna aserci√≥n por prueba‚Äù en el sentido de una √∫nica *intenci√≥n verificada*. Sin embargo, no significa que literalmente no pueda haber m√°s de un m√©todo de assert, sino que **todas las aserciones de un test deben relacionarse con el mismo comportamiento bajo prueba**. Si se necesitan varias aserciones para ese comportamiento, es v√°lido incluirlas juntas (p.ej., comprobar varias propiedades de un objeto tras una √∫nica acci√≥n). Lo importante es evitar que un test se vuelva demasiado ‚Äúansioso‚Äù (*Eager Test*), probando demasiadas cosas a la vez ([Assertion Roulette & Eager Test. Assertion Roulette is a test smell‚Ä¶ | by bytedev | Medium](https://bytedev.medium.com/assertion-roulette-eager-test-1481db0b744e#:~:text=Assertion%20Roulette%20can%20often%20be,is%20one%20%E2%80%9CAct%E2%80%9D%20per%20test)). *(Recursos: Entrada ‚ÄúHow to write better assertions: 5 Best Practices‚Äù ‚Äì Cesar Aguirre (DEV, 2021), gratis, pr√°ctico ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=4,and%20Assert)) ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=5,methods)); Art√≠culo Medium ‚ÄúAssertion Roulette & Eager Test‚Äù ‚Äì bytedev, 2023 ([Assertion Roulette & Eager Test. Assertion Roulette is a test smell‚Ä¶ | by bytedev | Medium](https://bytedev.medium.com/assertion-roulette-eager-test-1481db0b744e#:~:text=Assertion%20Roulette%20can%20often%20be,is%20one%20%E2%80%9CAct%E2%80%9D%20per%20test)).)*  

- **Claridad y mensajes en las aserciones** ‚Äì Cada aserci√≥n debe expresar claramente qu√© se est√° validando. Es una **mala pr√°ctica** usar aserciones sin contexto o poco descriptivas. Por ejemplo, una aserci√≥n como `assertTrue(x > 0)` no indica qu√© representa `x` ni por qu√© deber√≠a ser positivo, dificultando entender un fallo ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=Otra%20pr%C3%A1ctica%20recomendada%20para%20usar,documentar%20su%20l%C3%B3gica%20y%20expectativas)). En su lugar, es preferible usar m√©todos de aserci√≥n m√°s sem√°nticos (p. ej., `assertPositive(x)`, si existe) o al menos agregar un mensaje: `assertTrue(x > 0, "El saldo de la cuenta no debe ser negativo")` ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=Otra%20pr%C3%A1ctica%20recomendada%20para%20usar,documentar%20su%20l%C3%B3gica%20y%20expectativas)). De esta forma, si la prueba falla, el mensaje ayuda a ubicar r√°pidamente la causa. Las **aserciones m√∫ltiples** en un mismo test tambi√©n deben manejarse con cuidado: si todas usan el mismo m√©todo gen√©rico sin mensajes, puede ser dif√≠cil saber *cu√°l* fall√≥. Este problema es conocido como **‚ÄúAssertion Roulette‚Äù**, un *test smell* donde *‚Äúpuede ser dif√≠cil determinar cu√°l de varias aserciones en un test caus√≥ la falla‚Äù* ([Assertion Roulette & Eager Test. Assertion Roulette is a test smell‚Ä¶ | by bytedev | Medium](https://bytedev.medium.com/assertion-roulette-eager-test-1481db0b744e#:~:text=Share)). Para evitarlo, se sugiere: (a) incluir mensajes o usar aserciones espec√≠ficas que indiquen el valor esperado/actual, (b) no acumular decenas of verificaciones en un solo test ‚Äì en lugar de eso, repartir en tests m√°s enfocados si es posible, y (c) si se usan muchas aserciones juntas (por necesidad), considerar utilidades como JUnit `assertAll` para que se reporten *todas* las fallas de una vez. En general, la **legibilidad** y **mantenibilidad** de las pruebas mejora si las aserciones se entienden f√°cilmente. Un principio de dise√±o es que una persona leyendo el test debe poder captar qu√© condici√≥n se comprueba y qu√© significa su incumplimiento. *(Recursos: Art√≠culo de LinkedIn *‚Äúpr√°cticas recomendadas con aserciones‚Äù*, espa√±ol, b√°sico ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=Otra%20pr%C3%A1ctica%20recomendada%20para%20usar,documentar%20su%20l%C3%B3gica%20y%20expectativas)); Descripci√≥n de *Assertion Roulette* en xUnit Patterns (Gerard Meszaros) ‚Äì libro de referencia, 2007 (pago, avanzado) ([Assertion Roulette & Eager Test. Assertion Roulette is a test smell‚Ä¶ | by bytedev | Medium](https://bytedev.medium.com/assertion-roulette-eager-test-1481db0b744e#:~:text=Share)).)*  

- **Otras buenas pr√°cticas** ‚Äì **No duplicar l√≥gica en las aserciones**: evitar c√°lculos complejos dentro del propio `assert` (por ejemplo, pasando como argumento una expresi√≥n con operaciones l√≥gicas intrincadas). Toda la l√≥gica deber√≠a estar en la fase Act o Arrange, dejando la aserci√≥n lo m√°s simple posible (p. ej., comparar un resultado ya calculado con un valor esperado conocido) ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=Have%20a%20single%20Act%20and,to%20assert%20on%20each%20value)) ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=5,methods)). **Usar las aserciones apropiadas**: las bibliotecas de pruebas ofrecen muchas variantes, escoger la que comunique mejor la intenci√≥n. Por ejemplo, en vez de `assertTrue(lista.size() == 5)`, usar `assertEquals(5, lista.size())`; en vez de comparar strings con equals, quiz√° usar algo como `assertTrue(texto.contains(...))` o, mejor, en JUnit usar `assertLinesMatch` o en Kotest `texto shouldContain "..."`. Algunas bibliotecas tienen clases espec√≠ficas, como `StringAssert` en JUnit (4) o m√©todos especializados (`contains`, `startsWith`) ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=Use%20the%20right%20assertion%20methods,roll%20your%20own%20assertion%20framework)) ‚Äì aprovecharlos mejora la expresividad. **Mantener las pruebas limpias**: refactorizar si una misma secuencia de aserciones se repite en muchos tests (posiblemente extray√©ndola a una funci√≥n utilitaria o aserci√≥n custom, como se mencion√≥ antes). Revisar peri√≥dicamente que las aserciones sigan siendo v√°lidas cuando cambian requisitos; a veces una aserci√≥n puede volverse obsoleta o redundante y conviene eliminarla para evitar ruido ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=5%20Revisa%20y%20refactoriza%20tus,aserciones%20con%20regularidad)). Finalmente, **‚Äúprobar las aserciones‚Äù** en s√≠ mismas en cierto modo: esto significa verificar que nuestras aserciones fallan cuando deben (por ejemplo, si invertimos una condici√≥n deliberadamente para asegurarnos de que el mensaje de error es √∫til). Aunque uno no escribe tests unitarios para las aserciones, s√≠ puede validarlas emp√≠ricamente durante el desarrollo de la prueba. *(Recursos: Serie de art√≠culos *‚ÄúUnit Testing 101‚Äù* ‚Äì Aguirre, especialmente ‚ÄúDon‚Äôt duplicate logic in Asserts‚Äù (DEV.to, 2021) para errores comunes ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=Have%20a%20single%20Act%20and,to%20assert%20on%20each%20value)) ([How to write better assertions: 5 Best Practices - DEV Community](https://dev.to/canro91/unit-test-best-practices-on-assertions-1mpm#:~:text=5,methods)); Art√≠culo colaborativo de LinkedIn en espa√±ol ‚Äì recomendaciones varias ([Procedimientos recomendados para usar aserciones en pruebas de c√≥digo](https://www.linkedin.com/advice/0/what-best-practices-using-assertions-testing-6uxje?lang=es#:~:text=5%20Revisa%20y%20refactoriza%20tus,aserciones%20con%20regularidad)); **xUnit Test Patterns** ‚Äì G. Meszaros, cap√≠tulo de ‚ÄúSmells‚Äù de pruebas, que cubre patrones como *Assertion Roulette*, *Lazy Test*, etc. (conceptual).)* */}