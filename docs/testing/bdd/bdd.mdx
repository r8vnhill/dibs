---
title: BDD by example
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard, JestCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="testing-kt" />
<ModuleSetup module='bdd' task='setupBddModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupdBddModule") {
        description = "Creates the base module and files for the BDD introductory lesson"
        module.set("bdd")
        doLast {
            createFiles(
                "users",
                main to "UserService.kt",
                test to "UserServiceTest.kt",
            )
        }
    }
    ```
</ModuleSetup>

El **Desarrollo Dirigido por Comportamiento** (*Behavior-Driven Development*, BDD) es una metodolog√≠a √°gil basada en colaboraci√≥n. A diferencia del Desarrollo Dirigido por Pruebas (*Test-Driven Development*, TDD), BDD enfatiza la comunicaci√≥n entre quienes programan, QA y partes interesadas no t√©cnicas, asegurando que todas las personas involucradas compartan el mismo entendimiento del software. BDD se centra en el comportamiento esperado del software desde la perspectiva de quienes lo utilizan

En esta lecci√≥n, exploraremos c√≥mo implementar BDD utilizando **Kotest**. Suponemos que ya te manejas con TDD y ahora quieres integrar BDD en tu flujo de trabajo.

## üöÄ Introducci√≥n al BDD (Behavior-Driven Development)

El **Behavior-Driven Development** es una metodolog√≠a que busca:

- **Fomentar la colaboraci√≥n** entre todas las partes involucradas en el desarrollo, como equipos de desarrollo, testers, y stakeholders.
- **Definir el comportamiento** esperado del sistema utilizando un lenguaje claro y accesible, cercano al lenguaje natural.
- **Guiar el desarrollo** mediante ejemplos y escenarios espec√≠ficos que ilustran c√≥mo deber√≠a comportarse el sistema bajo diferentes circunstancias.

En BDD, las pruebas se estructuran para describir **caracter√≠sticas** y **escenarios** que se alinean con los requisitos del negocio, permitiendo que las pruebas act√∫en como documentaci√≥n viviente del sistema.

### Estructura de una Prueba BDD

Un test BDD t√≠pico sigue la siguiente estructura:

1. **Given**: Describe el estado inicial o las condiciones previas del sistema.
2. **When**: Describe la acci√≥n o evento que se est√° probando.
3. **Then**: Describe el resultado o comportamiento esperado como consecuencia de la acci√≥n.

## üìö Caso de Estudio: Gesti√≥n de Usuarios

Supongamos que estamos desarrollando una biblioteca de software para la gesti√≥n de usuarixs. Queremos implementar funcionalidades clave, como:

- Registrar nuevxs usuarixs en el sistema.
- Manejar situaciones excepcionales, como el intento de registro de unx usuarix que ya existe (duplicado).

Utilizaremos BDD para guiar el desarrollo de estas funcionalidades, escribiendo especificaciones que detallen el comportamiento esperado del sistema en diferentes escenarios.

## ‚úçÔ∏è Escribiendo Especificaciones con Kotest

Kotest proporciona varios estilos para escribir pruebas en un formato BDD. En esta lecci√≥n, utilizaremos el estilo `FreeSpec`, que es flexible y legible, permitiendo estructurar las pruebas en una jerarqu√≠a que imita el lenguaje natural y facilita la comprensi√≥n del flujo de escenarios. Aunque en esta lecci√≥n utilizamos `FreeSpec`, puedes optar por otros estilos seg√∫n tus necesidades y preferencias.

## ‚úÖ Registro de Usuarixs Exitoso

### Especificaci√≥n

Comenzamos escribiendo una especificaci√≥n para un caso com√∫n en el que una persona se registra correctamente. La estructura de BDD con Kotest nos permite expresar el comportamiento de forma natural:

```kotlin
"A user service" - {
    "when registering a new user" - {
        "should add the user to the database" { }
    }
}
```

Esta es la estructura b√°sica de nuestra especificaci√≥n BDD. Ahora, agregaremos los detalles que prueban si el usuario se registra correctamente en el sistema.

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```kotlin showLineNumbers title="bdd/src/test/kotlin/com/github/username/users/UserServiceTest.kt"
        lateinit var userService: UserService

        beforeEach {
            userService = UserService()
        }

        "A user service" - {
            "when registering a new user" - {
                "should add the user to the database" {
                    userService.register(USER, PASSWORD)
                    userService.users.contains(USER) shouldBe true
                }
            }
        }
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```kotlin showLineNumbers title="bdd/src/test/kotlin/com/github/username/users/UserServiceTest.kt"
        package com.github.username.users

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        private const val USER = "ichigo"
        private const val PASSWORD = "shinigami123"

        class UserServiceTest : FreeSpec({
            lateinit var userService: UserService

            // Inicializa el servicio antes de cada test
            beforeEach {
                userService = UserService()
            }

            "A user service" - {
                "when registering a new user" - {
                    "should add the user to the database" {
                        userService.register(USER, PASSWORD)
                        userService.users.contains(USER) shouldBe true
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Estructura BDD**: Hemos utilizado la sintaxis `given/when/then` impl√≠cita con el estilo `FreeSpec` de Kotest. Esto facilita la escritura de pruebas de comportamiento enfocadas en casos de uso del sistema.
    - **`lateinit`**: La variable `userService` se declara como `lateinit`, lo que significa que no se inicializa inmediatamente, sino antes de cada prueba. Esto es una alternativa m√°s segura a la inicializaci√≥n como `null`.
    - **Inicializaci√≥n**: El servicio de usuarixs (`UserService`) se reinicializa antes de cada prueba para asegurar que cada prueba se ejecute en un entorno limpio.
    - **Prueba esencial**: La prueba verifica que, al registrar una nueva persona usuaria, esta se guarda correctamente en la "base de datos" (representada por una colecci√≥n `users`).
</Explanation>

Este enfoque BDD ayuda a que las pruebas reflejen el comportamiento esperado de la biblioteca de software desde una perspectiva clara y centrada en quien la utiliza.

### Implementaci√≥n M√≠nima

Ahora, implementamos el c√≥digo m√≠nimo para que la prueba pase.

```kotlin showLineNumbers title="bdd/src/main/kotlin/com/github/username/users/UserService.kt"
package com.github.username.users

class UserService {
    private val _users = mutableMapOf<String, String>()
    val users: List<String> 
        get() = _users.keys.toList()

    fun register(username: String, password: String) {
        _users[username] = password
    }
}
```

La prueba debe pasar ahora, confirmando que unx usuarix puede registrarse exitosamente.

<Exercise>
    Extiene la clase `UserService` para manejar la autenticaci√≥n exitosa de unx usuarix. Escribe una especificaci√≥n BDD y una prueba que verifique que unx usuarix registrado pueda autenticarse correctamente con su nombre de usuario y contrase√±a.
    
    <Solution>
        ```kotlin showLineNumbers
        "when authenticating an existing user" - {
            "should return true for valid credentials" {
                userService.register(USER, PASSWORD)
                userService.authenticate(USER, PASSWORD) shouldBe true
            }
        }
        ```

        ```kotlin showLineNumbers
        fun authenticate(username: String, password: String) = 
            _users[username] == password
        ```    
    </Solution>
</Exercise>

## ‚ö†Ô∏è Manejo de Usuarixs Duplicados

### Especificaci√≥n

Escribimos una especificaci√≥n para manejar el caso excepcional donde unx usuarix intenta registrarse con un nombre de usuario ya existente.

```kotlin
class UserServiceTest : FreeSpec({
    "A user service" - {
        "when registering a new user" - {
            "should have the user in the database" { }
        }

        "when registering an existing user" - {
            "should throw an exception" { }
        }
    }
})
```

Con el escenario definido, podemos llenar los detalles espec√≠ficos.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        "when registering an existing user" - {
            "should throw an exception" {
                userService.register(USER, PASSWORD)
                shouldThrow<IllegalArgumentException> {
                    userService.register(USER, PASSWORD)
                }.message shouldBe "User already exists"
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="bdd/src/test/kotlin/com/github/username/users/UserServiceTest.kt"
        package cl.ravenhill.users

        import io.kotest.assertions.throwables.shouldThrow
        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe

        private const val USER = "ichigo"
        private const val PASSWORD = "shinigami123"

        class UserServiceTest : FreeSpec({
            lateinit var userService: UserService

            beforeEach {
                userService = UserService()
            }

            "A user service" - {
                "when registering a new user" - {
                    "should have the user in the database" {
                        userService.register(USER, PASSWORD)
                        userService.users.contains(USER) shouldBe true
                    }
                }

                "when registering an existing user" - {
                    "should throw an exception" {
                        userService.register(USER, PASSWORD)
                        shouldThrow<IllegalArgumentException> {
                            userService.register(USER, PASSWORD)
                        }.message shouldBe "User already exists"
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Prueba de excepci√≥n**: Utilizamos `shouldThrow` para verificar que se arroje una excepci√≥n `IllegalArgumentException` cuando se intenta registrar unx usuarix duplicado.
    - **Mensaje de error**: Verificamos que el mensaje de la excepci√≥n sea `"User already exists"`, lo que indica que la persona ya est√° registrada en el sistema.
</Explanation>

### Implementaci√≥n M√≠nima

Lo siguiente es implementar el c√≥digo m√≠nimo para que la prueba pase.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        fun register(username: String, password: String) {
            require(username !in _users) { "User already exists" }
            _users[username] = password
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="bdd/src/main/kotlin/com/github/username/users/UserService.kt"
        package com.github.username.users
        
        class UserService {
            private val _users = mutableMapOf<String, String>()
            val users: List<String>
                get() = _users.keys.toList()

            fun register(username: String, password: String) {
                require(username !in _users) { "User already exists" }
                _users[username] = password
            }
        }
        ```
    </TabItem>
</BoxedTabs>

<Exercise>
    Extiende la clase `UserService` para manejar la autenticaci√≥n fallida de unx usuarix. Escribe una especificaci√≥n BDD y una prueba que verifique que unx usuarix no registrado no pueda autenticarse.

    La autenticaci√≥n puede fallar si la persona no existe en la base de datos o si la contrase√±a no coincide. Arroja una excepci√≥n `IllegalArgumentException` con un mensaje adecuado en caso de autenticaci√≥n fallida.

    <Solution>
        ```kotlin showLineNumbers title="bdd/src/test/kotlin/com/github/username/users/UserServiceTest.kt"
        "when authenticating a non-existing user" - {
            "should return false" {
                val wrongPassword = "wrongpassword"
                wrongPassword shouldNotBe PASSWORD
                userService.register(USER, PASSWORD)
                userService.authenticate(USER, "wrongpassword") shouldBe false
            }

            "should throw an exception" {
                shouldThrow<IllegalArgumentException> {
                    userService.authenticate("nonexistent", "password")
                }.message shouldBe "User not found"
            }
        }
        ```

        ```kotlin showLineNumbers title="bdd/src/main/kotlin/com/github/username/users/UserService.kt"
        fun authenticate(username: String, password: String): Boolean {
            require(username in _users) { "User not found" }
            return _users[username] == password
        }
        ```
    </Solution>
</Exercise>

## ‚öñÔ∏è Pros y Contras de BDD

<ProCons>
    <Pros>
        - **Colaboraci√≥n mejorada**: BDD promueve una comunicaci√≥n clara entre desarrolladorxs, testers y stakeholders no t√©cnicxs, asegurando que todxs compartan un entendimiento com√∫n de los requisitos y el comportamiento esperado del sistema.
        - **Documentaci√≥n viviente**: Las pruebas escritas en estilo BDD sirven como documentaci√≥n viviente. Si el c√≥digo cambia y una prueba BDD falla, eso indica que el comportamiento del sistema tambi√©n ha cambiado, ayudando a detectar inconsistencias de inmediato.
        - **Enfoque en lx usuarix final**: Al definir los escenarios en t√©rminos de comportamiento, BDD mantiene el enfoque en c√≥mo el sistema debe funcionar desde la perspectiva de lx usuarix final, mejorando as√≠ la alineaci√≥n con los objetivos del negocio.
        - **Mayor legibilidad**: Las pruebas BDD escritas con Kotest o frameworks similares utilizan un lenguaje cercano al natural, lo que las hace m√°s comprensibles para todas las partes involucradas en el proyecto, incluso aquellas sin conocimientos t√©cnicos profundos.
        - **Prevenci√≥n de errores**: Al especificar los escenarios antes de implementar el c√≥digo, BDD ayuda a identificar y manejar casos excepcionales de forma proactiva, lo que reduce la probabilidad de errores en tiempo de ejecuci√≥n.
    </Pros>
    <Cons>
        - **Curva de aprendizaje**: Implementar BDD efectivamente puede requerir un cambio de mentalidad y aprendizaje de nuevas herramientas y t√©cnicas, lo que podr√≠a ser un desaf√≠o para equipos que no est√©n familiarizados con esta metodolog√≠a.
        - **Tiempo adicional**: Escribir especificaciones detalladas y mantenerlas actualizadas puede llevar tiempo, lo que podr√≠a ralentizar el proceso de desarrollo inicial en comparaci√≥n con otros enfoques menos estructurados.
        - **Dependencia de colaboraci√≥n**: El √©xito de BDD depende en gran medida de la colaboraci√≥n efectiva entre equipos t√©cnicos y no t√©cnicos. Si esta colaboraci√≥n no es fluida, el proceso podr√≠a resultar ineficaz.
        - **Sobrecarga en proyectos peque√±os**: Para proyectos simples o de corta duraci√≥n, el enfoque detallado y estructurado de BDD puede resultar excesivo y generar una sobrecarga innecesaria en comparaci√≥n con TDD o pruebas unitarias tradicionales.
        - **Complejidad en casos complejos**: En proyectos grandes con m√∫ltiples escenarios y flujos de negocio, la gesti√≥n de especificaciones BDD puede volverse compleja, requiriendo un enfoque disciplinado para mantener la claridad y la consistencia.
    </Cons>
</ProCons>

## üéØ Conclusiones y Aprendizajes


En esta lecci√≥n, exploramos c√≥mo el **Behavior-Driven Development (BDD)**, en combinaci√≥n con **Test-Driven Development (TDD)**, puede transformar la manera en que desarrollamos bibliotecas de software, especialmente en un lenguaje como **Kotlin** utilizando **Kotest**.

### Puntos clave

- BDD no solo se enfoca en probar la funcionalidad, sino tambi√©n en capturar y expresar el **comportamiento** esperado desde la perspectiva de lx usuarix final, utilizando un lenguaje claro y natural.
- La estructura **Given-When-Then** de BDD nos permite definir escenarios de manera ordenada y comprensible, alineando las pruebas con los **requisitos del negocio**.
- Integramos BDD en el desarrollo de una **biblioteca de gesti√≥n de usuarixs**, demostrando c√≥mo se utilizan especificaciones para guiar la implementaci√≥n y refactorizaci√≥n del c√≥digo.
- Utilizando Kotest, exploramos c√≥mo escribir pruebas que son legibles y estructuradas, facilitando tanto la colaboraci√≥n en equipo como el mantenimiento a largo plazo del software.

---

Al final, BDD nos ayuda a mejorar la calidad del software, asegurando que cada caracter√≠stica se implemente con un claro entendimiento de su prop√≥sito y comportamiento esperado. Es una metodolog√≠a que, aunque puede implicar una mayor inversi√≥n inicial en tiempo y esfuerzo, proporciona un **valor significativo** en t√©rminos de colaboraci√≥n, claridad y reducci√≥n de errores a lo largo del ciclo de vida del desarrollo de software.

<div className="language-card-container">
    <JestCard link="/docs/testing/bdd/jest" />
</div>
