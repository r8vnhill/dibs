---
title: Matchers compuestos en otros frameworks
---

## JavaScript/Typescript: **Jest**

**Jest** es un popular framework de pruebas para aplicaciones JavaScript y TypeScript. Al igual que Kotest, Jest ofrece una amplia gama de **matchers** para verificar que los valores en las pruebas cumplen con ciertas condiciones. Además, permite la creación de **matchers personalizados**, que se pueden componer para validar reglas más complejas, de manera similar a Kotest.

### Matchers Personalizados en Jest

En **Jest**, se pueden crear matchers personalizados utilizando el método `expect.extend`. A continuación, se muestra cómo se podría implementar un matcher que valide contraseñas fuertes, similar a lo que se hace en Kotest:

```javascript title="test/matchers/beStrongPassword.t s" showLineNumbers
expect.extend({
  toBeStrongPassword(password: string) {
    const hasDigit = /\d/.test(password);
    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasMinLength = password.length >= 16;

    const pass = hasDigit && hasUppercase && hasLowercase && hasMinLength;
    if (pass) {
      return {
        message: () => `expected ${password} not to be a strong password`,
        pass: true,
      };
    } else {
      return {
        message: () => `expected ${password} to be a strong password`,
        pass: false,
      };
    }
  },
});
```

En este ejemplo:

- **`expect.extend`**: Añade el matcher personalizado `toBeStrongPassword` al conjunto de matchers disponibles en Jest.
- **`pass`**: Determina si la condición de la prueba se cumple o no.
- **`message`**: Proporciona un mensaje personalizado dependiendo del resultado de la validación.

### Uso en Pruebas

Una vez definido el matcher, se puede utilizar en las pruebas de Jest para validar que las contraseñas cumplen con los requisitos de fortaleza:

```javascript title="test/matchers/beStrongPassword.test.js" showLineNumbers
test('strong password validation', () => {
  expect('Password1AaBbCcDdEeFf').toBeStrongPassword();
});
```

### Comparación con Kotest

| Característica          | Kotest                                   | Jest                                                                   |
|-------------------------|------------------------------------------|------------------------------------------------------------------------|
| Definición de Matchers  | Utiliza funciones o clases en Kotlin     | Utiliza `expect.extend` en JavaScript/TypeScript                       |
| Composición de Matchers | Composición mediante `and` y `or`        | La lógica de los matchers personalizados se escribe dentro del matcher |
| Uso en Pruebas          | Se usa `should` con el matcher compuesto | Se usa `expect` con el matcher personalizado                           |

### Similitudes

1. **Matchers Compuestos**: Ambos frameworks permiten crear matchers personalizados que pueden combinarse para realizar validaciones más complejas.
2. **Reutilización**: Los matchers personalizados en Kotest y Jest se pueden reutilizar en múltiples pruebas, lo que mejora la flexibilidad y legibilidad de las pruebas.
3. **Mensajes de Error Personalizados**: Tanto Kotest como Jest permiten definir mensajes de error personalizados cuando un matcher falla, lo que ayuda a depurar fácilmente los problemas en las pruebas.

### Diferencias

1. **Composición**: En Kotest, la composición de matchers se realiza mediante operadores como `and` y `or`, mientras que en Jest la lógica de combinación de condiciones se escribe directamente dentro del matcher personalizado.
2. **Extensibilidad**: En Jest, los matchers personalizados se definen mediante `expect.extend`, lo que agrega flexibilidad para extender el sistema de aserciones nativo, mientras que en Kotest la creación de matchers está más integrada con las funciones del lenguaje y el sistema de tipos.

## Ruby: **RSpec**

**RSpec** es uno de los frameworks más populares para pruebas en Ruby. Aunque se centra principalmente en pruebas de comportamiento, RSpec también permite la creación de **matchers personalizados**, similar a cómo se pueden componer matchers en Kotest.

### Matchers Personalizados en RSpec

En **RSpec**, los matchers se definen utilizando el método `define` para crear un matcher que pueda ser reutilizado en diferentes pruebas. Los matchers también se pueden combinar para crear composiciones más complejas. A continuación, se muestra cómo se podría crear un matcher que valide contraseñas siguiendo reglas similares a las de Kotlin:

```ruby title="spec/matchers/be_strong_password.rb" showLineNumbers
RSpec::Matchers.define :be_strong_password do
  match do |password|
    password.length >= 16 &&
    password.match?(/\d/) &&
    password.match?(/[A-Z]/) &&
    password.match?(/[a-z]/)
  end

  failure_message do |password|
    "expected #{password} to be a strong password"
  end
end
```

En este ejemplo:

- **`define`**: Crea un matcher personalizado llamado `be_strong_password`.
- **`match`**: Contiene la lógica que verifica si la contraseña cumple con los requisitos.
- **`failure_message`**: Proporciona un mensaje de error personalizado cuando el matcher falla.

### Uso en Pruebas

Una vez definido el matcher, podemos utilizarlo en nuestras pruebas de RSpec de manera similar a cómo se haría en Kotest con un matcher compuesto:

```ruby title="spec/matchers/be_strong_password_spec.rb" showLineNumbers
require 'matchers/be_strong_password'

RSpec.describe 'Strong Password' do
  it 'is valid with at least 16 characters, one digit, one uppercase, and one lowercase letter' do
    expect('Password1AaBbCcDdEeFf').to be_strong_password
  end
end
```

### Comparación con Kotest

| Característica          | Kotest                                   | RSpec                                                                    |
|-------------------------|------------------------------------------|--------------------------------------------------------------------------|
| Definición de Matchers  | Utiliza funciones o clases en Kotlin     | Define matchers personalizados usando bloques `define` en Ruby           |
| Composición de Matchers | Se puede realizar mediante `and` y `or`  | También se pueden combinar matchers utilizando lógica dentro del matcher |
| Uso en Pruebas          | Se usa `should` con el matcher compuesto | Se usa `expect` con el matcher personalizado                             |

### Similitudes

1. **Matchers Compuestos**: Ambos frameworks permiten crear matchers compuestos para realizar validaciones más complejas.
2. **Reutilización**: Los matchers personalizados se pueden reutilizar en múltiples pruebas, proporcionando flexibilidad y claridad en las validaciones.
3. **Mensajes de Error Personalizados**: Tanto en Kotest como en RSpec, es posible definir mensajes de error personalizados cuando una validación falla.

### Diferencias

1. **Sintaxis**: Kotest sigue la sintaxis de Kotlin, que es más concisa y estática, mientras que RSpec utiliza la flexibilidad de Ruby y su enfoque basado en bloques para definir matchers personalizados.
2. **DSL**: RSpec se basa en un DSL altamente dinámico propio de Ruby, lo que permite una mayor flexibilidad en la creación de matchers, mientras que Kotest aprovecha las ventajas de un lenguaje tipado como Kotlin para garantizar mayor seguridad en tiempo de compilación.
