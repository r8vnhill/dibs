---
title: Matchers composicionales
---
import References from "../../../src/components/ReferencesComponent";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import GithubRepoLink from "../../../src/components/GithubRepoLink";
import ReadingTime from "../../../src/components/ReadingTime";

<ReadingTime/>
<GithubRepoLink user={"r8vnhill"} repo={"assertions-kt"}/>

<br/>
## Matchers Composicionales

Los **matchers** se pueden combinar para crear reglas más complejas mediante la **composición** de otros matchers más simples. Esto permite verificar condiciones complejas de forma declarativa y legible.

Existen dos operaciones lógicas clave para componer matchers:

- **Suma lógica** (`Matcher.any` o `or`): Se satisface si al menos uno de los matchers es verdadero.
- **Producto lógico** (`Matcher.all` o `and`): Se satisface solo si todos los matchers son verdaderos.

### Ejemplo de composición de Matchers

Vamos a implementar un matcher para verificar que una contraseña es "fuerte". En este contexto, una contraseña fuerte debe:

- Contener al menos un número.
- Contener al menos una letra mayúscula.
- Contener al menos una letra minúscula.
- Tener al menos 16 caracteres.

<Tabs>
    <TabItem value="and" label="and">
        ```kotlin title="matchers/src/test/kotlin/cl/ravenhill/matchers/BeStrongPassword.kt"
        package cl.ravenhill.matchers

        import io.kotest.matchers.and
        import io.kotest.matchers.string.contain
        import io.kotest.matchers.string.containADigit
        import io.kotest.matchers.string.haveMinLength

        val beStrongPassword = containADigit() and
                contain("[A-Z]".toRegex()) and
                contain("[a-z]".toRegex()) and
                haveMinLength(16)
        ```
    </TabItem>
    <TabItem value="all" label="all">
        ```kotlin title="matchers/src/test/kotlin/cl/ravenhill/matchers/BeStrongPassword.kt"
        package cl.ravenhill.matchers

        import io.kotest.matchers.Matcher
        import io.kotest.matchers.compose.all
        import io.kotest.matchers.string.contain
        import io.kotest.matchers.string.containADigit
        import io.kotest.matchers.string.haveMinLength

        val beStrongPassword = Matcher.all(
            containADigit(),
            contain("[A-Z]".toRegex()),
            contain("[a-z]".toRegex()),
            haveMinLength(16)
        )
        ```
    </TabItem>
</Tabs>

### Uso en las pruebas

Una vez que hemos definido el matcher `beStrongPassword`, podemos utilizarlo en nuestras pruebas para asegurarnos de que las contraseñas cumplen con los requisitos de fortaleza:

```kotlin title="matchers/src/test/kotlin/cl/ravenhill/matchers/BeStrongPasswordTest.kt"
package cl.ravenhill.matchers

import io.kotest.core.spec.style.FreeSpec
import io.kotest.matchers.should

class StrongPasswordTest : FreeSpec({
    "A strong password" - {
        "should contain a digit, uppercase and lowercase letters, and at least 16 characters" {
            "Password1AaBbCcDdEeFf" should beStrongPassword
        }
    }
})
```

La composición de matchers es una herramienta poderosa que permite crear validaciones complejas de manera concisa y reutilizable.

:::tip Ejercicio
<Tabs>
    <TabItem value={"Enunciado"} label={"Enunciado"}>
        Crea un matcher compuesto que valide si una cadena es un correo electrónico válido. Un correo válido debe:

        1. Contener un símbolo `@`.
        2. Tener al menos un carácter antes del `@`.
        3. Tener al menos un carácter después del `@` y antes del `.`.
        4. Terminar con un dominio que tenga al menos 2 caracteres después del `.`.

        _Hints:_
        - _Puedes utilizar ``indexOf: String.(String) -> Int`` para encontrar la posición de un carácter en una cadena._
        - _Puedes utilizar ``substringAfterLast: String.(String) -> String`` para obtener la parte de una cadena después de la última ocurrencia de un carácter._
        - _Algunos matchers útiles son `contain` y `haveLengthAtLeast`._
    </TabItem>
    <TabItem value={"Solución"} label={"Solución"}>
        ```kotlin title="matchers/src/test/kotlin/cl/ravenhill/matchers/BeValidEmail.kt"
        package cl.ravenhill.matchers

        import io.kotest.matchers.Matcher
        import io.kotest.matchers.MatcherResult
        import io.kotest.matchers.and
        import io.kotest.matchers.string.contain

        fun beValidEmail(): Matcher<String> {
            val containsAt = contain("@")
            val hasTextBeforeAt = Matcher<String> { value ->
                MatcherResult(
                    value.indexOf("@") > 0,
                    { "The email should have text before '@'" },
                    { "The email has valid text before '@'" }
                )
            }
            val hasTextAfterAt = Matcher<String> { value ->
                MatcherResult(
                    value.indexOf("@") < value.lastIndexOf(".") - 1,
                    { "The email should have text between '@' and '.'" },
                    { "The email has valid text between '@' and '.'" }
                )
            }
            val validDomain = Matcher<String> { value ->
                MatcherResult(
                    value.substringAfterLast(".").length >= 2,
                    { "The domain should have at least 2 characters" },
                    { "The domain is valid" }
                )
            }

            return containsAt and hasTextBeforeAt and hasTextAfterAt and validDomain
        }
        ```
    </TabItem>
</Tabs>
:::

## Ejemplos en otros frameworks
<details>
    <summary>Ver ejemplos en otros frameworks</summary>

    ### JUnit + Hamcrest (Java)

    En **JUnit** usando **Hamcrest**, puedes combinar matchers utilizando `allOf()` para una composición de "y" lógica, o `anyOf()` para "o" lógica.

    ```java
    import static org.hamcrest.MatcherAssert.assertThat;
    import static org.hamcrest.Matchers.*;

    public class ExampleTest {
        @Test
        public void testCompositionalMatchers() {
            assertThat(42, allOf(greaterThan(40), lessThan(50)));
            assertThat("Hello world", anyOf(containsString("world"), containsString("planet")));
        }
    }
    ```

    - **`allOf(greaterThan(40), lessThan(50))`**: Verifica si el valor es mayor que 40 y menor que 50.
    - **`anyOf(containsString("world"), containsString("planet"))`**: Verifica si la cadena contiene "world" o "planet".

    ### Mocha + Chai (TypeScript)

    En **Mocha** con **Chai**, puedes combinar matchers utilizando `and` y `or` para crear validaciones compuestas.

    ```typescript
    import { expect } from 'chai';

    describe('Compositional Matchers Test', () => {
        it('should pass with combined matchers', () => {
            const result = 'Password123';
            expect(result).to.be.a('string').and.to.have.lengthOf.at.least(8).and.to.match(/\d/);
        });

        it('should pass for any of the conditions', () => {
            const result = 42;
            expect(result).to.be.oneOf([42, 43, 44]);
        });
    });
    ```

    ### RSpec (Ruby)

    En **RSpec** con **Ruby**, puedes combinar matchers usando `and` y `or`.

    ```ruby
    describe 'Compositional Matchers' do
        it 'combines matchers using and' do
            expect(42).to be > 40 and be < 50
        end

        it 'combines matchers using or' do
            expect('Hello world').to include('world').or include('planet')
        end
    end
    ```

    ### ScalaTest (Scala)

    En **ScalaTest**, puedes combinar matchers con `and` y `or`.

    ```scala
    import org.scalatest.flatspec.AnyFlatSpec
    import org.scalatest.matchers.should.Matchers

    class ExampleTest extends AnyFlatSpec with Matchers {
        "A number" should "be between 40 and 50" in {
            42 should (be > 40 and be < 50)
        }

        "A string" should "include 'world' or 'planet'" in {
            "Hello world" should (include ("world") or include ("planet"))
        }
    }
    ```

    ### NUnit (C#)

    En **NUnit**, puedes componer matchers utilizando `And` y `Or` para crear validaciones complejas.

    ```csharp
    using NUnit.Framework;

    [TestFixture]
    public class ExampleTest {
        [Test]
        public void CompositionalMatchersTest() {
            Assert.That(42, Is.GreaterThan(40).And.LessThan(50));
            Assert.That("Hello world", Does.Contain("world").Or.Contain("planet"));
        }
    }
    ```

    - **`Is.GreaterThan(40).And.LessThan(50)`**: Verifica si el valor es mayor que 40 y menor que 50.
    - **`Does.Contain("world").Or.Contain("planet")`**: Verifica si la cadena contiene "world" o "planet".
</details>

## Conclusión

Los **matchers composicionales** ofrecen una forma poderosa y concisa de validar múltiples condiciones al mismo tiempo, permitiendo escribir pruebas más expresivas y legibles. A través de operaciones lógicas como `and` y `or`, es posible combinar diferentes matchers para validar condiciones complejas de manera declarativa. Esta capacidad está disponible en una amplia variedad de frameworks de testing, lo que permite aplicar este enfoque en distintos lenguajes y ecosistemas de desarrollo, facilitando la creación de tests más robustos y reutilizables.

<References references={[
    {
        accessedDate: '22 de septiembre de 2024',
        siteOrAuthor: 'Kotest',
        title: 'Composed Matchers | Kotest',
        type: 'web',
        url: 'https://kotest.io/docs/assertions/composed-matchers.html',
    },
]}/>
