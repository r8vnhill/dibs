---
title: Matchers comunes en RSpec
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

**RSpec** es un framework de testing para Ruby que sigue el paradigma de Desarrollo Orientado por Comportamiento (BDD). Los matchers en RSpec se utilizan junto con el método `expect` para establecer expectativas sobre el código que se está probando.

## Ejemplos Comunes de Matchers en RSpec

- **Igualdad**: Verifica si un valor es igual a otro.

  ```ruby
  expect(result).to eq(42)
  ```

- **Desigualdad**: Verifica que dos valores no sean iguales.

  ```ruby
  expect(result).not_to eq(0)
  ```

- **No Nulo**: Asegura que un valor no es `nil`.

  ```ruby
  expect(result).not_to be_nil
  ```

- **Contenido en Cadenas**: Verifica que una cadena contiene otra subcadena.

  ```ruby
  expect(string).to include("world")
  ```

- **Empieza con**: Verifica que una cadena comienza con un prefijo específico.

  ```ruby
  expect(string).to start_with("Hello")
  ```

## Encadenar Matchers en RSpec

En RSpec, las expectativas se pueden expresar en sentencias separadas para el mismo objeto, pero no es común encadenar múltiples matchers en una sola expresión como en Kotest.

```ruby
expect(result).not_to be_nil
expect(result).to be > 10
expect(result).to be < 50
```

Para cadenas:

```ruby
expect(string).to start_with("Hello")
expect(string).to include("world")
expect(string).to end_with("!")
```

Aunque cada expectativa está en una línea separada, RSpec permite una lectura fluida y clara de las condiciones que se están verificando.

## Comparación final

| **Característica**                | **Kotest**                                                                                                                     | **RSpec**                                                                                                                   |
|-----------------------------------|---------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| **Encadenamiento de matchers**     | Soporta el encadenamiento fluido de matchers en una sola expresión, mejorando la legibilidad de las pruebas.                     | No se permite el encadenamiento de matchers en una misma línea; cada verificación se realiza en líneas separadas.            |
| **Expresividad del lenguaje**      | Kotlin proporciona una sintaxis moderna y concisa, y Kotest lo aprovecha para crear tests altamente legibles y eficientes.      | Ruby permite una sintaxis cercana al lenguaje natural, haciendo que las pruebas en RSpec sean claras y fáciles de entender.  |
| **Capacidad de personalización**   | Soporta matchers personalizados, pero con menos flexibilidad comparado con Ruby debido a las restricciones del tipado estático. | Gracias a la metaprogramación en Ruby, RSpec permite una personalización avanzada de matchers de manera sencilla.            |
| **Tipado estático vs dinámico**    | Kotest se beneficia del tipado estático de Kotlin, ofreciendo seguridad en tiempo de compilación y reduciendo errores en runtime.| Ruby es dinámico, permitiendo mayor flexibilidad, pero sacrificando la detección de errores en tiempo de ejecución.          |
| **Asincronía y concurrencia**      | Soporta pruebas con coroutines de Kotlin, lo que permite manejar pruebas asincrónicas de manera eficiente.                      | Ruby soporta concurrencia, pero no tiene un equivalente directo a las coroutines de Kotlin, limitando las pruebas asincrónicas.|

### Beneficios y limitaciones

<ProCons>
  <Pros>
    - **Expresividad**: **RSpec** permite escribir pruebas de manera muy cercana al lenguaje natural, lo que facilita la lectura y entendimiento del código de prueba. Su sintaxis, basada en el paradigma de desarrollo orientado por comportamiento (BDD), ayuda a definir claramente las expectativas del código.
    - **Personalización avanzada**: Gracias a la metaprogramación de **Ruby**, **RSpec** permite crear fácilmente matchers personalizados y adaptar el framework a las necesidades específicas del proyecto. Esto otorga una gran flexibilidad para validar casos únicos o comportamientos no estándar.
    - **Flexibilidad dinámica**: Al ser Ruby un lenguaje dinámico, **RSpec** permite una mayor flexibilidad en tiempo de ejecución. Esto hace que sea muy fácil modificar el comportamiento de las pruebas o cambiar cómo se manejan ciertas condiciones sin restricciones de tipado estático.
  </Pros>
  <Cons>
    - **Rendimiento**: Al estar basado en **Ruby**, un lenguaje interpretado, **RSpec** puede ser más lento en contextos de pruebas a gran escala o en sistemas con muchas pruebas concurrentes. Esto puede afectar el tiempo de ejecución de los test suites grandes comparado con frameworks basados en lenguajes más rápidos como Kotlin.
    - **Sin encadenamiento de matchers**: A diferencia de frameworks como **Kotest**, **RSpec** no permite encadenar múltiples matchers en una sola línea, lo que puede hacer que las pruebas se alarguen y se tornen menos compactas cuando se necesitan múltiples validaciones sobre el mismo objeto.
    - **Falta de seguridad en tiempo de compilación**: Debido a la naturaleza dinámica de Ruby, **RSpec** no ofrece la seguridad en tiempo de compilación que se encuentra en lenguajes con tipado estático como Kotlin. Esto significa que algunos errores sólo se detectarán en tiempo de ejecución, lo que puede ser un inconveniente en proyectos grandes o críticos.
    - **Soporte limitado para asincronía**: Aunque Ruby ofrece soporte para concurrencia, no tiene un mecanismo nativo como las coroutines en **Kotlin**, lo que hace que las pruebas asincrónicas y concurrentes sean menos eficientes y más difíciles de manejar en **RSpec**.
  </Cons>
</ProCons>

## ¿Qué aprendimos?

En esta lección, hemos comparado los **matchers** comunes en **RSpec** y **Kotest**, explorando cómo se utilizan ambos frameworks para validar expectativas en pruebas. También vimos las principales diferencias entre el encadenamiento de matchers, el tipado estático versus dinámico, y cómo el paradigma de desarrollo orientado por comportamiento (BDD) influye en la estructura de los tests en **RSpec**.

### Puntos clave:

- **Expresividad**: **RSpec** destaca por su sintaxis natural y clara, mientras que **Kotest** ofrece una sintaxis más concisa y eficiente gracias al tipado estático de **Kotlin**.
- **Personalización**: **RSpec** permite una gran flexibilidad a través de la metaprogramación de **Ruby**, facilitando la creación de matchers personalizados.
- **Encadenamiento**: **Kotest** permite encadenar matchers en una sola línea, mientras que **RSpec** separa las expectativas, lo que puede hacer que las pruebas sean más largas pero también más explícitas.
- **Rendimiento**: **RSpec** puede ser menos eficiente en sistemas con muchas pruebas debido a la naturaleza interpretada de **Ruby**.

---

<References references={[
    {
        title: "Exploring RSpec Expectations",
        bookTitle: "Effective testing with RSpec 3: Build Ruby apps with confidence",
        publisher: "The Pragmatic Bookshelf",
        pages: "169–185",
        year: "2017",
        author: "M. Marston & I. Dees",
        type: "book",
    },
]}/>
