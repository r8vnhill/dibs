---
title: Matchers comunes en Mocha + Chai
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

En **Mocha** junto con **Chai**, los **matchers** se utilizan para realizar validaciones expresivas en pruebas, similar a lo que ofrece Kotest en Kotlin. Mocha es un framework de pruebas para **JavaScript** y **TypeScript**, y Chai proporciona un sistema de aserciones con matchers que permiten validar diferentes condiciones de manera legible.

### Ejemplos Comunes de Matchers en Mocha + Chai:

- **Igualdad**: Verifica si un valor es igual a otro.
    ```javascript
    expect(result).to.equal(42);
    ```
- **Desigualdad**: Verifica que dos valores no sean iguales.
    ```javascript
    expect(result).to.not.equal(0);
    ```
- **No Nulo**: Asegura que un valor no es nulo o indefinido.
    ```javascript
    expect(result).to.not.be.null;
    expect(result).to.not.be.undefined;
    ```
- **Contenido en Cadenas**: Verifica que una cadena contiene otra.
    ```javascript
    expect(string).to.include("world");
    ```
- **Empieza con**: Verifica que una cadena comienza con un prefijo específico.
    ```javascript
    expect(string).to.match(/^Hello/);
    ```

### Encadenar Matchers en Mocha + Chai

Al igual que en Kotest, Chai permite **encadenar matchers** para hacer las pruebas más expresivas y evitar múltiples sentencias `expect`.

Por ejemplo:

```javascript
expect(result).to.be.a('number')
  .and.to.be.above(10)
  .and.to.be.below(50);
```

Aquí, se verifica que `result`:
1. **Es un número**.
2. **Es mayor que 10**.
3. **Es menor que 50**.

Otro ejemplo con cadenas:

```javascript
expect(string).to.startWith("Hello")
  .and.to.include("world")
  .and.to.endWith("!");
```

Aquí se valida que la cadena:
1. **Comienza con "Hello"**.
2. **Contiene "world"**.
3. **Termina con "!"**.

### Similitudes y Diferencias con Kotest

#### **Similitudes**:
- Ambos frameworks permiten hacer aserciones legibles y expresivas, con la posibilidad de encadenar múltiples matchers en una sola expresión.
- Chai y Kotest incluyen una amplia gama de matchers para validar condiciones comunes como igualdad, no nulidad, y contenido de cadenas.

#### **Diferencias**:
- En **Kotest**, la sintaxis de los matchers utiliza la forma `shouldBe`, mientras que en **Chai**, se usa `expect().to`.
- Kotest ofrece una mayor fluidez en su sintaxis con métodos como `shouldStartWith`, mientras que en Mocha + Chai es necesario combinar matchers de cadenas (`include`, `match`) para lograr lo mismo.
- **Mocha** se centra principalmente en JavaScript y TypeScript, mientras que **Kotest** es específico para Kotlin y está más integrado con las características del lenguaje.

### Resumen comparativo

| **Característica**                 | **Mocha + Chai**                                                                                       | **Kotest**                                                                                                  |
|------------------------------------|--------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| **Aserciones comunes**             | `expect(result).to.equal(value)`                                                                        | `result shouldBe value`                                                                                     |
| **Encadenamiento de matchers**     | Soporte para encadenamiento usando `.and` para validar múltiples condiciones en una sola expresión       | Soporte fluido para encadenar múltiples condiciones con una sintaxis clara (`shouldBe`, `shouldStartWith`)    |
| **Sintaxis**                       | Usa `expect().to` y `.and` para aserciones                                                              | Usa `shouldBe`, `shouldStartWith`, `shouldContain` y otras expresiones idiomáticas                          |
| **Integración**                    | Se utiliza comúnmente con **Mocha** para la estructura de pruebas y **Chai** para las aserciones         | **Kotest** ofrece una solución integrada para pruebas con un enfoque idiomático a Kotlin                    |

## ¿Qué aprendimos?

En esta comparación, hemos aprendido que tanto **Mocha + Chai** en JavaScript/TypeScript como **Kotest** en Kotlin ofrecen potentes capacidades para escribir pruebas expresivas y legibles mediante el uso de **matchers**.

### Puntos clave

1. **Sintaxis de Aserciones**: **Mocha + Chai** usa la estructura `expect().to` para realizar las aserciones, mientras que **Kotest** utiliza una sintaxis más idiomática para Kotlin, como `shouldBe` y `shouldStartWith`.  
2. **Encadenamiento de Matchers**: Ambos frameworks permiten encadenar **matchers** para validar múltiples condiciones en una sola expresión, mejorando la legibilidad de las pruebas. Sin embargo, Kotest proporciona una fluidez natural para Kotlin, mientras que Chai sigue una estructura más basada en métodos.
3. **Compatibilidad e Integración**: **Mocha** es un framework diseñado para JavaScript y TypeScript, por lo que es ampliamente usado en proyectos frontend y backend en esos lenguajes. Por su parte, **Kotest** está diseñado específicamente para **Kotlin**, ofreciendo integración profunda con las características del lenguaje, como **coroutines** y **DSLs**.

---

En conclusión, ambos frameworks son altamente eficientes para escribir pruebas expresivas, pero la elección entre ellos depende principalmente del lenguaje en el que estés trabajando. **Mocha + Chai** es la opción ideal para entornos JavaScript/TypeScript, mientras que **Kotest** se destaca en el ecosistema Kotlin con un enfoque más idiomático y fluido.

<References references={[
    {
        title: "Mocha—The fun, simple, flexible JavaScript test framework",
        url: "https://mochajs.org/#getting-started",
        accessedDate: "18 de octubre de 2024",
        type: "web",
    },
]}/>
