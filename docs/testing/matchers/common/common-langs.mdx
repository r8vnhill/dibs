---
title: Matchers comunes en otros frameworks
---

## Javascript/Typescript: Mocha + Chai

En **Mocha** junto con **Chai**, los **matchers** se utilizan para realizar validaciones expresivas en pruebas, similar a lo que ofrece Kotest en Kotlin. Mocha es un framework de pruebas para **JavaScript** y **TypeScript**, y Chai proporciona un sistema de aserciones con matchers que permiten validar diferentes condiciones de manera legible.

### Ejemplos Comunes de Matchers en Mocha + Chai:

- **Igualdad**: Verifica si un valor es igual a otro.
    ```javascript
    expect(result).to.equal(42);
    ```
- **Desigualdad**: Verifica que dos valores no sean iguales.
    ```javascript
    expect(result).to.not.equal(0);
    ```
- **No Nulo**: Asegura que un valor no es nulo o indefinido.
    ```javascript
    expect(result).to.not.be.null;
    expect(result).to.not.be.undefined;
    ```
- **Contenido en Cadenas**: Verifica que una cadena contiene otra.
    ```javascript
    expect(string).to.include("world");
    ```
- **Empieza con**: Verifica que una cadena comienza con un prefijo específico.
    ```javascript
    expect(string).to.match(/^Hello/);
    ```

### Encadenar Matchers en Mocha + Chai

Al igual que en Kotest, Chai permite **encadenar matchers** para hacer las pruebas más expresivas y evitar múltiples sentencias `expect`.

Por ejemplo:

```javascript
expect(result).to.be.a('number')
  .and.to.be.above(10)
  .and.to.be.below(50);
```

Aquí, se verifica que `result`:
1. **Es un número**.
2. **Es mayor que 10**.
3. **Es menor que 50**.

Otro ejemplo con cadenas:

```javascript
expect(string).to.startWith("Hello")
  .and.to.include("world")
  .and.to.endWith("!");
```

Aquí se valida que la cadena:
1. **Comienza con "Hello"**.
2. **Contiene "world"**.
3. **Termina con "!"**.

### Similitudes y Diferencias con Kotest

#### **Similitudes**:
- Ambos frameworks permiten hacer aserciones legibles y expresivas, con la posibilidad de encadenar múltiples matchers en una sola expresión.
- Chai y Kotest incluyen una amplia gama de matchers para validar condiciones comunes como igualdad, no nulidad, y contenido de cadenas.

#### **Diferencias**:
- En **Kotest**, la sintaxis de los matchers utiliza la forma `shouldBe`, mientras que en **Chai**, se usa `expect().to`.
- Kotest ofrece una mayor fluidez en su sintaxis con métodos como `shouldStartWith`, mientras que en Mocha + Chai es necesario combinar matchers de cadenas (`include`, `match`) para lograr lo mismo.
- **Mocha** se centra principalmente en JavaScript y TypeScript, mientras que **Kotest** es específico para Kotlin y está más integrado con las características del lenguaje.

## JVM: JUnit + Hamcrest

En **JUnit** con **Hamcrest**, los **matchers** permiten verificar condiciones de manera expresiva, similar a Kotest, pero utilizando una combinación de `assertThat` y diferentes matchers para lograr las mismas validaciones.

### Ejemplos Comunes de Matchers en JUnit + Hamcrest:

- **Igualdad**: Verifica si un valor es igual a otro.
    ```java
    assertThat(result, is(42));
    ```
- **Desigualdad**: Verifica que dos valores no son iguales.
    ```java
    assertThat(result, not(0));
    ```
- **No Nulo**: Asegura que un valor no es nulo.
    ```java
    assertThat(result, notNullValue());
    ```
- **Contenido en Cadenas**: Verifica que una cadena contiene otra.
    ```java
    assertThat(string, containsString("world"));
    ```
- **Empieza con**: Verifica que una cadena comienza con un prefijo específico.
    ```java
    assertThat(string, startsWith("Hello"));
    ```

### Encadenar Matchers en JUnit + Hamcrest

Al igual que en Kotest, en Hamcrest también es posible **encadenar matchers** para combinar múltiples condiciones en una sola declaración.

Por ejemplo:

```java
assertThat(result, allOf(greaterThan(10), lessThan(50), notNullValue()));
```

En este ejemplo, se verifica que `result`:
1. **Es mayor que 10**.
2. **Es menor que 50**.
3. **No es nulo**.

Otro ejemplo con cadenas:

```java
assertThat(string, allOf(startsWith("Hello"), containsString("world"), endsWith("!")));
```

Aquí se verifica que `string`:
1. **Comienza con "Hello"**.
2. **Contiene "world"**.
3. **Termina con "!"**.

### Similitudes y Diferencias con Kotest

- **Similitudes**: Ambos frameworks permiten escribir pruebas de forma expresiva y fluida usando matchers para verificar diferentes condiciones. Los matchers son encadenables, lo que mejora la legibilidad del código de pruebas.

- **Diferencias**: En Kotest, las validaciones se expresan de forma más fluida y natural con el uso de métodos como `shouldBe` y `shouldNotBe`, mientras que JUnit + Hamcrest utiliza una sintaxis basada en `assertThat` y matchers separados como `is()`, `not()`, y `containsString()`.
