---
title: Matchers predefinidos
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import { 
    LanguageCard,
    RSpecCard
} from "/src/components/cards/LanguageCard";
import Tooltip from '@site/src/components/Tooltip';
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime/>
<GithubRepoLink user={"r8vnhill"} repo={"assertions-kt"}/>

Los *matchers* son el coraz√≥n de las pruebas expresivas en **Kotest**. Permiten escribir afirmaciones legibles y declarativas, enfocadas m√°s en el *qu√©* esperamos del valor evaluado que en el *c√≥mo* lo verificamos. Gracias a su sintaxis fluida, los matchers ayudan a que los tests se lean como descripciones naturales del comportamiento esperado.

En esta lecci√≥n conocer√°s c√≥mo usar los **matchers predefinidos** que ofrece Kotest: desde validaciones simples como comprobar igualdad o nulidad, hasta expresiones m√°s sofisticadas encadenadas. Tambi√©n ver√°s c√≥mo esta forma de testear no solo mejora la claridad del c√≥digo, sino que facilita la detecci√≥n de errores y hace que tus pruebas se comuniquen mejor con otras personas.

Kotest incluye cientos de matchers especializados para trabajar con tipos como listas, cadenas, fechas, JSON, e incluso excepciones. Aprender a dominarlos es clave para escribir tests m√°s concisos, expresivos y mantenibles.

## Ejemplos Comunes de Matchers en Kotest

### Igualdad y Desigualdad

El matcher `shouldBe` en Kotest verifica si dos valores son **iguales estructuralmente**, es decir, si `a == b`. Esto significa que no compara identidad de objetos (`===`), sino su **contenido l√≥gico** tal como lo define el m√©todo `equals()`.

#### üí° Ejemplo contextualizado

Imaginemos que est√°s desarrollando una biblioteca para manejar configuraciones de usuario. Tienes una funci√≥n que devuelve una configuraci√≥n por defecto, y quieres asegurarte de que su contenido sea el correcto, **sin importar si es la misma instancia**:

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
  
  ```kotlin showLineNumbers
  defaultConfig() shouldBe UserConfig()
  ```
  
  </TabItem>
  <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
  
  ```kotlin showLineNumbers title="src/test/kotlin/UserConfigTest.kt"
  package com.github.username.config

  import io.kotest.core.spec.style.FreeSpec
  import io.kotest.matchers.shouldBe

  class UserConfigTest : FreeSpec({
      "default config should match expected content" {
          defaultConfig() shouldBe UserConfig()
      }
  })
  ```

  ```kotlin showLineNumbers title="src/main/kotlin/UserConfig.kt"
  package com.github.username.config

  class UserConfig(
      val theme: String = "light",
      val notificationsEnabled: Boolean = true
  )

  fun defaultConfig() = UserConfig()
  ```
  
  </TabItem>
</BoxedTabs>

<Explanation>
  En esta prueba verificamos que `defaultConfig()` devuelva una instancia que **tenga el mismo contenido** que la instancia creada directamente con `UserConfig()`.  
  Gracias a que `UserConfig` es una `data class`, Kotlin implementa autom√°ticamente `equals()` para comparar los campos.

  Esta forma de comparar objetos es √∫til al dise√±ar bibliotecas, ya que permite testear el **contenido esperado** sin depender de referencias exactas.
</Explanation>

#### ‚ùå Desigualdad

Si deseas comprobar que **dos valores no son iguales estructuralmente**, puedes usar el matcher `shouldNotBe`:

```kotlin
testConfig shouldNotBe defaultConfig()
```

Esto asegura que los contenidos no son equivalentes seg√∫n `equals()`.

<Explanation>
  - `a shouldBe b` ‚Üí verifica que `a == b`
  - `a shouldNotBe b` ‚Üí verifica que `a != b`

  Ambas expresiones se basan en `equals()`. Si necesitas redefinir lo que significa "igualdad" para una clase, puedes sobreescribir `equals()` o usar una `data class`, como en este ejemplo.
</Explanation>

:::tip[Igualdad referencial]

Si necesitas verificar que **dos referencias apuntan al mismo objeto en memoria**, puedes usar `shouldBeSameInstanceAs`:

```kotlin
a shouldBeSameInstanceAs b
```

Este matcher compara identidad referencial (`===`), no contenido l√≥gico.

:::


- **Igualdad**: Verifica si un valor es igual a otro.
    ```kotlin
    result shouldBe 42
    ```
- **Desigualdad**: Verifica que dos valores no sean iguales.
    ```kotlin
    result shouldNotBe 0
    ```
- **No Nulo**: Asegura que un valor no es nulo.
    ```kotlin
    result.shouldNotBeNull()
    ```
- **Contenido en Cadenas**: Verifica que una cadena contiene otra.
    ```kotlin
    string.shouldContain("world")
    ```
- **Empieza con**: Verifica que una cadena comienza con un prefijo espec√≠fico.
    ```kotlin
    string.shouldStartWith("Hello")
    ```

### Encadenar Matchers

Una de las ventajas de Kotest es que puedes **encadenar matchers** para hacer varias verificaciones en una sola expresi√≥n, mejorando la legibilidad del c√≥digo.

Por ejemplo:

```kotlin
result.shouldNotBeNull()
    .shouldBeGreaterThan(10)
    .shouldBeLessThan(50)
```


En este ejemplo, se verifica que `result`:
1. **No es nulo**.
2. **Es mayor que 10**.
3. **Es menor que 50**.

Otro ejemplo con cadenas:

```kotlin
string.shouldStartWith("Hello")
    .shouldContain("world")
    .shouldEndWith("!")
```

Aqu√≠, se verifica que `string`:

1. **Comienza con "Hello"**.
2. **Contiene "world"**.
3. **Termina con "!"**.

El encadenamiento de matchers permite que las pruebas sean m√°s expresivas y f√°ciles de seguir, eliminando la necesidad de m√∫ltiples sentencias `assert` y mejorando la fluidez de la validaci√≥n.

## Beneficios y limitaciones

<ProCons>
    <Pros>
        - **Legibilidad mejorada**: Los matchers en Kotest ofrecen una sintaxis m√°s expresiva y natural que las aserciones tradicionales (`assert`). Esto facilita que las pruebas sean m√°s claras y f√°ciles de entender.
        - **Encadenamiento**: Los matchers permiten encadenar m√∫ltiples validaciones en una sola l√≠nea, lo que reduce la cantidad de c√≥digo repetitivo y hace que las pruebas sean m√°s fluidas.
        - **Errores m√°s detallados**: Cuando una prueba falla, los matchers suelen generar mensajes de error m√°s espec√≠ficos y detallados que las aserciones comunes, lo que facilita la depuraci√≥n.
        - **Gran variedad de validaciones**: Kotest proporciona una amplia gama de matchers (m√°s de 350) que cubren validaciones espec√≠ficas, lo que permite que las pruebas se adapten mejor a diferentes tipos de datos y contextos.
        - **Consistencia**: El uso de matchers permite un enfoque m√°s consistente y estandarizado en las pruebas, especialmente cuando se utilizan en proyectos grandes o con varios colaboradores.
    </Pros>
    <Cons>
        - **Sobrecarga de dependencias**: Utilizar matchers avanzados puede requerir la inclusi√≥n de dependencias adicionales (como `kotest-assertions-json` o `kotest-assertions-core`), lo que puede aumentar el tama√±o del proyecto innecesariamente en casos simples.
        - **Curva de aprendizaje**: Aunque son m√°s expresivos, los matchers requieren que lxs desarrolladorxs aprendan una nueva API en lugar de utilizar aserciones tradicionales que pueden ser m√°s familiares.
    </Cons>
</ProCons>

## ¬øQu√© hemos visto?

En esta secci√≥n hemos explorado los **matchers** en Kotest, aprendiendo a verificar condiciones como igualdad, no nulidad, y contenido de cadenas de manera expresiva. Vimos ejemplos comunes de matchers como `shouldBe`, `shouldNotBe`, y c√≥mo encadenarlos para hacer las pruebas m√°s legibles y eficientes.

Esta forma de definir expectativas mejora la claridad, consistencia y fluidez de las pruebas.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://chaijs.com/img/chai-logo.png"
        language="JavaScript: Mocha + Chai"
        link="/docs/testing/matchers/common/chai"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/184143/java.svg"
        language="JVM: AssertJ"
        link="/docs/testing/matchers/common/assertj"
    />
    <LanguageCard
        logoSrc="https://hamcrest.org/images/logo.jpg"
        language="JVM: Hamcrest"
        link="/docs/testing/matchers/common/hamcrest"
    />
    <RSpecCard link="/docs/testing/matchers/common/rspec"/>
</div>

<References references={[
    {
        accessedDate: '26 de septiembre de 2024',
        siteOrAuthor: 'Kotest',
        title: 'Core Matchers | Kotest',
        type: 'web',
        url: 'https://kotest.io/docs/assertions/core-matchers.html',
    },
]}/>
