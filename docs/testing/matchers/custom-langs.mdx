---
title: Matchers personalizados en otros lenguajes
---

## Java: Hamcrest

**Hamcrest** es una librería de matchers para Java que se utiliza comúnmente con **JUnit** para escribir aserciones más legibles y expresivas.

### Estructura de un Matcher en Hamcrest

Para crear un matcher personalizado en Hamcrest, debes extender la clase `TypeSafeMatcher<T>`, donde `T` es el tipo de objeto que estás probando. Debes implementar dos métodos clave:

- `matchesSafely(T item)`: Contiene la lógica de la comparación.
- `describeTo(Description description)`: Proporciona una descripción del matcher para los mensajes de error.

### Crear un Matcher para Verificar Números Pares

Vamos a crear un matcher personalizado que verifique si un número entero es par, similar al ejemplo de **Kotest**.

```java
import org.hamcrest.Description;
import org.hamcrest.TypeSafeMatcher;

public class IsEvenMatcher extends TypeSafeMatcher<Integer> {

    @Override
    protected boolean matchesSafely(Integer number) {
        return number % 2 == 0;
    }

    @Override
    public void describeTo(Description description) {
        description.appendText("an even number");
    }

    @Override
    protected void describeMismatchSafely(Integer number, Description mismatchDescription) {
        mismatchDescription.appendText("was ").appendValue(number);
    }

    public static IsEvenMatcher isEven() {
        return new IsEvenMatcher();
    }
}
```

### Usar el Matcher Personalizado en Pruebas

Ahora, podemos utilizar el matcher `isEven()` en nuestras pruebas con **JUnit**:

```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.not;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class IsEvenMatcherTest {

    @Test
    @DisplayName("Números pares deben ser reconocidos como pares")
    public void testEvenNumbers() {
        int[] evenNumbers = {2, 4, 6, 8, 10};
        for (int number : evenNumbers) {
            assertThat(number, IsEvenMatcher.isEven());
        }
    }

    @Test
    @DisplayName("Números impares no deben ser reconocidos como pares")
    public void testOddNumbers() {
        int[] oddNumbers = {1, 3, 5, 7, 9};
        for (int number : oddNumbers) {
            assertThat(number, not(IsEvenMatcher.isEven()));
        }
    }
}
```

### Comparación con Kotest

#### Similitudes

- **Estructura de los Matchers**: Tanto en **Kotest** como en **Hamcrest**, los matchers personalizados se basan en interfaces o clases que requieren implementar métodos específicos para definir la lógica de comparación y los mensajes de error.

- **Uso en Pruebas**: En ambos casos, los matchers personalizados se utilizan en las pruebas para realizar aserciones más expresivas y claras.

- **Métodos de Ayuda**: Ambos frameworks proporcionan formas de crear matchers personalizados de manera concisa y reutilizable.

### Diferencias

- **Definición de Matchers**:
    - En **Kotest**, los matchers implementan la interfaz `Matcher<T>` y devuelven un `MatcherResult`.
    - En **Hamcrest**, los matchers extienden la clase `TypeSafeMatcher<T>` y sobrescriben métodos como `matchesSafely` y `describeTo`.

- **Mensajes de Error**:
    - En **Kotest**, los mensajes de error se manejan mediante funciones `failureMessageFn` y `negatedFailureMessageFn` en `MatcherResult`.
    - En **Hamcrest**, los mensajes de error se construyen usando el objeto `Description` en los métodos `describeTo` y `describeMismatchSafely`.

- **Verificación de Tipos**:
    - **Kotest** aprovecha el sistema de tipos de Kotlin y las funciones lambda para crear matchers de forma más funcional.
    - **Hamcrest** utiliza clases y herencia para definir matchers, siguiendo un enfoque más orientado a objetos.

### Limitaciones y Consideraciones

- **Simplicidad vs. Verbosidad**: La sintaxis de Kotlin permite una definición más concisa de matchers personalizados en comparación con Java, donde se requiere más código boilerplate.
