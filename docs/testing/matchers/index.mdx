---
title: "Matchers: Testing Declarativo"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />

Cuando escribimos pruebas automatizadas, es fundamental que el código de test sea **claro, expresivo y fácil de mantener**. Las aserciones tradicionales (`assertEquals`, `assertTrue`, etc.) cumplen su propósito, pero pueden resultar poco legibles o verbosas, especialmente en escenarios complejos. 

Los **matchers** surgen como una solución declarativa para expresar expectativas de forma más natural. En lugar de enfocarnos en cómo comparar valores, nos enfocamos en **qué esperamos** de ellos. Esta aproximación no solo mejora la legibilidad, sino que también produce mensajes de error más informativos y uniformes.

## 💡 ¿Por qué usar Matchers en tus pruebas?

<ProCons>
    <Pros>
        - **Declarativos y Expresivos**: Hacen que las pruebas sean más legibles, ya que expresan las expectativas de manera más natural.
        - **Mensajes de error claros:** Ofrecen descripciones detalladas que facilitan el diagnóstico rápido cuando una prueba falla.
        - **Consistencia en el código de pruebas:** Promueven un estilo uniforme y fácil de mantener a lo largo del proyecto.
        - **Amplio Soporte**: Son compatibles con diversos frameworks de testing como **AssertJ** (Java), **NUnit** (C#), **Scalatest** (Scala), **Jest** (TypeScript), **PyHamcrest** (Python), **RSpec** (Ruby), **GoogleTest** (C++), y **XCTest** (Swift), entre otros.        
    </Pros>
</ProCons>

## ⚖️ Comparación: Aserciones vs. Matchers

| **Aserciones**                                                                                  | **Matchers**                                                                                                          |
|-------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Verificaciones básicas que comparan valores y lanzan una excepción si la condición no se cumple | Encapsulan las comparaciones y mensajes de error, proporcionando una API más limpia y expresiva para escribir pruebas |
| `assertNotEquals(user.username, null)`                                                          | `user.username.shouldNotBeNull()`                                                                                     |

Como vemos, los Matchers hacen que las pruebas sean más legibles, concisas y autoexplicativas. Al eliminar ruido visual y mejorar los mensajes de error, se vuelven una herramienta clave para escribir tests sostenibles y expresivos.

### 🧪 Ejemplos con Matchers en Kotlin

```kotlin
val survivor = Survivor(name = "Rick", location = "Alexandria")

// En lugar de:
assertNotNull(survivor.name)
assertEquals("Alexandria", survivor.location)

// Usamos:
survivor.name.shouldNotBeNull()
survivor.location shouldBe "Alexandria"
```

## 🧭 Próximos pasos

Ahora que comprendemos la importancia de los matchers y cómo mejoran la claridad de nuestras pruebas, estamos listxs para profundizar en su uso y personalización. En las próximas secciones abordaremos:

- **Matchers predefinidos**: Exploraremos el conjunto de matchers que ya vienen listos para usar, cubriendo casos comunes como igualdad, nulidad, contenido de listas, rangos y expresiones regulares.
- **Matchers personalizados**: Aprenderemos a escribir nuestros propios matchers para adaptar las validaciones a nuestro dominio, haciendo que las pruebas sean aún más expresivas y reutilizables.
- **Matchers compuestos**: Veremos cómo combinar múltiples condiciones en un solo matcher, lo que permite verificar comportamientos complejos de manera concisa y coherente.

Estas herramientas nos permitirán escribir pruebas más precisas, legibles y alineadas con el diseño del dominio, tanto en bibliotecas reutilizables como en aplicaciones completas.
