---
title: Generadores a partir de PRNG
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="testing-kt" />
<ModuleSetup module='prng' task='setupPrngModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupPrngModule") {
        description = "Creates the base module and files for the PRNG based generator lesson"
        module.set("pbt:arbitrary:prng")
        doLast {
            createFiles(
                "lists",
                main to "average.kt",
                test to "AverageTest.kt",
            )
            createFiles(
                "maps",
                test to "IntStringMapTest.kt",
            )
        }
    }
    ```
</ModuleSetup>

Una de las formas m√°s b√°sicas de crear un generador en Kotest es utilizando la funci√≥n de orden superior `arbitrary`, que aprovecha un **Pseudo-Random Number Generator** manejado internamente por Kotest. Esta funci√≥n permite generar datos de prueba controlados y reproducibles, √∫tiles para la creaci√≥n de tests basados en propiedades.

## üìã Ejemplo: Generador de listas de n√∫meros

### üß≠ Definiendo la especificaci√≥n

Supongamos que queremos generar listas de **n√∫meros reales (Double)** de tama√±o arbitrario para probar una funci√≥n que calcula el promedio. Para lograrlo, podemos definir un generador que cree un par de datos: el primer elemento ser√° una lista de n√∫meros y el segundo ser√° el promedio esperado de esa lista. De esta manera, podremos validar f√°cilmente si la funci√≥n de promedio calcula correctamente el resultado.

Comencemos por definir una especificaci√≥n BDD (Behavior-Driven Development) para nuestro test:

```kotlin showLineNumbers
"Given a list of integers" - {
    "when calculating the average of a non-empty list" - {
        ("should return the sum of the elements divided by the number of " +
                "elements") {}
    }
}
```

Este enfoque sigue el flujo natural del lenguaje BDD, lo que permite expresar el comportamiento de la funci√≥n de manera clara y comprensible.

Ahora implementamos los detalles de nuestro test, donde usaremos un generador para crear pares de listas de n√∫meros y sus promedios correspondientes:

```kotlin showLineNumbers
checkAll(...) { (list, expectedAverage) ->
    average(list) shouldBe expectedAverage
}
```

<Explanation>
    Este ejemplo ilustra c√≥mo esperamos que nuestro generador funcione. Generar√° pares de listas de n√∫meros junto con sus promedios esperados. Luego, el test verificar√° que el promedio calculado por nuestra funci√≥n sea igual al promedio esperado generado previamente. Esto garantiza que nuestra implementaci√≥n de la funci√≥n de promedio sea correcta bajo una variedad de casos de prueba.
</Explanation>

### üõ†Ô∏è Implementando el generador

Para crear un generador personalizado en **Kotest**, utilizaremos la funci√≥n `arbitrary`, que nos permite definir c√≥mo se generan los datos de prueba seg√∫n nuestro caso de uso espec√≠fico. A continuaci√≥n, seguiremos dos convenciones para mantener nuestro c√≥digo limpio y organizado:

- El nombre de todos los generadores debe comenzar con `arb`, indicando que estamos definiendo un generador arbitrario.
- Especificamos claramente el tipo de datos que generar√°, lo que mejora la legibilidad y facilita la comprensi√≥n del prop√≥sito del generador.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        private typealias ListAndAverage = Pair<MutableList<Double>, Double>

        private fun arbIntListAndAverage(): Arb<ListAndAverage> = 
            arbitrary { (random, seed) ->
                val list = mutableListOf<Int>()
                val size = random.nextInt(1, 100)
                var average = 0
                repeat(size) {
                    val number = random.nextInt(1, 100)
                    list += number
                    average += number / size
                }
                list to average
            }
        ```

        ```kotlin showLineNumbers
        checkAll(arbIntListAndAverage()) { (list, expectedAverage) ->
            average(list)
                .shouldBeGreaterThanOrEqual(expectedAverage - 0.0001)
                .shouldBeLessThan(expectedAverage + 0.0001)
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="pbt/arbitrary/prng/src/test/kotlin/com/github/username/lists/AverageTest.kt"
        package com.github.username.lists

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.doubles.shouldBeGreaterThanOrEqual
        import io.kotest.matchers.doubles.shouldBeLessThan
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.arbitrary
        import io.kotest.property.checkAll

        typealias ListAndAverage = Pair<MutableList<Double>, Double>

        class AverageTest : FreeSpec({
            "Given a list of integers" - {
                "when calculating the average of a non-empty list" - {
                    ("should return the sum of the elements divided by the number of " +
                            "elements") {
                        checkAll(arbIntListAndAverage()) { (list, average) ->
                            average(list)
                                .shouldBeGreaterThanOrEqual(average - 0.0001)
                                .shouldBeLessThan(average + 0.0001)
                        }
                    }
                }
            }
        })

        private fun arbIntListAndAverage(): Arb<ListAndAverage> = arbitrary { (random, seed) ->
            val list = mutableListOf<Double>()
            val size = random.nextInt(1, 100)
            var average = 0.0
            repeat(size) {
                val number = random.nextDouble(1.0, 100.0)
                list += number
                average += number / size
            }
            list to average
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - Definimos un alias `ListAndAverage` para representar un par que contiene una lista de n√∫meros reales y su promedio aproximado. Esto hace que el prop√≥sito del generador sea m√°s expl√≠cito.
    - Implementamos un generador llamado `arbIntListAndAverage` que produce listas aleatorias y calcula un promedio de forma **deliberadamente distinta** a la implementaci√≥n real:
        - En lugar de sumar todos los elementos y luego dividir, el generador utiliza una **acumulaci√≥n parcial**: suma el resultado de dividir cada n√∫mero por el tama√±o de la lista.  
        - Esta forma alternativa introduce peque√±as imprecisiones por errores de redondeo, lo cual es **intencional**.
    - ¬øPor qu√© hacerlo as√≠?  
        - El objetivo del generador no es replicar exactamente la l√≥gica de la funci√≥n `average`, sino proporcionar un valor de referencia suficientemente cercano que **no dependa de la misma l√≥gica que estamos testeando**.
        - Al usar una f√≥rmula distinta, aumentamos la confianza de que estamos validando correctamente el comportamiento de la funci√≥n.
    - Para compensar la posible diferencia introducida por la forma alternativa de c√°lculo, el test no exige una igualdad exacta, sino que verifica que el resultado est√© dentro de un **margen de tolerancia razonable** (`¬±0.0001`).
    - La funci√≥n `arbitrary` recibe una pareja `(random, seed)`, donde `random` es un generador de n√∫meros aleatorios que usamos para construir nuestros datos.
</Explanation>

:::tip Buenas pr√°cticas al dise√±ar generadores

Cuando escribas un generador para una prueba basada en propiedades, **evita replicar directamente la l√≥gica de la funci√≥n bajo prueba**. Si ambos usan el mismo algoritmo, el test puede pasar incluso si la l√≥gica est√° equivocada en ambos lados.

En lugar de eso, genera los datos de entrada de forma aleatoria y calcula los valores esperados usando **una l√≥gica alternativa, una aproximaci√≥n o una propiedad matem√°tica conocida**. Luego, compara los resultados permitiendo un peque√±o margen de error si es necesario (por ejemplo, con tolerancia para `Double` o `Float`).

üí° _Esto ayuda a que el test valide el comportamiento real de la funci√≥n y no simplemente replique su implementaci√≥n._

:::

### üßÆ Implementando la funci√≥n de promedio

Finalmente, implementamos la funci√≥n `average` que calcula el promedio de una lista de n√∫meros. Es importante recordar que la implementaci√≥n de la funci√≥n debe ser distinta a la l√≥gica del generador, ya que replicar esa l√≥gica no ser√≠a √∫til para realizar pruebas efectivas.

<BoxedTabs>
  <TabItem label={"Implementaci√≥n iterativa"} value={"Implementaci√≥n iterativa"}>
    ```kotlin showLineNumbers title="pbt/arbitrary/prng/src/main/kotlin/com/github/username/lists/average.kt"
    package com.github.username.lists.average

    fun average(list: List<Double>): Double {
        var sum = 0.0
        for (number in list) {
            sum += number
        }
        return sum / list.size
    }
    ```

    <Explanation>
        - En esta implementaci√≥n iterativa, usamos un bucle `for` para recorrer la lista de n√∫meros.
        - Cada n√∫mero se suma al acumulador `sum`, que luego se divide por el tama√±o de la lista para obtener el promedio.
        - Este enfoque es sencillo y f√°cil de entender, pero puede ser menos idiom√°tico en Kotlin que otras alternativas m√°s funcionales.
    </Explanation>
  </TabItem>

  <TabItem label={"Implementaci√≥n funcional"} value={"Implementaci√≥n funcional"}>
    ```kotlin showLineNumbers title="pbt/arbitrary/prng/src/main/kotlin/com/github/username/lists/average.kt"
    package com.github.username.lists.average

    fun average(list: List<Double>) =
        list.fold(0.0) { acc, number -> 
            acc + number
        } / list.size 
    ```

    <Explanation>
        - Esta implementaci√≥n utiliza un enfoque funcional con la funci√≥n `fold`, que recorre la lista    acumulando el resultado en el par√°metro `acc` (acumulador).
        - Al final del recorrido, dividimos la suma acumulada por el tama√±o de la lista para obtener el promedio.
        - Este enfoque es m√°s conciso y expresivo, aprovechando las caracter√≠sticas funcionales de Kotlin.
    </Explanation>
  </TabItem>
</BoxedTabs>

<details>
    <summary>üìê Controlar la semilla del generador</summary>

    En algunos casos, es √∫til **controlar la semilla del generador aleatorio** para garantizar **reproducibilidad de los tests**. Esto puede ser importante cuando necesitas depurar un fallo o mantener pruebas estables.

    En Kotest, esto se puede lograr usando `PropTestConfig` y marcando la clase con `@OptIn(ExperimentalKotest::class)`:

    ```kotlin showLineNumbers
    // highlight-next-line
    @OptIn(ExperimentalKotest::class)
    class AverageTest : FreeSpec({
        "Given a list of integers" - {
            "when calculating the average of a non-empty list" - {
                ("should return the sum of the elements divided by the number of " +
                        "elements") {
                    checkAll(
                        // highlight-next-line
                        PropTestConfig(seed = 123456), // üîê Semilla fija
                        arbIntListAndAverage()
                    ) { (list, average) ->
                        average(list)
                            .shouldBeGreaterThanOrEqual(average - 0.0001)
                            .shouldBeLessThan(average + 0.0001)
                    }
                }
            }
        }
    })
    ```

    Esto asegura que el test use la **misma secuencia de valores generados cada vez**, facilitando la identificaci√≥n de errores dif√≠ciles de reproducir.
</details>

## üß™ Ejercicio: Generador de diccionarios

<Exercise>
    Implementa un generador arbitrario que produzca diccionarios donde:

    - **La llave** sea un n√∫mero entero.
    - **El valor** sea un `String` generado por la concatenaci√≥n de caracteres aleatorios.

    #### Detalles del ejercicio:

    1. El tama√±o del diccionario debe generarse de manera aleatoria.
    2. Para generar los caracteres aleatorios que componen los valores del diccionario, puedes utilizar la funci√≥n `nextInt: Random.() -> Int` para obtener n√∫meros aleatorios dentro del rango de valores Unicode (entre `0x0000` y `0xFFFF`).
    3. Una vez generado el n√∫mero, convi√©rtelo en un car√°cter usando la funci√≥n `toChar: Int.() -> Char`.

    #### Ejemplo de generaci√≥n de un car√°cter aleatorio:

    ```kotlin
    random.nextInt(0x0000, 0xFFFF).toChar()
    ```

    Este c√≥digo generar√° un n√∫mero aleatorio en el rango Unicode y lo convertir√° a su correspondiente car√°cter. Usa este enfoque para construir las cadenas que ser√°n los valores del diccionario.
    
    <Solution>
        <BoxedTabs>
            <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
                ```kotlin showLineNumbers
                typealias IntStringMap = Map<Int, String>

                fun arbIntStringMap(): Arb<IntStringMap> = arbitrary { (random, seed) ->
                    val map = mutableMapOf<Int, String>()
                    val size = random.nextInt(1, 100)
                    while (map.size < size) {
                        val key = random.nextInt()
                        val stringSize = random.nextInt(1, 100)
                        val value = List(stringSize) {
                            random.nextInt(0x0000, 0xFFFF).toChar()
                        }.joinToString("")
                        map[key] = value
                    }
                    map
                }
                ```
            </TabItem>
            <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
                ```kotlin showLineNumbers tile="pbt/arbitrary/prng/src/test/kotlin/com/github/username/maps/IntStringMapTest.kt"
                package com.github.username.maps

                import io.kotest.core.spec.style.FreeSpec
                import io.kotest.matchers.collections.shouldHaveSize
                import io.kotest.matchers.ints.shouldBeGreaterThan
                import io.kotest.matchers.ints.shouldBeLessThanOrEqual
                import io.kotest.matchers.shouldBe
                import io.kotest.property.Arb
                import io.kotest.property.arbitrary.arbitrary
                import io.kotest.property.checkAll

                class IntStringMapTest : FreeSpec({

                    "Given a randomly generated map of Int to String" - {
                        "when generating a new map" - {
                            "then it should contain at least one entry" {
                                checkAll(arbIntStringMap()) { map ->
                                    map.size shouldBeGreaterThan 0
                                }
                            }

                            "then it should not contain duplicate keys" {
                                checkAll(arbIntStringMap()) { map ->
                                    map.keys shouldHaveSize map.size
                                }
                            }

                            "then all string values should have at least one character" {
                                checkAll(arbIntStringMap()) { map ->
                                    map.values.forEach { value ->
                                        value.length shouldBeGreaterThan 0
                                    }
                                }
                            }

                            "then all string values should have at most 100 characters" {
                                checkAll(arbIntStringMap()) { map ->
                                    map.values.forEach { value ->
                                        value.length shouldBeLessThanOrEqual 100
                                    }
                                }
                            }

                            "then the total number of entries should be at most 100" {
                                checkAll(arbIntStringMap()) { map ->
                                    map.size shouldBeLessThanOrEqual 100
                                }
                            }
                        }
                    }
                })

                // highlight-start
                private typealias IntStringMap = Map<Int, String>

                private fun arbIntStringMap(): Arb<IntStringMap> = arbitrary { (random, seed) ->
                    val map = mutableMapOf<Int, String>()
                    val size = random.nextInt(1, 100)
                    while (map.size < size) {
                        val key = random.nextInt()
                        val stringSize = random.nextInt(1, 100)
                        val value = List(stringSize) {
                            random.nextInt(0x0000, 0xFFFF).toChar()
                        }.joinToString("")
                        map[key] = value
                    }
                    map
                }
                // highlight-end
                ```
            </TabItem>
        </BoxedTabs>
    </Solution>
</Exercise>

## üéØ Conclusiones

En esta lecci√≥n aprendimos a dise√±ar generadores personalizados usando la funci√≥n `arbitrary` de Kotest, aprovechando un generador de n√∫meros pseudoaleatorios (PRNG) para crear datos variados, controlables y reproducibles. Este enfoque es fundamental en pruebas basadas en propiedades.

### üîë Puntos clave:

- **El generador no debe replicar la l√≥gica de la funci√≥n bajo prueba.**  
  En lugar de eso, utilizamos una aproximaci√≥n distinta para calcular el resultado esperado. Esto ayuda a detectar errores reales en la implementaci√≥n.
- **La reproducibilidad es posible gracias a la configuraci√≥n de semillas.**  
  Usar `PropTestConfig(seed = ...)` permite depurar fallos y mantener resultados consistentes entre ejecuciones.
- **Los generadores pueden componerse libremente.**  
  Vimos c√≥mo construir estructuras m√°s complejas como listas o diccionarios a partir de combinaciones de generadores simples.
- **Las comparaciones deben tener en cuenta la naturaleza de los datos.**  
  Para tipos como `Double`, es importante permitir un margen de tolerancia debido a los errores de redondeo acumulados.

### üß∞ ¬øQu√© nos llevamos?

Al usar generadores personalizados basados en PRNG, ganamos mayor **control sobre los datos**, mejor **reproducibilidad de tests**, y la posibilidad de crear verificaciones m√°s robustas y variadas, lo que resulta especialmente valioso en el desarrollo de **librer√≠as confiables**.

## üìñ Referencias

### üî• Recomendadas

üåê Generador de n√∫meros pseudoaleatorios. (2024). En Wikipedia, la enciclopedia libre. https://es.wikipedia.org/w/index.php?title=Generador_de_n%C3%BAmeros_pseudoaleatorios&oldid=161973175 {/* √öltima revisi√≥n: ??? */}

{/* ### üîπ Adicionales */}

{/* TODO: Bibliograf√¨as por revisar */}
{/*
## 2. Generadores de N√∫meros Pseudoaleatorios (PRNG)  
Un **generador de n√∫meros pseudoaleatorios** es un algoritmo determin√≠stico que produce una secuencia de valores ‚Äúaleatorios‚Äù a partir de una semilla inicial. Aunque la secuencia est√° completamente determinada por su estado interno, un buen PRNG imita las propiedades estad√≠sticas de la aleatoriedad verdadera ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=una%20sucesi%C3%B3n%20de%20n%C3%BAmeros%20que,papel%20central%20en%20la%20criptograf%C3%ADa)). Los PRNG son fundamentales en simulaciones de Monte Carlo y desempe√±an un papel central en criptograf√≠a y en la generaci√≥n de datos de prueba ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=pseudoaleatorios%20son%20importantes%20en%20la,central%20en%20la%20%2068)). La mayor√≠a de PRNG cl√°sicos (ej. congruenciales lineales, generadores de Fibonacci retrasados, **LFSR** de registros de desplazamiento) est√°n dise√±ados para producir distribuciones uniformes ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=La%20mayor%C3%ADa%20de%20los%20algoritmos,74%2C%20y%20el%20Mersenne%20twister)) y periodos largos, pero deben someterse a riguroso an√°lisis matem√°tico para asegurar su calidad ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=Se%20requiere%20de%20un%20cuidadoso,2%20%5D%E2%80%8B)). A continuaci√≥n se listan referencias sobre teor√≠a de PRNG, algoritmos emblem√°ticos y aplicaciones en testing/data generation:

- **D. E. Knuth ‚Äì _The Art of Computer Programming, Vol. 2: Seminumerical Algorithms_, Ch.¬†3** ‚Äì Referencia cl√°sica que cubre en profundidad la generaci√≥n de n√∫meros aleatorios y pruebas estad√≠sticas de aleatoriedad ([Pseudorandom number generator - Wikipedia](https://en.wikipedia.org/wiki/Pseudorandom_number_generator#:~:text=,randomness)). *En ingl√©s, libro f√≠sico o digital (no libre)*. Es un recurso **muy t√©cnico** (b√≠blico en computaci√≥n) que sienta las bases te√≥ricas de los PRNG (calidad, periodo, pruebas de uniformidad, etc.).  
- **Matsumoto & Nishimura (1998), ‚ÄúMersenne Twister: A 623-dimensionally equidistributed‚Ä¶ PRNG‚Äù** ‚Äì Art√≠culo que present√≥ el **Mersenne Twister**, uno de los PRNG m√°s utilizados. *En ingl√©s, PDF libre*. Introdujo un periodo extremadamente largo (2^19937‚àí1) y excelente uniformidad en alta dimensi√≥n ([Pseudorandom number generator - Wikipedia](https://en.wikipedia.org/wiki/Pseudorandom_number_generator#:~:text=The%201997%20invention%20of%20the,at%20the%20time%20of%20its)), superando muchos defectos de generadores previos. Es un trabajo t√©cnico, pero sus resultados (MT19937) se adoptaron ampliamente (ej. como default en Python, R, etc.) dada su eficiencia y calidad estad√≠stica.  
- **Wikipedia (es) ‚Äì ‚ÄúGenerador de n√∫meros pseudoaleatorios‚Äù** ‚Äì Art√≠culo enciclop√©dico en espa√±ol con una visi√≥n general. *En espa√±ol, libre online*. Resume las clases comunes de PRNG y ejemplos hist√≥ricos ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=La%20mayor%C3%ADa%20de%20los%20algoritmos,74%2C%20y%20el%20Mersenne%20twister)), discute problemas t√≠picos (periodos cortos, secuencias correlacionadas, mala distribuci√≥n en varias dimensiones) ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=En%20la%20pr%C3%A1ctica%2C%20los%20resultados,Entre%20estos%20se%20incluyen)) e incluye an√©cdotas cl√°sicas (e.g. el infame RANDU con serias deficiencias ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=Los%20defectos%20que%20son%20exhibidos,lo%20que%20podr%C3%ADa%20haber%20sido)), la cita ‚Äúla generaci√≥n de n√∫meros aleatorios es demasiado importante para dejarla al azar‚Äù ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=,2%20%5D%E2%80%8B))). Es un buen **punto de partida** para conceptos b√°sicos, con referencias a fuentes m√°s detalladas.  
- **L‚ÄôEcuyer, P. (2007), ‚ÄúRandom Number Generation‚Äù** ‚Äì Cap√≠tulo de libro (Handbook of Comp. Statistics) por un experto en PRNG. *En ingl√©s, disponible en l√≠nea en sitios acad√©micos*. Profundiza en criterios de calidad (periodo, uniformidad multidimensional, tests te√≥ricos y emp√≠ricos) y describe algoritmos modernos. Por su naturaleza, es un recurso **avanzado**, √∫til si se requiere un entendimiento matem√°tico riguroso de los PRNG.  
- **PRNG criptogr√°ficamente seguros** ‚Äì En contextos de seguridad, se emplean PRNG con fuertes garant√≠as impredecibles (a costa de velocidad). Por ejemplo, **Blum Blum Shub (1986)** es un algoritmo con fundamentaci√≥n te√≥rica en teor√≠a de n√∫meros que ofrece secuencias impredecibles bajo ciertas premisas ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=congruentes%20%2C%20generadores%20Fibonacci%20demorados,74%2C%20y%20el%20Mersenne%20twister)). Tambi√©n existen frameworks como Fortuna (de Bruce Schneier) para entrop√≠a acumulada. Estos algoritmos suelen documentarse en est√°ndares oficiales (ej. NIST SP 800-90A) y literatura de criptograf√≠a. *En ingl√©s y espa√±ol, varias fuentes; a menudo requieren suscripci√≥n*. Son recursos **muy t√©cnicos** orientados a aplicaciones cr√≠ticas (seguridad, casinos, etc.), complementando la comprensi√≥n de PRNG generales.  
- **Documentaci√≥n de lenguajes (Python `random`, Java `java.util.Random`, etc.)** ‚Äì Las implementaciones pr√°cticas de PRNG vienen en bibliotecas est√°ndar. Por ejemplo, la documentaci√≥n de Python (m√≥dulo `random`) explica el uso de su PRNG (basado en Mersenne Twister) ([Generador de n√∫meros pseudoaleatorios - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios#:~:text=congruentes%20%2C%20generadores%20Fibonacci%20demorados,74%2C%20y%20el%20Mersenne%20twister)). *Multiling√ºe, libre*. Estas referencias son **did√°cticas** para aprender a usar PRNG en c√≥digo, aunque no profundizan en la teor√≠a. Son √∫tiles para ver aplicaciones inmediatas en generaci√≥n de datos pseudoaleatorios en tests o simulaciones.

## 3. T√©cnicas de generaci√≥n de datos para testing automatizado  
La eficacia de las pruebas automatizadas depende en gran medida de la calidad y variedad de los **datos de entrada generados**. En el contexto de PBT, existen librer√≠as que permiten definir *generadores* de datos aleatorios con ciertas restricciones, as√≠ como procedimientos de **shrinking** para simplificar casos fallo. Por ejemplo, Hypothesis (Python) ofrece un amplio cat√°logo de *estrategias* para generar datos (n√∫meros, cadenas, estructuras, etc.) que el usuario puede componer y ajustar ([hypothesis/hypothesis-python/docs/data.rst at master ¬∑ HypothesisWorks/hypothesis ¬∑ GitHub](https://github.com/HypothesisWorks/hypothesis/blob/master/hypothesis-python/docs/data.rst#:~:text=Most%20things%20should%20be%20easy,and%20everything%20should%20be%20possible)). Cada estrategia sabe c√≥mo *simplificar* un valor complejo a uno m√°s peque√±o equivalente cuando se halla un contraejemplo, facilitando el an√°lisis del error ([hypothesis/hypothesis-python/docs/data.rst at master ¬∑ HypothesisWorks/hypothesis ¬∑ GitHub](https://github.com/HypothesisWorks/hypothesis/blob/master/hypothesis-python/docs/data.rst#:~:text=Shrinking)) (por ejemplo, si una propiedad falla con una lista de 10 elementos, Hypothesis intentar√° reducirla a la lista m√°s peque√±a que tambi√©n falle). QuickCheck y derivados funcionan de forma similar: definen generadores aleatorios para tipos de datos (mediante la clase `Arbitrary` en Haskell/Scala, por ejemplo) y usan combinadores para crear generadores de estructuras m√°s complejas a partir de los b√°sicos ([Property-based testing con ScalaCheck. - Adictos al trabajo](https://adictosaltrabajo.com/2018/02/27/property-based-testing-con-scalacheck/#:~:text=Tal%20y%20como%20se%20vi%C3%B3,Gen)) ([Property-based testing con ScalaCheck. - Adictos al trabajo](https://adictosaltrabajo.com/2018/02/27/property-based-testing-con-scalacheck/#:~:text=Si%20se%20necesitan%20crear%20generadores,existenes.%20Por%20ejemplo)). Algunas t√©cnicas y recursos relevantes en este √°mbito son:

- **Estrategias y generadores en frameworks PBT** ‚Äì La documentaci√≥n oficial de Hypothesis ([hypothesis/hypothesis-python/docs/data.rst at master ¬∑ HypothesisWorks/hypothesis ¬∑ GitHub](https://github.com/HypothesisWorks/hypothesis/blob/master/hypothesis-python/docs/data.rst#:~:text=Most%20things%20should%20be%20easy,and%20everything%20should%20be%20possible)) y ScalaCheck ([Property-based testing con ScalaCheck. - Adictos al trabajo](https://adictosaltrabajo.com/2018/02/27/property-based-testing-con-scalacheck/#:~:text=match%20at%20L196%20Tal%20y,Gen)) detalla c√≥mo construir generadores personalizados. *En ingl√©s (Hypothesis) y espa√±ol (ScalaCheck), libre*. Estos recursos muestran enfoques **pr√°cticos**: uso de combinadores para mezclar fuentes aleatorias, elecci√≥n ponderada de casos (ej. `oneOf` con preferencias) y control de tama√±os de estructura para explorar casos peque√±os primero. Son √∫tiles para aprender a *especificar datos de prueba* de forma declarativa.  
- **Shrinkage (reducci√≥n de casos)** ‚Äì Mecanismo clave en PBT. El blog de Hypothesis explica claramente el proceso: generar datos arbitrarios seg√∫n una especificaci√≥n y, si se encuentra un fallo, ‚Äúcortarlo hasta que sea mucho m√°s peque√±o‚Äù conservando el fallo ([Hypothesis 6.130.0 documentation](https://hypothesis.readthedocs.io/#:~:text=It%20works%20by%20generating%20arbitrary,forget%20it%20in%20the%20future)). *En ingl√©s, libre*. Comprender el shrinking es importante para aprovechar PBT al m√°ximo; muchos frameworks lo hacen autom√°ticamente, pero el desarrollador debe conocer c√≥mo sus generadores influyen en el orden de simplificaci√≥n.  
- **Modelos de estado y secuencias de acciones** ‚Äì Para probar software con estado (p.ej. APIs, bases de datos), las t√©cnicas de **model-based testing** permiten generar no solo datos, sino secuencias de operaciones. Herramientas como PropEr/Hypothesis soportan definir modelos de m√°quina de estados para generar llamadas v√°lidas aleatorias a un sistema (por ejemplo, secuencias de inserci√≥n/borrado en una estructura de datos) y verificar invariantes en cada paso. Un recurso avanzado es el cap√≠tulo experimental de FsCheck sobre testing basado en modelos ([Test data: generators, shrinkers and Arbitrary instances
](https://fscheck.github.io/FsCheck//TestData.html#:~:text=)) ([Test data: generators, shrinkers and Arbitrary instances
](https://fscheck.github.io/FsCheck//TestData.html#:~:text=Shrinkers%20have%20types%20of%20the,process%20continues%20with%20that%20value)). *En ingl√©s, libre*. Es un tema **t√©cnico** avanzado, pero muy poderoso para automatizar pruebas de sistemas complejos mediante generaci√≥n de interacciones.  
- **Fuzzing guiado y generaci√≥n dirigida** ‚Äì M√°s all√° de los generadores aleatorios puros, existen t√©cnicas para *dirigir* la generaci√≥n hacia casos interesantes. Por ejemplo, **fuzzers** como AFL utilizan heur√≠sticas (e incluso instrumentaci√≥n del c√≥digo) para generar entradas que maximicen la cobertura o alcanzan ramas raras. Un estudio relevante es *‚ÄúTargeted Property-Based Testing‚Äù* (L√∂scher, 2019) que combina b√∫squeda heur√≠stica con PBT ([Targeted property-based testing - ACM Digital Library](https://dl.acm.org/doi/10.1145/3092703.3092711#:~:text=Targeted%20property,Verif)). *En ingl√©s, puede requerir subscripci√≥n*. Estos enfoques h√≠bridos (search-based testing) son **avanzados**, y apuntan a automatizar la generaci√≥n de datos de prueba *no aleatoria pura* sino informada por objetivos (cobertura, condiciones espec√≠ficas), lo cual complementa a los generadores aleatorios est√°ndar.  
- **Reutilizaci√≥n de generadores en testing tradicional** ‚Äì Una buena pr√°ctica es aprovechar los generadores de datos incluso en pruebas unitarias cl√°sicas. Por ejemplo, el tutorial de ScalaCheck se√±ala que los generadores pueden emplearse para crear datos de entrada de manera centralizada (*Object Mother*) en tests manuales ([Property-based testing con ScalaCheck. - Adictos al trabajo](https://adictosaltrabajo.com/2018/02/27/property-based-testing-con-scalacheck/#:~:text=A%20lo%20largo%20del%20tutorial,los%20test%20basados%20en%20propiedades)). *En espa√±ol, libre*. Esto es **did√°ctico** para ver que las t√©cnicas de generaci√≥n autom√°ticas no se limitan a PBT estricto, sino que pueden ayudar a producir casos diversos y reproducibles en cualquier tipo de prueba automatizada. Al centralizar la l√≥gica de generaci√≥n, se obtiene mayor variedad de pruebas con menos esfuerzo y se reduce la duplicaci√≥n de c√≥digo de *setup* de tests.

**Nota:** Muchos de estos recursos son de acceso libre (documentaci√≥n, blogs, papers en arXiv o repositorios universitarios). En caso de art√≠culos acad√©micos en ACM/IEEE u otros, a menudo existen versiones preprint o slides de conferencia disponibles p√∫blicamente. Los recursos marcados como libros comerciales (e.g. Knuth, Fred Hebert) pueden requerir compra o suscripci√≥n, aunque sus ideas principales suelen estar resumidas en papers o p√°ginas web de la comunidad. Se recomienda comenzar por los materiales did√°cticos (tutoriales, documentaci√≥n oficial, blogs introductorios) e ir profundizando hacia las fuentes t√©cnicas y acad√©micas conforme se necesite un mayor nivel de detalle te√≥rico. Esto asegurar√° construir una base s√≥lida antes de abordar contenidos m√°s avanzados. */}