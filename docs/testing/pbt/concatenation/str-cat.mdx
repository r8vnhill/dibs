---
title: "Ejemplo: Concatenación de Strings"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard, JqwikCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink repo={"property-based-testing-kt"} user={"r8vnhill"}/>

<details>
    <summary>
        Comencemos por crear un módulo para la lección...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path 'str-cat' -ItemType Directory
            '// Intentionally left blank' |
                Out-File -FilePath 'str-cat\build.gradle.kts'
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            md str-cat
            '// Intentionally left blank' > 'str-cat\build.gradle.kts'
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            mkdir str-cat
            echo '// Intentionally left blank' > \
                'str-cat/build.gradle.kts'
            ```
        </TabItem>
    </BoxedTabs>

    Recuerda agregar el nuevo módulo al archivo `settings.gradle.kts`.
</details>

Supongamos que queremos asegurarnos de que la concatenación de strings en nuestro proyecto funciona de forma correcta. En lugar de probar casos específicos con entradas puntuales, podemos buscar definir propiedades generales que deberían cumplirse sin importar los valores de entrada. Esto nos lleva a preguntarnos: ¿qué propiedades fundamentales debe respetar la concatenación de strings?

## Integrando Property-Based Testing en Nuestro Proyecto

Para comenzar a utilizar **Property-Based Testing** en tu proyecto, lo primero que debes hacer es agregar las dependencias necesarias en tu catálogo de versiones. Esto incluye las bibliotecas de Kotest para pruebas basadas en propiedades.

Añade las dependencias correspondientes en el archivo `versions.toml`:

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```toml showLineNumbers
        [libraries]
        kotest-property = { module = "io.kotest:kotest-property", version.ref = "kotest" }
        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest", "kotest-property"]
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```toml showLineNumbers
        [versions]
        kotlin = "2.0.20"
        pbt = "1.0.0"
        detekt = "1.23.6"
        kotest = "5.9.1"

        [libraries]
        kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
        detekt-formatting = { module = "io.gitlab.arturbosch.detekt:detekt-formatting", version.ref = "detekt" }
        kotest-runner-junit5 = { module = "io.kotest:kotest-runner-junit5", version.ref = "kotest" }
        kotest-datatest = { module = "io.kotest:kotest-framework-datatest", version.ref = "kotest" }
        kotest-property = { module = "io.kotest:kotest-property", version.ref = "kotest" }

        [plugins]
        detekt = { id = "io.gitlab.arturbosch.detekt", version.ref = "detekt" }

        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest", "kotest-property"]
        ```
    </TabItem>
</BoxedTabs>

Con este **bundle** configurado, ya no es necesario añadir las dependencias de Kotest manualmente en el bloque `dependencies` de tu archivo de configuración `build.gradle.kts`. Simplemente, puedes referenciar el bundle `kotest` y asegurarte de tener todas las herramientas necesarias para realizar pruebas basadas en propiedades.

Este enfoque mantiene tu archivo de dependencias limpio y organizado, permitiendo una fácil actualización o adición de herramientas de prueba en el futuro.

## Implementación del Test

<details>
    <summary>
        Si quieres crear los archivos desde la terminal...
    </summary>

    <BoxedTabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            $Group = 'com\github\username'
            ```

            ```powershell
            $StringTestDir = "src\test\kotlin\$Group\strings"
            New-Item -Path $StringTestDir -ItemType Directory -Force
            "package $Group.strings" -replace '\\', '.' | 
                Out-File -FilePath "$StringTestDir\StringConcatenationTest.kt"
            ```
        </TabItem>
        <TabItem value="Windows (corto)" label="Windows (corto)">
            ```powershell
            $Group = 'com\github\username'
            ```

            ```powershell
            $StringTestDir = "src\test\kotlin\$Group\strings"
            md $StringTestDir
            "package $Group.strings" -replace '\\', '.' > `
                "$StringTestDir\StringConcatenationTest.kt"
            ```
        </TabItem>
        <TabItem value="Linux/Mac" label="Linux/Mac">
            ```bash
            GROUP="com/github/username"
            ```

            ```bash
            STRING_TEST_DIR="src/test/kotlin/$GROUP/strings"
            mkdir -p "$STRING_TEST_DIR"
            echo "package ${GROUP//\//.}.strings" > \
                "$STRING_TEST_DIR/StringConcatenationTest.kt"
            ```
        </TabItem>
    </BoxedTabs>
</details>

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers title="src/test/kotlin/com/github/username/strings/StringConcatenationTest.kt"
        checkAll(Arb.string(), Arb.string()) { s1, s2 ->
            (s1 + s2) shouldHaveLength (s1.length + s2.length)
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers title="src/test/kotlin/com/github/username/strings/StringConcatenationTest.kt"
        package com.github.username.strings

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.string
        import io.kotest.property.checkAll

        class StringConcatenationTest : FreeSpec({
            "A String" - {
                "when concatenated" - {
                    "should have the sum of the lengths of the original strings" {
                        checkAll(Arb.string(), Arb.string()) { s1, s2 ->
                            (s1 + s2) shouldHaveLength (s1.length + s2.length)
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

:::info Explicación del Código

- Usamos `checkAll` para realizar **testing basado en propiedades**, probando con diferentes combinaciones de inputs generados automáticamente.
- `Arb.string()` es un generador arbitrario que proporciona strings aleatorios, incluyendo casos de borde como el string vacío.
- La propiedad que estamos verificando es que la **longitud de la concatenación de dos strings debe ser igual a la suma de las longitudes de los strings originales**. Esto se mantiene sin importar los valores específicos de los strings generados.

:::

Esta técnica permite probar de forma exhaustiva la propiedad del código, garantizando que funcione correctamente bajo una variedad de condiciones.

## Probando más propiedades

Además de la propiedad de longitud que ya hemos probado, podemos definir otras propiedades fundamentales sobre los strings, que deberían mantenerse sin importar la implementación. Aquí es útil introducir el concepto de **monoide**.

### ¿Qué es un Monoide?

Un **monoide** es una estructura algebraica formada por:

- Un conjunto $A$
- Una operación binaria $+$ que combina dos elementos de $A$
- Un elemento neutro $0$ que no altera el valor de ningún elemento al ser combinado con él

Dicha estructura debe cumplir con las siguientes propiedades:

- **Asociatividad**: Para todo $a$, $b$, y $c$ en $A$, se cumple que $(a + b) + c = a + (b + c)$.
- **Elemento Neutro**: Para todo $a$ en $A$, se cumple que $a + 0 = 0 + a = a$.

En el contexto de strings, la operación de **concatenación** cumple con estas propiedades, y el string vacío actúa como el **elemento neutro**. Diremos entonces que los strings forman un monoide bajo la operación de concatenación.

### Definiendo Propiedades del Monoide para Strings

Podemos verificar que la concatenación de strings sigue las leyes de los monoides: la **identidad** (izquierda y derecha) y la **asociatividad**.

<BoxedTabs>
    <TabItem label={"Código esencial"} value={"Código esencial"}>
        ```kotlin showLineNumbers
        "left identity" {
            checkAll(Arb.string()) { s ->
                ("" + s) shouldBe s
            }
        }

        "right identity" {
            checkAll(Arb.string()) { s ->
                (s + "") shouldBe s
            }
        }

        "associativity" {
            checkAll(Arb.string(), Arb.string(), Arb.string()) { s1, s2, s3 ->
                ((s1 + s2) + s3) shouldBe (s1 + (s2 + s3))
            }
        }
        ```
    </TabItem>
    <TabItem label={"Código completo"} value={"Código completo"}>
        ```kotlin showLineNumbers
        package cl.ravenhill.strings

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.string
        import io.kotest.property.checkAll

        class StringConcatenationTest : FreeSpec({
            "String concatenation" - {
                "should have a length equal to the sum of the input strings' lengths" {
                    checkAll(Arb.string(), Arb.string()) { s1, s2 ->
                        (s1 + s2).length shouldBe s1.length + s2.length
                    }
                }

                "should follow monoid laws" - {
                    "left identity" {
                        checkAll(Arb.string()) { s ->
                            ("" + s) shouldBe s
                        }
                    }

                    "right identity" {
                        checkAll(Arb.string()) { s ->
                            (s + "") shouldBe s
                        }
                    }

                    "associativity" {
                        checkAll(Arb.string(), Arb.string(), Arb.string()) { s1, s2, s3 ->
                            ((s1 + s2) + s3) shouldBe (s1 + (s2 + s3))
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Identidad por la izquierda**: Concatenar el string vacío por la izquierda no cambia el valor original del string.
    - **Identidad por la derecha**: Concatenar el string vacío por la derecha tampoco altera el valor original.
    - **Asociatividad**: La concatenación de strings es asociativa, es decir, el orden en que se agrupan las operaciones de concatenación no afecta el resultado.
</Explanation>

Este enfoque nos permite probar formalmente propiedades importantes de los strings y asegurar que el comportamiento esperado se mantenga bajo cualquier circunstancia.

### ¿Qué Aprendimos?

En esta lección, hemos explorado cómo aplicar **Property-Based Testing** para verificar propiedades generales sobre la concatenación de strings. En lugar de realizar pruebas con casos específicos, nos enfocamos en propiedades fundamentales que los strings deben cumplir, como la **longitud de la concatenación** y las **leyes de los monoides**.

- **Testing Basado en Propiedades**: A través de herramientas como `Kotest`, podemos generar inputs variados y aleatorios, lo que permite probar exhaustivamente un amplio rango de casos. Esto es útil para detectar errores que podrían no aparecer en pruebas específicas o unitarias.
- **Monoides**: Identificamos que los strings forman un monoide bajo la operación de concatenación, cumpliendo con las propiedades de **asociatividad** y **elemento neutro**. Verificamos estas propiedades en el código para asegurarnos de que se mantengan en cualquier situación.
- **Verificación Formal**: Definir propiedades generales nos ayuda a crear pruebas más robustas y reutilizables. Verificamos que la longitud de la concatenación sea la suma de las longitudes individuales, y que la concatenación respete las leyes del monoide.

Este enfoque nos permite garantizar que la concatenación de strings en nuestro proyecto se comporte de manera consistente y correcta bajo una amplia variedad de condiciones, sin importar las entradas específicas.

<div className="language-card-container">
    <JqwikCard link="/docs/testing/pbt/concatenation/jqwik"/>
    <LanguageCard
        logoSrc="https://spockframework.org/spock/docs/2.3/images/spock-main-logo.png"
        language="JVM: Spock"
        link="/docs/testing/pbt/concatenation/spock"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala: ScalaTest"
        link="/docs/testing/pbt/concatenation/scalatest"
    />
</div>

<References references={[
    {
        title: "8. Property-based testing",
        bookTitle: "Functional Programming in Kotlin",
        publisher: "Manning Publications Co. LLC",
        location: "Shelter Island, NY",
        pages: "150–176",
        year: "2021",
        author: "Marco Vermeulen, Rúnar Bjarnason, Paul Chiusano",
        type: "book",
    },
]}/>
