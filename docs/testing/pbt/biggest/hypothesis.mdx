---
title: "Caso de estudio: M√°ximo de una lista en Python con Hypothesis"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="python-dibs" />

En este ejemplo, queremos probar una funci√≥n `biggest` que toma una lista de enteros y devuelve el valor m√°ximo. Para este caso, definiremos una propiedad que verifique que el valor m√°ximo de una lista es igual al √∫ltimo elemento de la lista una vez ordenada.

## üî¢ Propiedades y Generaci√≥n de Datos

Con **Hypothesis**, podemos definir estrategias que generen listas de enteros y escribir tests que verifiquen las propiedades esperadas de nuestra funci√≥n `biggest`. Comenzamos creando un test para asegurar que, en una lista no vac√≠a, el valor m√°ximo devuelto por `biggest` coincida con el √∫ltimo elemento de la lista cuando esta se encuentra ordenada.

```python showLineNumbers title="src/testing/pbt/biggest/test/biggest_test.py"
from hypothesis import given
from hypothesis.strategies import integers, lists

from testing.pbt.biggest.src.biggest import biggest


@given(lists(integers(), min_size=1))
def test_biggest_with_sorted_list(lst: list[int]) -> None:
    assert biggest(lst) == sorted(lst)[-1]

def test_biggest_with_empty_list() -> None:
    assert biggest([]) == float('-inf')
```

<Explanation>  
    - **`@given(lists(integers(), min_size=1))`**: Hypothesis genera listas aleatorias de enteros y las pasa como argumento a la prueba. Esto permite verificar el comportamiento de la funci√≥n con una gran variedad de entradas sin necesidad de escribir casos de prueba manualmente.  
    - **Exploraci√≥n de casos l√≠mite**: Hypothesis no solo genera listas de tama√±o arbitrario, sino que tambi√©n detecta autom√°ticamente **casos l√≠mite** como listas con un solo elemento o listas con valores extremos, lo que ayuda a descubrir posibles errores en la implementaci√≥n.  
    - **Manejo de listas vac√≠as**: Como `max([])` en Python lanza una excepci√≥n, `biggest([])` est√° dise√±ado para devolver `float('-inf')`, asegurando un comportamiento predecible y evitando errores de ejecuci√≥n en escenarios donde la lista es vac√≠a.  

</Explanation>

## üõ†Ô∏è Implementaci√≥n de la Funci√≥n `biggest`

La funci√≥n `biggest` toma una lista de enteros y devuelve el valor m√°ximo. En este ejemplo, `biggest` retorna `-inf` cuando recibe una lista vac√≠a, usando `reduce` para encontrar el valor m√°ximo en otros casos.

```python showLineNumbers title="src/testing/pbt/biggest/src/biggest.py"
from functools import reduce

def biggest(lst: list[int]) -> int | float:
    return reduce(lambda acc, number: number if number > acc else acc, lst, float('-inf'))
```

## üìä Resumen comparativo

| **Caracter√≠stica**                          | **Hypothesis**                                                                                           | **Kotest**                                                                                               |
|---------------------------------------------|----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| **Estrategias de generaci√≥n de datos**      | Proporciona estrategias para generar m√∫ltiples tipos de datos, incluyendo listas, enteros, y cadenas.    | Similar a Hypothesis, permite generar datos de distintos tipos para pruebas, aunque con mayor personalizaci√≥n.|
| **Integraci√≥n de propiedades en tests**     | Tests basados en propiedades se integran de forma fluida con decoradores, como `@given`, y estrategias.  | Tambi√©n permite tests basados en propiedades usando `checkAll`, con un dise√±o cohesivo para BDD.          |
| **Manejo de casos especiales**              | Proporciona mecanismos autom√°ticos para listas vac√≠as o valores extremos en datos generados.             | Kotest permite configuraci√≥n en generadores, pero requiere especificaciones m√°s detalladas en algunos casos.|
| **Personalizaci√≥n de estrategias**          | Permite definir estrategias avanzadas mediante combinaciones y composici√≥n de estrategias.               | Ofrece una flexibilidad comparable, pero requiere m√°s configuraciones manuales para generar ciertos datos complejos.|

### ‚öñÔ∏è Beneficios y Limitaciones de Hypothesis

<ProCons>
    <Pros>
        - **Automatizaci√≥n en generaci√≥n de datos**: Hypothesis genera autom√°ticamente una amplia gama de valores de entrada, cubriendo casos normales y extremos sin requerir definiciones manuales para cada uno.
        - **Reproducci√≥n de errores**: Cuando una prueba falla, Hypothesis guarda el caso de prueba que gener√≥ el error, facilitando la depuraci√≥n mediante la reutilizaci√≥n del caso exacto.
        - **Amplia compatibilidad en estrategias**: Hypothesis tiene estrategias listas para una variedad de tipos de datos, lo que permite probar funciones que usan listas, enteros, strings, etc., de manera r√°pida y sencilla.
    </Pros>
    <Cons>
        - **Control limitado sobre datos complejos**: Aunque Hypothesis es potente para casos simples, la configuraci√≥n de estrategias avanzadas o espec√≠ficas puede volverse tediosa, en particular para objetos personalizados complejos.
    </Cons>
</ProCons>

## üìå Conclusiones

En esta lecci√≥n, exploramos c√≥mo utilizar **Hypothesis** para realizar pruebas basadas en propiedades (**Property-Based Testing, PBT**) en Python. A trav√©s del caso de estudio de la funci√≥n `biggest`, demostramos c√≥mo generar datos autom√°ticamente y verificar propiedades generales del c√≥digo en lugar de depender de pruebas manuales.

### üîë Puntos clave

1. **Pruebas basadas en propiedades**:  
   - En lugar de definir casos espec√≠ficos de prueba, usamos estrategias para generar datos aleatorios y verificar que se cumplan ciertas propiedades de la funci√≥n bajo prueba.
2. **Generaci√≥n autom√°tica de datos**:  
   - Hypothesis permite definir estrategias que producen una amplia variedad de entradas, lo que ayuda a detectar errores en escenarios inesperados.
3. **Detecci√≥n de casos l√≠mite**:  
   - Hypothesis explora autom√°ticamente situaciones extremas, como listas vac√≠as o valores at√≠picos, lo que mejora la cobertura de las pruebas sin esfuerzo adicional.
4. **Manejo de listas vac√≠as**:  
   - Implementamos `biggest([]) == float('-inf')` para evitar excepciones y garantizar un comportamiento predecible en escenarios con entradas vac√≠as.
5. **Comparaci√≥n con Kotest**:  
   - Hypothesis y Kotest ofrecen enfoques similares para PBT, pero mientras Hypothesis automatiza la detecci√≥n de casos l√≠mite, Kotest permite mayor personalizaci√≥n en la generaci√≥n de datos.

### ‚úÖ Reflexi√≥n final

El **Property-Based Testing** con Hypothesis proporciona una forma escalable y eficiente de validar funciones en Python, asegurando robustez y fiabilidad en el c√≥digo. Aunque puede requerir configuraciones adicionales para datos complejos, su capacidad para descubrir errores ocultos lo convierte en una herramienta valiosa en el desarrollo de software.

Este enfoque es especialmente √∫til en **librer√≠as de software** y proyectos donde la validaci√≥n exhaustiva de funciones es cr√≠tica. Aplicar PBT en tu flujo de trabajo te ayudar√° a mejorar la calidad del c√≥digo y reducir la probabilidad de errores inesperados.
