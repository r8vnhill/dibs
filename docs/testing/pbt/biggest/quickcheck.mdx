---
title: "Caso de estudio: M√°ximo de una lista en Haskell con QuickCheck"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="haskell-dibs" />

Vamos a construir una propiedad para encontrar el mayor valor en una lista de enteros. Al igual que en **Kotest**, primero definimos la propiedad que se desea probar, asegur√°ndonos de que la funci√≥n a testear cumpla con los criterios establecidos.

En **Haskell**, utilizamos **QuickCheck** para generar autom√°ticamente casos de prueba y verificar una propiedad. En este ejemplo, probamos que el mayor valor en una lista de enteros corresponde al √∫ltimo elemento de la lista cuando est√° ordenada.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```haskell showLineNumbers
        prop_biggest :: [Int] -> Property
        prop_biggest xs = not (null xs) ==> biggest xs == last (sort xs)

        prop_emptyList :: Property
        prop_emptyList = biggest [] === minBound
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```haskell showLineNumbers title="testing\pbt\biggest\Main.hs"
        module Main where

            import Test.QuickCheck
            import Data.List (sort)
            import Biggest (biggest)

            prop_biggest :: [Int] -> Property
            prop_biggest xs = not (null xs) ==> biggest xs == last (sort xs)

            prop_emptyList :: Property
            prop_emptyList = biggest [] === minBound

            main :: IO ()
            main = do
                quickCheck prop_biggest
                quickCheck prop_emptyList
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    La propiedad `prop_biggest` verifica que el valor m√°s grande de una lista no vac√≠a sea el mismo que el √∫ltimo elemento de la lista cuando est√° ordenada. La funci√≥n `biggest`, que se est√° probando, debe devolver el mayor valor de la lista. La funci√≥n `sort` ordena la lista y `last` devuelve el √∫ltimo elemento, que corresponde al mayor cuando la lista est√° ordenada. La condici√≥n `not (null xs)` evita que se pruebe la propiedad con listas vac√≠as, ya que no tiene sentido comparar listas vac√≠as en este caso.
</Explanation>

<details>
    <summary>¬øPor qu√© `foldl` en lugar de `foldr`?</summary>

    - `foldl max x xs` **es m√°s eficiente en listas largas** porque `max` es una operaci√≥n acumulativa que se aplica de izquierda a derecha.
    - `foldr max x xs` har√≠a que la evaluaci√≥n ocurra de derecha a izquierda, lo que en listas largas puede llevar a problemas de rendimiento debido a la evaluaci√≥n diferida (`lazy evaluation`).
    - `foldl` en este caso es seguro porque `max` es estricta y no necesita la evaluaci√≥n diferida de `foldr`.
</details>

## üìå Comparaci√≥n con Kotest: Generaci√≥n de Datos y Propiedades

1. **Generaci√≥n de datos**: QuickCheck en Haskell, al igual que Kotest, utiliza generadores para probar m√∫ltiples casos. La funci√≥n `Arb.list(Arb.int())` en Kotest se traduce en QuickCheck simplemente como `Arbitrary [Int]`, que genera listas de enteros. Sin embargo, en Haskell, los generadores son impl√≠citos para tipos est√°ndar como listas, lo que facilita la configuraci√≥n inicial.
   
2. **Propiedades**: Ambas herramientas permiten definir propiedades que se deben cumplir. En QuickCheck, se utiliza el operador `==>` para indicar condiciones previas que deben cumplirse antes de ejecutar la prueba, como asegurarse de que la lista no est√© vac√≠a, algo que en Kotest se manejar√≠a como un caso de borde.

3. **Pruebas deterministas**: Mientras que Kotest utiliza una semilla espec√≠fica para repetir pruebas fallidas, QuickCheck tambi√©n puede recibir una semilla para replicar las pruebas, pero el control sobre los generadores de casos puede ser m√°s avanzado en Haskell, gracias a la posibilidad de componer generadores personalizados de manera m√°s fluida.

## üíª Implementaci√≥n de la funci√≥n `biggest`

```haskell showLineNumbers title="testing\pbt\biggest\Biggest.hs"
module Biggest (biggest) where

    biggest :: [Int] -> Int
    biggest [] = minBound
    biggest (x:xs) = foldl max x xs
```

### ‚öñÔ∏è Beneficios y limitaciones

<ProCons>
  <Pros>
    - **Puramente funcional**: Haskell, como lenguaje funcional puro, facilita las pruebas basadas en propiedades gracias a la naturaleza inmutable de los datos, lo que simplifica la validaci√≥n de comportamientos sin preocuparse por efectos secundarios.
    - **Generadores avanzados**: QuickCheck permite una composici√≥n m√°s avanzada y poderosa de generadores, haciendo que las pruebas sean muy expresivas y flexibles. Generadores personalizados se pueden componer de manera sencilla.
    - **Tipos y pureza**: Gracias a la inferencia de tipos y la pureza de Haskell, se pueden definir propiedades complejas de manera concisa sin preocuparse por efectos secundarios. Esto lo hace ideal para validar comportamientos matem√°ticos o algoritmos complejos.
  </Pros>

  <Cons>
    - **Curva de aprendizaje**: Aunque QuickCheck es poderoso, tiene una curva de aprendizaje m√°s pronunciada debido a la complejidad del lenguaje y el manejo expl√≠cito de efectos secundarios.
    - **Manejo manual de efectos secundarios**: En Haskell, los efectos secundarios como I/O no son autom√°ticos y requieren uso de monads como `IO`, lo que puede complicar la escritura de pruebas en algunos casos.
    - **Rendimiento**: Las pruebas en Haskell pueden ser m√°s lentas si los generadores no est√°n bien optimizados, especialmente al probar propiedades complejas con listas grandes o estructuras de datos avanzadas.
</Cons>
</ProCons>

## üéØ Conclusiones

### üìå Puntos clave

- **QuickCheck y Kotest comparten principios similares** ‚Üí Ambos frameworks permiten definir propiedades en lugar de casos de prueba espec√≠ficos, generando autom√°ticamente datos para verificar el comportamiento del c√≥digo.
- **QuickCheck es m√°s expresivo en la composici√≥n de generadores** ‚Üí En Haskell, los generadores son impl√≠citos para tipos est√°ndar, mientras que en Kotest se deben definir manualmente.
- **Uso de `foldl` en la implementaci√≥n de `biggest`** ‚Üí Se utiliza `foldl` en lugar de `foldr` porque es m√°s eficiente en listas grandes, evitando problemas de evaluaci√≥n diferida.
- **Pureza funcional y seguridad en Haskell** ‚Üí La ausencia de efectos secundarios facilita la validaci√≥n de propiedades, asegurando que el c√≥digo se comporte de manera predecible.
- **Curva de aprendizaje de QuickCheck** ‚Üí Aunque poderoso, su uso requiere familiaridad con Haskell y la manipulaci√≥n de efectos secundarios mediante monads.

### üöÄ Lecciones aprendidas
- **Las pruebas basadas en propiedades son una herramienta poderosa** ‚Üí Permiten detectar errores en funciones matem√°ticas y algoritmos de manera m√°s efectiva que las pruebas unitarias tradicionales.
- **Haskell proporciona garant√≠as adicionales debido a su tipado fuerte** ‚Üí QuickCheck se integra perfectamente con la naturaleza funcional del lenguaje, asegurando que las pruebas sean m√°s predecibles y reutilizables.
- **Comparar herramientas en diferentes lenguajes ayuda a entender sus ventajas y limitaciones** ‚Üí En entornos funcionales como Haskell, las pruebas pueden ser m√°s concisas y expresivas, mientras que en lenguajes como Kotlin, la sintaxis es m√°s familiar para quienes provienen de la programaci√≥n orientada a objetos.

Al explorar QuickCheck y Kotest, vemos c√≥mo distintas estrategias de **Property-Based Testing** pueden mejorar la calidad del software, adapt√°ndose a los paradigmas de cada lenguaje.
