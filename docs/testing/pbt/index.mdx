---
title: Property-Based Testing
---
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import GithubRepoLink from "../../../src/components/GithubRepoLink";
import ReadingTime from "../../../src/components/ReadingTime";

<ReadingTime/>
<GithubRepoLink repo={"property-based-testing-kt"} user={"r8vnhill"}/>

:::note Si quieres seguir el código del tutorial puedes comenzar desde [este punto](https://github.com/r8vnhill/property-based-testing-kt/tree/base)

Si tienes ``gh`` instalado, puedes obtener el código haciendo:

```bash
gh repo clone r8vnhill/property-based-testing-kt
cd property-based-testing-kt || exit
git checkout base
```

Si quieres tener tu propia copia del código, puedes hacer un fork del repositorio y clonarlo desde tu cuenta de GitHub.

```bash
gh repo fork r8vnhill/property-based-testing-kt
cd property-based-testing-kt || exit
git checkout base
```

:::

## Testeando la función `merge`

Imaginemos que queremos testear la función `merge`, la cual toma dos listas ordenadas como entrada y devuelve una nueva lista que contiene todos los elementos de ambas listas, manteniendo el orden.

### ¿Cómo podríamos probar esta función?

Podríamos recurrir a **Data-Driven Testing** para verificar su comportamiento. Esto implicaría definir varios conjuntos de datos de entrada y validar que la función produce los resultados esperados para cada uno. Sin embargo, ¿qué conjuntos de datos serían apropiados para cubrir todos los casos posibles?

### Preguntas clave al elegir inputs:

1. ¿Qué ocurre si una o ambas listas están vacías?
2. ¿Qué pasa cuando las listas tienen elementos repetidos?
3. ¿Cómo se comporta `merge` cuando una lista contiene elementos mayores o menores que todos los de la otra?
4. ¿Qué sucede si ambas listas ya están ordenadas pero con diferentes rangos de valores?

### Ejemplo de inputs que podríamos usar:

- `merge([], [])` → `[]` (Ambas listas vacías)
- `merge([1, 3, 5], [])` → `[1, 3, 5]` (Una lista vacía)
- `merge([], [2, 4, 6])` → `[2, 4, 6]` (Otra lista vacía)
- `merge([1, 3], [2, 4])` → `[1, 2, 3, 4]` (Listas con valores intercalados)
- `merge([1, 2, 3], [4, 5, 6])` → `[1, 2, 3, 4, 5, 6]` (Una lista con valores completamente menores)
- `merge([2, 4, 6], [1, 3, 5])` → `[1, 2, 3, 4, 5, 6]` (Listas desordenadas entre sí)

<details>
    <summary>Comencemos por crear un módulo que contenga la implementación de la colección perezosa.</summary>

    <Tabs groupId={"os"}>
        <TabItem value="Windows" label="Windows">
            ```powershell
            New-Item -Path "intro\src\test\kotlin" -ItemType Directory
            Set-Content -Path "intro\build.gradle.kts" -Value "// Intentionally left blank"
            ```
        </TabItem>
        <TabItem value={"Windows (corto)"} label={"Windows (corto)"}>
            ```powershell
            mkdir intro\src\test\kotlin
            "// Intentionally left blank" > intro\build.gradle.kts
            ```
        </TabItem>
        <TabItem value="Unix" label="Unix">
            ```bash
            mkdir -p intro/src/test/kotlin
            echo "// Intentionally left blank" > intro/build.gradle.kts
            ```
        </TabItem>
    </Tabs>

    Recuerda añadir el nuevo módulo al archivo `settings.gradle.kts`.
</details>

### Definición de `data class` para los Casos de Prueba

En primer lugar, definimos una **data class** para encapsular los casos de prueba. Esta clase representa los inputs (`list1`, `list2`) y el resultado esperado (`expected`), lo que facilita la organización y reutilización de datos en nuestras pruebas.

```kotlin title="intro/src/test/kotlin/com/github/tu_usuario/merge/MergeTest.kt" showLineNumbers
package com.github.tu_usuario.merge

// Clase de prueba para almacenar listas y el resultado esperado
private data class MergeTestCase(
    val list1: List<Int>,    // Primera lista de enteros
    val list2: List<Int>,    // Segunda lista de enteros
    val expected: List<Int>  // Lista resultante esperada
)
```

### Definición de los Casos de Prueba con `withData`

A continuación, definimos los casos de prueba usando la estructura `FreeSpec` y la función `withData`, lo que permite pasar múltiples casos de prueba de forma concisa y ejecutar la misma lógica sobre diferentes inputs.

```kotlin title="intro/src/test/kotlin/com/github/tu_usuario/merge/MergeTest.kt" showLineNumbers
// ...
class MergeTest : FreeSpec({
    "Merging two lists" - {
        "should return a list with all elements sorted" - {
            withData(  // Se definen los casos de prueba
                MergeTestCase(listOf(), listOf(), listOf()),                         // Caso: ambas listas vacías
                MergeTestCase(listOf(1), listOf(), listOf(1)),                       // Caso: primera lista con un elemento
                MergeTestCase(listOf(), listOf(1), listOf(1)),                       // Caso: segunda lista con un elemento
                MergeTestCase(listOf(1), listOf(1), listOf(1, 1)),                   // Caso: listas con el mismo elemento
                MergeTestCase(listOf(1, 2), listOf(1), listOf(1, 1, 2)),             // Caso: listas de tamaño diferente
                MergeTestCase(listOf(1), listOf(1, 2), listOf(1, 1, 2)),             // Otro caso con listas de diferente tamaño
                MergeTestCase(listOf(1, 3), listOf(2, 4), listOf(1, 2, 3, 4)),       // Caso: listas intercaladas
                MergeTestCase(listOf(1, 2, 3), listOf(4, 5, 6), listOf(1, 2, 3, 4, 5, 6))  // Caso: listas consecutivas
            ) { (list1, list2, expected) ->  // Desestructuración de la clase MergeTestCase
                merge(list1, list2) shouldBe expected  // Verificación del resultado
            }
        }
    }
})
```

## El Desafío del Data-Driven Testing

Aunque el **Data-Driven Testing** es una técnica poderosa para probar diferentes conjuntos de datos de manera sistemática, presenta algunos desafíos importantes:

1. **Mantenimiento y Complejidad**: Requiere que el desarrollador piense y defina manualmente todos los casos de prueba posibles. A medida que los escenarios crecen en complejidad, la cantidad de datos y la gestión de los mismos pueden volverse complicadas y propensas a errores.

2. **Dificultad para Cumplir el Principio Open/Closed**: Si necesitamos agregar más casos de prueba, esto generalmente implica modificar directamente el código de prueba existente, lo que puede ir en contra del principio **Open/Closed** del diseño de software. Este principio establece que el código debe estar abierto a la extensión pero cerrado a la modificación. Cada vez que agregamos nuevos casos, estamos alterando el cuerpo de las pruebas, lo que aumenta el riesgo de introducir errores o inconsistencias.

### Posibles Soluciones

Una solución es utilizar **generación automática de datos de prueba** o emplear estrategias como el **property-based testing**, donde los casos se generan dinámicamente a partir de propiedades del sistema, reduciendo la necesidad de definir manualmente todos los casos y mejorando la capacidad de mantener el código de pruebas sin modificaciones constantes.

## Property-Based Testing (PBT)

El **Property-Based Testing** es una metodología de prueba en la que se definen propiedades generales sobre el comportamiento esperado de un programa. En lugar de escribir casos de prueba específicos, se especifican propiedades que deben cumplirse para cualquier conjunto de entradas, y el framework de PBT genera automáticamente una amplia variedad de datos de entrada para verificar dichas propiedades.

### Ventajas

- **Cobertura exhaustiva**: PBT permite probar una función contra miles de casos de prueba generados automáticamente, lo que aumenta la probabilidad de encontrar errores que podrían pasar desapercibidos con pruebas manuales o casos limitados.
- **Detección temprana de errores**: Al probar con una gama extensa de entradas, PBT ayuda a descubrir errores en etapas tempranas del desarrollo.
- **Enfoque en el comportamiento**: En lugar de enfocarse en casos específicos, PBT ayuda a definir y verificar el comportamiento general de un programa, asegurando que se cumpla bajo múltiples condiciones.

### Desafíos

**Mayor complejidad inicial**: Escribir pruebas basadas en propiedades puede ser más complejo que los tests tradicionales, ya que se requiere una buena comprensión de las propiedades fundamentales del sistema que estamos probando.

:::tip

Aunque puede ser más difícil de implementar al principio, **Property-Based Testing** ofrece una poderosa alternativa al enfoque tradicional de **Data-Driven Testing**. Con su capacidad para generar numerosos casos de prueba automáticamente, PBT no solo mejora la cobertura y la robustez de las pruebas, sino que también contribuye a identificar fallos más rápidamente.

¡Considera usar PBT como una herramienta preferida frente a DDT en tus proyectos!

:::

### Propiedades en Property-Based Testing

A diferencia de los **tests tradicionales**, que dependen de casos de prueba específicos basados en ejemplos, las **propiedades** en Property-Based Testing definen condiciones generales que deben cumplirse sin importar los valores de entrada de la función.

- **Tests basados en ejemplos**: Verifican comportamientos en función de inputs específicos.
- **Propiedades**: Establecen afirmaciones generales sobre el comportamiento que siempre deben cumplirse, independientemente de los inputs.

#### Importancia de la Pureza de las Propiedades

Para que las propiedades sean efectivas y fiables en **Property-Based Testing**, es crucial que sean **propias** (**puras**). La **pureza** de una propiedad implica que:

1. **Determinismo**: Una propiedad pura siempre produce el mismo resultado dado el mismo input. No depende de estados externos ni de variables globales que puedan cambiar.
2. **Sin Efectos Secundarios**: Las propiedades puras no modifican el estado del sistema ni interactúan con el mundo exterior (por ejemplo, no realizan operaciones de I/O, no modifican bases de datos, etc.).
3. **Independencia**: Cada ejecución de una propiedad es independiente de las demás, lo que facilita la paralelización y evita interferencias entre pruebas.

**Ventajas de las Propiedades Puras:**

- **Reproducibilidad**: Si una prueba falla, es más fácil reproducir el error porque no hay estados externos que afecten el comportamiento.
- **Facilidad de Mantenimiento**: Las propiedades puras son más simples de entender y mantener, ya que su comportamiento está completamente determinado por sus inputs.
- **Eficiencia**: Al no depender de efectos secundarios, las propiedades puras pueden ejecutarse más rápidamente y de manera más eficiente.

#### Generación Automática de Casos de Prueba

El **framework de testing** genera automáticamente una variedad de casos de prueba basados en las propiedades definidas. Este proceso se basa en múltiples condiciones y combinaciones de inputs, asegurando que la función cumpla con las expectativas bajo distintas circunstancias. Al enfocarse en propiedades puras, se garantiza que cada caso de prueba sea independiente y confiable, maximizando la efectividad del testing.

### Generadores Arbitrarios

Los **generadores arbitrarios** son herramientas poderosas que permiten generar una gran variedad de entradas aleatorias para probar propiedades en los tests. En **Kotest**, existe una amplia gama de generadores prediseñados para diferentes tipos de datos, como enteros, cadenas, y colecciones, lo que facilita la creación de pruebas robustas con diversos escenarios de entrada.

Además, Kotest permite definir **generadores personalizados**, lo que brinda flexibilidad para casos de prueba más específicos y complejos. Estos generadores pueden componerse y transformarse, lo que los hace extremadamente versátiles para probar funciones bajo múltiples condiciones.

Aunque los generadores de Kotest **no son mónadas formales**, ya que no cumplen estrictamente con todas las leyes monádicas, se comportan de forma similar. Al igual que las mónadas, los generadores permiten la **composición** mediante operaciones como `flatMap`, facilitando la construcción de flujos de generación de datos altamente personalizables para pruebas más exhaustivas y dinámicas.

## ¿Qué hemos visto?

En esta lección, hemos explorado cómo integrar **Property-Based Testing** en nuestro proyecto para superar las limitaciones del **Data-Driven Testing**. Hemos explorado los conceptos clave de PBT, incluyendo la definición de propiedades, la importancia de la pureza de las propiedades, y la generación automática de casos de prueba mediante generadores arbitrarios.

### Puntos clave:
- **Property-Based Testing** es una técnica poderosa que permite probar el comportamiento general de una función bajo múltiples entradas generadas automáticamente.
- **Generadores arbitrarios** facilitan la creación de entradas de prueba diversificadas y personalizables.
- Aunque PBT puede ser más complejo de implementar al principio, ofrece una cobertura de pruebas superior, ayudando a identificar errores de manera más temprana y eficiente.

Considera usar **PBT** en tus proyectos para mejorar la calidad de tus pruebas y asegurar el correcto comportamiento de tus funciones bajo diversas condiciones.