---
title: Property-Based Testing
---

## Testeando la función `merge`

Imaginemos que queremos testear la función `merge`, la cual toma dos listas ordenadas como entrada y devuelve una nueva lista que contiene todos los elementos de ambas listas, manteniendo el orden.

### ¿Cómo podríamos probar esta función?

Podríamos recurrir a **Data-Driven Testing** para verificar su comportamiento. Esto implicaría definir varios conjuntos de datos de entrada y validar que la función produce los resultados esperados para cada uno. Sin embargo, ¿qué conjuntos de datos serían apropiados para cubrir todos los casos posibles?

### Preguntas clave al elegir inputs:

1. ¿Qué ocurre si una o ambas listas están vacías?
2. ¿Qué pasa cuando las listas tienen elementos repetidos?
3. ¿Cómo se comporta `merge` cuando una lista contiene elementos mayores o menores que todos los de la otra?
4. ¿Qué sucede si ambas listas ya están ordenadas pero con diferentes rangos de valores?

### Ejemplo de inputs que podríamos usar:

- `merge([], [])` → `[]` (Ambas listas vacías)
- `merge([1, 3, 5], [])` → `[1, 3, 5]` (Una lista vacía)
- `merge([], [2, 4, 6])` → `[2, 4, 6]` (Otra lista vacía)
- `merge([1, 3], [2, 4])` → `[1, 2, 3, 4]` (Listas con valores intercalados)
- `merge([1, 2, 3], [4, 5, 6])` → `[1, 2, 3, 4, 5, 6]` (Una lista con valores completamente menores)
- `merge([2, 4, 6], [1, 3, 5])` → `[1, 2, 3, 4, 5, 6]` (Listas desordenadas entre sí)

Comencemos por definir una data class para representar los inputs y output de la función


