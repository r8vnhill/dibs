---
title: Iterator pattern en TypeScript
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import CodeBlock from '@theme/CodeBlock'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="  " />

El **patr√≥n Iterador** es una t√©cnica utilizada en programaci√≥n orientada a objetos para recorrer una colecci√≥n de manera secuencial sin exponer su estructura interna. En TypeScript, este patr√≥n se implementa utilizando la **interfaz iterable** nativa y los generadores (`generators`), ofreciendo un enfoque flexible para recorrer estructuras de datos.  

## üìå Iteradores en TypeScript

TypeScript proporciona soporte nativo para el patr√≥n iterador a trav√©s de la interfaz `Iterable<T>`, que define el m√©todo `Symbol.iterator()`. Este m√©todo retorna un iterador que implementa `Iterator<T>`, con las funciones `next()` para avanzar y `done` para verificar si se ha completado el recorrido.  

```typescript showLineNumbers
interface Iterator<T> {
  next(): { value: T; done: boolean };
}

interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}
```

## üõ†Ô∏è Implementaci√≥n del patr√≥n Iterador

Supongamos que queremos modelar una biblioteca que almacena libros y proporciona un iterador para recorrerlos.  

### üèóÔ∏è 1. Definir el Iterador

El primer paso es definir la clase que implementa la interfaz `Iterator<T>` para recorrer la colecci√≥n de libros.  

```typescript showLineNumbers
class BookIterator implements Iterator<string> {
  private position = 0;

  constructor(private books: string[]) {}

  next(): { value: string; done: boolean } {
    if (this.position >= this.books.length) {
      return { value: "", done: true };
    }
    return { value: this.books[this.position++], done: false };
  }
}
```

Aqu√≠, `next()` devuelve el siguiente libro en la colecci√≥n hasta que no quedan m√°s elementos.  

### üìö 2. Implementar la colecci√≥n iterable

La biblioteca debe implementar `Iterable<T>` para devolver una instancia del iterador.  

```typescript showLineNumbers
class Library implements Iterable<string> {
  constructor(private books: string[]) {}

  [Symbol.iterator](): Iterator<string> {
    return new BookIterator(this.books);
  }
}
```

### üîÑ 3. Uso del iterador

Ahora podemos recorrer la biblioteca utilizando un `for...of`.  

```typescript showLineNumbers
const library = new Library([
  "Historia del Feminismo",
  "El general en su laberinto",
  "Choque de reyes"
]);

for (const book of library) {
  console.log(book);
}
```

### ‚ö° Iterador con Generadores en TypeScript

Podemos simplificar el c√≥digo usando un **generador**, eliminando la necesidad de una clase iteradora separada:  

```typescript showLineNumbers
class Library implements Iterable<string> {
  constructor(private books: string[]) {}

  *[Symbol.iterator](): IterableIterator<string> {
    for (const book of this.books) {
      yield book;
    }
  }
}
```

## üìä Resumen comparativo

| **Aspecto**                 | **TypeScript**                                           | **Kotlin**                                   |
|-----------------------------|---------------------------------------------------------|----------------------------------------------|
| **Soporte nativo**          | Usa `Iterable<T>` e `Iterator<T>` con `Symbol.iterator` | Usa `Iterable<T>` e `Iterator<T>`           |
| **Definici√≥n del iterador** | Implementa `Iterator<T>` con `next()` y `done`         | Implementa `Iterator<T>` con `next()` y `hasNext()` |
| **Iteraci√≥n nativa**        | `for...of` y el operador de propagaci√≥n `...`         | `for` loop y `iterator()` impl√≠cito         |
| **Iteradores avanzados**    | Usa **generadores** con `function*`                    | Usa **secuencias (`Sequence<T>`)**          |
| **Acceso a iteradores**     | `library[Symbol.iterator]()`                           | `library.iterator()`                         |
| **Control de finalizaci√≥n** | `done: boolean` en `next()` indica fin del recorrido  | `hasNext()` indica si hay m√°s elementos     |
| **Laziness (Evaluaci√≥n diferida)** | Disponible con `yield` en generadores         | Disponible con `Sequence<T>`                |
| **Paralelismo**             | No soporta paralelismo en iteradores nativos           | Puede usar `asIterable()` con `parallelStream()` |
| **Compatibilidad con estructuras existentes** | Funciona con `Array`, `Set`, `Map` y `String` | Funciona con `List`, `Set`, `Map` y `String` |
| **Sobrecarga de memoria**   | Baja con generadores (`yield`)                         | Baja con `Sequence<T>`                      |

### ‚úÖ Beneficios y ‚ùå limitaciones de TypeScript

<ProCons>
    <Pros>
        - **Soporte nativo**: TypeScript integra `Iterable<T>` y `Symbol.iterator`, lo que facilita la implementaci√≥n del patr√≥n sin necesidad de clases adicionales.
        - **Iteraci√≥n simplificada**: Permite recorrer estructuras de datos usando `for...of` y el operador de propagaci√≥n `...`, evitando el manejo manual del iterador.
        - **Evaluaci√≥n diferida con generadores**: Los generadores (`function*`) permiten recorrer colecciones grandes sin cargar todos los elementos en memoria.
        - **Compatibilidad con estructuras nativas**: Funciona con `Array`, `Set`, `Map` y `String` sin necesidad de modificaciones.
        - **Interoperabilidad con JavaScript**: TypeScript puede trabajar con cualquier iterador de JavaScript, permitiendo su uso en bibliotecas externas y APIs nativas.
    </Pros>
    <Cons>
        - **Sin control sobre concurrencia**: A diferencia de Kotlin, TypeScript no ofrece una alternativa directa para recorrer colecciones en paralelo.
        - **Sin soporte para secuencias avanzadas**: No tiene un equivalente directo a `Sequence<T>` de Kotlin, lo que limita la composici√≥n funcional de iteradores.
        - **Menor seguridad de tipos en iteradores externos**: TypeScript permite el uso de iteradores sin verificaci√≥n estricta, lo que puede generar errores en tiempo de ejecuci√≥n si los datos no son consistentes.
    </Cons>
</ProCons>

## üéØ Conclusiones

El patr√≥n **Iterator** en TypeScript ofrece una manera flexible y estructurada de recorrer colecciones sin exponer su implementaci√≥n interna. Gracias a `Iterable<T>` y `Symbol.iterator`, la integraci√≥n con las estructuras nativas del lenguaje es sencilla, permitiendo iteraciones eficientes y concisas.

A lo largo de la lecci√≥n, hemos explorado su implementaci√≥n, su comparaci√≥n con Kotlin y sus ventajas en t√©rminos de **simplicidad, evaluaci√≥n diferida con generadores y compatibilidad con estructuras de datos est√°ndar**. Tambi√©n hemos analizado sus **limitaciones**, como la falta de soporte nativo para concurrencia y secuencias avanzadas.

### üîë Puntos clave

- **Iteraci√≥n nativa**: TypeScript proporciona iteradores de forma integrada con `for...of` y `Symbol.iterator`, lo que simplifica su uso.
- **Soporte para evaluaci√≥n diferida**: Los generadores (`function*`) permiten recorrer colecciones sin cargar todos los elementos en memoria, mejorando la eficiencia.
- **Compatibilidad con estructuras est√°ndar**: Funciona de manera directa con `Array`, `Set`, `Map` y `String` sin necesidad de modificaciones.
- **Diferencias con Kotlin**: Aunque ambos lenguajes soportan iteradores, Kotlin ofrece **secuencias (`Sequence<T>`)** como alternativa m√°s poderosa para manipulaci√≥n de datos.

### üß∞ ¬øQu√© nos llevamos?

El patr√≥n iterador sigue siendo una herramienta fundamental para la manipulaci√≥n de colecciones, tanto en TypeScript como en otros lenguajes. En TypeScript, su implementaci√≥n es natural gracias a `Symbol.iterator`, y su combinaci√≥n con generadores lo hace a√∫n m√°s poderoso. Sin embargo, su uso debe evaluarse seg√∫n el contexto: en colecciones simples, una iteraci√≥n directa puede ser suficiente, mientras que en estructuras m√°s complejas o grandes vol√∫menes de datos, los generadores ofrecen una alternativa eficiente.

Si bien existen diferencias con Kotlin en t√©rminos de abstracci√≥n y soporte para secuencias, ambos enfoques buscan lo mismo: **recorrer estructuras de datos de forma eficiente sin comprometer la encapsulaci√≥n ni la claridad del c√≥digo**. Comprender c√≥mo cada lenguaje implementa este patr√≥n nos permite aprovechar mejor sus capacidades y elegir la mejor soluci√≥n seg√∫n nuestras necesidades.

## üìñ Referencias

### üî• Recomendadas

üåê Documentation‚ÄîIterators and Generators. (s.¬†f.). Recuperado 21 de marzo de 2025, de https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html
