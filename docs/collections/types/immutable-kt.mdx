---
title: Colecciones inmutables
---
import LanguageCard from "../../../src/components/cards/LanguageCard";
import GitHubRepoLink from "../../../src/components/GithubRepoLink";
import References from "../../../src/components/ReferencesComponent";
import ReadingTime from '../../../src/components/ReadingTime';
import CollectionsVariance from '../../../src/pages/collections/types/collections-variance.mdx';

<ReadingTime />
<GitHubRepoLink repo={"collections-kt"} user={"r8vnhill"} />

Kotlin ofrece una amplia variedad de **colecciones inmutables** que permiten gestionar datos de manera eficiente sin modificar su estado. Estas colecciones garantizan la seguridad en situaciones donde no se desea que los datos cambien después de ser inicializados, proporcionando inmutabilidad por defecto.

:::note Diferenciación entre Colecciones Iterables y Diccionarios
A diferencia de otros lenguajes, Kotlin separa las colecciones iterables (``Collection``) de los diccionarios (``Map``).
:::

## `Collection`

En Kotlin, una **colección** es una estructura iterable que almacena elementos de manera organizada. Las colecciones tienen un tamaño definido (`size`) y permiten buscar elementos dentro de ellas utilizando el método `contains`, o el operador `in`, que es equivalente.

### Ejemplo

```kotlin showLineNumbers
val strings: Collection<String> = listOf("Kotlin", "Java")
println(strings.contains("Kotlin"))  // Output: true
println("Java" in strings)  // Output: true
```

### Nota sobre Covarianza

Las colecciones son covariantes, lo que permite asignar una colección de un tipo a una colección de su supertipo. Aunque algunos métodos podrían requerir contravarianza, Kotlin los permite siempre y cuando no modifiquen la colección, ya que son métodos de solo lectura, como `contains`.

<details>
    <summary>Más detalles sobre covarianza</summary>

    <CollectionsVariance />
</details>

La covarianza en colecciones permite flexibilidad al tratar con tipos genéricos sin comprometer la seguridad de los tipos en operaciones de solo lectura.

### `List`

Una **lista** es una colección ordenada de elementos, en la que cada elemento tiene una posición indexada, lo que permite acceder y manipular elementos directamente mediante su índice. Además, las listas pueden contener elementos duplicados, lo que significa que un mismo valor puede aparecer en múltiples posiciones dentro de la lista.

```kotlin showLineNumbers
public interface List<out E> : Collection<E>
```

#### Ejemplo:

```kotlin showLineNumbers
val immutableList: List<String> = listOf("Kotlin", "Java", "Scala")
println(immutableList[0])  // Output: Kotlin
```

### `Set`

Un **set** es una colección que no permite elementos duplicados y no garantiza un orden específico de los mismos. Los sets son útiles cuando se necesita asegurar que cada elemento sea único dentro de la colección. Además, los sets soportan operaciones matemáticas como **unión**, **intersección** y **diferencia**. En Kotlin, se pueden crear sets utilizando la función `setOf`.

```kotlin showLineNumbers
public interface Set<out E> : Collection<E>
```

#### Ejemplo:

```kotlin showLineNumbers
val immutableSet: Set<String> = setOf("Kotlin", "Java", "Scala")
println("Kotlin" in immutableSet)  // Output: true
```

## `Map`

Un **map** es una colección que asocia claves (*keys*) con valores (*values*), donde cada clave está vinculada a un único valor. Esta estructura permite acceder de manera eficiente a un valor dado su clave. En un map, las claves deben ser únicas, aunque los valores pueden repetirse. Los mapas en Kotlin se crean usando la función `mapOf`, seguida de una secuencia de pares clave-valor.

```kotlin showLineNumbers
public interface Map<K, out V>
```

### Ejemplo

```kotlin showLineNumbers
val immutableMap: Map<String, Int> = mapOf("Kotlin" to 1, "Java" to 2)
println(immutableMap["Kotlin"])  // Output: 1
```

## Beneficios de las Colecciones Inmutables

1. **Seguridad**: Garantizan que los datos no cambien, lo que evita errores imprevistos.
2. **Facilitan la concurrencia**: Al no cambiar su estado, son naturalmente seguras para usar en entornos concurrentes.
3. **Lectura más clara**: Es más fácil razonar sobre el comportamiento de un programa cuando las colecciones son inmutables, ya que no se esperan cambios imprevistos.

<div className="language-card-container">
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Logo_C_sharp.svg/1200px-Logo_C_sharp.svg.png"
        language="C#"
        link="immutable/csharp"
    />
    <LanguageCard
        logoSrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Haskell-Logo.svg/1200px-Haskell-Logo.svg.png"
        language="Haskell"
        link="immutable/haskell"
    />
</div>

<References references={[
    {
        title: "Chapter 9. Collections: Get Organized",
        bookTitle: "Head First Kotlin",
        pages: "439-502",
        location: "Beijing Boston Farnham Sebastopol Tokyo",
        publisher: "O’Reilly",
        year: "2019",
        type: "book",
        author: 'Dawn Griffiths & David Griffiths'
    },
]}/>
