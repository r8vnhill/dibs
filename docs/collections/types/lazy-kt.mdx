---
title: Colecciones Perezosas
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard, JavaScriptCard, JavaCard, PythonCard, RustCard, ScalaCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="collections-kt" />
<ModuleSetup module='lazy' task='setupLazyModule'>
    ```Kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupLazyModule") {
        description = "Creates the base module and files for the Lazy Collections module"
        module.set("lazy")

        doLast {
            
        }
    }
    ```
</ModuleSetup>

En Kotlin, el uso de colecciones es habitual para transformar y procesar datos. Sin embargo, en ciertos escenarios ‚Äîcomo flujos infinitos, operaciones costosas o pipelines complejos‚Äî, las colecciones tradicionales pueden introducir costos innecesarios en tiempo y memoria debido a su evaluaci√≥n inmediata.

En esta lecci√≥n abordaremos las **colecciones perezosas**, aquellas que **difieren la evaluaci√≥n** de sus elementos hasta que realmente se necesitan. Veremos c√≥mo este enfoque permite mejorar la eficiencia sin sacrificar expresividad, y c√≥mo implementarlo tanto manualmente con `Iterable` e `Iterator`, como idiom√°ticamente con `Sequence`.

El objetivo es que puedas:

- Entender c√≥mo funciona la evaluaci√≥n perezosa.
- Dise√±ar estructuras perezosas personalizadas.
- Comparar su comportamiento frente a colecciones tempranas.
- Usarlas para escribir c√≥digo m√°s expresivo y eficiente en tus bibliotecas.

## üò¥ ¬øQu√© es una Colecci√≥n Perezosa?

Una **colecci√≥n perezosa** es una estructura cuyos elementos no se calculan ni procesan de inmediato, sino que se generan solo cuando se necesitan. Esta estrategia es clave al dise√±ar bibliotecas que deben ser eficientes y componibles, especialmente cuando se trabaja con flujos infinitos, transformaciones encadenadas o datos costosos de calcular.

A diferencia de las colecciones tradicionales ‚Äîque procesan todos los elementos tan pronto como se aplica una operaci√≥n‚Äî, las colecciones perezosas permiten **diferir la evaluaci√≥n**, lo que evita c√°lculos innecesarios y reduce el uso de memoria. Esto las hace ideales para construir APIs que necesitan ofrecer eficiencia sin sacrificar expresividad.

<Definition title="Evaluaci√≥n temprana">
    La **evaluaci√≥n temprana** es una estrategia en la cual las expresiones son evaluadas inmediatamente cuando el programa las encuentra. Esto garantiza que todos los valores est√©n disponibles cuando se necesiten, pero puede provocar c√°lculos in√∫tiles o el uso excesivo de recursos si no todos los datos se van a utilizar.
</Definition>

<Definition title="Evaluaci√≥n perezosa">
    La **evaluaci√≥n perezosa** consiste en posponer el c√°lculo de una expresi√≥n hasta que su valor sea requerido. Al diferir la evaluaci√≥n, se optimiza el uso de recursos y se evita trabajo innecesario. Esta t√©cnica es especialmente √∫til en bibliotecas que manipulan flujos complejos, estructuras infinitas o secuencias derivadas de operaciones encadenadas.
</Definition>

## üí§ Implementaci√≥n de una Colecci√≥n Perezosa Personalizada

Al dise√±ar una biblioteca de utilidades num√©ricas, es com√∫n que deseemos ofrecer secuencias num√©ricas como parte de una API. Por ejemplo, podr√≠amos querer incluir una funci√≥n que permita generar una secuencia de n√∫meros pares para tareas estad√≠sticas, simulaciones o transformaciones funcionales.

En lugar de devolver una lista completa ‚Äîlo cual podr√≠a ser ineficiente o incluso inviable si la secuencia es infinita‚Äî, una mejor opci√≥n es exponer una **colecci√≥n perezosa** que genere estos valores bajo demanda. Esto no solo mejora el rendimiento, sino que permite componer operaciones de manera m√°s expresiva y segura.

En este ejemplo, implementamos una colecci√≥n perezosa como parte de una biblioteca que expone una secuencia infinita de n√∫meros pares.

### üìã Especificaci√≥n BDD

```kotlin showLineNumbers
"Given a lazy sequence of even numbers from the library" - {
    "when the user requests the first n elements" - {
        "then the sequence should produce the first n even numbers correctly" {}
    }
}
```

### üìù Implementaci√≥n de las pruebas

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        checkAll(Arb.int(1..100)) { n ->
            val evens = EvenNumbers()
            val collected = mutableListOf<Int>()
            val iterator = evens.iterator()

            while (iterator.hasNext() && collected.size < n) {
                collected += iterator.next()
            }

            val expected = (0..<(n * 2) step 2).toList()
            collected shouldBe expected
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="lazy/src/test/kotlin/com/github/username/numeric/NumericSequencesTest.kt"
        package com.github.username.numeric

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.int
        import io.kotest.property.checkAll

        class NumericSequencesTest : FreeSpec({

            "Given a lazy sequence of even numbers from the library" - {
                "when the user requests the first n elements" - {
                    "then the sequence should produce the first n even numbers correctly" {
                        checkAll(Arb.int(1..100)) { n ->
                            val evens = EvenNumbers()
                            val collected = mutableListOf<Int>()
                            val iterator = evens.iterator()

                            while (iterator.hasNext() && collected.size < n) {
                                collected += iterator.next()
                            }

                            val expected = (0..<(n * 2) step 2).toList()
                            collected shouldBe expected
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Esta prueba valida que la secuencia `EvenNumbers()` ‚Äîprovista por nuestra biblioteca‚Äî genera los primeros `n` n√∫meros pares de forma perezosa y correcta.

    - Se usa **Property-Based Testing** para verificar el comportamiento con diferentes valores de `n`.
    - La colecci√≥n resultante se compara con una lista construida manualmente usando `(0..<(n * 2) step 2)`, que representa la especificaci√≥n esperada de la secuencia de pares.
    - Este enfoque garantiza que el generador perezoso cumple con la interfaz `Iterable` y que su comportamiento es consistente y predecible, cualidades esenciales en componentes reutilizables dentro de una biblioteca.
</Explanation>

### üß© Definiendo la clase `EvenNumbers`

```kotlin showLineNumbers
package com.github.username.even

class EvenNumbers : Iterable<Int> {
    override fun iterator(): Iterator<Int> = EvenNumberIterator()
}
```

<Explanation>
    - Creamos una clase `EvenNumbers` que representa una colecci√≥n perezosa de n√∫meros pares. Al implementar `Iterable<Int>`, esta clase se puede usar como cualquier colecci√≥n de Kotlin en ciclos `for`, llamadas a `toList()`, o cualquier otra operaci√≥n que recorra elementos.  
    - En lugar de almacenar los n√∫meros en memoria, delega la generaci√≥n de valores a un iterador (`EvenNumberIterator`), lo que permite producir los n√∫meros uno a uno, solo cuando se necesitan. Este dise√±o es √∫til para bibliotecas que necesitan exponer flujos infinitos o c√°lculos diferidos de manera limpia y reutilizable.
</Explanation>

### ‚öôÔ∏è Definiendo la clase `EvenNumberIterator`

```kotlin showLineNumbers
package com.github.username.even

class EvenNumberIterator : Iterator<Int> {
    private var current = 0

    override fun hasNext(): Boolean = true

    override fun next() = if (current >= Int.MAX_VALUE - 1) {
        throw NoSuchElementException()
    } else {
        val nextValue = current
        current += 2
        nextValue
    }
}
```

<Explanation>
    - Implementamos un iterador personalizado llamado `EvenNumberIterator`, que genera n√∫meros pares de forma infinita y perezosa. Cada vez que se llama a `next()`, se produce el siguiente n√∫mero par sin necesidad de precomputar la secuencia completa.  
    - El m√©todo `hasNext()` siempre devuelve `true` porque el flujo es infinito, aunque protegemos el l√≠mite superior de `Int` para evitar desbordamientos. Este patr√≥n permite a las bibliotecas ofrecer secuencias num√©ricas eficientes y seguras, ideales para flujos de datos, simulaciones o generadores en tiempo real.
</Explanation>

:::warning Consideraciones al Usar Colecciones Perezosas

- **Control del Flujo**: Es crucial limitar el n√∫mero de elementos que se consumen de una secuencia infinita para evitar bucles infinitos y desbordamientos de memoria.
- **Inmutabilidad**: Las colecciones perezosas suelen ser inmutables, promoviendo un estilo de programaci√≥n funcional y evitando efectos secundarios.
- **Comprensi√≥n de la Evaluaci√≥n Perezosa**: Es importante entender c√≥mo y cu√°ndo se eval√∫an las operaciones para evitar comportamientos inesperados.

:::



## üìä Comparaci√≥n entre Tipos de Colecciones en Kotlin

| **Caracter√≠stica**                  | **Evaluaci√≥n Temprana (Inmutables)**<br/>`List`, `Set`, `Map`     | **Evaluaci√≥n Temprana Mutables**<br/>`MutableList`, `MutableSet`, `MutableMap` | **Evaluaci√≥n Perezosa**<br/>`Sequence` o personalizada |
|-------------------------------------|------------------------------------------------------------------|-------------------------------------------------------------------------------|----------------------------------------------------------------|
| **Evaluaci√≥n**                      | **Inmediata**                                                    | **Inmediata**                                                                 | **Diferida (lazy)**                                            |
| **Mutabilidad**                     | Inmutables                                                       | Mutables                                                                      | Inmutables por defecto                                         |
| **Uso de memoria**                  | Alto: genera colecciones intermedias                             | Alto (similar a inmutables)                                                   | Bajo: evita estructuras intermedias                            |
| **Procesamiento**                   | Procesa todos los elementos al aplicar una operaci√≥n             | Igual que inmutables, pero con modificaci√≥n directa                           | Solo procesa lo que se necesita                               |
| **Flujos infinitos**                | ‚ùå No soportado                                                  | ‚ùå No soportado                                                                | ‚úÖ Soportado                                                   |
| **Encadenamiento de operaciones**   | Menos eficiente: cada paso crea una nueva colecci√≥n              | Similar, con posibilidad de modificar                                         | M√°s eficiente gracias a la evaluaci√≥n perezosa                 |
| **Flexibilidad**                    | F√°cil de usar y entender                                         | M√°s flexible por ser modificable                                              | Requiere dise√±o cuidadoso                                     |
| **Ejemplo de uso**                  | Datos constantes                                                  | Listas din√°micas que cambian en tiempo de ejecuci√≥n                           | Flujos de datos grandes o infinitos                           |
| **Mutaciones durante la iteraci√≥n** | ‚ùå No permitidas                                                 | ‚úÖ Permitidas con `MutableIterator`                                           | No aplica directamente                                         |

## üò™ Colecciones perezosas en Kotlin: `Sequence`

En Kotlin, la interfaz [`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/) representa una colecci√≥n **perezosa**, dise√±ada para trabajar con grandes vol√∫menes de datos o flujos potencialmente infinitos sin generar colecciones intermedias en memoria.

Las secuencias permiten **encadenar operaciones intermedias** como `map`, `filter` o `takeWhile` sin que estas se eval√∫en inmediatamente. En su lugar, las transformaciones se aplican de forma diferida, una a una, y **solo cuando se invoca una operaci√≥n terminal** ‚Äîcomo `toList()`, `first()`, o `forEach()`‚Äî. Esto permite mejorar el rendimiento y reducir el uso de memoria, especialmente √∫til al dise√±ar **APIs de procesamiento de datos o bibliotecas de transformaci√≥n funcional**.

### üí° Ejemplo de uso de secuencias en Kotlin

Veamos c√≥mo construir una secuencia infinita de n√∫meros pares y obtener los primeros `n` elementos usando dos enfoques idiom√°ticos de Kotlin. Ambos ejemplos ilustran c√≥mo la evaluaci√≥n perezosa puede ayudarte a escribir c√≥digo m√°s eficiente y expresivo, especialmente √∫til al construir bibliotecas que procesan flujos de datos.

<BoxedTabs>
    <TabItem label={"Implementaci√≥n b√°sica"} value={"Implementaci√≥n b√°sica"}>
        ```kotlin showLineNumbers
        val evenNumbers = sequence {
            var number = 0
            while (true) {
                yield(number)
                number += 2
            }
        }

        val firstNEvens = evenNumbers
            .take(SIZE)
            .toList()
        ```

        <Explanation>
            - **`sequence {}`** permite definir una secuencia perezosa manualmente.
            - Dentro del bloque, generamos un flujo infinito de n√∫meros pares usando `yield`.
            - Solo se generan los elementos necesarios gracias a `take(SIZE)`, y luego se materializan en memoria con `toList()`.
        </Explanation>
    </TabItem>

    <TabItem label={"Implementaci√≥n mejorada"} value={"Implementaci√≥n mejorada"}>
        ```kotlin showLineNumbers
        val evenNumbers = generateSequence(0) { it + 2 }

        val firstNEvens = evenNumbers
            .take(SIZE)
            .toList()
        ```

        <Explanation>
            - **`generateSequence(start) { next }`** es una forma m√°s concisa de definir secuencias basadas en funciones.
            - Es ideal para bibliotecas, ya que reduce el ruido y mejora la legibilidad sin sacrificar pereza ni expresividad.
        </Explanation>
    </TabItem>
</BoxedTabs>

Este patr√≥n te permite construir flujos infinitos o costosos de forma segura, sin incurrir en sobrecarga de memoria. Es una herramienta clave cuando dise√±as bibliotecas que transforman datos en m√∫ltiples etapas sin crear estructuras intermedias innecesarias.

## üß™ Ejercicio: Secuencia de Fibonacci

<Exercise>
    Imagina que est√°s construyendo una biblioteca de secuencias num√©ricas. Tu objetivo es implementar una secuencia perezosa que genere los n√∫meros de Fibonacci usando `Sequence`.

    Cada n√∫mero de Fibonacci se define como la suma de los dos anteriores, comenzando con `0` y `1`.

    **No almacenes todos los elementos generados: deben calcularse bajo demanda.**

    <Solution>
    ```kotlin showLineNumbers
    fun fibonacciSequence(): Sequence<Long> = sequence {
        var a = 0L
        var b = 1L
        while (true) {
            yield(a)
            a = b.also { b += a }
        }
    }
    ```
    </Solution>
</Exercise>

## üéØ Conclusiones

El uso de **colecciones perezosas** representa una herramienta poderosa para quienes dise√±an bibliotecas orientadas al procesamiento de datos, algoritmos num√©ricos o flujos potencialmente infinitos. A diferencia de las colecciones tradicionales, las colecciones perezosas permiten construir APIs m√°s expresivas, eficientes y componibles, favoreciendo la claridad sin sacrificar rendimiento.

Durante esta lecci√≥n, implementamos una colecci√≥n perezosa personalizada utilizando el patr√≥n *Iterator*, y exploramos c√≥mo Kotlin provee construcciones idiom√°ticas como `Sequence` y `generateSequence` que permiten lograr el mismo objetivo de forma m√°s declarativa y legible.

### üîë Puntos clave

- Las colecciones tradicionales eval√∫an sus elementos de inmediato, lo que puede generar c√°lculos innecesarios o consumo de memoria excesivo.
- Las colecciones perezosas **difieren la evaluaci√≥n** hasta que los elementos son requeridos, optimizando recursos.
- Kotlin ofrece soporte idiom√°tico para este patr√≥n a trav√©s de `Sequence`, `sequence {}` y `generateSequence(...)`.
- Al dise√±ar bibliotecas, este enfoque permite **exponer flujos reutilizables**, **evitar estructuras temporales** y **mejorar la componibilidad** de las APIs.

### üß∞ ¬øQu√© nos llevamos?

Dise√±ar colecciones perezosas no solo es una t√©cnica para mejorar el rendimiento: es una forma de pensar en t√©rminos de eficiencia, claridad y componibilidad. Al adoptar este enfoque en nuestras bibliotecas, no solo optimizamos recursos, sino que tambi√©n promovemos un dise√±o m√°s expresivo y declarativo, donde las transformaciones ocurren solo cuando son necesarias.

Este modelo de evaluaci√≥n nos invita a repensar c√≥mo construimos APIs: en lugar de forzar al usuario a cargar y transformar datos prematuramente, le damos el control para decidir **cu√°ndo** y **cu√°nto** necesita. As√≠, las colecciones perezosas se convierten en aliadas poderosas para escribir c√≥digo reutilizable, predecible y elegante ‚Äîespecialmente cuando trabajamos con flujos infinitos, datos derivados o estructuras altamente din√°micas.

En definitiva, nos llevamos una herramienta conceptual y pr√°ctica que expande nuestra caja de herramientas como dise√±adores de software, ayud√°ndonos a construir bibliotecas m√°s eficientes, expresivas y sostenibles.

<div className="language-card-container">
    <JavaCard link="/docs/collections/types/lazy/java" />
    <JavaScriptCard link="/docs/collections/types/lazy/js" />
    <PythonCard link="/docs/collections/types/lazy/python" />
    <RustCard link="/docs/collections/types/lazy/rust" />
    <ScalaCard link="/docs/collections/types/lazy/scala" />
</div>

## üìñ Referencias

### üî• Recomendadas

- üåê Tema 10: Evaluaci√≥n perezosa. (s.¬†f.). Recuperado 29 de marzo de 2025, de https://www.cs.us.es/~jalonso/cursos/i1m/temas/tema-10.html

### üîπ Adicionales

- üì∞ Casero, A. (2024, marzo 15). ¬øQu√© es la evaluaci√≥n perezosa en programaci√≥n? Keep Coding. https://keepcoding.io/blog/evaluacion-perezosa-en-programacion/
