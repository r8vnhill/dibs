---
title: Colecciones perezosas en JavaScript
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

En JavaScript, la **evaluaci√≥n perezosa** nos permite generar valores solo cuando los necesitamos. Esto es √∫til cuando trabajamos con secuencias grandes o incluso infinitas, evitando que el programa consuma m√°s memoria de la necesaria. Una de las formas m√°s pr√°cticas de lograr esto es con **generadores**.

## üìå ¬øQu√© es un generador?

Un generador es b√°sicamente una funci√≥n especial que puede **pausar y reanudar su ejecuci√≥n**. Se define con `function*` y usa la palabra clave `yield` para devolver valores de manera perezosa.

```javascript showLineNumbers
function* evenNumbers() {
    let num = 0;
    while (true) {
        yield num;
        num += 2;
    }
}
```

<Explanation>
Aqu√≠ `evenNumbers` es un generador infinito de n√∫meros pares. Cada vez que llamamos a `next()`, la funci√≥n se pausa en `yield num` y espera hasta que pidamos el siguiente valor. As√≠ evitamos generar n√∫meros innecesarios.
</Explanation>

## üöÄ ¬øC√≥mo usamos un generador?

Para obtener los primeros `n` n√∫meros pares, basta con usar un bucle y llamar a `next()` en cada iteraci√≥n:

```javascript
const evenGen = evenNumbers();
const firstTenEvens = [];

for (let i = 0; i < 10; i++) {
    firstTenEvens.push(evenGen.next().value);
}

console.log(firstTenEvens);  // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

Cada llamada a `next()` nos da el siguiente n√∫mero de la secuencia, y el generador sigue funcionando hasta que decidimos detenerlo.

## ‚ö° Generadores as√≠ncronos en JavaScript

JavaScript tambi√©n nos permite trabajar con **flujos de datos as√≠ncronos** usando generadores as√≠ncronos (`async function*`). Estos son muy √∫tiles para manejar datos que llegan de una API o de un archivo sin bloquear la ejecuci√≥n.

```javascript showLineNumbers
async function* asyncNumbers() {
    let num = 0;
    while (num < 10) {
        await new Promise(resolve => setTimeout(resolve, 1000)); // Espera 1 segundo
        yield num++;
    }
}

(async () => {
    for await (const num of asyncNumbers()) {
        console.log(num);
    }
})();
```

<Explanation>
Aqu√≠ `asyncNumbers` emite un n√∫mero cada segundo, pausando su ejecuci√≥n con `await`. Luego usamos `for await...of` para iterar sobre los valores sin necesidad de materializarlos todos en memoria.
</Explanation>

## üìä Resumen comparativo

Si comparamos JavaScript y Kotlin en cuanto a evaluaci√≥n perezosa, encontramos diferencias importantes:

| **Caracter√≠stica**               | **JavaScript**                                                                           | **Kotlin**                                                                            |
|----------------------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| **Definici√≥n de secuencias**     | Usa `function*` para crear generadores.                                                 | Usa `sequence {}` o `generateSequence()`.                                            |
| **Encadenamiento de operaciones**| No soporta `map` o `filter` en generadores sin convertirlos en arrays.                  | Soporta operaciones como `map`, `filter` y `take` sin crear colecciones intermedias. |
| **Asincron√≠a**                   | Permite generadores as√≠ncronos (`async function*`).                                      | Usa `Flow` para manejar flujos de datos asincr√≥nicos.                                |
| **Flujos infinitos**             | Puede generar secuencias infinitas sin problemas.                                      | Permite lo mismo, pero con tipado seguro y mayor control.                            |

## ‚úÖ Beneficios y limitaciones

<ProCons>
    <Pros>
        - **JavaScript es m√°s flexible**: Su sintaxis con `function*` es sencilla y f√°cil de entender.  
        - **Generadores as√≠ncronos**: Puedes manejar datos as√≠ncronos de manera elegante.  
        - **Ideal para flujos infinitos**: Solo genera los valores cuando se necesitan.  
    </Pros>
    <Cons>
        - **No puedes encadenar `map` o `filter` directamente**: Hay que convertir el generador en un array antes.  
        - **Menos seguridad de tipos**: Puede generar errores en tiempo de ejecuci√≥n que en Kotlin se evitar√≠an en compilaci√≥n.  
        - **Mayor riesgo de errores en asincron√≠a**: Manejar flujos as√≠ncronos con generadores puede ser complicado.  
    </Cons>
</ProCons>

## üéØ Conclusiones

Los generadores en JavaScript ofrecen una forma poderosa de trabajar con secuencias perezosas, permitiendo producir valores solo cuando se necesitan. Esto los hace ideales para flujos de datos grandes o infinitos, optimizando el uso de memoria y mejorando el rendimiento en ciertos escenarios.  

Sin embargo, su uso tiene algunas limitaciones, especialmente en comparaci√≥n con las secuencias en Kotlin. La falta de encadenamiento directo de transformaciones (`map`, `filter`, etc.) y la menor seguridad de tipos pueden hacer que el c√≥digo sea m√°s propenso a errores.  

A pesar de esto, JavaScript destaca en su capacidad para manejar asincron√≠a con generadores as√≠ncronos, permitiendo trabajar con datos que llegan de manera progresiva, algo que en Kotlin requiere el uso de `Flow` o coroutines.  

En definitiva, la elecci√≥n entre JavaScript y Kotlin depender√° del contexto y las necesidades del proyecto: si buscas flexibilidad y asincron√≠a, JavaScript es una excelente opci√≥n; si priorizas seguridad de tipos y composici√≥n fluida de operaciones, Kotlin tiene ventajas significativas.  

### üîë Puntos clave

- **Los generadores en JavaScript (`function*`)** permiten crear secuencias perezosas sin consumir m√°s memoria de la necesaria.  
- **Los generadores as√≠ncronos (`async function*`)** son √∫tiles para manejar flujos de datos que llegan de forma progresiva.  
- **Kotlin ofrece una API m√°s estructurada para secuencias perezosas**, permitiendo encadenar operaciones como `map` y `filter` sin necesidad de convertirlas en listas.  
- **JavaScript es m√°s flexible, pero menos seguro en tiempo de compilaci√≥n**, mientras que **Kotlin prioriza la seguridad de tipos**.  
- **Ambos lenguajes permiten flujos infinitos**, pero Kotlin proporciona un control m√°s estricto sobre los tipos de datos.  

---

Los generadores y secuencias perezosas son herramientas fundamentales para escribir c√≥digo m√°s eficiente y escalable. Elegir la mejor opci√≥n depender√° del equilibrio entre flexibilidad, seguridad y facilidad de composici√≥n en cada caso. üöÄ

<References references={[
    {
        title: "Generator‚ÄîJavaScript | MDN",
        url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
        accessedDate: "13 de marzo de 2025",
        type: "web",
    },
]}  />