---
title: Colecciones perezosas en Python
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

En **Python**, los **generadores** son una forma poderosa de crear iteradores de manera eficiente y perezosa. Un generador es una función que utiliza la palabra clave `yield` para producir una secuencia de valores sobre la marcha, sin almacenar todos los elementos en memoria a la vez. Esto los hace ideales para trabajar con grandes conjuntos de datos o secuencias infinitas.

## Características Principales de los Generadores en Python

1. **Creación Simple**: Los generadores se definen como funciones normales que contienen al menos una instrucción `yield`.
2. **Ejecución Perezosa**: Los valores se generan y devuelven uno a uno a medida que se solicitan, lo que ahorra memoria y mejora el rendimiento.
3. **Iteración Fácil**: Los generadores son iterables y pueden ser utilizados en bucles `for`, comprensiones de listas, y otras construcciones iterativas de Python.
4. **Estado Persistente**: Los generadores mantienen su estado entre las llamadas, permitiendo continuar la generación de valores donde se dejó.

## Ejemplo de un Generador en Python

A continuación, se muestra cómo implementar un generador en Python que produce una secuencia infinita de números pares, similar a la implementación de Kotlin presentada anteriormente:

```python showLineNumbers
from typing import Generator, List

def even_numbers() -> Generator[int, None, None]:
    number: int = 0
    while True:
        yield number
        number += 2

# Uso del generador
gen: Generator[int, None, None] = even_numbers()
first_ten_evens: List[int] = [next(gen) for _ in range(10)]
print(first_ten_evens)  # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

## Comparación Detallada

| **Característica**                    | **Kotlin (`Sequence`)**                                 | **Python (`Generators`)**                                                    |
|---------------------------------------|---------------------------------------------------------|------------------------------------------------------------------------------|
| **Sintaxis de Creación**              | Utiliza `sequence {}` con `yield`                       | Funciones definidas con `def` y `yield`                                      |
| **Tipo Estático vs Dinámico**         | Tipado estático con generics                            | Tipado dinámico                                                              |
| **Control de Flujo**                  | Control explícito mediante constructores de secuencias  | Control implícito a través de la lógica del generador                        |
| **Manejo de Estado**                  | Mantiene estado interno automáticamente                 | Mantiene estado interno automáticamente                                      |
| **Reusabilidad**                      | Se pueden encadenar múltiples operaciones               | Se pueden encadenar múltiples operaciones                                    |
| **Evaluación Perezosa**               | Totalmente perezosa, ejecuta operaciones bajo demanda   | Totalmente perezosa, ejecuta operaciones bajo demanda                        |
| **Manejo de Secuencias Infinitas**    | Soportado mediante `while (true)` y `yield`             | Soportado mediante `while True` y `yield`                                    |
| **Integración con APIs**              | Integrado en la biblioteca estándar de Kotlin           | Integrado en la biblioteca estándar de Python                                |
| **Performance y Optimización**        | Optimizado para JVM con inlining y otras optimizaciones | Optimizado para CPython, pero puede ser menos eficiente en ciertos contextos |

## Consideraciones Finales

Ambos **Kotlin** y **Python** ofrecen poderosas herramientas para trabajar con colecciones perezosas, cada una adaptada a las características y filosofías de su respectivo lenguaje. Mientras que Kotlin brinda un enfoque robusto y tipado estáticamente seguro, ideal para aplicaciones que requieren alta performance y seguridad de tipos, Python proporciona una solución más flexible y fácil de usar, perfecta para desarrolladores que valoran la rapidez y la simplicidad.

Al elegir entre **secuencias de Kotlin** y **generadores de Python**, es esencial considerar el contexto del proyecto, las necesidades de rendimiento, y las preferencias en cuanto al sistema de tipos. Ambas herramientas son altamente efectivas para manejar grandes volúmenes de datos y flujos infinitos de manera eficiente, aprovechando la evaluación perezosa para optimizar el uso de recursos.

<References references={[
    {
        title: "Generators - Python Wiki",
        url: "https://wiki.python.org/moin/Generators",
        type: "web",
        accessedDate: "28 de septiembre de 2024",
        siteOrAuthor: "Python Wiki"
    },
]} />
