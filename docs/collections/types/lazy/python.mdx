---
title: Colecciones Perezosas en Python
---
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>

Después de haber explorado en detalle cómo **Kotlin** implementa las **colecciones perezosas** a través de **secuencias** (`Sequence`), es útil comparar esta funcionalidad con cómo otros lenguajes abordan conceptos similares. En esta sección, compararemos las colecciones perezosas de Kotlin con los **generadores** (`generators`) de **Python**, destacando las similitudes, diferencias y casos de uso ideales para cada enfoque.

## Generadores en Python

En **Python**, los **generadores** son una forma poderosa de crear iteradores de manera eficiente y perezosa. Un generador es una función que utiliza la palabra clave `yield` para producir una secuencia de valores sobre la marcha, sin almacenar todos los elementos en memoria a la vez. Esto los hace ideales para trabajar con grandes conjuntos de datos o secuencias infinitas.

### Características Principales de los Generadores en Python

1. **Creación Simple**: Los generadores se definen como funciones normales que contienen al menos una instrucción `yield`.
2. **Ejecución Perezosa**: Los valores se generan y devuelven uno a uno a medida que se solicitan, lo que ahorra memoria y mejora el rendimiento.
3. **Iteración Fácil**: Los generadores son iterables y pueden ser utilizados en bucles `for`, comprensiones de listas, y otras construcciones iterativas de Python.
4. **Estado Persistente**: Los generadores mantienen su estado entre las llamadas, permitiendo continuar la generación de valores donde se dejó.

### Ejemplo de un Generador en Python

A continuación, se muestra cómo implementar un generador en Python que produce una secuencia infinita de números pares, similar a la implementación de Kotlin presentada anteriormente:

```python showLineNumbers
from typing import Generator, List

def even_numbers() -> Generator[int, None, None]:
    number: int = 0
    while True:
        yield number
        number += 2

# Uso del generador
gen: Generator[int, None, None] = even_numbers()
first_ten_evens: List[int] = [next(gen) for _ in range(10)]
print(first_ten_evens)  # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

### Comparación Detallada

| **Característica**                    | **Kotlin (`Sequence`)**                                 | **Python (`Generators`)**                                                    |
|---------------------------------------|---------------------------------------------------------|------------------------------------------------------------------------------|
| **Sintaxis de Creación**              | Utiliza `sequence {}` con `yield`                       | Funciones definidas con `def` y `yield`                                      |
| **Tipo Estático vs Dinámico**         | Tipado estático con generics                            | Tipado dinámico                                                              |
| **Control de Flujo**                  | Control explícito mediante constructores de secuencias  | Control implícito a través de la lógica del generador                        |
| **Manejo de Estado**                  | Mantiene estado interno automáticamente                 | Mantiene estado interno automáticamente                                      |
| **Reusabilidad**                      | Se pueden encadenar múltiples operaciones               | Se pueden encadenar múltiples operaciones                                    |
| **Evaluación Perezosa**               | Totalmente perezosa, ejecuta operaciones bajo demanda   | Totalmente perezosa, ejecuta operaciones bajo demanda                        |
| **Manejo de Secuencias Infinitas**    | Soportado mediante `while (true)` y `yield`             | Soportado mediante `while True` y `yield`                                    |
| **Integración con APIs**              | Integrado en la biblioteca estándar de Kotlin           | Integrado en la biblioteca estándar de Python                                |
| **Performance y Optimización**        | Optimizado para JVM con inlining y otras optimizaciones | Optimizado para CPython, pero puede ser menos eficiente en ciertos contextos |

### Consideraciones Finales

Ambos **Kotlin** y **Python** ofrecen poderosas herramientas para trabajar con colecciones perezosas, cada una adaptada a las características y filosofías de su respectivo lenguaje. Mientras que Kotlin brinda un enfoque robusto y tipado estáticamente seguro, ideal para aplicaciones que requieren alta performance y seguridad de tipos, Python proporciona una solución más flexible y fácil de usar, perfecta para desarrolladores que valoran la rapidez y la simplicidad.

Al elegir entre **secuencias de Kotlin** y **generadores de Python**, es esencial considerar el contexto del proyecto, las necesidades de rendimiento, y las preferencias en cuanto al sistema de tipos. Ambas herramientas son altamente efectivas para manejar grandes volúmenes de datos y flujos infinitos de manera eficiente, aprovechando la evaluación perezosa para optimizar el uso de recursos.

<References references={[
    {
        title: "Generators - Python Wiki",
        url: "https://wiki.python.org/moin/Generators",
        type: "web",
        accessedDate: "28 de septiembre de 2024",
        siteOrAuthor: "Python Wiki"
    },
]} />


[//]: # (<References references={[)

[//]: # (    {)

[//]: # (        title: "",)

[//]: # (        url: "",)

[//]: # (        type: "article",)

[//]: # (        author: "",)

[//]: # (        publishedDate: "",)

[//]: # (    },)

[//]: # (    {)

[//]: # (        accessedDate: '',)

[//]: # (        siteOrAuthor: '',)

[//]: # (        title: '',)

[//]: # (        type: 'web',)

[//]: # (        url: '',)

[//]: # (    },)

[//]: # (    {)

[//]: # (        title: "",)

[//]: # (        bookTitle: "",)

[//]: # (        pages: "",)

[//]: # (        location: "",)

[//]: # (        publisher: "",)

[//]: # (        year: "",)

[//]: # (        type: "book",)

[//]: # (        author: '')

[//]: # (    },)

[//]: # (]}/>)
