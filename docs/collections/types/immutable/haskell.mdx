---
title: Colecciones inmutables en Haskell
---
import References from "@site/src/components/ReferencesComponent";
import ReadingTime from '@site/src/components/ReadingTime';

<ReadingTime/>

En **Haskell**, un lenguaje puramente funcional, la inmutabilidad es la norma por defecto, lo que hace que todas las estructuras de datos sean inmutables.

Veamos una comparación entre las colecciones inmutables en **Kotlin** y **Haskell**.

### Listas Inmutables

En **Kotlin**, las listas inmutables se manejan utilizando la interfaz `List`. En **Haskell**, las listas son inmutables por defecto y se representan usando corchetes `[]`.

```haskell
let immutableList = ["Haskell", "Scala", "Kotlin"]
print (immutableList !! 0)  -- Output: Haskell
```

### Conjuntos Inmutables (Sets)

En **Haskell**, el módulo `Data.Set` proporciona conjuntos inmutables.

```haskell
import qualified Data.Set as Set

let immutableSet = Set.fromList ["Haskell", "Scala", "Kotlin"]
print (Set.member "Haskell" immutableSet)  -- Output: True
```

### Mapas Inmutables (Diccionarios)

```haskell
import qualified Data.Map as Map

let immutableMap = Map.fromList [("Haskell", 1), ("Scala", 2)]
print (Map.lookup "Haskell" immutableMap)  -- Output: Just 1
```

### Comparación final

| **Característica**            | **Kotlin** (`List`, `Set`, `Map`)      | **Haskell** (`[]`, `Set`, `Map`)              |
|-------------------------------|----------------------------------------|-----------------------------------------------|
| **Inmutabilidad por defecto** | Garantizada solo si se usa `listOf`    | Todas las estructuras de datos son inmutables |
| **Mutabilidad**               | Necesita `MutableList`, `MutableSet`   | No existe mutabilidad, todo es inmutable      |
| **Uso en concurrencia**       | Las colecciones inmutables son seguras | Seguro por defecto al ser puramente funcional |
| **Operaciones funcionales**   | Disponible, pero no obligatorio        | Uso intensivo de funciones como `map`, `fold` |
| **Desempeño**                 | Eficiente, pero con optimizaciones     | Muy eficiente debido a la evaluación perezosa |

### Conclusión

**Kotlin** ofrece colecciones inmutables que proporcionan seguridad y eficiencia en el manejo de datos, con la flexibilidad de usar mutabilidad cuando sea necesario. **Haskell**, en cambio, fuerza la inmutabilidad de todas sus estructuras de datos, lo que fomenta un estilo de programación más predecible y naturalmente concurrente. Mientras Kotlin otorga un control explícito sobre la mutabilidad, Haskell adopta un enfoque más rígido, donde todo es inmutable por diseño.

<References references={[
    {
        title: "Data.Collections",
        url: "https://hackage.haskell.org/package/collections-api-1.0.0.0/docs/Data-Collections.html",
        type: "web",
        accessedDate: '28 de septiembre de 2024'
    }
]}/>

[//]: # (<References references={[)

[//]: # (    {)

[//]: # (        title: "",)

[//]: # (        url: "",)

[//]: # (        type: "article",)

[//]: # (        author: "",)

[//]: # (        publishedDate: "",)

[//]: # (    },)

[//]: # (    {)

[//]: # (        accessedDate: '',)

[//]: # (        siteOrAuthor: '',)

[//]: # (        title: '',)

[//]: # (        type: 'web',)

[//]: # (        url: '',)

[//]: # (    },)

[//]: # (    {)

[//]: # (        title: "",)

[//]: # (        bookTitle: "",)

[//]: # (        pages: "",)

[//]: # (        location: "",)

[//]: # (        publisher: "",)

[//]: # (        year: "",)

[//]: # (        type: "book",)

[//]: # (        author: '')

[//]: # (    },)

[//]: # (]}/>)
