---
title: Colecciones Mutables en Swift
---
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';

<ReadingTime/>

En **Swift**, las colecciones mutables, como en **Kotlin**, permiten modificar su contenido después de ser creadas. Swift ofrece versiones mutables para sus colecciones estándar, que incluyen **`Array`**, **`Set`**, y **`Dictionary`**. Estas colecciones son útiles cuando se necesita agregar, eliminar o cambiar elementos durante la ejecución del programa.

### Diferencia entre Colecciones Mutables e Inmutables

En Swift, las colecciones mutables se crean declarando las colecciones con la palabra clave **`var`**, mientras que las colecciones inmutables se crean con **`let`**. Las colecciones declaradas con **`let`** no pueden ser modificadas, mientras que las que se declaran con **`var`** sí pueden cambiarse.

### Ejemplo en Swift

```swift
var mutableArray: [String] = c["Swift", "Kotlin"]
mutableArray.append("Scala") // Añadir un elemento
mutableArray[1] = "Objective-C" // Modificar un elemento
print(mutableArray) // Output: ["Swift", "Objective-C", "Scala"]

let immutableArray: [String] = ["Swift", "Kotlin"]
// immutableArray.append("Scala") // Error: la colección es inmutable
```

### `Array`, `Set`, y `Dictionary`

Al igual que en Kotlin, Swift también tiene sus equivalentes mutables para listas, sets y mapas:

- **`Array`**: Es similar a la `MutableList` de Kotlin, permitiendo la manipulación ordenada de elementos por índices.
- **`Set`**: Similar a `MutableSet`, no permite duplicados y ofrece operaciones como unión y diferencia.
- **`Dictionary`**: Similar a `MutableMap`, permite la modificación de pares clave-valor.

### Ejemplo de Modificación de Colecciones en Swift

#### `Array` (Lista Mutable)

```swift
var languages: [String] = ["Swift", "Kotlin"]
languages.append("Scala")
languages[0] = "Objective-C"
print(languages)  // Output: ["Objective-C", "Kotlin", "Scala"]
```

#### `Set` (Conjunto Mutable)

```swift
var uniqueLanguages: Set<String> = ["Swift", "Kotlin"]
uniqueLanguages.insert("Scala")
uniqueLanguages.remove("Kotlin")
print(uniqueLanguages)  // Output: ["Swift", "Scala"]
```

#### `Dictionary` (Mapa Mutable)

```swift
var languageVersions: [String: Int] = ["Swift": 5, "Kotlin": 1]
languageVersions["Scala"] = 2
languageVersions["Kotlin"] = 3
languageVersions.removeValue(forKey: "Swift")
print(languageVersions)  // Output: ["Scala": 2, "Kotlin": 3]
```

## Comparación entre Kotlin y Swift

| Característica            | Kotlin                              | Swift                                                                                   |
|---------------------------|-------------------------------------|-----------------------------------------------------------------------------------------|
| **Listas Mutables**       | `MutableList`                       | `Array`                                                                                 |
| **Sets Mutables**         | `MutableSet`                        | `Set`                                                                                   |
| **Mapas Mutables**        | `MutableMap`                        | `Dictionary`                                                                            |
| **Declaración Mutable**   | `val mutableList = mutableListOf()` | `var mutableArray = [String]()`                                                         |
| **Declaración Inmutable** | `val immutableList = listOf()`      | `let immutableArray = [String]()`                                                       |
| **Modificación Directa**  | Soportada                           | Soportada                                                                               |
| **Interfaz Mutable**      | `MutableCollection`, `MutableList`  | No hay interfaces específicas, pero el comportamiento mutable depende de `var` o `let`. |

:::tip Ventajas de las Colecciones Mutables en Swift

1. **Simplicidad en la Declaración**: La diferencia entre colecciones mutables e inmutables en Swift es muy clara y sencilla gracias al uso de `var` y `let`. Esto hace que el manejo de la mutabilidad sea fácil de entender para lxs desarrolladorxs.
2. **Eficiencia de Memoria**: Swift utiliza optimizaciones internas como la "copy-on-write", lo que significa que las colecciones solo se copian cuando es necesario, optimizando el uso de memoria y mejorando el rendimiento en escenarios donde se manejan grandes cantidades de datos.
3. **Compatibilidad con Tipos Genéricos**: Las colecciones mutables en Swift son altamente genéricas, lo que permite reutilizar los mismos tipos de colecciones con cualquier tipo de datos, desde tipos básicos hasta clases o estructuras personalizadas.
4. **Seguridad en Tiempo de Compilación**: Swift ofrece una sólida verificación de tipos y una gestión segura de la memoria, lo que reduce los errores en tiempo de ejecución, haciendo que las colecciones mutables sean seguras de usar en entornos críticos.

:::

:::danger Desventajas de las Colecciones Mutables en Swift

1. **Falta de Interfaces Mutables**: A diferencia de Kotlin, Swift no tiene interfaces mutables específicas como `MutableList` o `MutableCollection`, lo que puede limitar la abstracción y el polimorfismo en algunos casos, ya que los comportamientos mutables dependen directamente del uso de `var`.
2. **Sobrecarga de Complejidad en Contextos Concurrentes**: Aunque Swift optimiza el acceso a colecciones mutables, en entornos concurrentes es necesario tomar precauciones adicionales, como usar mecanismos de sincronización, lo que agrega complejidad en aplicaciones multihilo.
3. **Menos Flexibilidad en la Personalización**: Swift no permite el mismo nivel de personalización o extensión en las colecciones mutables como Kotlin, lo que puede ser una desventaja si necesitas comportamientos más especializados o complejos en tus estructuras de datos.

:::

## ¿Qué Aprendimos?

En esta lección, exploramos las **colecciones mutables en Swift** y cómo se comparan con las de Kotlin. Vimos que ambas lenguas permiten modificar sus colecciones después de haber sido creadas, y analizamos cómo Swift utiliza las palabras clave `var` y `let` para diferenciar entre colecciones mutables e inmutables.

Aprendimos que **Swift** ofrece optimizaciones como *copy-on-write* y una integración fluida con tipos genéricos, lo que la hace eficiente y segura. Sin embargo, vimos que **Kotlin** tiene una ventaja al ofrecer **interfaces específicas** para colecciones mutables, mientras que en Swift, el comportamiento mutable depende del uso de `var`.

Las **ventajas** de las colecciones mutables en Swift incluyen su simplicidad y eficiencia en memoria, pero sus **desventajas** incluyen una mayor complejidad en aplicaciones concurrentes y menos flexibilidad en la personalización de colecciones.

Al final, tanto Kotlin como Swift proporcionan potentes mecanismos para manejar colecciones mutables, cada una con sus propias fortalezas y limitaciones.

<References references={[
    {
        publisher: "Big Nerd Ranch",
        pages: "81–92",
        type: "book",
        title: "8. Arrays",
        author: "Mikey Ward",
        year: "2020",
        bookTitle: "Swift Programming: The Big Nerd Ranch Guide",
        location: "Arizona Ave, NE"
    },
    {
        publisher: "Big Nerd Ranch",
        pages: "105–112",
        type: "book",
        title: "10. Dictionaries",
        author: "Mikey Ward",
        year: "2020",
        bookTitle: "Swift Programming: The Big Nerd Ranch Guide",
        location: "Arizona Ave, NE"
    },
    {
        publisher: "Big Nerd Ranch",
        pages: "113–122",
        type: "book",
        title: "11. Sets",
        author: "Mikey Ward",
        year: "2020",
        bookTitle: "Swift Programming: The Big Nerd Ranch Guide",
        location: "Arizona Ave, NE"
    },
]}/>
